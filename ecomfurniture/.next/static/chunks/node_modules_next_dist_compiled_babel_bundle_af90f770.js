(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/compiled/babel/bundle.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var _tagged_template_literal = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_tagged_template_literal.cjs [app-client] (ecmascript)");
function _templateObject() {
    const data = _tagged_template_literal._([
        '\n    (function (root, factory) {\n      if (typeof define === "function" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === "object") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  '
    ]);
    _templateObject = function() {
        return data;
    };
    return data;
}
function _templateObject1() {
    const data = _tagged_template_literal._([
        "return ",
        ""
    ]);
    _templateObject1 = function() {
        return data;
    };
    return data;
}
function _templateObject2() {
    const data = _tagged_template_literal._([
        "\n    ",
        "(\n      ",
        ",\n      function (",
        ", ",
        ") {\n        ",
        "\n        return { F: ",
        ", d: ",
        " };\n      },\n      ",
        "\n    )\n  "
    ]);
    _templateObject2 = function() {
        return data;
    };
    return data;
}
function _templateObject3() {
    const data = _tagged_template_literal._([
        "let ",
        " = ",
        ""
    ]);
    _templateObject3 = function() {
        return data;
    };
    return data;
}
function _templateObject4() {
    const data = _tagged_template_literal._([
        "\n        ",
        "(this)\n      "
    ]);
    _templateObject4 = function() {
        return data;
    };
    return data;
}
function _templateObject5() {
    const data = _tagged_template_literal._([
        "\n        function () {\n          return this.",
        ";\n        }\n      "
    ]);
    _templateObject5 = function() {
        return data;
    };
    return data;
}
function _templateObject6() {
    const data = _tagged_template_literal._([
        "\n        function (value) {\n          this.",
        " = value;\n        }\n      "
    ]);
    _templateObject6 = function() {
        return data;
    };
    return data;
}
function _templateObject7() {
    const data = _tagged_template_literal._([
        "\n      o => o.",
        "\n    "
    ]);
    _templateObject7 = function() {
        return data;
    };
    return data;
}
function _templateObject8() {
    const data = _tagged_template_literal._([
        "\n      (o, v) => o.",
        " = v\n    "
    ]);
    _templateObject8 = function() {
        return data;
    };
    return data;
}
function _templateObject9() {
    const data = _tagged_template_literal._([
        "\n        class extends ",
        " {}\n      "
    ]);
    _templateObject9 = function() {
        return data;
    };
    return data;
}
function _templateObject10() {
    const data = _tagged_template_literal._([
        "var ",
        " = ",
        ""
    ]);
    _templateObject10 = function() {
        return data;
    };
    return data;
}
function _templateObject11() {
    const data = _tagged_template_literal._([
        "\n        Object.prototype.hasOwnProperty.call(",
        ", ",
        ")\n      "
    ]);
    _templateObject11 = function() {
        return data;
    };
    return data;
}
function _templateObject12() {
    const data = _tagged_template_literal._([
        "",
        " === ",
        ""
    ]);
    _templateObject12 = function() {
        return data;
    };
    return data;
}
function _templateObject13() {
    const data = _tagged_template_literal._([
        "",
        ".has(",
        ")"
    ]);
    _templateObject13 = function() {
        return data;
    };
    return data;
}
function _templateObject14() {
    const data = _tagged_template_literal._([
        "(_) => ",
        " = _"
    ]);
    _templateObject14 = function() {
        return data;
    };
    return data;
}
function _templateObject15() {
    const data = _tagged_template_literal._([
        "BASE(REF, PROP)[PROP]"
    ]);
    _templateObject15 = function() {
        return data;
    };
    return data;
}
function _templateObject16() {
    const data = _tagged_template_literal._([
        "\n      Object.defineProperty(",
        ", ",
        ", {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ",
        "\n      });\n    "
    ]);
    _templateObject16 = function() {
        return data;
    };
    return data;
}
function _templateObject17() {
    const data = _tagged_template_literal._([
        "",
        ".set(",
        ", {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ",
        ",\n        })"
    ]);
    _templateObject17 = function() {
        return data;
    };
    return data;
}
function _templateObject18() {
    const data = _tagged_template_literal._([
        "{ writable: true, value: ",
        " }"
    ]);
    _templateObject18 = function() {
        return data;
    };
    return data;
}
function _templateObject19() {
    const data = _tagged_template_literal._([
        "{\n        _: ",
        "\n      }"
    ]);
    _templateObject19 = function() {
        return data;
    };
    return data;
}
function _templateObject20() {
    const data = _tagged_template_literal._([
        "\n          var ",
        " = {\n            // configurable is false by default\n            // enumerable is false by default\n            // writable is false by default\n            get: ",
        ",\n            set: ",
        "\n          }\n        "
    ]);
    _templateObject20 = function() {
        return data;
    };
    return data;
}
function _templateObject21() {
    const data = _tagged_template_literal._([
        "\n        var ",
        " = {\n          // configurable is false by default\n          // enumerable is false by default\n          writable: true,\n          value: ",
        "\n        };\n      "
    ]);
    _templateObject21 = function() {
        return data;
    };
    return data;
}
function _templateObject22() {
    const data = _tagged_template_literal._([
        "\n        Object.defineProperty(",
        ", ",
        ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ",
        "\n        });\n      "
    ]);
    _templateObject22 = function() {
        return data;
    };
    return data;
}
function _templateObject23() {
    const data = _tagged_template_literal._([
        "\n        Object.defineProperty(",
        ", ",
        ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ",
        ",\n          set: ",
        "\n        });\n      "
    ]);
    _templateObject23 = function() {
        return data;
    };
    return data;
}
function _templateObject24() {
    const data = _tagged_template_literal._([
        "\n          ",
        ".set(",
        ", {\n            get: ",
        ",\n            set: ",
        "\n          });\n        "
    ]);
    _templateObject24 = function() {
        return data;
    };
    return data;
}
function _templateObject25() {
    const data = _tagged_template_literal._([
        "",
        "(\n      ",
        ",\n      ",
        ",\n      {\n        get: ",
        ",\n        set: ",
        "\n      },\n    )"
    ]);
    _templateObject25 = function() {
        return data;
    };
    return data;
}
function _templateObject26() {
    const data = _tagged_template_literal._([
        "",
        ".add(",
        ")"
    ]);
    _templateObject26 = function() {
        return data;
    };
    return data;
}
function _templateObject27() {
    const data = _tagged_template_literal._([
        "",
        "(\n      ",
        ",\n      ",
        "\n    )"
    ]);
    _templateObject27 = function() {
        return data;
    };
    return data;
}
function _templateObject28() {
    const data = _tagged_template_literal._([
        "\n        Object.defineProperty(",
        ", ",
        ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ",
        ",\n          set: ",
        "\n        })\n      "
    ]);
    _templateObject28 = function() {
        return data;
    };
    return data;
}
function _templateObject29() {
    const data = _tagged_template_literal._([
        "\n      Object.defineProperty(",
        ", ",
        ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ",
        "\n      });\n    "
    ]);
    _templateObject29 = function() {
        return data;
    };
    return data;
}
function _templateObject30() {
    const data = _tagged_template_literal._([
        "[].slice.call(arguments, 1)"
    ]);
    _templateObject30 = function() {
        return data;
    };
    return data;
}
function _templateObject31() {
    const data = _tagged_template_literal._([
        "(() => { ",
        " })()"
    ]);
    _templateObject31 = function() {
        return data;
    };
    return data;
}
function _templateObject32() {
    const data = _tagged_template_literal._([
        "super(...args)"
    ]);
    _templateObject32 = function() {
        return data;
    };
    return data;
}
function _templateObject33() {
    const data = _tagged_template_literal._([
        "`${",
        "}`"
    ], [
        "\\`\\${",
        "}\\`"
    ]);
    _templateObject33 = function() {
        return data;
    };
    return data;
}
function _templateObject34() {
    const data = _tagged_template_literal._([
        "\n        Promise.resolve().then(() => ",
        ")\n      "
    ]);
    _templateObject34 = function() {
        return data;
    };
    return data;
}
function _templateObject35() {
    const data = _tagged_template_literal._([
        "\n      (specifier =>\n        new Promise(r => r(",
        "))\n          .then(s => ",
        ")\n      )(",
        ")\n    "
    ]);
    _templateObject35 = function() {
        return data;
    };
    return data;
}
function _templateObject36() {
    const data = _tagged_template_literal._([
        "\n      (specifier =>\n        new Promise(r => r(",
        "))\n      )(",
        ")\n    "
    ]);
    _templateObject36 = function() {
        return data;
    };
    return data;
}
function _templateObject37() {
    const data = _tagged_template_literal._([
        "\n      (specifier => ",
        ")(",
        ")\n    "
    ]);
    _templateObject37 = function() {
        return data;
    };
    return data;
}
function _templateObject38() {
    const data = _tagged_template_literal._([
        "var NAME = SOURCE;"
    ]);
    _templateObject38 = function() {
        return data;
    };
    return data;
}
function _templateObject39() {
    const data = _tagged_template_literal._([
        '\n            Object.defineProperty(EXPORTS, "NAME", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          '
    ]);
    _templateObject39 = function() {
        return data;
    };
    return data;
}
function _templateObject40() {
    const data = _tagged_template_literal._([
        "EXPORTS.NAME = NAMESPACE;"
    ]);
    _templateObject40 = function() {
        return data;
    };
    return data;
}
function _templateObject41() {
    const data = _tagged_template_literal._([
        "\n      ",
        ".",
        " = ",
        ";\n    "
    ]);
    _templateObject41 = function() {
        return data;
    };
    return data;
}
function _templateObject42() {
    const data = _tagged_template_literal._([
        "\n      ",
        '["',
        '"] = ',
        ";\n    "
    ]);
    _templateObject42 = function() {
        return data;
    };
    return data;
}
function _templateObject43() {
    const data = _tagged_template_literal._([
        "\n      Object.defineProperty(",
        ', "',
        '", {\n        enumerable: true,\n        get: function() {\n          return ',
        ";\n        },\n      });\n    "
    ]);
    _templateObject43 = function() {
        return data;
    };
    return data;
}
function _templateObject44() {
    const data = _tagged_template_literal._([
        "\n        EXPORTS.__esModule = true;\n      "
    ]);
    _templateObject44 = function() {
        return data;
    };
    return data;
}
function _templateObject45() {
    const data = _tagged_template_literal._([
        '\n        Object.defineProperty(EXPORTS, "__esModule", {\n          value: true,\n        });\n      '
    ]);
    _templateObject45 = function() {
        return data;
    };
    return data;
}
function _templateObject46() {
    const data = _tagged_template_literal._([
        '\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === "default" || key === "__esModule") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      '
    ]);
    _templateObject46 = function() {
        return data;
    };
    return data;
}
function _templateObject47() {
    const data = _tagged_template_literal._([
        '\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === "default" || key === "__esModule") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    '
    ]);
    _templateObject47 = function() {
        return data;
    };
    return data;
}
function _templateObject48() {
    const data = _tagged_template_literal._([
        "\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "
    ]);
    _templateObject48 = function() {
        return data;
    };
    return data;
}
function _templateObject49() {
    const data = _tagged_template_literal._([
        "",
        '["',
        '"] = ',
        ""
    ]);
    _templateObject49 = function() {
        return data;
    };
    return data;
}
function _templateObject50() {
    const data = _tagged_template_literal._([
        "",
        ".",
        " = ",
        ""
    ]);
    _templateObject50 = function() {
        return data;
    };
    return data;
}
function _templateObject51() {
    const data = _tagged_template_literal._([
        "\n      Object.defineProperty(",
        ', "',
        '", {\n        enumerable: true,\n        value: void 0,\n        writable: true\n      })["',
        '"] = ',
        ""
    ]);
    _templateObject51 = function() {
        return data;
    };
    return data;
}
function _templateObject52() {
    const data = _tagged_template_literal._([
        "\n    (function() {\n      throw new Error('\"' + '",
        "' + '\" is read-only.');\n    })()\n  "
    ]);
    _templateObject52 = function() {
        return data;
    };
    return data;
}
function _templateObject53() {
    const data = _tagged_template_literal._([
        "\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        "
    ]);
    _templateObject53 = function() {
        return data;
    };
    return data;
}
function _templateObject54() {
    const data = _tagged_template_literal._([
        "\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      "
    ]);
    _templateObject54 = function() {
        return data;
    };
    return data;
}
function _templateObject55() {
    const data = _tagged_template_literal._([
        "\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        "
    ]);
    _templateObject55 = function() {
        return data;
    };
    return data;
}
function _templateObject56() {
    const data = _tagged_template_literal._([
        "\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      "
    ]);
    _templateObject56 = function() {
        return data;
    };
    return data;
}
function _templateObject57() {
    const data = _tagged_template_literal._([
        "pipelineOperator"
    ]);
    _templateObject57 = function() {
        return data;
    };
    return data;
}
function _templateObject58() {
    const data = _tagged_template_literal._([
        "flow"
    ]);
    _templateObject58 = function() {
        return data;
    };
    return data;
}
function _templateObject59() {
    const data = _tagged_template_literal._([
        "jsx"
    ]);
    _templateObject59 = function() {
        return data;
    };
    return data;
}
function _templateObject60() {
    const data = _tagged_template_literal._([
        "typescript"
    ]);
    _templateObject60 = function() {
        return data;
    };
    return data;
}
function _templateObject61() {
    const data = _tagged_template_literal._([
        "placeholders"
    ]);
    _templateObject61 = function() {
        return data;
    };
    return data;
}
function _templateObject62() {
    const data = _tagged_template_literal._([
        "require(",
        ")"
    ]);
    _templateObject62 = function() {
        return data;
    };
    return data;
}
function _templateObject63() {
    const data = _tagged_template_literal._([
        '\n    (function(){\n      throw new Error(\n        "The CommonJS \'" + "',
        '" + "\' variable is not available in ES6 modules." +\n        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +\n        "Babel config for this file.");\n    })()\n  '
    ]);
    _templateObject63 = function() {
        return data;
    };
    return data;
}
function _templateObject64() {
    const data = _tagged_template_literal._([
        "\n                var ",
        " = ",
        ";\n              "
    ]);
    _templateObject64 = function() {
        return data;
    };
    return data;
}
function _templateObject65() {
    const data = _tagged_template_literal._([
        "\n        function ",
        "() {\n          const data = ",
        ";\n          ",
        " = function(){ return data; };\n          return data;\n        }\n      "
    ]);
    _templateObject65 = function() {
        return data;
    };
    return data;
}
function _templateObject66() {
    const data = _tagged_template_literal._([
        "\n              this.",
        " = ",
        "\n            "
    ]);
    _templateObject66 = function() {
        return data;
    };
    return data;
}
function _templateObject67() {
    const data = _tagged_template_literal._([
        "module.exports = ",
        ""
    ]);
    _templateObject67 = function() {
        return data;
    };
    return data;
}
function _templateObject68() {
    const data = _tagged_template_literal._([
        "\n      ",
        " ||\n        (",
        " = ",
        ")\n    "
    ]);
    _templateObject68 = function() {
        return data;
    };
    return data;
}
function _templateObject69() {
    const data = _tagged_template_literal._([
        "\n    (function (",
        ") {\n      ",
        "\n    })(",
        " || (",
        " = ",
        "));\n  "
    ]);
    _templateObject69 = function() {
        return data;
    };
    return data;
}
function _templateObject70() {
    const data = _tagged_template_literal._([
        "(",
        ' + "").replace(/([\\/].*.[mc]?)tsx?$/, "$1js")'
    ], [
        "(",
        ' + "").replace(/([\\\\/].*\\.[mc]?)tsx?$/, "$1js")'
    ]);
    _templateObject70 = function() {
        return data;
    };
    return data;
}
function _templateObject71() {
    const data = _tagged_template_literal._([
        "\n    (function (",
        ") {\n      function ",
        "(",
        ") {\n        return ",
        ".apply(this, arguments);\n      }\n\n      ",
        ".toString = function () {\n        return ",
        ".toString();\n      }\n\n      return ",
        ";\n    })(",
        ")\n  "
    ]);
    _templateObject71 = function() {
        return data;
    };
    return data;
}
(()=>{
    var e1 = {
        5565: (e1)=>{
            function webpackEmptyAsyncContext(e1) {
                return Promise.resolve().then(()=>{
                    var t = new Error("Cannot find module '" + e1 + "'");
                    t.code = "MODULE_NOT_FOUND";
                    throw t;
                });
            }
            webpackEmptyAsyncContext.keys = ()=>[];
            webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
            webpackEmptyAsyncContext.id = 5565;
            e1.exports = webpackEmptyAsyncContext;
        },
        3914: function(e1, t, r) {
            (function(t, n) {
                ("TURBOPACK compile-time truthy", 1) ? e1.exports = n(r(8536), r(2987)) : "TURBOPACK unreachable";
            })(this, function(e1, t) {
                "use strict";
                const r = SegmentObject("", -1, -1, "", null);
                const n = [];
                function SegmentObject(e1, t, r, n, s) {
                    return {
                        source: e1,
                        line: t,
                        column: r,
                        name: n,
                        content: s
                    };
                }
                function Source(e1, t, r, n) {
                    return {
                        map: e1,
                        sources: t,
                        source: r,
                        content: n
                    };
                }
                function MapSource(e1, t) {
                    return Source(e1, t, "", null);
                }
                function OriginalSource(e1, t) {
                    return Source(null, n, e1, t);
                }
                function traceMappings(n) {
                    const s = new t.GenMapping({
                        file: n.map.file
                    });
                    const { sources: i, map: a } = n;
                    const o = a.names;
                    const l = e1.decodedMappings(a);
                    for(let e1 = 0; e1 < l.length; e1++){
                        const n = l[e1];
                        for(let a = 0; a < n.length; a++){
                            const l = n[a];
                            const c = l[0];
                            let p = r;
                            if (l.length !== 1) {
                                const e1 = i[l[1]];
                                p = originalPositionFor(e1, l[2], l[3], l.length === 5 ? o[l[4]] : "");
                                if (p == null) continue;
                            }
                            const { column: u, line: d, name: f, content: h, source: m } = p;
                            t.maybeAddSegment(s, e1, c, m, d, u, f);
                            if (m && h != null) t.setSourceContent(s, m, h);
                        }
                    }
                    return s;
                }
                function originalPositionFor(t, n, s, i) {
                    if (!t.map) {
                        return SegmentObject(t.source, n, s, i, t.content);
                    }
                    const a = e1.traceSegment(t.map, n, s);
                    if (a == null) return null;
                    if (a.length === 1) return r;
                    return originalPositionFor(t.sources[a[1]], a[2], a[3], a.length === 5 ? t.map.names[a[4]] : i);
                }
                function asArray(e1) {
                    if (Array.isArray(e1)) return e1;
                    return [
                        e1
                    ];
                }
                function buildSourceMapTree(t, r) {
                    const n = asArray(t).map((t)=>new e1.TraceMap(t, ""));
                    const s = n.pop();
                    for(let e1 = 0; e1 < n.length; e1++){
                        if (n[e1].sources.length > 1) {
                            throw new Error("Transformation map ".concat(e1, " must have exactly one source file.\n") + "Did you specify these with the most recent transformation maps first?");
                        }
                    }
                    let i = build(s, r, "", 0);
                    for(let e1 = n.length - 1; e1 >= 0; e1--){
                        i = MapSource(n[e1], [
                            i
                        ]);
                    }
                    return i;
                }
                function build(t, r, n, s) {
                    const { resolvedSources: i, sourcesContent: a } = t;
                    const o = s + 1;
                    const l = i.map((t, s)=>{
                        const i = {
                            importer: n,
                            depth: o,
                            source: t || "",
                            content: undefined
                        };
                        const l = r(i.source, i);
                        const { source: c, content: p } = i;
                        if (l) return build(new e1.TraceMap(l, c), r, c, o);
                        const u = p !== undefined ? p : a ? a[s] : null;
                        return OriginalSource(c, u);
                    });
                    return MapSource(t, l);
                }
                class SourceMap {
                    toString() {
                        return JSON.stringify(this);
                    }
                    constructor(e1, r){
                        const n = r.decodedMappings ? t.toDecodedMap(e1) : t.toEncodedMap(e1);
                        this.version = n.version;
                        this.file = n.file;
                        this.mappings = n.mappings;
                        this.names = n.names;
                        this.sourceRoot = n.sourceRoot;
                        this.sources = n.sources;
                        if (!r.excludeContent) {
                            this.sourcesContent = n.sourcesContent;
                        }
                    }
                }
                function remapping(e1, t, r) {
                    const n = typeof r === "object" ? r : {
                        excludeContent: !!r,
                        decodedMappings: false
                    };
                    const s = buildSourceMapTree(e1, t);
                    return new SourceMap(traceMappings(s), n);
                }
                return remapping;
            });
        },
        2987: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(7168), r(1575), r(8536)) : "TURBOPACK unreachable";
            })(this, function(e1, t, r, n) {
                "use strict";
                const s = 0;
                const i = 1;
                const a = 2;
                const o = 3;
                const l = 4;
                const c = -1;
                e1.addSegment = void 0;
                e1.addMapping = void 0;
                e1.maybeAddSegment = void 0;
                e1.maybeAddMapping = void 0;
                e1.setSourceContent = void 0;
                e1.toDecodedMap = void 0;
                e1.toEncodedMap = void 0;
                e1.fromMap = void 0;
                e1.allMappings = void 0;
                let p;
                class GenMapping {
                    constructor({ file: e1, sourceRoot: r } = {}){
                        this._names = new t.SetArray;
                        this._sources = new t.SetArray;
                        this._sourcesContent = [];
                        this._mappings = [];
                        this.file = e1;
                        this.sourceRoot = r;
                    }
                }
                (()=>{
                    e1.addSegment = (e1, t, r, n, s, i, a, o)=>p(false, e1, t, r, n, s, i, a, o);
                    e1.maybeAddSegment = (e1, t, r, n, s, i, a, o)=>p(true, e1, t, r, n, s, i, a, o);
                    e1.addMapping = (e1, t)=>addMappingInternal(false, e1, t);
                    e1.maybeAddMapping = (e1, t)=>addMappingInternal(true, e1, t);
                    e1.setSourceContent = (e1, r, n)=>{
                        const { _sources: s, _sourcesContent: i } = e1;
                        i[t.put(s, r)] = n;
                    };
                    e1.toDecodedMap = (e1)=>{
                        const { file: t, sourceRoot: r, _mappings: n, _sources: s, _sourcesContent: i, _names: a } = e1;
                        removeEmptyFinalLines(n);
                        return {
                            version: 3,
                            file: t || undefined,
                            names: a.array,
                            sourceRoot: r || undefined,
                            sources: s.array,
                            sourcesContent: i,
                            mappings: n
                        };
                    };
                    e1.toEncodedMap = (t)=>{
                        const n = e1.toDecodedMap(t);
                        return Object.assign(Object.assign({}, n), {
                            mappings: r.encode(n.mappings)
                        });
                    };
                    e1.allMappings = (e1)=>{
                        const t = [];
                        const { _mappings: r, _sources: n, _names: c } = e1;
                        for(let e1 = 0; e1 < r.length; e1++){
                            const p = r[e1];
                            for(let r = 0; r < p.length; r++){
                                const u = p[r];
                                const d = {
                                    line: e1 + 1,
                                    column: u[s]
                                };
                                let f = undefined;
                                let h = undefined;
                                let m = undefined;
                                if (u.length !== 1) {
                                    f = n.array[u[i]];
                                    h = {
                                        line: u[a] + 1,
                                        column: u[o]
                                    };
                                    if (u.length === 5) m = c.array[u[l]];
                                }
                                t.push({
                                    generated: d,
                                    source: f,
                                    original: h,
                                    name: m
                                });
                            }
                        }
                        return t;
                    };
                    e1.fromMap = (e1)=>{
                        const t = new n.TraceMap(e1);
                        const r = new GenMapping({
                            file: t.file,
                            sourceRoot: t.sourceRoot
                        });
                        putAll(r._names, t.names);
                        putAll(r._sources, t.sources);
                        r._sourcesContent = t.sourcesContent || t.sources.map(()=>null);
                        r._mappings = n.decodedMappings(t);
                        return r;
                    };
                    p = (e1, r, n, s, i, a, o, l, p)=>{
                        const { _mappings: u, _sources: d, _sourcesContent: f, _names: h } = r;
                        const m = getLine(u, n);
                        const y = getColumnIndex(m, s);
                        if (!i) {
                            if (e1 && skipSourceless(m, y)) return;
                            return insert(m, y, [
                                s
                            ]);
                        }
                        const g = t.put(d, i);
                        const b = l ? t.put(h, l) : c;
                        if (g === f.length) f[g] = p !== null && p !== void 0 ? p : null;
                        if (e1 && skipSource(m, y, g, a, o, b)) {
                            return;
                        }
                        return insert(m, y, l ? [
                            s,
                            g,
                            a,
                            o,
                            b
                        ] : [
                            s,
                            g,
                            a,
                            o
                        ]);
                    };
                })();
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++){
                        e1[r] = [];
                    }
                    return e1[t];
                }
                function getColumnIndex(e1, t) {
                    let r = e1.length;
                    for(let n = r - 1; n >= 0; r = n--){
                        const r = e1[n];
                        if (t >= r[s]) break;
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function removeEmptyFinalLines(e1) {
                    const { length: t } = e1;
                    let r = t;
                    for(let t = r - 1; t >= 0; r = t, t--){
                        if (e1[t].length > 0) break;
                    }
                    if (r < t) e1.length = r;
                }
                function putAll(e1, r) {
                    for(let n = 0; n < r.length; n++)t.put(e1, r[n]);
                }
                function skipSourceless(e1, t) {
                    if (t === 0) return true;
                    const r = e1[t - 1];
                    return r.length === 1;
                }
                function skipSource(e1, t, r, n, s, p) {
                    if (t === 0) return false;
                    const u = e1[t - 1];
                    if (u.length === 1) return false;
                    return r === u[i] && n === u[a] && s === u[o] && p === (u.length === 5 ? u[l] : c);
                }
                function addMappingInternal(e1, t, r) {
                    const { generated: n, source: s, original: i, name: a, content: o } = r;
                    if (!s) {
                        return p(e1, t, n.line - 1, n.column, null, null, null, null, null);
                    }
                    const l = s;
                    return p(e1, t, n.line - 1, n.column, l, i.line - 1, i.column, a, o);
                }
                e1.GenMapping = GenMapping;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        7237: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(7734), r(8918), r(8536)) : "TURBOPACK unreachable";
            })(this, function(e1, t, r, n) {
                "use strict";
                const s = 0;
                const i = 1;
                const a = 2;
                const o = 3;
                const l = 4;
                const c = -1;
                class GenMapping {
                    constructor({ file: e1, sourceRoot: r } = {}){
                        this._names = new t.SetArray;
                        this._sources = new t.SetArray;
                        this._sourcesContent = [];
                        this._mappings = [];
                        this.file = e1;
                        this.sourceRoot = r;
                        this._ignoreList = new t.SetArray;
                    }
                }
                function cast(e1) {
                    return e1;
                }
                function addSegment(e1, t, r, n, s, i, a, o) {
                    return addSegmentInternal(false, e1, t, r, n, s, i, a, o);
                }
                function addMapping(e1, t) {
                    return addMappingInternal(false, e1, t);
                }
                const maybeAddSegment = (e1, t, r, n, s, i, a, o)=>addSegmentInternal(true, e1, t, r, n, s, i, a, o);
                const maybeAddMapping = (e1, t)=>addMappingInternal(true, e1, t);
                function setSourceContent(e1, r, n) {
                    const { _sources: s, _sourcesContent: i } = cast(e1);
                    const a = t.put(s, r);
                    i[a] = n;
                }
                function setIgnore(e1, r) {
                    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                    const { _sources: s, _sourcesContent: i, _ignoreList: a } = cast(e1);
                    const o = t.put(s, r);
                    if (o === i.length) i[o] = null;
                    if (n) t.put(a, o);
                    else t.remove(a, o);
                }
                function toDecodedMap(e1) {
                    const { _mappings: t, _sources: r, _sourcesContent: n, _names: s, _ignoreList: i } = cast(e1);
                    removeEmptyFinalLines(t);
                    return {
                        version: 3,
                        file: e1.file || undefined,
                        names: s.array,
                        sourceRoot: e1.sourceRoot || undefined,
                        sources: r.array,
                        sourcesContent: n,
                        mappings: t,
                        ignoreList: i.array
                    };
                }
                function toEncodedMap(e1) {
                    const t = toDecodedMap(e1);
                    return Object.assign(Object.assign({}, t), {
                        mappings: r.encode(t.mappings)
                    });
                }
                function fromMap(e1) {
                    const t = new n.TraceMap(e1);
                    const r = new GenMapping({
                        file: t.file,
                        sourceRoot: t.sourceRoot
                    });
                    putAll(cast(r)._names, t.names);
                    putAll(cast(r)._sources, t.sources);
                    cast(r)._sourcesContent = t.sourcesContent || t.sources.map(()=>null);
                    cast(r)._mappings = n.decodedMappings(t);
                    if (t.ignoreList) putAll(cast(r)._ignoreList, t.ignoreList);
                    return r;
                }
                function allMappings(e1) {
                    const t = [];
                    const { _mappings: r, _sources: n, _names: c } = cast(e1);
                    for(let e1 = 0; e1 < r.length; e1++){
                        const p = r[e1];
                        for(let r = 0; r < p.length; r++){
                            const u = p[r];
                            const d = {
                                line: e1 + 1,
                                column: u[s]
                            };
                            let f = undefined;
                            let h = undefined;
                            let m = undefined;
                            if (u.length !== 1) {
                                f = n.array[u[i]];
                                h = {
                                    line: u[a] + 1,
                                    column: u[o]
                                };
                                if (u.length === 5) m = c.array[u[l]];
                            }
                            t.push({
                                generated: d,
                                source: f,
                                original: h,
                                name: m
                            });
                        }
                    }
                    return t;
                }
                function addSegmentInternal(e1, r, n, s, i, a, o, l, p) {
                    const { _mappings: u, _sources: d, _sourcesContent: f, _names: h } = cast(r);
                    const m = getLine(u, n);
                    const y = getColumnIndex(m, s);
                    if (!i) {
                        if (e1 && skipSourceless(m, y)) return;
                        return insert(m, y, [
                            s
                        ]);
                    }
                    const g = t.put(d, i);
                    const b = l ? t.put(h, l) : c;
                    if (g === f.length) f[g] = p !== null && p !== void 0 ? p : null;
                    if (e1 && skipSource(m, y, g, a, o, b)) {
                        return;
                    }
                    return insert(m, y, l ? [
                        s,
                        g,
                        a,
                        o,
                        b
                    ] : [
                        s,
                        g,
                        a,
                        o
                    ]);
                }
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++){
                        e1[r] = [];
                    }
                    return e1[t];
                }
                function getColumnIndex(e1, t) {
                    let r = e1.length;
                    for(let n = r - 1; n >= 0; r = n--){
                        const r = e1[n];
                        if (t >= r[s]) break;
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function removeEmptyFinalLines(e1) {
                    const { length: t } = e1;
                    let r = t;
                    for(let t = r - 1; t >= 0; r = t, t--){
                        if (e1[t].length > 0) break;
                    }
                    if (r < t) e1.length = r;
                }
                function putAll(e1, r) {
                    for(let n = 0; n < r.length; n++)t.put(e1, r[n]);
                }
                function skipSourceless(e1, t) {
                    if (t === 0) return true;
                    const r = e1[t - 1];
                    return r.length === 1;
                }
                function skipSource(e1, t, r, n, s, p) {
                    if (t === 0) return false;
                    const u = e1[t - 1];
                    if (u.length === 1) return false;
                    return r === u[i] && n === u[a] && s === u[o] && p === (u.length === 5 ? u[l] : c);
                }
                function addMappingInternal(e1, t, r) {
                    const { generated: n, source: s, original: i, name: a, content: o } = r;
                    if (!s) {
                        return addSegmentInternal(e1, t, n.line - 1, n.column, null, null, null, null, null);
                    }
                    return addSegmentInternal(e1, t, n.line - 1, n.column, s, i.line - 1, i.column, a, o);
                }
                e1.GenMapping = GenMapping;
                e1.addMapping = addMapping;
                e1.addSegment = addSegment;
                e1.allMappings = allMappings;
                e1.fromMap = fromMap;
                e1.maybeAddMapping = maybeAddMapping;
                e1.maybeAddSegment = maybeAddSegment;
                e1.setIgnore = setIgnore;
                e1.setSourceContent = setSourceContent;
                e1.toDecodedMap = toDecodedMap;
                e1.toEncodedMap = toEncodedMap;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        6982: function(e1) {
            (function(t, r) {
                ("TURBOPACK compile-time truthy", 1) ? e1.exports = r() : "TURBOPACK unreachable";
            })(this, function() {
                "use strict";
                const e1 = /^[\w+.-]+:\/\//;
                const t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
                const r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
                var n;
                (function(e1) {
                    e1[e1["Empty"] = 1] = "Empty";
                    e1[e1["Hash"] = 2] = "Hash";
                    e1[e1["Query"] = 3] = "Query";
                    e1[e1["RelativePath"] = 4] = "RelativePath";
                    e1[e1["AbsolutePath"] = 5] = "AbsolutePath";
                    e1[e1["SchemeRelative"] = 6] = "SchemeRelative";
                    e1[e1["Absolute"] = 7] = "Absolute";
                })(n || (n = {}));
                function isAbsoluteUrl(t) {
                    return e1.test(t);
                }
                function isSchemeRelativeUrl(e1) {
                    return e1.startsWith("//");
                }
                function isAbsolutePath(e1) {
                    return e1.startsWith("/");
                }
                function isFileUrl(e1) {
                    return e1.startsWith("file:");
                }
                function isRelative(e1) {
                    return /^[.?#]/.test(e1);
                }
                function parseAbsoluteUrl(e1) {
                    const r = t.exec(e1);
                    return makeUrl(r[1], r[2] || "", r[3], r[4] || "", r[5] || "/", r[6] || "", r[7] || "");
                }
                function parseFileUrl(e1) {
                    const t = r.exec(e1);
                    const n = t[2];
                    return makeUrl("file:", "", t[1] || "", "", isAbsolutePath(n) ? n : "/" + n, t[3] || "", t[4] || "");
                }
                function makeUrl(e1, t, r, s, i, a, o) {
                    return {
                        scheme: e1,
                        user: t,
                        host: r,
                        port: s,
                        path: i,
                        query: a,
                        hash: o,
                        type: n.Absolute
                    };
                }
                function parseUrl(e1) {
                    if (isSchemeRelativeUrl(e1)) {
                        const t = parseAbsoluteUrl("http:" + e1);
                        t.scheme = "";
                        t.type = n.SchemeRelative;
                        return t;
                    }
                    if (isAbsolutePath(e1)) {
                        const t = parseAbsoluteUrl("http://foo.com" + e1);
                        t.scheme = "";
                        t.host = "";
                        t.type = n.AbsolutePath;
                        return t;
                    }
                    if (isFileUrl(e1)) return parseFileUrl(e1);
                    if (isAbsoluteUrl(e1)) return parseAbsoluteUrl(e1);
                    const t = parseAbsoluteUrl("http://foo.com/" + e1);
                    t.scheme = "";
                    t.host = "";
                    t.type = e1 ? e1.startsWith("?") ? n.Query : e1.startsWith("#") ? n.Hash : n.RelativePath : n.Empty;
                    return t;
                }
                function stripPathFilename(e1) {
                    if (e1.endsWith("/..")) return e1;
                    const t = e1.lastIndexOf("/");
                    return e1.slice(0, t + 1);
                }
                function mergePaths(e1, t) {
                    normalizePath(t, t.type);
                    if (e1.path === "/") {
                        e1.path = t.path;
                    } else {
                        e1.path = stripPathFilename(t.path) + e1.path;
                    }
                }
                function normalizePath(e1, t) {
                    const r = t <= n.RelativePath;
                    const s = e1.path.split("/");
                    let i = 1;
                    let a = 0;
                    let o = false;
                    for(let e1 = 1; e1 < s.length; e1++){
                        const t = s[e1];
                        if (!t) {
                            o = true;
                            continue;
                        }
                        o = false;
                        if (t === ".") continue;
                        if (t === "..") {
                            if (a) {
                                o = true;
                                a--;
                                i--;
                            } else if (r) {
                                s[i++] = t;
                            }
                            continue;
                        }
                        s[i++] = t;
                        a++;
                    }
                    let l = "";
                    for(let e1 = 1; e1 < i; e1++){
                        l += "/" + s[e1];
                    }
                    if (!l || o && !l.endsWith("/..")) {
                        l += "/";
                    }
                    e1.path = l;
                }
                function resolve(e1, t) {
                    if (!e1 && !t) return "";
                    const r = parseUrl(e1);
                    let s = r.type;
                    if (t && s !== n.Absolute) {
                        const e1 = parseUrl(t);
                        const i = e1.type;
                        switch(s){
                            case n.Empty:
                                r.hash = e1.hash;
                            case n.Hash:
                                r.query = e1.query;
                            case n.Query:
                            case n.RelativePath:
                                mergePaths(r, e1);
                            case n.AbsolutePath:
                                r.user = e1.user;
                                r.host = e1.host;
                                r.port = e1.port;
                            case n.SchemeRelative:
                                r.scheme = e1.scheme;
                        }
                        if (i > s) s = i;
                    }
                    normalizePath(r, s);
                    const i = r.query + r.hash;
                    switch(s){
                        case n.Hash:
                        case n.Query:
                            return i;
                        case n.RelativePath:
                            {
                                const n = r.path.slice(1);
                                if (!n) return i || ".";
                                if (isRelative(t || e1) && !isRelative(n)) {
                                    return "./" + n + i;
                                }
                                return n + i;
                            }
                        case n.AbsolutePath:
                            return r.path + i;
                        default:
                            return r.scheme + "//" + r.user + r.host + r.port + r.path + i;
                    }
                }
                return resolve;
            });
        },
        7168: function(e1, t) {
            (function(e1, r) {
                ("TURBOPACK compile-time truthy", 1) ? r(t) : "TURBOPACK unreachable";
            })(this, function(e1) {
                "use strict";
                e1.get = void 0;
                e1.put = void 0;
                e1.pop = void 0;
                class SetArray {
                    constructor(){
                        this._indexes = {
                            __proto__: null
                        };
                        this.array = [];
                    }
                }
                (()=>{
                    e1.get = (e1, t)=>e1._indexes[t];
                    e1.put = (t, r)=>{
                        const n = e1.get(t, r);
                        if (n !== undefined) return n;
                        const { array: s, _indexes: i } = t;
                        return i[r] = s.push(r) - 1;
                    };
                    e1.pop = (e1)=>{
                        const { array: t, _indexes: r } = e1;
                        if (t.length === 0) return;
                        const n = t.pop();
                        r[n] = undefined;
                    };
                })();
                e1.SetArray = SetArray;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        7734: function(e1, t) {
            (function(e1, r) {
                ("TURBOPACK compile-time truthy", 1) ? r(t) : "TURBOPACK unreachable";
            })(this, function(e1) {
                "use strict";
                class SetArray {
                    constructor(){
                        this._indexes = {
                            __proto__: null
                        };
                        this.array = [];
                    }
                }
                function cast(e1) {
                    return e1;
                }
                function get(e1, t) {
                    return cast(e1)._indexes[t];
                }
                function put(e1, t) {
                    const r = get(e1, t);
                    if (r !== undefined) return r;
                    const { array: n, _indexes: s } = cast(e1);
                    const i = n.push(t);
                    return s[t] = i - 1;
                }
                function pop(e1) {
                    const { array: t, _indexes: r } = cast(e1);
                    if (t.length === 0) return;
                    const n = t.pop();
                    r[n] = undefined;
                }
                function remove(e1, t) {
                    const r = get(e1, t);
                    if (r === undefined) return;
                    const { array: n, _indexes: s } = cast(e1);
                    for(let e1 = r + 1; e1 < n.length; e1++){
                        const t = n[e1];
                        n[e1 - 1] = t;
                        s[t]--;
                    }
                    s[t] = undefined;
                    n.pop();
                }
                e1.SetArray = SetArray;
                e1.get = get;
                e1.pop = pop;
                e1.put = put;
                e1.remove = remove;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        1575: function(e1, t) {
            (function(e1, r) {
                ("TURBOPACK compile-time truthy", 1) ? r(t) : "TURBOPACK unreachable";
            })(this, function(e1) {
                "use strict";
                const t = ",".charCodeAt(0);
                const r = ";".charCodeAt(0);
                const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                const s = new Uint8Array(64);
                const i = new Uint8Array(128);
                for(let e1 = 0; e1 < n.length; e1++){
                    const t = n.charCodeAt(e1);
                    s[e1] = t;
                    i[t] = e1;
                }
                const a = typeof TextDecoder !== "undefined" ? new TextDecoder : typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined" ? {
                    decode (e1) {
                        const t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e1.buffer, e1.byteOffset, e1.byteLength);
                        return t.toString();
                    }
                } : {
                    decode (e1) {
                        let t = "";
                        for(let r = 0; r < e1.length; r++){
                            t += String.fromCharCode(e1[r]);
                        }
                        return t;
                    }
                };
                function decode(e1) {
                    const t = new Int32Array(5);
                    const r = [];
                    let n = 0;
                    do {
                        const s = indexOf(e1, n);
                        const i = [];
                        let a = true;
                        let o = 0;
                        t[0] = 0;
                        for(let r = n; r < s; r++){
                            let n;
                            r = decodeInteger(e1, r, t, 0);
                            const l = t[0];
                            if (l < o) a = false;
                            o = l;
                            if (hasMoreVlq(e1, r, s)) {
                                r = decodeInteger(e1, r, t, 1);
                                r = decodeInteger(e1, r, t, 2);
                                r = decodeInteger(e1, r, t, 3);
                                if (hasMoreVlq(e1, r, s)) {
                                    r = decodeInteger(e1, r, t, 4);
                                    n = [
                                        l,
                                        t[1],
                                        t[2],
                                        t[3],
                                        t[4]
                                    ];
                                } else {
                                    n = [
                                        l,
                                        t[1],
                                        t[2],
                                        t[3]
                                    ];
                                }
                            } else {
                                n = [
                                    l
                                ];
                            }
                            i.push(n);
                        }
                        if (!a) sort(i);
                        r.push(i);
                        n = s + 1;
                    }while (n <= e1.length)
                    return r;
                }
                function indexOf(e1, t) {
                    const r = e1.indexOf(";", t);
                    return r === -1 ? e1.length : r;
                }
                function decodeInteger(e1, t, r, n) {
                    let s = 0;
                    let a = 0;
                    let o = 0;
                    do {
                        const r = e1.charCodeAt(t++);
                        o = i[r];
                        s |= (o & 31) << a;
                        a += 5;
                    }while (o & 32)
                    const l = s & 1;
                    s >>>= 1;
                    if (l) {
                        s = -2147483648 | -s;
                    }
                    r[n] += s;
                    return t;
                }
                function hasMoreVlq(e1, r, n) {
                    if (r >= n) return false;
                    return e1.charCodeAt(r) !== t;
                }
                function sort(e1) {
                    e1.sort(sortComparator);
                }
                function sortComparator(e1, t) {
                    return e1[0] - t[0];
                }
                function encode(e1) {
                    const n = new Int32Array(5);
                    const s = 1024 * 16;
                    const i = s - 36;
                    const o = new Uint8Array(s);
                    const l = o.subarray(0, i);
                    let c = 0;
                    let p = "";
                    for(let u = 0; u < e1.length; u++){
                        const d = e1[u];
                        if (u > 0) {
                            if (c === s) {
                                p += a.decode(o);
                                c = 0;
                            }
                            o[c++] = r;
                        }
                        if (d.length === 0) continue;
                        n[0] = 0;
                        for(let e1 = 0; e1 < d.length; e1++){
                            const r = d[e1];
                            if (c > i) {
                                p += a.decode(l);
                                o.copyWithin(0, i, c);
                                c -= i;
                            }
                            if (e1 > 0) o[c++] = t;
                            c = encodeInteger(o, c, n, r, 0);
                            if (r.length === 1) continue;
                            c = encodeInteger(o, c, n, r, 1);
                            c = encodeInteger(o, c, n, r, 2);
                            c = encodeInteger(o, c, n, r, 3);
                            if (r.length === 4) continue;
                            c = encodeInteger(o, c, n, r, 4);
                        }
                    }
                    return p + a.decode(o.subarray(0, c));
                }
                function encodeInteger(e1, t, r, n, i) {
                    const a = n[i];
                    let o = a - r[i];
                    r[i] = a;
                    o = o < 0 ? -o << 1 | 1 : o << 1;
                    do {
                        let r = o & 31;
                        o >>>= 5;
                        if (o > 0) r |= 32;
                        e1[t++] = s[r];
                    }while (o > 0)
                    return t;
                }
                e1.decode = decode;
                e1.encode = encode;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        8918: function(e1, t) {
            (function(e1, r) {
                ("TURBOPACK compile-time truthy", 1) ? r(t) : "TURBOPACK unreachable";
            })(this, function(e1) {
                "use strict";
                const t = ",".charCodeAt(0);
                const r = ";".charCodeAt(0);
                const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                const s = new Uint8Array(64);
                const i = new Uint8Array(128);
                for(let e1 = 0; e1 < n.length; e1++){
                    const t = n.charCodeAt(e1);
                    s[e1] = t;
                    i[t] = e1;
                }
                function decodeInteger(e1, t) {
                    let r = 0;
                    let n = 0;
                    let s = 0;
                    do {
                        const t = e1.next();
                        s = i[t];
                        r |= (s & 31) << n;
                        n += 5;
                    }while (s & 32)
                    const a = r & 1;
                    r >>>= 1;
                    if (a) {
                        r = -2147483648 | -r;
                    }
                    return t + r;
                }
                function encodeInteger(e1, t, r) {
                    let n = t - r;
                    n = n < 0 ? -n << 1 | 1 : n << 1;
                    do {
                        let t = n & 31;
                        n >>>= 5;
                        if (n > 0) t |= 32;
                        e1.write(s[t]);
                    }while (n > 0)
                    return t;
                }
                function hasMoreVlq(e1, r) {
                    if (e1.pos >= r) return false;
                    return e1.peek() !== t;
                }
                const a = 1024 * 16;
                const o = typeof TextDecoder !== "undefined" ? new TextDecoder : typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined" ? {
                    decode (e1) {
                        const t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e1.buffer, e1.byteOffset, e1.byteLength);
                        return t.toString();
                    }
                } : {
                    decode (e1) {
                        let t = "";
                        for(let r = 0; r < e1.length; r++){
                            t += String.fromCharCode(e1[r]);
                        }
                        return t;
                    }
                };
                class StringWriter {
                    write(e1) {
                        const { buffer: t } = this;
                        t[this.pos++] = e1;
                        if (this.pos === a) {
                            this.out += o.decode(t);
                            this.pos = 0;
                        }
                    }
                    flush() {
                        const { buffer: e1, out: t, pos: r } = this;
                        return r > 0 ? t + o.decode(e1.subarray(0, r)) : t;
                    }
                    constructor(){
                        this.pos = 0;
                        this.out = "";
                        this.buffer = new Uint8Array(a);
                    }
                }
                class StringReader {
                    next() {
                        return this.buffer.charCodeAt(this.pos++);
                    }
                    peek() {
                        return this.buffer.charCodeAt(this.pos);
                    }
                    indexOf(e1) {
                        const { buffer: t, pos: r } = this;
                        const n = t.indexOf(e1, r);
                        return n === -1 ? t.length : n;
                    }
                    constructor(e1){
                        this.pos = 0;
                        this.buffer = e1;
                    }
                }
                const l = [];
                function decodeOriginalScopes(e1) {
                    const { length: t } = e1;
                    const r = new StringReader(e1);
                    const n = [];
                    const s = [];
                    let i = 0;
                    for(; r.pos < t; r.pos++){
                        i = decodeInteger(r, i);
                        const e1 = decodeInteger(r, 0);
                        if (!hasMoreVlq(r, t)) {
                            const t = s.pop();
                            t[2] = i;
                            t[3] = e1;
                            continue;
                        }
                        const a = decodeInteger(r, 0);
                        const o = decodeInteger(r, 0);
                        const c = o & 1;
                        const p = c ? [
                            i,
                            e1,
                            0,
                            0,
                            a,
                            decodeInteger(r, 0)
                        ] : [
                            i,
                            e1,
                            0,
                            0,
                            a
                        ];
                        let u = l;
                        if (hasMoreVlq(r, t)) {
                            u = [];
                            do {
                                const e1 = decodeInteger(r, 0);
                                u.push(e1);
                            }while (hasMoreVlq(r, t))
                        }
                        p.vars = u;
                        n.push(p);
                        s.push(p);
                    }
                    return n;
                }
                function encodeOriginalScopes(e1) {
                    const t = new StringWriter;
                    for(let r = 0; r < e1.length;){
                        r = _encodeOriginalScopes(e1, r, t, [
                            0
                        ]);
                    }
                    return t.flush();
                }
                function _encodeOriginalScopes(e1, r, n, s) {
                    const i = e1[r];
                    const { 0: a, 1: o, 2: l, 3: c, 4: p, vars: u } = i;
                    if (r > 0) n.write(t);
                    s[0] = encodeInteger(n, a, s[0]);
                    encodeInteger(n, o, 0);
                    encodeInteger(n, p, 0);
                    const d = i.length === 6 ? 1 : 0;
                    encodeInteger(n, d, 0);
                    if (i.length === 6) encodeInteger(n, i[5], 0);
                    for (const e1 of u){
                        encodeInteger(n, e1, 0);
                    }
                    for(r++; r < e1.length;){
                        const t = e1[r];
                        const { 0: i, 1: a } = t;
                        if (i > l || i === l && a >= c) {
                            break;
                        }
                        r = _encodeOriginalScopes(e1, r, n, s);
                    }
                    n.write(t);
                    s[0] = encodeInteger(n, l, s[0]);
                    encodeInteger(n, c, 0);
                    return r;
                }
                function decodeGeneratedRanges(e1) {
                    const { length: t } = e1;
                    const r = new StringReader(e1);
                    const n = [];
                    const s = [];
                    let i = 0;
                    let a = 0;
                    let o = 0;
                    let c = 0;
                    let p = 0;
                    let u = 0;
                    let d = 0;
                    let f = 0;
                    do {
                        const e1 = r.indexOf(";");
                        let t = 0;
                        for(; r.pos < e1; r.pos++){
                            t = decodeInteger(r, t);
                            if (!hasMoreVlq(r, e1)) {
                                const e1 = s.pop();
                                e1[2] = i;
                                e1[3] = t;
                                continue;
                            }
                            const h = decodeInteger(r, 0);
                            const m = h & 1;
                            const y = h & 2;
                            const g = h & 4;
                            let b = null;
                            let T = l;
                            let S;
                            if (m) {
                                const e1 = decodeInteger(r, a);
                                o = decodeInteger(r, a === e1 ? o : 0);
                                a = e1;
                                S = [
                                    i,
                                    t,
                                    0,
                                    0,
                                    e1,
                                    o
                                ];
                            } else {
                                S = [
                                    i,
                                    t,
                                    0,
                                    0
                                ];
                            }
                            S.isScope = !!g;
                            if (y) {
                                const e1 = c;
                                const t = p;
                                c = decodeInteger(r, c);
                                const n = e1 === c;
                                p = decodeInteger(r, n ? p : 0);
                                u = decodeInteger(r, n && t === p ? u : 0);
                                b = [
                                    c,
                                    p,
                                    u
                                ];
                            }
                            S.callsite = b;
                            if (hasMoreVlq(r, e1)) {
                                T = [];
                                do {
                                    d = i;
                                    f = t;
                                    const e1 = decodeInteger(r, 0);
                                    let n;
                                    if (e1 < -1) {
                                        n = [
                                            [
                                                decodeInteger(r, 0)
                                            ]
                                        ];
                                        for(let t = -1; t > e1; t--){
                                            const e1 = d;
                                            d = decodeInteger(r, d);
                                            f = decodeInteger(r, d === e1 ? f : 0);
                                            const t = decodeInteger(r, 0);
                                            n.push([
                                                t,
                                                d,
                                                f
                                            ]);
                                        }
                                    } else {
                                        n = [
                                            [
                                                e1
                                            ]
                                        ];
                                    }
                                    T.push(n);
                                }while (hasMoreVlq(r, e1))
                            }
                            S.bindings = T;
                            n.push(S);
                            s.push(S);
                        }
                        i++;
                        r.pos = e1 + 1;
                    }while (r.pos < t)
                    return n;
                }
                function encodeGeneratedRanges(e1) {
                    if (e1.length === 0) return "";
                    const t = new StringWriter;
                    for(let r = 0; r < e1.length;){
                        r = _encodeGeneratedRanges(e1, r, t, [
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]);
                    }
                    return t.flush();
                }
                function _encodeGeneratedRanges(e1, r, n, s) {
                    const i = e1[r];
                    const { 0: a, 1: o, 2: l, 3: c, isScope: p, callsite: u, bindings: d } = i;
                    if (s[0] < a) {
                        catchupLine(n, s[0], a);
                        s[0] = a;
                        s[1] = 0;
                    } else if (r > 0) {
                        n.write(t);
                    }
                    s[1] = encodeInteger(n, i[1], s[1]);
                    const f = (i.length === 6 ? 1 : 0) | (u ? 2 : 0) | (p ? 4 : 0);
                    encodeInteger(n, f, 0);
                    if (i.length === 6) {
                        const { 4: e1, 5: t } = i;
                        if (e1 !== s[2]) {
                            s[3] = 0;
                        }
                        s[2] = encodeInteger(n, e1, s[2]);
                        s[3] = encodeInteger(n, t, s[3]);
                    }
                    if (u) {
                        const { 0: e1, 1: t, 2: r } = i.callsite;
                        if (e1 !== s[4]) {
                            s[5] = 0;
                            s[6] = 0;
                        } else if (t !== s[5]) {
                            s[6] = 0;
                        }
                        s[4] = encodeInteger(n, e1, s[4]);
                        s[5] = encodeInteger(n, t, s[5]);
                        s[6] = encodeInteger(n, r, s[6]);
                    }
                    if (d) {
                        for (const e1 of d){
                            if (e1.length > 1) encodeInteger(n, -e1.length, 0);
                            const t = e1[0][0];
                            encodeInteger(n, t, 0);
                            let r = a;
                            let s = o;
                            for(let t = 1; t < e1.length; t++){
                                const i = e1[t];
                                r = encodeInteger(n, i[1], r);
                                s = encodeInteger(n, i[2], s);
                                encodeInteger(n, i[0], 0);
                            }
                        }
                    }
                    for(r++; r < e1.length;){
                        const t = e1[r];
                        const { 0: i, 1: a } = t;
                        if (i > l || i === l && a >= c) {
                            break;
                        }
                        r = _encodeGeneratedRanges(e1, r, n, s);
                    }
                    if (s[0] < l) {
                        catchupLine(n, s[0], l);
                        s[0] = l;
                        s[1] = 0;
                    } else {
                        n.write(t);
                    }
                    s[1] = encodeInteger(n, c, s[1]);
                    return r;
                }
                function catchupLine(e1, t, n) {
                    do {
                        e1.write(r);
                    }while (++t < n)
                }
                function decode(e1) {
                    const { length: t } = e1;
                    const r = new StringReader(e1);
                    const n = [];
                    let s = 0;
                    let i = 0;
                    let a = 0;
                    let o = 0;
                    let l = 0;
                    do {
                        const e1 = r.indexOf(";");
                        const t = [];
                        let c = true;
                        let p = 0;
                        s = 0;
                        while(r.pos < e1){
                            let n;
                            s = decodeInteger(r, s);
                            if (s < p) c = false;
                            p = s;
                            if (hasMoreVlq(r, e1)) {
                                i = decodeInteger(r, i);
                                a = decodeInteger(r, a);
                                o = decodeInteger(r, o);
                                if (hasMoreVlq(r, e1)) {
                                    l = decodeInteger(r, l);
                                    n = [
                                        s,
                                        i,
                                        a,
                                        o,
                                        l
                                    ];
                                } else {
                                    n = [
                                        s,
                                        i,
                                        a,
                                        o
                                    ];
                                }
                            } else {
                                n = [
                                    s
                                ];
                            }
                            t.push(n);
                            r.pos++;
                        }
                        if (!c) sort(t);
                        n.push(t);
                        r.pos = e1 + 1;
                    }while (r.pos <= t)
                    return n;
                }
                function sort(e1) {
                    e1.sort(sortComparator);
                }
                function sortComparator(e1, t) {
                    return e1[0] - t[0];
                }
                function encode(e1) {
                    const n = new StringWriter;
                    let s = 0;
                    let i = 0;
                    let a = 0;
                    let o = 0;
                    for(let l = 0; l < e1.length; l++){
                        const c = e1[l];
                        if (l > 0) n.write(r);
                        if (c.length === 0) continue;
                        let p = 0;
                        for(let e1 = 0; e1 < c.length; e1++){
                            const r = c[e1];
                            if (e1 > 0) n.write(t);
                            p = encodeInteger(n, r[0], p);
                            if (r.length === 1) continue;
                            s = encodeInteger(n, r[1], s);
                            i = encodeInteger(n, r[2], i);
                            a = encodeInteger(n, r[3], a);
                            if (r.length === 4) continue;
                            o = encodeInteger(n, r[4], o);
                        }
                    }
                    return n.flush();
                }
                e1.decode = decode;
                e1.decodeGeneratedRanges = decodeGeneratedRanges;
                e1.decodeOriginalScopes = decodeOriginalScopes;
                e1.encode = encode;
                e1.encodeGeneratedRanges = encodeGeneratedRanges;
                e1.encodeOriginalScopes = encodeOriginalScopes;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        8536: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(8918), r(6982)) : "TURBOPACK unreachable";
            })(this, function(e1, t, r) {
                "use strict";
                function resolve(e1, t) {
                    if (t && !t.endsWith("/")) t += "/";
                    return r(e1, t);
                }
                function stripFilename(e1) {
                    if (!e1) return "";
                    const t = e1.lastIndexOf("/");
                    return e1.slice(0, t + 1);
                }
                const n = 0;
                const s = 1;
                const i = 2;
                const a = 3;
                const o = 4;
                const l = 1;
                const c = 2;
                function maybeSort(e1, t) {
                    const r = nextUnsortedSegmentLine(e1, 0);
                    if (r === e1.length) return e1;
                    if (!t) e1 = e1.slice();
                    for(let n = r; n < e1.length; n = nextUnsortedSegmentLine(e1, n + 1)){
                        e1[n] = sortSegments(e1[n], t);
                    }
                    return e1;
                }
                function nextUnsortedSegmentLine(e1, t) {
                    for(let r = t; r < e1.length; r++){
                        if (!isSorted(e1[r])) return r;
                    }
                    return e1.length;
                }
                function isSorted(e1) {
                    for(let t = 1; t < e1.length; t++){
                        if (e1[t][n] < e1[t - 1][n]) {
                            return false;
                        }
                    }
                    return true;
                }
                function sortSegments(e1, t) {
                    if (!t) e1 = e1.slice();
                    return e1.sort(sortComparator);
                }
                function sortComparator(e1, t) {
                    return e1[n] - t[n];
                }
                let p = false;
                function binarySearch(e1, t, r, s) {
                    while(r <= s){
                        const i = r + (s - r >> 1);
                        const a = e1[i][n] - t;
                        if (a === 0) {
                            p = true;
                            return i;
                        }
                        if (a < 0) {
                            r = i + 1;
                        } else {
                            s = i - 1;
                        }
                    }
                    p = false;
                    return r - 1;
                }
                function upperBound(e1, t, r) {
                    for(let s = r + 1; s < e1.length; r = s++){
                        if (e1[s][n] !== t) break;
                    }
                    return r;
                }
                function lowerBound(e1, t, r) {
                    for(let s = r - 1; s >= 0; r = s--){
                        if (e1[s][n] !== t) break;
                    }
                    return r;
                }
                function memoizedState() {
                    return {
                        lastKey: -1,
                        lastNeedle: -1,
                        lastIndex: -1
                    };
                }
                function memoizedBinarySearch(e1, t, r, s) {
                    const { lastKey: i, lastNeedle: a, lastIndex: o } = r;
                    let l = 0;
                    let c = e1.length - 1;
                    if (s === i) {
                        if (t === a) {
                            p = o !== -1 && e1[o][n] === t;
                            return o;
                        }
                        if (t >= a) {
                            l = o === -1 ? 0 : o;
                        } else {
                            c = o;
                        }
                    }
                    r.lastKey = s;
                    r.lastNeedle = t;
                    return r.lastIndex = binarySearch(e1, t, l, c);
                }
                function buildBySources(e1, t) {
                    const r = t.map(buildNullArray);
                    for(let o = 0; o < e1.length; o++){
                        const l = e1[o];
                        for(let e1 = 0; e1 < l.length; e1++){
                            const c = l[e1];
                            if (c.length === 1) continue;
                            const p = c[s];
                            const u = c[i];
                            const d = c[a];
                            const f = r[p];
                            const h = f[u] || (f[u] = []);
                            const m = t[p];
                            let y = upperBound(h, d, memoizedBinarySearch(h, d, m, u));
                            m.lastIndex = ++y;
                            insert(h, y, [
                                d,
                                o,
                                c[n]
                            ]);
                        }
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function buildNullArray() {
                    return {
                        __proto__: null
                    };
                }
                const AnyMap = function(e1, t) {
                    const r = parse(e1);
                    if (!("sections" in r)) {
                        return new TraceMap(r, t);
                    }
                    const n = [];
                    const s = [];
                    const i = [];
                    const a = [];
                    const o = [];
                    recurse(r, t, n, s, i, a, o, 0, 0, Infinity, Infinity);
                    const l = {
                        version: 3,
                        file: r.file,
                        names: a,
                        sources: s,
                        sourcesContent: i,
                        mappings: n,
                        ignoreList: o
                    };
                    return presortedDecodedMap(l);
                };
                function parse(e1) {
                    return typeof e1 === "string" ? JSON.parse(e1) : e1;
                }
                function recurse(e1, t, r, n, s, i, a, o, l, c, p) {
                    const { sections: u } = e1;
                    for(let e1 = 0; e1 < u.length; e1++){
                        const { map: d, offset: f } = u[e1];
                        let h = c;
                        let m = p;
                        if (e1 + 1 < u.length) {
                            const t = u[e1 + 1].offset;
                            h = Math.min(c, o + t.line);
                            if (h === c) {
                                m = Math.min(p, l + t.column);
                            } else if (h < c) {
                                m = l + t.column;
                            }
                        }
                        addSection(d, t, r, n, s, i, a, o + f.line, l + f.column, h, m);
                    }
                }
                function addSection(e1, t, r, l, c, p, u, d, f, h, m) {
                    const y = parse(e1);
                    if ("sections" in y) return recurse(...arguments);
                    const g = new TraceMap(y, t);
                    const b = l.length;
                    const T = p.length;
                    const S = decodedMappings(g);
                    const { resolvedSources: x, sourcesContent: E, ignoreList: P } = g;
                    append(l, x);
                    append(p, g.names);
                    if (E) append(c, E);
                    else for(let e1 = 0; e1 < x.length; e1++)c.push(null);
                    if (P) for(let e1 = 0; e1 < P.length; e1++)u.push(P[e1] + b);
                    for(let e1 = 0; e1 < S.length; e1++){
                        const t = d + e1;
                        if (t > h) return;
                        const l = getLine(r, t);
                        const c = e1 === 0 ? f : 0;
                        const p = S[e1];
                        for(let e1 = 0; e1 < p.length; e1++){
                            const r = p[e1];
                            const u = c + r[n];
                            if (t === h && u >= m) return;
                            if (r.length === 1) {
                                l.push([
                                    u
                                ]);
                                continue;
                            }
                            const d = b + r[s];
                            const f = r[i];
                            const y = r[a];
                            l.push(r.length === 4 ? [
                                u,
                                d,
                                f,
                                y
                            ] : [
                                u,
                                d,
                                f,
                                y,
                                T + r[o]
                            ]);
                        }
                    }
                }
                function append(e1, t) {
                    for(let r = 0; r < t.length; r++)e1.push(t[r]);
                }
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++)e1[r] = [];
                    return e1[t];
                }
                const u = "`line` must be greater than 0 (lines start at line 1)";
                const d = "`column` must be greater than or equal to 0 (columns start at column 0)";
                const f = -1;
                const h = 1;
                class TraceMap {
                    constructor(e1, t){
                        const r = typeof e1 === "string";
                        if (!r && e1._decodedMemo) return e1;
                        const n = r ? JSON.parse(e1) : e1;
                        const { version: s, file: i, names: a, sourceRoot: o, sources: l, sourcesContent: c } = n;
                        this.version = s;
                        this.file = i;
                        this.names = a || [];
                        this.sourceRoot = o;
                        this.sources = l;
                        this.sourcesContent = c;
                        this.ignoreList = n.ignoreList || n.x_google_ignoreList || undefined;
                        const p = resolve(o || "", stripFilename(t));
                        this.resolvedSources = l.map((e1)=>resolve(e1 || "", p));
                        const { mappings: u } = n;
                        if (typeof u === "string") {
                            this._encoded = u;
                            this._decoded = undefined;
                        } else {
                            this._encoded = undefined;
                            this._decoded = maybeSort(u, r);
                        }
                        this._decodedMemo = memoizedState();
                        this._bySources = undefined;
                        this._bySourceMemos = undefined;
                    }
                }
                function cast(e1) {
                    return e1;
                }
                function encodedMappings(e1) {
                    var r;
                    var n;
                    return (r = (n = cast(e1))._encoded) !== null && r !== void 0 ? r : n._encoded = t.encode(cast(e1)._decoded);
                }
                function decodedMappings(e1) {
                    var r;
                    return (r = cast(e1))._decoded || (r._decoded = t.decode(cast(e1)._encoded));
                }
                function traceSegment(e1, t, r) {
                    const n = decodedMappings(e1);
                    if (t >= n.length) return null;
                    const s = n[t];
                    const i = traceSegmentInternal(s, cast(e1)._decodedMemo, t, r, h);
                    return i === -1 ? null : s[i];
                }
                function originalPositionFor(e1, t) {
                    let { line: r, column: n, bias: l } = t;
                    r--;
                    if (r < 0) throw new Error(u);
                    if (n < 0) throw new Error(d);
                    const c = decodedMappings(e1);
                    if (r >= c.length) return OMapping(null, null, null, null);
                    const p = c[r];
                    const f = traceSegmentInternal(p, cast(e1)._decodedMemo, r, n, l || h);
                    if (f === -1) return OMapping(null, null, null, null);
                    const m = p[f];
                    if (m.length === 1) return OMapping(null, null, null, null);
                    const { names: y, resolvedSources: g } = e1;
                    return OMapping(g[m[s]], m[i] + 1, m[a], m.length === 5 ? y[m[o]] : null);
                }
                function generatedPositionFor(e1, t) {
                    const { source: r, line: n, column: s, bias: i } = t;
                    return generatedPosition(e1, r, n, s, i || h, false);
                }
                function allGeneratedPositionsFor(e1, t) {
                    const { source: r, line: n, column: s, bias: i } = t;
                    return generatedPosition(e1, r, n, s, i || f, true);
                }
                function eachMapping(e1, t) {
                    const r = decodedMappings(e1);
                    const { names: n, resolvedSources: s } = e1;
                    for(let e1 = 0; e1 < r.length; e1++){
                        const i = r[e1];
                        for(let r = 0; r < i.length; r++){
                            const a = i[r];
                            const o = e1 + 1;
                            const l = a[0];
                            let c = null;
                            let p = null;
                            let u = null;
                            let d = null;
                            if (a.length !== 1) {
                                c = s[a[1]];
                                p = a[2] + 1;
                                u = a[3];
                            }
                            if (a.length === 5) d = n[a[4]];
                            t({
                                generatedLine: o,
                                generatedColumn: l,
                                source: c,
                                originalLine: p,
                                originalColumn: u,
                                name: d
                            });
                        }
                    }
                }
                function sourceIndex(e1, t) {
                    const { sources: r, resolvedSources: n } = e1;
                    let s = r.indexOf(t);
                    if (s === -1) s = n.indexOf(t);
                    return s;
                }
                function sourceContentFor(e1, t) {
                    const { sourcesContent: r } = e1;
                    if (r == null) return null;
                    const n = sourceIndex(e1, t);
                    return n === -1 ? null : r[n];
                }
                function isIgnored(e1, t) {
                    const { ignoreList: r } = e1;
                    if (r == null) return false;
                    const n = sourceIndex(e1, t);
                    return n === -1 ? false : r.includes(n);
                }
                function presortedDecodedMap(e1, t) {
                    const r = new TraceMap(clone(e1, []), t);
                    cast(r)._decoded = e1.mappings;
                    return r;
                }
                function decodedMap(e1) {
                    return clone(e1, decodedMappings(e1));
                }
                function encodedMap(e1) {
                    return clone(e1, encodedMappings(e1));
                }
                function clone(e1, t) {
                    return {
                        version: e1.version,
                        file: e1.file,
                        names: e1.names,
                        sourceRoot: e1.sourceRoot,
                        sources: e1.sources,
                        sourcesContent: e1.sourcesContent,
                        mappings: t,
                        ignoreList: e1.ignoreList || e1.x_google_ignoreList
                    };
                }
                function OMapping(e1, t, r, n) {
                    return {
                        source: e1,
                        line: t,
                        column: r,
                        name: n
                    };
                }
                function GMapping(e1, t) {
                    return {
                        line: e1,
                        column: t
                    };
                }
                function traceSegmentInternal(e1, t, r, n, s) {
                    let i = memoizedBinarySearch(e1, n, t, r);
                    if (p) {
                        i = (s === f ? upperBound : lowerBound)(e1, n, i);
                    } else if (s === f) i++;
                    if (i === -1 || i === e1.length) return -1;
                    return i;
                }
                function sliceGeneratedPositions(e1, t, r, s, i) {
                    let a = traceSegmentInternal(e1, t, r, s, h);
                    if (!p && i === f) a++;
                    if (a === -1 || a === e1.length) return [];
                    const o = p ? s : e1[a][n];
                    if (!p) a = lowerBound(e1, o, a);
                    const u = upperBound(e1, o, a);
                    const d = [];
                    for(; a <= u; a++){
                        const t = e1[a];
                        d.push(GMapping(t[l] + 1, t[c]));
                    }
                    return d;
                }
                function generatedPosition(e1, t, r, n, s, i) {
                    var a;
                    r--;
                    if (r < 0) throw new Error(u);
                    if (n < 0) throw new Error(d);
                    const { sources: o, resolvedSources: p } = e1;
                    let f = o.indexOf(t);
                    if (f === -1) f = p.indexOf(t);
                    if (f === -1) return i ? [] : GMapping(null, null);
                    const h = (a = cast(e1))._bySources || (a._bySources = buildBySources(decodedMappings(e1), cast(e1)._bySourceMemos = o.map(memoizedState)));
                    const m = h[f][r];
                    if (m == null) return i ? [] : GMapping(null, null);
                    const y = cast(e1)._bySourceMemos[f];
                    if (i) return sliceGeneratedPositions(m, y, r, n, s);
                    const g = traceSegmentInternal(m, y, r, n, s);
                    if (g === -1) return GMapping(null, null);
                    const b = m[g];
                    return GMapping(b[l] + 1, b[c]);
                }
                e1.AnyMap = AnyMap;
                e1.GREATEST_LOWER_BOUND = h;
                e1.LEAST_UPPER_BOUND = f;
                e1.TraceMap = TraceMap;
                e1.allGeneratedPositionsFor = allGeneratedPositionsFor;
                e1.decodedMap = decodedMap;
                e1.decodedMappings = decodedMappings;
                e1.eachMapping = eachMapping;
                e1.encodedMap = encodedMap;
                e1.encodedMappings = encodedMappings;
                e1.generatedPositionFor = generatedPositionFor;
                e1.isIgnored = isIgnored;
                e1.originalPositionFor = originalPositionFor;
                e1.presortedDecodedMap = presortedDecodedMap;
                e1.sourceContentFor = sourceContentFor;
                e1.traceSegment = traceSegment;
            });
        },
        133: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "commentRegex", {
                get: function getCommentRegex() {
                    return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
                }
            });
            Object.defineProperty(t, "mapFileCommentRegex", {
                get: function getMapFileCommentRegex() {
                    return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/gm;
                }
            });
            var r;
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined") {
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from === "function") {
                    r = decodeBase64WithBufferFrom;
                } else {
                    r = decodeBase64WithNewBuffer;
                }
            } else {
                r = decodeBase64WithAtob;
            }
            function decodeBase64WithBufferFrom(e1) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e1, "base64").toString();
            }
            function decodeBase64WithNewBuffer(e1) {
                if (typeof value === "number") {
                    throw new TypeError("The value to decode must not be of type number.");
                }
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](e1, "base64").toString();
            }
            function decodeBase64WithAtob(e1) {
                return decodeURIComponent(escape(atob(e1)));
            }
            function stripComment(e1) {
                return e1.split(",").pop();
            }
            function readFromFileMap(e1, r) {
                var n = t.mapFileCommentRegex.exec(e1);
                var s = n[1] || n[2];
                try {
                    var e1 = r(s);
                    if (e1 != null && typeof e1.catch === "function") {
                        return e1.catch(throwError);
                    } else {
                        return e1;
                    }
                } catch (e1) {
                    throwError(e1);
                }
                function throwError(e1) {
                    throw new Error("An error occurred while trying to read the map file at " + s + "\n" + e1.stack);
                }
            }
            function Converter(e1, t) {
                t = t || {};
                if (t.hasComment) {
                    e1 = stripComment(e1);
                }
                if (t.encoding === "base64") {
                    e1 = r(e1);
                } else if (t.encoding === "uri") {
                    e1 = decodeURIComponent(e1);
                }
                if (t.isJSON || t.encoding) {
                    e1 = JSON.parse(e1);
                }
                this.sourcemap = e1;
            }
            Converter.prototype.toJSON = function(e1) {
                return JSON.stringify(this.sourcemap, null, e1);
            };
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined") {
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from === "function") {
                    Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
                } else {
                    Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
                }
            } else {
                Converter.prototype.toBase64 = encodeBase64WithBtoa;
            }
            function encodeBase64WithBufferFrom() {
                var e1 = this.toJSON();
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e1, "utf8").toString("base64");
            }
            function encodeBase64WithNewBuffer() {
                var e1 = this.toJSON();
                if (typeof e1 === "number") {
                    throw new TypeError("The json to encode must not be of type number.");
                }
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](e1, "utf8").toString("base64");
            }
            function encodeBase64WithBtoa() {
                var e1 = this.toJSON();
                return btoa(unescape(encodeURIComponent(e1)));
            }
            Converter.prototype.toURI = function() {
                var e1 = this.toJSON();
                return encodeURIComponent(e1);
            };
            Converter.prototype.toComment = function(e1) {
                var t, r, n;
                if (e1 != null && e1.encoding === "uri") {
                    t = "";
                    r = this.toURI();
                } else {
                    t = ";base64";
                    r = this.toBase64();
                }
                n = "sourceMappingURL=data:application/json;charset=utf-8" + t + "," + r;
                return e1 != null && e1.multiline ? "/*# " + n + " */" : "//# " + n;
            };
            Converter.prototype.toObject = function() {
                return JSON.parse(this.toJSON());
            };
            Converter.prototype.addProperty = function(e1, t) {
                if (this.sourcemap.hasOwnProperty(e1)) throw new Error('property "' + e1 + '" already exists on the sourcemap, use set property instead');
                return this.setProperty(e1, t);
            };
            Converter.prototype.setProperty = function(e1, t) {
                this.sourcemap[e1] = t;
                return this;
            };
            Converter.prototype.getProperty = function(e1) {
                return this.sourcemap[e1];
            };
            t.fromObject = function(e1) {
                return new Converter(e1);
            };
            t.fromJSON = function(e1) {
                return new Converter(e1, {
                    isJSON: true
                });
            };
            t.fromURI = function(e1) {
                return new Converter(e1, {
                    encoding: "uri"
                });
            };
            t.fromBase64 = function(e1) {
                return new Converter(e1, {
                    encoding: "base64"
                });
            };
            t.fromComment = function(e1) {
                var r, n;
                e1 = e1.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
                r = t.commentRegex.exec(e1);
                n = r && r[4] || "uri";
                return new Converter(e1, {
                    encoding: n,
                    hasComment: true
                });
            };
            function makeConverter(e1) {
                return new Converter(e1, {
                    isJSON: true
                });
            }
            t.fromMapFileComment = function(e1, t) {
                if (typeof t === "string") {
                    throw new Error("String directory paths are no longer supported with `fromMapFileComment`\n" + "Please review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
                }
                var r = readFromFileMap(e1, t);
                if (r != null && typeof r.then === "function") {
                    return r.then(makeConverter);
                } else {
                    return makeConverter(r);
                }
            };
            t.fromSource = function(e1) {
                var r = e1.match(t.commentRegex);
                return r ? t.fromComment(r.pop()) : null;
            };
            t.fromMapFileSource = function(e1, r) {
                if (typeof r === "string") {
                    throw new Error("String directory paths are no longer supported with `fromMapFileSource`\n" + "Please review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
                }
                var n = e1.match(t.mapFileCommentRegex);
                return n ? t.fromMapFileComment(n.pop(), r) : null;
            };
            t.removeComments = function(e1) {
                return e1.replace(t.commentRegex, "");
            };
            t.removeMapFileComments = function(e1) {
                return e1.replace(t.mapFileCommentRegex, "");
            };
            t.generateMapFileComment = function(e1, t) {
                var r = "sourceMappingURL=" + e1;
                return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
            };
        },
        6433: (e1)=>{
            "use strict";
            const t = Symbol.for("gensync:v1:start");
            const r = Symbol.for("gensync:v1:suspend");
            const n = "GENSYNC_EXPECTED_START";
            const s = "GENSYNC_EXPECTED_SUSPEND";
            const i = "GENSYNC_OPTIONS_ERROR";
            const a = "GENSYNC_RACE_NONEMPTY";
            const o = "GENSYNC_ERRBACK_NO_CALLBACK";
            e1.exports = Object.assign(function gensync(e1) {
                let t = e1;
                if (typeof e1 !== "function") {
                    t = newGenerator(e1);
                } else {
                    t = wrapGenerator(e1);
                }
                return Object.assign(t, makeFunctionAPI(t));
            }, {
                all: buildOperation({
                    name: "all",
                    arity: 1,
                    sync: function(e1) {
                        const t = Array.from(e1[0]);
                        return t.map((e1)=>evaluateSync(e1));
                    },
                    async: function(e1, t, r) {
                        const n = Array.from(e1[0]);
                        if (n.length === 0) {
                            Promise.resolve().then(()=>t([]));
                            return;
                        }
                        let s = 0;
                        const i = n.map(()=>undefined);
                        n.forEach((e1, n)=>{
                            evaluateAsync(e1, (e1)=>{
                                i[n] = e1;
                                s += 1;
                                if (s === i.length) t(i);
                            }, r);
                        });
                    }
                }),
                race: buildOperation({
                    name: "race",
                    arity: 1,
                    sync: function(e1) {
                        const t = Array.from(e1[0]);
                        if (t.length === 0) {
                            throw makeError("Must race at least 1 item", a);
                        }
                        return evaluateSync(t[0]);
                    },
                    async: function(e1, t, r) {
                        const n = Array.from(e1[0]);
                        if (n.length === 0) {
                            throw makeError("Must race at least 1 item", a);
                        }
                        for (const e1 of n){
                            evaluateAsync(e1, t, r);
                        }
                    }
                })
            });
            function makeFunctionAPI(e1) {
                const t = {
                    sync: function() {
                        for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                            t[_key] = arguments[_key];
                        }
                        return evaluateSync(e1.apply(this, t));
                    },
                    async: function() {
                        for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                            t[_key] = arguments[_key];
                        }
                        return new Promise((r, n)=>{
                            evaluateAsync(e1.apply(this, t), r, n);
                        });
                    },
                    errback: function() {
                        for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                            t[_key] = arguments[_key];
                        }
                        const r = t.pop();
                        if (typeof r !== "function") {
                            throw makeError("Asynchronous function called without callback", o);
                        }
                        let n;
                        try {
                            n = e1.apply(this, t);
                        } catch (e1) {
                            r(e1);
                            return;
                        }
                        evaluateAsync(n, (e1)=>r(undefined, e1), (e1)=>r(e1));
                    }
                };
                return t;
            }
            function assertTypeof(e1, t, r, n) {
                if (typeof r === e1 || n && typeof r === "undefined") {
                    return;
                }
                let s;
                if (n) {
                    s = "Expected opts.".concat(t, " to be either a ").concat(e1, ", or undefined.");
                } else {
                    s = "Expected opts.".concat(t, " to be a ").concat(e1, ".");
                }
                throw makeError(s, i);
            }
            function makeError(e1, t) {
                return Object.assign(new Error(e1), {
                    code: t
                });
            }
            function newGenerator(param) {
                let { name: e1, arity: t, sync: r, async: n, errback: s } = param;
                assertTypeof("string", "name", e1, true);
                assertTypeof("number", "arity", t, true);
                assertTypeof("function", "sync", r);
                assertTypeof("function", "async", n, true);
                assertTypeof("function", "errback", s, true);
                if (n && s) {
                    throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", i);
                }
                if (typeof e1 !== "string") {
                    let t;
                    if (s && s.name && s.name !== "errback") {
                        t = s.name;
                    }
                    if (n && n.name && n.name !== "async") {
                        t = n.name.replace(/Async$/, "");
                    }
                    if (r && r.name && r.name !== "sync") {
                        t = r.name.replace(/Sync$/, "");
                    }
                    if (typeof t === "string") {
                        e1 = t;
                    }
                }
                if (typeof t !== "number") {
                    t = r.length;
                }
                return buildOperation({
                    name: e1,
                    arity: t,
                    sync: function(e1) {
                        return r.apply(this, e1);
                    },
                    async: function(e1, t, i) {
                        if (n) {
                            n.apply(this, e1).then(t, i);
                        } else if (s) {
                            s.call(this, ...e1, (e1, r)=>{
                                if (e1 == null) t(r);
                                else i(e1);
                            });
                        } else {
                            t(r.apply(this, e1));
                        }
                    }
                });
            }
            function wrapGenerator(e1) {
                return setFunctionMetadata(e1.name, e1.length, function() {
                    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                        t[_key] = arguments[_key];
                    }
                    return e1.apply(this, t);
                });
            }
            function buildOperation(param) {
                let { name: e1, arity: n, sync: s, async: i } = param;
                return setFunctionMetadata(e1, n, function*() {
                    for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                        e1[_key] = arguments[_key];
                    }
                    const n = yield t;
                    if (!n) {
                        const t = s.call(this, e1);
                        return t;
                    }
                    let a;
                    try {
                        i.call(this, e1, (e1)=>{
                            if (a) return;
                            a = {
                                value: e1
                            };
                            n();
                        }, (e1)=>{
                            if (a) return;
                            a = {
                                err: e1
                            };
                            n();
                        });
                    } catch (e1) {
                        a = {
                            err: e1
                        };
                        n();
                    }
                    yield r;
                    if (a.hasOwnProperty("err")) {
                        throw a.err;
                    }
                    return a.value;
                });
            }
            function evaluateSync(e1) {
                let t;
                while(!({ value: t } = e1.next()).done){
                    assertStart(t, e1);
                }
                return t;
            }
            function evaluateAsync(e1, t, r) {
                (function step() {
                    try {
                        let r;
                        while(!({ value: r } = e1.next()).done){
                            assertStart(r, e1);
                            let t = true;
                            let n = false;
                            const s = e1.next(()=>{
                                if (t) {
                                    n = true;
                                } else {
                                    step();
                                }
                            });
                            t = false;
                            assertSuspend(s, e1);
                            if (!n) {
                                return;
                            }
                        }
                        return t(r);
                    } catch (e1) {
                        return r(e1);
                    }
                })();
            }
            function assertStart(e1, r) {
                if (e1 === t) return;
                throwError(r, makeError("Got unexpected yielded value in gensync generator: ".concat(JSON.stringify(e1), ". Did you perhaps mean to use 'yield*' instead of 'yield'?"), n));
            }
            function assertSuspend(param, n) {
                let { value: e1, done: t } = param;
                if (!t && e1 === r) return;
                throwError(n, makeError(t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got ".concat(JSON.stringify(e1), ". If you get this, it is probably a gensync bug."), s));
            }
            function throwError(e1, t) {
                if (e1.throw) e1.throw(t);
                throw t;
            }
            function isIterable(e1) {
                return !!e1 && (typeof e1 === "object" || typeof e1 === "function") && !e1[Symbol.iterator];
            }
            function setFunctionMetadata(e1, t, r) {
                if (typeof e1 === "string") {
                    const t = Object.getOwnPropertyDescriptor(r, "name");
                    if (!t || t.configurable) {
                        Object.defineProperty(r, "name", Object.assign(t || {}, {
                            configurable: true,
                            value: e1
                        }));
                    }
                }
                if (typeof t === "number") {
                    const e1 = Object.getOwnPropertyDescriptor(r, "length");
                    if (!e1 || e1.configurable) {
                        Object.defineProperty(r, "length", Object.assign(e1 || {}, {
                            configurable: true,
                            value: t
                        }));
                    }
                }
                return r;
            }
        },
        6929: (e1, t, r)=>{
            "use strict";
            e1.exports = r(3676);
        },
        8874: (e1, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
            t.matchToToken = function(e1) {
                var t = {
                    type: "invalid",
                    value: e1[0],
                    closed: undefined
                };
                if (e1[1]) t.type = "string", t.closed = !!(e1[3] || e1[4]);
                else if (e1[5]) t.type = "comment";
                else if (e1[6]) t.type = "comment", t.closed = !!e1[7];
                else if (e1[8]) t.type = "regex";
                else if (e1[9]) t.type = "number";
                else if (e1[10]) t.type = "name";
                else if (e1[11]) t.type = "punctuator";
                else if (e1[12]) t.type = "whitespace";
                return t;
            };
        },
        4849: (e1)=>{
            "use strict";
            const t = {};
            const r = t.hasOwnProperty;
            const forOwn = (e1, t)=>{
                for(const n in e1){
                    if (r.call(e1, n)) {
                        t(n, e1[n]);
                    }
                }
            };
            const extend = (e1, t)=>{
                if (!t) {
                    return e1;
                }
                forOwn(t, (t, r)=>{
                    e1[t] = r;
                });
                return e1;
            };
            const forEach = (e1, t)=>{
                const r = e1.length;
                let n = -1;
                while(++n < r){
                    t(e1[n]);
                }
            };
            const fourHexEscape = (e1)=>"\\u" + ("0000" + e1).slice(-4);
            const hexadecimal = (e1, t)=>{
                let r = e1.toString(16);
                if (t) return r;
                return r.toUpperCase();
            };
            const n = t.toString;
            const s = Array.isArray;
            const isBuffer = (e1)=>typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] === "function" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(e1);
            const isObject = (e1)=>n.call(e1) == "[object Object]";
            const isString = (e1)=>typeof e1 == "string" || n.call(e1) == "[object String]";
            const isNumber = (e1)=>typeof e1 == "number" || n.call(e1) == "[object Number]";
            const isFunction = (e1)=>typeof e1 == "function";
            const isMap = (e1)=>n.call(e1) == "[object Map]";
            const isSet = (e1)=>n.call(e1) == "[object Set]";
            const i = {
                "\\": "\\\\",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t"
            };
            const a = /[\\\b\f\n\r\t]/;
            const o = /[0-9]/;
            const l = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
            const c = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
            const p = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
            const jsesc = (e1, t)=>{
                const increaseIndentation = ()=>{
                    m = h;
                    ++t.indentLevel;
                    h = t.indent.repeat(t.indentLevel);
                };
                const r = {
                    escapeEverything: false,
                    minimal: false,
                    isScriptContext: false,
                    quotes: "single",
                    wrap: false,
                    es6: false,
                    json: false,
                    compact: true,
                    lowercaseHex: false,
                    numbers: "decimal",
                    indent: "\t",
                    indentLevel: 0,
                    __inline1__: false,
                    __inline2__: false
                };
                const n = t && t.json;
                if (n) {
                    r.quotes = "double";
                    r.wrap = true;
                }
                t = extend(r, t);
                if (t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick") {
                    t.quotes = "single";
                }
                const u = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'";
                const d = t.compact;
                const f = t.lowercaseHex;
                let h = t.indent.repeat(t.indentLevel);
                let m = "";
                const y = t.__inline1__;
                const g = t.__inline2__;
                const b = d ? "" : "\n";
                let T;
                let S = true;
                const x = t.numbers == "binary";
                const E = t.numbers == "octal";
                const P = t.numbers == "decimal";
                const v = t.numbers == "hexadecimal";
                if (n && e1 && isFunction(e1.toJSON)) {
                    e1 = e1.toJSON();
                }
                if (!isString(e1)) {
                    if (isMap(e1)) {
                        if (e1.size == 0) {
                            return "new Map()";
                        }
                        if (!d) {
                            t.__inline1__ = true;
                            t.__inline2__ = false;
                        }
                        return "new Map(" + jsesc(Array.from(e1), t) + ")";
                    }
                    if (isSet(e1)) {
                        if (e1.size == 0) {
                            return "new Set()";
                        }
                        return "new Set(" + jsesc(Array.from(e1), t) + ")";
                    }
                    if (isBuffer(e1)) {
                        if (e1.length == 0) {
                            return "Buffer.from([])";
                        }
                        return "Buffer.from(" + jsesc(Array.from(e1), t) + ")";
                    }
                    if (s(e1)) {
                        T = [];
                        t.wrap = true;
                        if (y) {
                            t.__inline1__ = false;
                            t.__inline2__ = true;
                        }
                        if (!g) {
                            increaseIndentation();
                        }
                        forEach(e1, (e1)=>{
                            S = false;
                            if (g) {
                                t.__inline2__ = false;
                            }
                            T.push((d || g ? "" : h) + jsesc(e1, t));
                        });
                        if (S) {
                            return "[]";
                        }
                        if (g) {
                            return "[" + T.join(", ") + "]";
                        }
                        return "[" + b + T.join("," + b) + b + (d ? "" : m) + "]";
                    } else if (isNumber(e1)) {
                        if (n) {
                            return JSON.stringify(e1);
                        }
                        if (P) {
                            return String(e1);
                        }
                        if (v) {
                            let t = e1.toString(16);
                            if (!f) {
                                t = t.toUpperCase();
                            }
                            return "0x" + t;
                        }
                        if (x) {
                            return "0b" + e1.toString(2);
                        }
                        if (E) {
                            return "0o" + e1.toString(8);
                        }
                    } else if (!isObject(e1)) {
                        if (n) {
                            return JSON.stringify(e1) || "null";
                        }
                        return String(e1);
                    } else {
                        T = [];
                        t.wrap = true;
                        increaseIndentation();
                        forOwn(e1, (e1, r)=>{
                            S = false;
                            T.push((d ? "" : h) + jsesc(e1, t) + ":" + (d ? "" : " ") + jsesc(r, t));
                        });
                        if (S) {
                            return "{}";
                        }
                        return "{" + b + T.join("," + b) + b + (d ? "" : m) + "}";
                    }
                }
                const A = t.escapeEverything ? c : p;
                T = e1.replace(A, (e1, r, s, c, p, d)=>{
                    if (r) {
                        if (t.minimal) return r;
                        const e1 = r.charCodeAt(0);
                        const n = r.charCodeAt(1);
                        if (t.es6) {
                            const t = (e1 - 55296) * 1024 + n - 56320 + 65536;
                            const r = hexadecimal(t, f);
                            return "\\u{" + r + "}";
                        }
                        return fourHexEscape(hexadecimal(e1, f)) + fourHexEscape(hexadecimal(n, f));
                    }
                    if (s) {
                        return fourHexEscape(hexadecimal(s.charCodeAt(0), f));
                    }
                    if (e1 == "\0" && !n && !o.test(d.charAt(p + 1))) {
                        return "\\0";
                    }
                    if (c) {
                        if (c == u || t.escapeEverything) {
                            return "\\" + c;
                        }
                        return c;
                    }
                    if (a.test(e1)) {
                        return i[e1];
                    }
                    if (t.minimal && !l.test(e1)) {
                        return e1;
                    }
                    const h = hexadecimal(e1.charCodeAt(0), f);
                    if (n || h.length > 2) {
                        return fourHexEscape(h);
                    }
                    return "\\x" + ("00" + h).slice(-2);
                });
                if (u == "`") {
                    T = T.replace(/\$\{/g, "\\${");
                }
                if (t.isScriptContext) {
                    T = T.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, n ? "\\u003C!--" : "\\x3C!--");
                }
                if (t.wrap) {
                    T = u + T + u;
                }
                return T;
            };
            jsesc.version = "3.0.2";
            e1.exports = jsesc;
        },
        1437: (e1, t, r)=>{
            let n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].argv || [], s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env;
            let i = !("NO_COLOR" in s || n.includes("--no-color")) && ("FORCE_COLOR" in s || n.includes("--color") || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32" || /*TURBOPACK member replacement*/ __turbopack_context__.t != null && r(6224).isatty(1) && s.TERM !== "dumb" || "CI" in s);
            let formatter = function(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e1;
                return (n)=>{
                    let s = "" + n;
                    let i = s.indexOf(t, e1.length);
                    return ~i ? e1 + replaceClose(s, t, r, i) + t : e1 + s + t;
                };
            };
            let replaceClose = (e1, t, r, n)=>{
                let s = "";
                let i = 0;
                do {
                    s += e1.substring(i, n) + r;
                    i = n + t.length;
                    n = e1.indexOf(t, i);
                }while (~n)
                return s + e1.substring(i);
            };
            let createColors = function() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : i;
                let t = e1 ? formatter : ()=>String;
                return {
                    isColorSupported: e1,
                    reset: t("[0m", "[0m"),
                    bold: t("[1m", "[22m", "[22m[1m"),
                    dim: t("[2m", "[22m", "[22m[2m"),
                    italic: t("[3m", "[23m"),
                    underline: t("[4m", "[24m"),
                    inverse: t("[7m", "[27m"),
                    hidden: t("[8m", "[28m"),
                    strikethrough: t("[9m", "[29m"),
                    black: t("[30m", "[39m"),
                    red: t("[31m", "[39m"),
                    green: t("[32m", "[39m"),
                    yellow: t("[33m", "[39m"),
                    blue: t("[34m", "[39m"),
                    magenta: t("[35m", "[39m"),
                    cyan: t("[36m", "[39m"),
                    white: t("[37m", "[39m"),
                    gray: t("[90m", "[39m"),
                    bgBlack: t("[40m", "[49m"),
                    bgRed: t("[41m", "[49m"),
                    bgGreen: t("[42m", "[49m"),
                    bgYellow: t("[43m", "[49m"),
                    bgBlue: t("[44m", "[49m"),
                    bgMagenta: t("[45m", "[49m"),
                    bgCyan: t("[46m", "[49m"),
                    bgWhite: t("[47m", "[49m")
                };
            };
            e1.exports = createColors();
            e1.exports.createColors = createColors;
        },
        3050: (e1, t, r)=>{
            function types() {
                return r(3061);
            }
            function codeFrame() {
                return r(3554);
            }
            function core() {
                return r(2358);
            }
            function coreLibConfig() {
                return r(8842);
            }
            function coreLibNormalizeFile() {
                return r(6380);
            }
            function coreLibNormalizeOpts() {
                return r(6351);
            }
            function coreLibBlockHoistPlugin() {
                return r(9273);
            }
            function coreLibPluginPass() {
                return r(3878);
            }
            function traverse() {
                return r(8026);
            }
            function generator() {
                return r(1605);
            }
            function parser() {
                return r(9849);
            }
            function eslintParser() {
                return r(3305).eslintParser();
            }
            function pluginProposalClassProperties() {
                return r(3305).pluginProposalClassProperties();
            }
            function pluginProposalExportNamespaceFrom() {
                return r(3305).pluginProposalExportNamespaceFrom();
            }
            function pluginProposalNumericSeparator() {
                return r(3305).pluginProposalNumericSeparator();
            }
            function pluginProposalObjectRestSpread() {
                return r(3305).pluginProposalObjectRestSpread();
            }
            function pluginSyntaxBigint() {
                return r(3305).pluginSyntaxBigint();
            }
            function pluginSyntaxDynamicImport() {
                return r(3305).pluginSyntaxDynamicImport();
            }
            function pluginSyntaxImportAttributes() {
                return r(3305).pluginSyntaxImportAttributes();
            }
            function pluginSyntaxJsx() {
                return r(3305).pluginSyntaxJsx();
            }
            function pluginTransformDefine() {
                return r(3305).pluginTransformDefine();
            }
            function pluginTransformModulesCommonjs() {
                return r(3305).pluginTransformModulesCommonjs();
            }
            function pluginTransformReactRemovePropTypes() {
                return r(3305).pluginTransformReactRemovePropTypes();
            }
            function pluginTransformRuntime() {
                return r(3305).pluginTransformRuntime();
            }
            function presetEnv() {
                return r(3305).presetEnv();
            }
            function presetReact() {
                return r(3305).presetReact();
            }
            function presetTypescript() {
                return r(3305).presetTypescript();
            }
            e1.exports = {
                types: types,
                codeFrame: codeFrame,
                core: core,
                coreLibConfig: coreLibConfig,
                coreLibNormalizeFile: coreLibNormalizeFile,
                coreLibNormalizeOpts: coreLibNormalizeOpts,
                coreLibBlockHoistPlugin: coreLibBlockHoistPlugin,
                coreLibPluginPass: coreLibPluginPass,
                generator: generator,
                traverse: traverse,
                eslintParser: eslintParser,
                parser: parser,
                pluginProposalClassProperties: pluginProposalClassProperties,
                pluginProposalExportNamespaceFrom: pluginProposalExportNamespaceFrom,
                pluginProposalNumericSeparator: pluginProposalNumericSeparator,
                pluginProposalObjectRestSpread: pluginProposalObjectRestSpread,
                pluginSyntaxBigint: pluginSyntaxBigint,
                pluginSyntaxDynamicImport: pluginSyntaxDynamicImport,
                pluginSyntaxImportAttributes: pluginSyntaxImportAttributes,
                pluginSyntaxJsx: pluginSyntaxJsx,
                pluginTransformDefine: pluginTransformDefine,
                pluginTransformModulesCommonjs: pluginTransformModulesCommonjs,
                pluginTransformReactRemovePropTypes: pluginTransformReactRemovePropTypes,
                pluginTransformRuntime: pluginTransformRuntime,
                presetEnv: presetEnv,
                presetReact: presetReact,
                presetTypescript: presetTypescript
            };
        },
        9491: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
        },
        7147: (e1)=>{
            "use strict";
            e1.exports = (()=>{
                const e1 = new Error("Cannot find module 'fs'");
                e1.code = 'MODULE_NOT_FOUND';
                throw e1;
            })();
        },
        8188: (e2)=>{
            "use strict";
            e2.exports = (()=>{
                const e1 = new Error("Cannot find module 'module'");
                e1.code = 'MODULE_NOT_FOUND';
                throw e1;
            })();
        },
        3305: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/babel-packages/packages-bundle.js [app-client] (ecmascript)");
        },
        4907: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/browserslist/index.js [app-client] (ecmascript)");
        },
        6937: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/debug/index.js [app-client] (ecmascript)");
        },
        8310: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/json5/index.js [app-client] (ecmascript)");
        },
        7330: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/lru-cache/index.js [app-client] (ecmascript)");
        },
        7849: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/semver/index.js [app-client] (ecmascript)");
        },
        1017: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
        },
        7282: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
        },
        6224: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/tty-browserify/index.js [app-client] (ecmascript)");
        },
        7310: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)");
        },
        3837: (e1)=>{
            "use strict";
            e1.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
        },
        4655: (e2)=>{
            "use strict";
            e2.exports = (()=>{
                const e1 = new Error("Cannot find module 'v8'");
                e1.code = 'MODULE_NOT_FOUND';
                throw e1;
            })();
        },
        3554: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(1437);
            var s = r(8874);
            var i = r(974);
            function isColorSupported() {
                return typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === "object" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FORCE_COLOR === "0" || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.FORCE_COLOR === "false") ? false : n.isColorSupported;
            }
            const compose = (e1, t)=>(r)=>e1(t(r));
            function buildDefs(e1) {
                return {
                    keyword: e1.cyan,
                    capitalized: e1.yellow,
                    jsxIdentifier: e1.yellow,
                    punctuator: e1.yellow,
                    number: e1.magenta,
                    string: e1.green,
                    regex: e1.magenta,
                    comment: e1.gray,
                    invalid: compose(compose(e1.white, e1.bgRed), e1.bold),
                    gutter: e1.gray,
                    marker: compose(e1.red, e1.bold),
                    message: compose(e1.red, e1.bold),
                    reset: e1.reset
                };
            }
            const a = buildDefs(n.createColors(true));
            const o = buildDefs(n.createColors(false));
            function getDefs(e1) {
                return e1 ? a : o;
            }
            const l = new Set([
                "as",
                "async",
                "from",
                "get",
                "of",
                "set"
            ]);
            const c = /\r\n|[\n\r\u2028\u2029]/;
            const p = /^[()[\]{}]$/;
            let u;
            {
                const e1 = /^[a-z][\w-]*$/i;
                const getTokenType = function(t, r, n) {
                    if (t.type === "name") {
                        if (i.isKeyword(t.value) || i.isStrictReservedWord(t.value, true) || l.has(t.value)) {
                            return "keyword";
                        }
                        if (e1.test(t.value) && (n[r - 1] === "<" || n.slice(r - 2, r) === "</")) {
                            return "jsxIdentifier";
                        }
                        if (t.value[0] !== t.value[0].toLowerCase()) {
                            return "capitalized";
                        }
                    }
                    if (t.type === "punctuator" && p.test(t.value)) {
                        return "bracket";
                    }
                    if (t.type === "invalid" && (t.value === "@" || t.value === "#")) {
                        return "punctuator";
                    }
                    return t.type;
                };
                u = function*(e1) {
                    let t;
                    while(t = s.default.exec(e1)){
                        const r = s.matchToToken(t);
                        yield {
                            type: getTokenType(r, t.index, e1),
                            value: r.value
                        };
                    }
                };
            }
            function highlight(e1) {
                if (e1 === "") return "";
                const t = getDefs(true);
                let r = "";
                for (const { type: n, value: s } of u(e1)){
                    if (n in t) {
                        r += s.split(c).map((e1)=>t[n](e1)).join("\n");
                    } else {
                        r += s;
                    }
                }
                return r;
            }
            let d = false;
            const f = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(e1, t, r) {
                const n = Object.assign({
                    column: 0,
                    line: -1
                }, e1.start);
                const s = Object.assign({}, n, e1.end);
                const { linesAbove: i = 2, linesBelow: a = 3 } = r || {};
                const o = n.line;
                const l = n.column;
                const c = s.line;
                const p = s.column;
                let u = Math.max(o - (i + 1), 0);
                let d = Math.min(t.length, c + a);
                if (o === -1) {
                    u = 0;
                }
                if (c === -1) {
                    d = t.length;
                }
                const f = c - o;
                const h = {};
                if (f) {
                    for(let e1 = 0; e1 <= f; e1++){
                        const r = e1 + o;
                        if (!l) {
                            h[r] = true;
                        } else if (e1 === 0) {
                            const e1 = t[r - 1].length;
                            h[r] = [
                                l,
                                e1 - l + 1
                            ];
                        } else if (e1 === f) {
                            h[r] = [
                                0,
                                p
                            ];
                        } else {
                            const n = t[r - e1].length;
                            h[r] = [
                                0,
                                n
                            ];
                        }
                    }
                } else {
                    if (l === p) {
                        if (l) {
                            h[o] = [
                                l,
                                0
                            ];
                        } else {
                            h[o] = true;
                        }
                    } else {
                        h[o] = [
                            l,
                            p - l
                        ];
                    }
                }
                return {
                    start: u,
                    end: d,
                    markerLines: h
                };
            }
            function codeFrameColumns(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                const n = r.forceColor || isColorSupported() && r.highlightCode;
                const s = getDefs(n);
                const i = e1.split(f);
                const { start: a, end: o, markerLines: l } = getMarkerLines(t, i, r);
                const c = t.start && typeof t.start.column === "number";
                const p = String(o).length;
                const u = n ? highlight(e1) : e1;
                let d = u.split(f, o).slice(a, o).map((e1, t)=>{
                    const n = a + 1 + t;
                    const i = " ".concat(n).slice(-p);
                    const o = " ".concat(i, " |");
                    const c = l[n];
                    const u = !l[n + 1];
                    if (c) {
                        let t = "";
                        if (Array.isArray(c)) {
                            const n = e1.slice(0, Math.max(c[0] - 1, 0)).replace(/[^\t]/g, " ");
                            const i = c[1] || 1;
                            t = [
                                "\n ",
                                s.gutter(o.replace(/\d/g, " ")),
                                " ",
                                n,
                                s.marker("^").repeat(i)
                            ].join("");
                            if (u && r.message) {
                                t += " " + s.message(r.message);
                            }
                        }
                        return [
                            s.marker(">"),
                            s.gutter(o),
                            e1.length > 0 ? " ".concat(e1) : "",
                            t
                        ].join("");
                    } else {
                        return " ".concat(s.gutter(o)).concat(e1.length > 0 ? " ".concat(e1) : "");
                    }
                }).join("\n");
                if (r.message && !c) {
                    d = "".concat(" ".repeat(p + 1)).concat(r.message, "\n").concat(d);
                }
                if (n) {
                    return s.reset(d);
                } else {
                    return d;
                }
            }
            function index(e1, t, r) {
                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                if (!d) {
                    d = true;
                    const e1 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].emitWarning(e1, "DeprecationWarning");
                    } else {
                        const t = new Error(e1);
                        t.name = "DeprecationWarning";
                        console.warn(new Error(e1));
                    }
                }
                r = Math.max(r, 0);
                const s = {
                    start: {
                        column: r,
                        line: t
                    }
                };
                return codeFrameColumns(e1, s, n);
            }
            t.codeFrameColumns = codeFrameColumns;
            t["default"] = index;
            t.highlight = highlight;
        },
        8566: (e1, t, r)=>{
            e1.exports = r(3702);
        },
        2810: (e1, t, r)=>{
            e1.exports = r(8427);
        },
        5732: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assertSimpleType = assertSimpleType;
            t.makeStrongCache = makeStrongCache;
            t.makeStrongCacheSync = makeStrongCacheSync;
            t.makeWeakCache = makeWeakCache;
            t.makeWeakCacheSync = makeWeakCacheSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(7987);
            var s = r(545);
            const synchronize = (e1)=>_gensync()(e1).sync;
            function* genTrue() {
                return true;
            }
            function makeWeakCache(e1) {
                return makeCachedFunction(WeakMap, e1);
            }
            function makeWeakCacheSync(e1) {
                return synchronize(makeWeakCache(e1));
            }
            function makeStrongCache(e1) {
                return makeCachedFunction(Map, e1);
            }
            function makeStrongCacheSync(e1) {
                return synchronize(makeStrongCache(e1));
            }
            function makeCachedFunction(e1, t) {
                const r = new e1;
                const i = new e1;
                const a = new e1;
                return function* cachedFunction(e1, o) {
                    const l = yield* (0, n.isAsync)();
                    const c = l ? i : r;
                    const p = yield* getCachedValueOrWait(l, c, a, e1, o);
                    if (p.valid) return p.value;
                    const u = new CacheConfigurator(o);
                    const d = t(e1, u);
                    let f;
                    let h;
                    if ((0, s.isIterableIterator)(d)) {
                        h = yield* (0, n.onFirstPause)(d, ()=>{
                            f = setupAsyncLocks(u, a, e1);
                        });
                    } else {
                        h = d;
                    }
                    updateFunctionCache(c, u, e1, h);
                    if (f) {
                        a.delete(e1);
                        f.release(h);
                    }
                    return h;
                };
            }
            function* getCachedValue(e1, t, r) {
                const n = e1.get(t);
                if (n) {
                    for (const { value: e1, valid: t } of n){
                        if (yield* t(r)) return {
                            valid: true,
                            value: e1
                        };
                    }
                }
                return {
                    valid: false,
                    value: null
                };
            }
            function* getCachedValueOrWait(e1, t, r, s, i) {
                const a = yield* getCachedValue(t, s, i);
                if (a.valid) {
                    return a;
                }
                if (e1) {
                    const e1 = yield* getCachedValue(r, s, i);
                    if (e1.valid) {
                        const t = yield* (0, n.waitFor)(e1.value.promise);
                        return {
                            valid: true,
                            value: t
                        };
                    }
                }
                return {
                    valid: false,
                    value: null
                };
            }
            function setupAsyncLocks(e1, t, r) {
                const n = new Lock;
                updateFunctionCache(t, e1, r, n);
                return n;
            }
            function updateFunctionCache(e1, t, r, n) {
                if (!t.configured()) t.forever();
                let s = e1.get(r);
                t.deactivate();
                switch(t.mode()){
                    case "forever":
                        s = [
                            {
                                value: n,
                                valid: genTrue
                            }
                        ];
                        e1.set(r, s);
                        break;
                    case "invalidate":
                        s = [
                            {
                                value: n,
                                valid: t.validator()
                            }
                        ];
                        e1.set(r, s);
                        break;
                    case "valid":
                        if (s) {
                            s.push({
                                value: n,
                                valid: t.validator()
                            });
                        } else {
                            s = [
                                {
                                    value: n,
                                    valid: t.validator()
                                }
                            ];
                            e1.set(r, s);
                        }
                }
            }
            class CacheConfigurator {
                simple() {
                    return makeSimpleConfigurator(this);
                }
                mode() {
                    if (this._never) return "never";
                    if (this._forever) return "forever";
                    if (this._invalidate) return "invalidate";
                    return "valid";
                }
                forever() {
                    if (!this._active) {
                        throw new Error("Cannot change caching after evaluation has completed.");
                    }
                    if (this._never) {
                        throw new Error("Caching has already been configured with .never()");
                    }
                    this._forever = true;
                    this._configured = true;
                }
                never() {
                    if (!this._active) {
                        throw new Error("Cannot change caching after evaluation has completed.");
                    }
                    if (this._forever) {
                        throw new Error("Caching has already been configured with .forever()");
                    }
                    this._never = true;
                    this._configured = true;
                }
                using(e1) {
                    if (!this._active) {
                        throw new Error("Cannot change caching after evaluation has completed.");
                    }
                    if (this._never || this._forever) {
                        throw new Error("Caching has already been configured with .never or .forever()");
                    }
                    this._configured = true;
                    const t = e1(this._data);
                    const r = (0, n.maybeAsync)(e1, "You appear to be using an async cache handler, but Babel has been called synchronously");
                    if ((0, n.isThenable)(t)) {
                        return t.then((e1)=>{
                            this._pairs.push([
                                e1,
                                r
                            ]);
                            return e1;
                        });
                    }
                    this._pairs.push([
                        t,
                        r
                    ]);
                    return t;
                }
                invalidate(e1) {
                    this._invalidate = true;
                    return this.using(e1);
                }
                validator() {
                    const e1 = this._pairs;
                    return function*(t) {
                        for (const [r, n] of e1){
                            if (r !== (yield* n(t))) return false;
                        }
                        return true;
                    };
                }
                deactivate() {
                    this._active = false;
                }
                configured() {
                    return this._configured;
                }
                constructor(e1){
                    this._active = true;
                    this._never = false;
                    this._forever = false;
                    this._invalidate = false;
                    this._configured = false;
                    this._pairs = [];
                    this._data = void 0;
                    this._data = e1;
                }
            }
            function makeSimpleConfigurator(e1) {
                function cacheFn(t) {
                    if (typeof t === "boolean") {
                        if (t) e1.forever();
                        else e1.never();
                        return;
                    }
                    return e1.using(()=>assertSimpleType(t()));
                }
                cacheFn.forever = ()=>e1.forever();
                cacheFn.never = ()=>e1.never();
                cacheFn.using = (t)=>e1.using(()=>assertSimpleType(t()));
                cacheFn.invalidate = (t)=>e1.invalidate(()=>assertSimpleType(t()));
                return cacheFn;
            }
            function assertSimpleType(e1) {
                if ((0, n.isThenable)(e1)) {
                    throw new Error("You appear to be using an async cache handler, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously handle your caching logic.");
                }
                if (e1 != null && typeof e1 !== "string" && typeof e1 !== "boolean" && typeof e1 !== "number") {
                    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
                }
                return e1;
            }
            class Lock {
                release(e1) {
                    this.released = true;
                    this._resolve(e1);
                }
                constructor(){
                    this.released = false;
                    this.promise = void 0;
                    this._resolve = void 0;
                    this.promise = new Promise((e1)=>{
                        this._resolve = e1;
                    });
                }
            }
            0 && 0;
        },
        9646: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildPresetChain = buildPresetChain;
            t.buildPresetChainWalker = void 0;
            t.buildRootChain = buildRootChain;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4320);
            var s = r(5076);
            var i = r(669);
            var a = r(8502);
            var o = r(195);
            var l = r(5329);
            var c = r(5732);
            var p = r(4449);
            const u = _debug()("babel:config:config-chain");
            function* buildPresetChain(e1, t) {
                const r = yield* d(e1, t);
                if (!r) return null;
                return {
                    plugins: dedupDescriptors(r.plugins),
                    presets: dedupDescriptors(r.presets),
                    options: r.options.map((e1)=>normalizeOptions(e1)),
                    files: new Set
                };
            }
            const d = t.buildPresetChainWalker = makeChainWalker({
                root: (e1)=>f(e1),
                env: (e1, t)=>h(e1)(t),
                overrides: (e1, t)=>m(e1)(t),
                overridesEnv: (e1, t, r)=>y(e1)(t)(r),
                createLogger: ()=>()=>{}
            });
            const f = (0, c.makeWeakCacheSync)((e1)=>buildRootDescriptors(e1, e1.alias, p.createUncachedDescriptors));
            const h = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildEnvDescriptors(e1, e1.alias, p.createUncachedDescriptors, t)));
            const m = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildOverrideDescriptors(e1, e1.alias, p.createUncachedDescriptors, t)));
            const y = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>(0, c.makeStrongCacheSync)((r)=>buildOverrideEnvDescriptors(e1, e1.alias, p.createUncachedDescriptors, t, r))));
            function* buildRootChain(e1, t) {
                let r, n;
                const s = new i.ConfigPrinter;
                const a = yield* S({
                    options: e1,
                    dirname: t.cwd
                }, t, undefined, s);
                if (!a) return null;
                const o = yield* s.output();
                let c;
                if (typeof e1.configFile === "string") {
                    c = yield* (0, l.loadConfig)(e1.configFile, t.cwd, t.envName, t.caller);
                } else if (e1.configFile !== false) {
                    c = yield* (0, l.findRootConfig)(t.root, t.envName, t.caller);
                }
                let { babelrc: p, babelrcRoots: u } = e1;
                let d = t.cwd;
                const f = emptyChain();
                const h = new i.ConfigPrinter;
                if (c) {
                    const e1 = g(c);
                    const n = yield* loadFileChain(e1, t, undefined, h);
                    if (!n) return null;
                    r = yield* h.output();
                    if (p === undefined) {
                        p = e1.options.babelrc;
                    }
                    if (u === undefined) {
                        d = e1.dirname;
                        u = e1.options.babelrcRoots;
                    }
                    mergeChain(f, n);
                }
                let m, y;
                let T = false;
                const x = emptyChain();
                if ((p === true || p === undefined) && typeof t.filename === "string") {
                    const e1 = yield* (0, l.findPackageData)(t.filename);
                    if (e1 && babelrcLoadEnabled(t, e1, u, d)) {
                        ({ ignore: m, config: y } = yield* (0, l.findRelativeConfig)(e1, t.envName, t.caller));
                        if (m) {
                            x.files.add(m.filepath);
                        }
                        if (m && shouldIgnore(t, m.ignore, null, m.dirname)) {
                            T = true;
                        }
                        if (y && !T) {
                            const e1 = b(y);
                            const r = new i.ConfigPrinter;
                            const s = yield* loadFileChain(e1, t, undefined, r);
                            if (!s) {
                                T = true;
                            } else {
                                n = yield* r.output();
                                mergeChain(x, s);
                            }
                        }
                        if (y && T) {
                            x.files.add(y.filepath);
                        }
                    }
                }
                if (t.showConfig) {
                    console.log('Babel configs on "'.concat(t.filename, '" (ascending priority):\n') + [
                        r,
                        n,
                        o
                    ].filter((e1)=>!!e1).join("\n\n") + "\n-----End Babel configs-----");
                }
                const E = mergeChain(mergeChain(mergeChain(emptyChain(), f), x), a);
                return {
                    plugins: T ? [] : dedupDescriptors(E.plugins),
                    presets: T ? [] : dedupDescriptors(E.presets),
                    options: T ? [] : E.options.map((e1)=>normalizeOptions(e1)),
                    fileHandling: T ? "ignored" : "transpile",
                    ignore: m || undefined,
                    babelrc: y || undefined,
                    config: c || undefined,
                    files: E.files
                };
            }
            function babelrcLoadEnabled(e1, t, r, n) {
                if (typeof r === "boolean") return r;
                const i = e1.root;
                if (r === undefined) {
                    return t.directories.includes(i);
                }
                let a = r;
                if (!Array.isArray(a)) {
                    a = [
                        a
                    ];
                }
                a = a.map((e1)=>typeof e1 === "string" ? _path().resolve(n, e1) : e1);
                if (a.length === 1 && a[0] === i) {
                    return t.directories.includes(i);
                }
                return a.some((r)=>{
                    if (typeof r === "string") {
                        r = (0, s.default)(r, n);
                    }
                    return t.directories.some((t)=>matchPattern(r, n, t, e1));
                });
            }
            const g = (0, c.makeWeakCacheSync)((e1)=>({
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: (0, n.validate)("configfile", e1.options, e1.filepath)
                }));
            const b = (0, c.makeWeakCacheSync)((e1)=>({
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: (0, n.validate)("babelrcfile", e1.options, e1.filepath)
                }));
            const T = (0, c.makeWeakCacheSync)((e1)=>({
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: (0, n.validate)("extendsfile", e1.options, e1.filepath)
                }));
            const S = makeChainWalker({
                root: (e1)=>buildRootDescriptors(e1, "base", p.createCachedDescriptors),
                env: (e1, t)=>buildEnvDescriptors(e1, "base", p.createCachedDescriptors, t),
                overrides: (e1, t)=>buildOverrideDescriptors(e1, "base", p.createCachedDescriptors, t),
                overridesEnv: (e1, t, r)=>buildOverrideEnvDescriptors(e1, "base", p.createCachedDescriptors, t, r),
                createLogger: (e1, t, r)=>buildProgrammaticLogger(e1, t, r)
            });
            const x = makeChainWalker({
                root: (e1)=>E(e1),
                env: (e1, t)=>P(e1)(t),
                overrides: (e1, t)=>v(e1)(t),
                overridesEnv: (e1, t, r)=>A(e1)(t)(r),
                createLogger: (e1, t, r)=>buildFileLogger(e1.filepath, t, r)
            });
            function* loadFileChain(e1, t, r, n) {
                const s = yield* x(e1, t, r, n);
                s == null || s.files.add(e1.filepath);
                return s;
            }
            const E = (0, c.makeWeakCacheSync)((e1)=>buildRootDescriptors(e1, e1.filepath, p.createUncachedDescriptors));
            const P = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildEnvDescriptors(e1, e1.filepath, p.createUncachedDescriptors, t)));
            const v = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildOverrideDescriptors(e1, e1.filepath, p.createUncachedDescriptors, t)));
            const A = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>(0, c.makeStrongCacheSync)((r)=>buildOverrideEnvDescriptors(e1, e1.filepath, p.createUncachedDescriptors, t, r))));
            function buildFileLogger(e1, t, r) {
                if (!r) {
                    return ()=>{};
                }
                return r.configure(t.showConfig, i.ChainFormatter.Config, {
                    filepath: e1
                });
            }
            function buildRootDescriptors(param, r, n) {
                let { dirname: e1, options: t } = param;
                return n(e1, t, r);
            }
            function buildProgrammaticLogger(e1, t, r) {
                var n;
                if (!r) {
                    return ()=>{};
                }
                return r.configure(t.showConfig, i.ChainFormatter.Programmatic, {
                    callerName: (n = t.caller) == null ? void 0 : n.name
                });
            }
            function buildEnvDescriptors(param, r, n, s) {
                let { dirname: e1, options: t } = param;
                var i;
                const a = (i = t.env) == null ? void 0 : i[s];
                return a ? n(e1, a, "".concat(r, '.env["').concat(s, '"]')) : null;
            }
            function buildOverrideDescriptors(param, r, n, s) {
                let { dirname: e1, options: t } = param;
                var i;
                const a = (i = t.overrides) == null ? void 0 : i[s];
                if (!a) throw new Error("Assertion failure - missing override");
                return n(e1, a, "".concat(r, ".overrides[").concat(s, "]"));
            }
            function buildOverrideEnvDescriptors(param, r, n, s, i) {
                let { dirname: e1, options: t } = param;
                var a, o;
                const l = (a = t.overrides) == null ? void 0 : a[s];
                if (!l) throw new Error("Assertion failure - missing override");
                const c = (o = l.env) == null ? void 0 : o[i];
                return c ? n(e1, c, "".concat(r, ".overrides[").concat(s, '].env["').concat(i, '"]')) : null;
            }
            function makeChainWalker(param) {
                let { root: e1, env: t, overrides: r, overridesEnv: n, createLogger: s } = param;
                return function* chainWalker(i, a) {
                    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set, l = arguments.length > 3 ? arguments[3] : void 0;
                    const { dirname: c } = i;
                    const p = [];
                    const u = e1(i);
                    if (configIsApplicable(u, c, a, i.filepath)) {
                        p.push({
                            config: u,
                            envName: undefined,
                            index: undefined
                        });
                        const e1 = t(i, a.envName);
                        if (e1 && configIsApplicable(e1, c, a, i.filepath)) {
                            p.push({
                                config: e1,
                                envName: a.envName,
                                index: undefined
                            });
                        }
                        (u.options.overrides || []).forEach((e1, t)=>{
                            const s = r(i, t);
                            if (configIsApplicable(s, c, a, i.filepath)) {
                                p.push({
                                    config: s,
                                    index: t,
                                    envName: undefined
                                });
                                const e1 = n(i, t, a.envName);
                                if (e1 && configIsApplicable(e1, c, a, i.filepath)) {
                                    p.push({
                                        config: e1,
                                        index: t,
                                        envName: a.envName
                                    });
                                }
                            }
                        });
                    }
                    if (p.some((param)=>{
                        let { config: { options: { ignore: e1, only: t } } } = param;
                        return shouldIgnore(a, e1, t, c);
                    })) {
                        return null;
                    }
                    const d = emptyChain();
                    const f = s(i, a, l);
                    for (const { config: e1, index: t, envName: r } of p){
                        if (!(yield* mergeExtendsChain(d, e1.options, c, a, o, l))) {
                            return null;
                        }
                        f(e1, t, r);
                        yield* mergeChainOpts(d, e1);
                    }
                    return d;
                };
            }
            function* mergeExtendsChain(e1, t, r, n, s, i) {
                if (t.extends === undefined) return true;
                const a = yield* (0, l.loadConfig)(t.extends, r, n.envName, n.caller);
                if (s.has(a)) {
                    throw new Error("Configuration cycle detected loading ".concat(a.filepath, ".\n") + "File already loaded following the config chain:\n" + Array.from(s, (e1)=>" - ".concat(e1.filepath)).join("\n"));
                }
                s.add(a);
                const o = yield* loadFileChain(T(a), n, s, i);
                s.delete(a);
                if (!o) return false;
                mergeChain(e1, o);
                return true;
            }
            function mergeChain(e1, t) {
                e1.options.push(...t.options);
                e1.plugins.push(...t.plugins);
                e1.presets.push(...t.presets);
                for (const r of t.files){
                    e1.files.add(r);
                }
                return e1;
            }
            function* mergeChainOpts(e1, param) {
                let { options: t, plugins: r, presets: n } = param;
                e1.options.push(t);
                e1.plugins.push(...yield* r());
                e1.presets.push(...yield* n());
                return e1;
            }
            function emptyChain() {
                return {
                    options: [],
                    presets: [],
                    plugins: [],
                    files: new Set
                };
            }
            function normalizeOptions(e1) {
                const t = Object.assign({}, e1);
                delete t.extends;
                delete t.env;
                delete t.overrides;
                delete t.plugins;
                delete t.presets;
                delete t.passPerPreset;
                delete t.ignore;
                delete t.only;
                delete t.test;
                delete t.include;
                delete t.exclude;
                if (hasOwnProperty.call(t, "sourceMap")) {
                    t.sourceMaps = t.sourceMap;
                    delete t.sourceMap;
                }
                return t;
            }
            function dedupDescriptors(e1) {
                const t = new Map;
                const r = [];
                for (const n of e1){
                    if (typeof n.value === "function") {
                        const e1 = n.value;
                        let s = t.get(e1);
                        if (!s) {
                            s = new Map;
                            t.set(e1, s);
                        }
                        let i = s.get(n.name);
                        if (!i) {
                            i = {
                                value: n
                            };
                            r.push(i);
                            if (!n.ownPass) s.set(n.name, i);
                        } else {
                            i.value = n;
                        }
                    } else {
                        r.push({
                            value: n
                        });
                    }
                }
                return r.reduce((e1, t)=>{
                    e1.push(t.value);
                    return e1;
                }, []);
            }
            function configIsApplicable(param, t, r, n) {
                let { options: e1 } = param;
                return (e1.test === undefined || configFieldIsApplicable(r, e1.test, t, n)) && (e1.include === undefined || configFieldIsApplicable(r, e1.include, t, n)) && (e1.exclude === undefined || !configFieldIsApplicable(r, e1.exclude, t, n));
            }
            function configFieldIsApplicable(e1, t, r, n) {
                const s = Array.isArray(t) ? t : [
                    t
                ];
                return matchesPatterns(e1, s, r, n);
            }
            function ignoreListReplacer(e1, t) {
                if (t instanceof RegExp) {
                    return String(t);
                }
                return t;
            }
            function shouldIgnore(e1, t, r, n) {
                if (t && matchesPatterns(e1, t, n)) {
                    var s;
                    const r = 'No config is applied to "'.concat((s = e1.filename) != null ? s : "(unknown)", '" because it matches one of `ignore: ').concat(JSON.stringify(t, ignoreListReplacer), '` from "').concat(n, '"');
                    u(r);
                    if (e1.showConfig) {
                        console.log(r);
                    }
                    return true;
                }
                if (r && !matchesPatterns(e1, r, n)) {
                    var i;
                    const t = 'No config is applied to "'.concat((i = e1.filename) != null ? i : "(unknown)", '" because it fails to match one of `only: ').concat(JSON.stringify(r, ignoreListReplacer), '` from "').concat(n, '"');
                    u(t);
                    if (e1.showConfig) {
                        console.log(t);
                    }
                    return true;
                }
                return false;
            }
            function matchesPatterns(e1, t, r, n) {
                return t.some((t)=>matchPattern(t, r, e1.filename, e1, n));
            }
            function matchPattern(e1, t, r, n, i) {
                if (typeof e1 === "function") {
                    return !!(0, a.endHiddenCallStack)(e1)(r, {
                        dirname: t,
                        envName: n.envName,
                        caller: n.caller
                    });
                }
                if (typeof r !== "string") {
                    throw new o.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", i);
                }
                if (typeof e1 === "string") {
                    e1 = (0, s.default)(e1, t);
                }
                return e1.test(r);
            }
            0 && 0;
        },
        4449: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createCachedDescriptors = createCachedDescriptors;
            t.createDescriptor = createDescriptor;
            t.createUncachedDescriptors = createUncachedDescriptors;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(9516);
            var s = r(5329);
            var i = r(8131);
            var a = r(5732);
            var o = r(78);
            function isEqualDescriptor(e1, t) {
                var r, n, s, i;
                return e1.name === t.name && e1.value === t.value && e1.options === t.options && e1.dirname === t.dirname && e1.alias === t.alias && e1.ownPass === t.ownPass && ((r = e1.file) == null ? void 0 : r.request) === ((n = t.file) == null ? void 0 : n.request) && ((s = e1.file) == null ? void 0 : s.resolved) === ((i = t.file) == null ? void 0 : i.resolved);
            }
            function* handlerOf(e1) {
                return e1;
            }
            function optionsWithResolvedBrowserslistConfigFile(e1, t) {
                if (typeof e1.browserslistConfigFile === "string") {
                    e1.browserslistConfigFile = (0, o.resolveBrowserslistConfigFile)(e1.browserslistConfigFile, t);
                }
                return e1;
            }
            function createCachedDescriptors(e1, t, r) {
                const { plugins: n, presets: s, passPerPreset: i } = t;
                return {
                    options: optionsWithResolvedBrowserslistConfigFile(t, e1),
                    plugins: n ? ()=>u(n, e1)(r) : ()=>handlerOf([]),
                    presets: s ? ()=>c(s, e1)(r)(!!i) : ()=>handlerOf([])
                };
            }
            function createUncachedDescriptors(e1, t, r) {
                return {
                    options: optionsWithResolvedBrowserslistConfigFile(t, e1),
                    plugins: (0, n.once)(()=>createPluginDescriptors(t.plugins || [], e1, r)),
                    presets: (0, n.once)(()=>createPresetDescriptors(t.presets || [], e1, r, !!t.passPerPreset))
                };
            }
            const l = new WeakMap;
            const c = (0, a.makeWeakCacheSync)((e1, t)=>{
                const r = t.using((e1)=>e1);
                return (0, a.makeStrongCacheSync)((t)=>(0, a.makeStrongCache)(function*(n) {
                        const s = yield* createPresetDescriptors(e1, r, t, n);
                        return s.map((e1)=>loadCachedDescriptor(l, e1));
                    }));
            });
            const p = new WeakMap;
            const u = (0, a.makeWeakCacheSync)((e1, t)=>{
                const r = t.using((e1)=>e1);
                return (0, a.makeStrongCache)(function*(t) {
                    const n = yield* createPluginDescriptors(e1, r, t);
                    return n.map((e1)=>loadCachedDescriptor(p, e1));
                });
            });
            const d = {};
            function loadCachedDescriptor(e1, t) {
                const { value: r, options: n = d } = t;
                if (n === false) return t;
                let s = e1.get(r);
                if (!s) {
                    s = new WeakMap;
                    e1.set(r, s);
                }
                let i = s.get(n);
                if (!i) {
                    i = [];
                    s.set(n, i);
                }
                if (!i.includes(t)) {
                    const e1 = i.filter((e1)=>isEqualDescriptor(e1, t));
                    if (e1.length > 0) {
                        return e1[0];
                    }
                    i.push(t);
                }
                return t;
            }
            function* createPresetDescriptors(e1, t, r, n) {
                return yield* createDescriptors("preset", e1, t, r, n);
            }
            function* createPluginDescriptors(e1, t, r) {
                return yield* createDescriptors("plugin", e1, t, r);
            }
            function* createDescriptors(e1, t, r, n, s) {
                const i = yield* _gensync().all(t.map((t, i)=>createDescriptor(t, r, {
                        type: e1,
                        alias: "".concat(n, "$").concat(i),
                        ownPass: !!s
                    })));
                assertNoDuplicates(i);
                return i;
            }
            function* createDescriptor(e1, t, param) {
                let { type: r, alias: n, ownPass: a } = param;
                const o = (0, i.getItemDescriptor)(e1);
                if (o) {
                    return o;
                }
                let l;
                let c;
                let p = e1;
                if (Array.isArray(p)) {
                    if (p.length === 3) {
                        [p, c, l] = p;
                    } else {
                        [p, c] = p;
                    }
                }
                let u = undefined;
                let d = null;
                if (typeof p === "string") {
                    if (typeof r !== "string") {
                        throw new Error("To resolve a string-based item, the type of item must be given");
                    }
                    const e1 = r === "plugin" ? s.loadPlugin : s.loadPreset;
                    const n = p;
                    ({ filepath: d, value: p } = yield* e1(p, t));
                    u = {
                        request: n,
                        resolved: d
                    };
                }
                if (!p) {
                    throw new Error("Unexpected falsy value: ".concat(String(p)));
                }
                if (typeof p === "object" && p.__esModule) {
                    if (p.default) {
                        p = p.default;
                    } else {
                        throw new Error("Must export a default export when using ES6 modules.");
                    }
                }
                if (typeof p !== "object" && typeof p !== "function") {
                    throw new Error("Unsupported format: ".concat(typeof p, ". Expected an object or a function."));
                }
                if (d !== null && typeof p === "object" && p) {
                    throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In ".concat(d));
                }
                return {
                    name: l,
                    alias: d || n,
                    value: p,
                    options: c,
                    dirname: t,
                    ownPass: a,
                    file: u
                };
            }
            function assertNoDuplicates(e1) {
                const t = new Map;
                for (const r of e1){
                    if (typeof r.value !== "function") continue;
                    let n = t.get(r.value);
                    if (!n) {
                        n = new Set;
                        t.set(r.value, n);
                    }
                    if (n.has(r.name)) {
                        const t = e1.filter((e1)=>e1.value === r.value);
                        throw new Error([
                            "Duplicate plugin/preset detected.",
                            "If you'd like to use two separate instances of a plugin,",
                            "they need separate names, e.g.",
                            "",
                            "  plugins: [",
                            "    ['some-plugin', {}],",
                            "    ['some-plugin', {}, 'some unique name'],",
                            "  ]",
                            "",
                            "Duplicates detected are:",
                            "".concat(JSON.stringify(t, null, 2))
                        ].join("\n"));
                    }
                    n.add(r.name);
                }
            }
            0 && 0;
        },
        8741: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ROOT_CONFIG_FILENAMES = void 0;
            t.findConfigUpwards = findConfigUpwards;
            t.findRelativeConfig = findRelativeConfig;
            t.findRootConfig = findRootConfig;
            t.loadConfig = loadConfig;
            t.resolveShowConfigPath = resolveShowConfigPath;
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _json() {
                const e1 = r(8310);
                _json = function() {
                    return e1;
                };
                return e1;
            }
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(5732);
            var s = r(3165);
            var i = r(4207);
            var a = r(7416);
            var o = r(5076);
            var l = r(195);
            var c = r(409);
            r(8188);
            var p = r(8502);
            var u = r(7987);
            const d = _debug()("babel:config:loading:files:configuration");
            const f = t.ROOT_CONFIG_FILENAMES = [
                "babel.config.js",
                "babel.config.cjs",
                "babel.config.mjs",
                "babel.config.json",
                "babel.config.cts"
            ];
            const h = [
                ".babelrc",
                ".babelrc.js",
                ".babelrc.cjs",
                ".babelrc.mjs",
                ".babelrc.json",
                ".babelrc.cts"
            ];
            const m = ".babelignore";
            const y = (0, n.makeWeakCache)(function* runConfig(e1, t) {
                yield* [];
                return {
                    options: (0, p.endHiddenCallStack)(e1)((0, s.makeConfigAPI)(t)),
                    cacheNeedsConfiguration: !t.configured()
                };
            });
            function* readConfigCode(e1, t) {
                if (!_fs().existsSync(e1)) return null;
                let r = yield* (0, a.default)(e1, (yield* (0, u.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module configuration " + "file, which is only supported when running Babel asynchronously " + "or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a configuration file that contains top-level " + "await, which is only supported when running Babel asynchronously.");
                let n = false;
                if (typeof r === "function") {
                    ({ options: r, cacheNeedsConfiguration: n } = yield* y(r, t));
                }
                if (!r || typeof r !== "object" || Array.isArray(r)) {
                    throw new l.default("Configuration should be an exported JavaScript object.", e1);
                }
                if (typeof r.then === "function") {
                    r.catch == null || r.catch(()=>{});
                    throw new l.default("You appear to be using an async configuration, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously return your config.", e1);
                }
                if (n) throwConfigError(e1);
                return buildConfigFileObject(r, e1);
            }
            const g = new WeakMap;
            function buildConfigFileObject(e1, t) {
                let r = g.get(e1);
                if (!r) {
                    g.set(e1, r = new Map);
                }
                let n = r.get(t);
                if (!n) {
                    n = {
                        filepath: t,
                        dirname: _path().dirname(t),
                        options: e1
                    };
                    r.set(t, n);
                }
                return n;
            }
            const b = (0, n.makeWeakCacheSync)((e1)=>{
                const t = e1.options["babel"];
                if (t === undefined) return null;
                if (typeof t !== "object" || Array.isArray(t) || t === null) {
                    throw new l.default(".babel property must be an object", e1.filepath);
                }
                return {
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: t
                };
            });
            const T = (0, i.makeStaticFileCache)((e1, t)=>{
                let r;
                try {
                    r = _json().parse(t);
                } catch (t) {
                    throw new l.default("Error while parsing config - ".concat(t.message), e1);
                }
                if (!r) throw new l.default("No config detected", e1);
                if (typeof r !== "object") {
                    throw new l.default("Config returned typeof ".concat(typeof r), e1);
                }
                if (Array.isArray(r)) {
                    throw new l.default("Expected config object but found array", e1);
                }
                delete r["$schema"];
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    options: r
                };
            });
            const S = (0, i.makeStaticFileCache)((e1, t)=>{
                const r = _path().dirname(e1);
                const n = t.split("\n").map((e1)=>e1.replace(/#.*$/, "").trim()).filter(Boolean);
                for (const t of n){
                    if (t[0] === "!") {
                        throw new l.default("Negation of file paths is not supported.", e1);
                    }
                }
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    ignore: n.map((e1)=>(0, o.default)(e1, r))
                };
            });
            function findConfigUpwards(e1) {
                let t = e1;
                for(;;){
                    for (const e1 of f){
                        if (_fs().existsSync(_path().join(t, e1))) {
                            return t;
                        }
                    }
                    const e1 = _path().dirname(t);
                    if (t === e1) break;
                    t = e1;
                }
                return null;
            }
            function* findRelativeConfig(e1, t, r) {
                let n = null;
                let s = null;
                const i = _path().dirname(e1.filepath);
                for (const o of e1.directories){
                    if (!n) {
                        var a;
                        n = yield* loadOneConfig(h, o, t, r, ((a = e1.pkg) == null ? void 0 : a.dirname) === o ? b(e1.pkg) : null);
                    }
                    if (!s) {
                        const e1 = _path().join(o, m);
                        s = yield* S(e1);
                        if (s) {
                            d("Found ignore %o from %o.", s.filepath, i);
                        }
                    }
                }
                return {
                    config: n,
                    ignore: s
                };
            }
            function findRootConfig(e1, t, r) {
                return loadOneConfig(f, e1, t, r);
            }
            function* loadOneConfig(e1, t, r, n) {
                let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                const i = yield* _gensync().all(e1.map((e1)=>readConfig(_path().join(t, e1), r, n)));
                const a = i.reduce((e1, r)=>{
                    if (r && e1) {
                        throw new l.default("Multiple configuration files found. Please remove one:\n" + " - ".concat(_path().basename(e1.filepath), "\n") + " - ".concat(r.filepath, "\n") + "from ".concat(t));
                    }
                    return r || e1;
                }, s);
                if (a) {
                    d("Found configuration %o from %o.", a.filepath, t);
                }
                return a;
            }
            function* loadConfig(e1, t, n, s) {
                const i = (((e1, t)=>(e1 = e1.split("."), t = t.split("."), +e1[0] > +t[0] || e1[0] == t[0] && +e1[1] >= +t[1]))(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node, "8.9") ? /*TURBOPACK member replacement*/ __turbopack_context__.t.resolve : function(e1, param) {
                    let { paths: [t] } = param, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r(8188);
                    let s = n._findPath(e1, n._nodeModulePaths(t).concat(t));
                    if (s) return s;
                    s = new Error("Cannot resolve module '".concat(e1, "'"));
                    s.code = "MODULE_NOT_FOUND";
                    throw s;
                })(e1, {
                    paths: [
                        t
                    ]
                });
                const a = yield* readConfig(i, n, s);
                if (!a) {
                    throw new l.default("Config file contains no configuration data", i);
                }
                d("Loaded config %o from %o.", e1, t);
                return a;
            }
            function readConfig(e1, t, r) {
                const n = _path().extname(e1);
                switch(n){
                    case ".js":
                    case ".cjs":
                    case ".mjs":
                    case ".ts":
                    case ".cts":
                    case ".mts":
                        return readConfigCode(e1, {
                            envName: t,
                            caller: r
                        });
                    default:
                        return T(e1);
                }
            }
            function* resolveShowConfigPath(e1) {
                const t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_SHOW_CONFIG_FOR;
                if (t != null) {
                    const r = _path().resolve(e1, t);
                    const n = yield* c.stat(r);
                    if (!n.isFile()) {
                        throw new Error("".concat(r, ": BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported."));
                    }
                    return r;
                }
                return null;
            }
            function throwConfigError(e1) {
                throw new l.default('Caching was left unconfigured. Babel\'s plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don\'t call this function again.\n  api.cache(true);\n\n  // Don\'t cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === "production");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};', e1);
            }
            0 && 0;
        },
        5329: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "ROOT_CONFIG_FILENAMES", {
                enumerable: true,
                get: function() {
                    return s.ROOT_CONFIG_FILENAMES;
                }
            });
            Object.defineProperty(t, "findConfigUpwards", {
                enumerable: true,
                get: function() {
                    return s.findConfigUpwards;
                }
            });
            Object.defineProperty(t, "findPackageData", {
                enumerable: true,
                get: function() {
                    return n.findPackageData;
                }
            });
            Object.defineProperty(t, "findRelativeConfig", {
                enumerable: true,
                get: function() {
                    return s.findRelativeConfig;
                }
            });
            Object.defineProperty(t, "findRootConfig", {
                enumerable: true,
                get: function() {
                    return s.findRootConfig;
                }
            });
            Object.defineProperty(t, "loadConfig", {
                enumerable: true,
                get: function() {
                    return s.loadConfig;
                }
            });
            Object.defineProperty(t, "loadPlugin", {
                enumerable: true,
                get: function() {
                    return i.loadPlugin;
                }
            });
            Object.defineProperty(t, "loadPreset", {
                enumerable: true,
                get: function() {
                    return i.loadPreset;
                }
            });
            Object.defineProperty(t, "resolvePlugin", {
                enumerable: true,
                get: function() {
                    return i.resolvePlugin;
                }
            });
            Object.defineProperty(t, "resolvePreset", {
                enumerable: true,
                get: function() {
                    return i.resolvePreset;
                }
            });
            Object.defineProperty(t, "resolveShowConfigPath", {
                enumerable: true,
                get: function() {
                    return s.resolveShowConfigPath;
                }
            });
            var n = r(847);
            var s = r(8741);
            var i = r(266);
            ({});
            0 && 0;
        },
        7416: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = loadCodeDefault;
            t.supportsESM = void 0;
            var n = r(7987);
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _url() {
                const e1 = r(7310);
                _url = function() {
                    return e1;
                };
                return e1;
            }
            r(8188);
            function _semver() {
                const e1 = r(7849);
                _semver = function() {
                    return e1;
                };
                return e1;
            }
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            var s = r(8502);
            var i = r(195);
            var a = r(7111);
            function asyncGeneratorStep(e1, t, r, n, s, i, a) {
                try {
                    var o = e1[i](a), l = o.value;
                } catch (e1) {
                    return void r(e1);
                }
                o.done ? t(l) : Promise.resolve(l).then(n, s);
            }
            function _asyncToGenerator(e1) {
                return function() {
                    var t = this, r = arguments;
                    return new Promise(function(n, s) {
                        var i = e1.apply(t, r);
                        function _next(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "next", e1);
                        }
                        function _throw(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "throw", e1);
                        }
                        _next(void 0);
                    });
                };
            }
            const o = _debug()("babel:config:loading:files:module-types");
            {
                try {
                    var l = r(1824);
                } catch (e1) {}
            }
            const c = t.supportsESM = _semver().satisfies(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node, "^12.17 || >=13.2");
            const p = new Set;
            function loadCjsDefault(e1) {
                if (p.has(e1)) {
                    o("Auto-ignoring usage of config %o.", e1);
                    return {};
                }
                let t;
                try {
                    p.add(e1);
                    t = (0, s.endHiddenCallStack)(/*TURBOPACK member replacement*/ __turbopack_context__.t)(e1);
                } finally{
                    p.delete(e1);
                }
                {
                    return t != null && (t.__esModule || t[Symbol.toStringTag] === "Module") ? t.default || (arguments[1] ? t : undefined) : t;
                }
            }
            const u = (0, s.endHiddenCallStack)(function() {
                var e1 = _asyncToGenerator(function*(e1) {
                    const t = (0, _url().pathToFileURL)(e1).toString() + "?import";
                    {
                        if (!l) {
                            throw new i.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n", e1);
                        }
                        return yield l(t);
                    }
                });
                function loadMjsFromPath(t) {
                    return e1.apply(this, arguments);
                }
                return loadMjsFromPath;
            }());
            const d = {
                ".js": "unknown",
                ".mjs": "esm",
                ".cjs": "cjs",
                ".ts": "unknown",
                ".mts": "esm",
                ".cts": "cjs"
            };
            const f = new Set;
            function* loadCodeDefault(e1, t, r, s) {
                let a;
                const o = _path().extname(e1);
                const l = o === ".ts" || o === ".cts" || o === ".mts";
                const c = d[hasOwnProperty.call(d, o) ? o : ".js"];
                const p = "".concat(t, " ").concat(c);
                switch(p){
                    case "require cjs":
                    case "auto cjs":
                        if (l) {
                            return ensureTsSupport(e1, o, ()=>loadCjsDefault(e1));
                        } else {
                            return loadCjsDefault(e1, arguments[2]);
                        }
                    case "auto unknown":
                    case "require unknown":
                    case "require esm":
                        try {
                            if (l) {
                                return ensureTsSupport(e1, o, ()=>loadCjsDefault(e1));
                            } else {
                                return loadCjsDefault(e1, arguments[2]);
                            }
                        } catch (t) {
                            if (t.code === "ERR_REQUIRE_ASYNC_MODULE" || t.code === "ERR_REQUIRE_CYCLE_MODULE" && f.has(e1)) {
                                f.add(e1);
                                if (!(a != null ? a : a = yield* (0, n.isAsync)())) {
                                    throw new i.default(s, e1);
                                }
                            } else if (t.code === "ERR_REQUIRE_ESM" || c === "esm") {} else {
                                throw t;
                            }
                        }
                    case "auto esm":
                        if (a != null ? a : a = yield* (0, n.isAsync)()) {
                            const t = l ? ensureTsSupport(e1, o, ()=>u(e1)) : u(e1);
                            return (yield* (0, n.waitFor)(t)).default;
                        }
                        throw new i.default(r, e1);
                    default:
                        throw new Error("Internal Babel error: unreachable code.");
                }
            }
            function ensureTsSupport(e1, t, n) {
                if (/*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[".ts"] || /*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[".cts"] || /*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[".mts"]) {
                    return n();
                }
                if (t !== ".cts") {
                    throw new i.default("You are using a ".concat(t, " config file, but Babel only supports transpiling .cts configs. Either:\n- Use a .cts config file\n- Update to Node.js 23.6.0, which has native TypeScript support\n- Install ts-node to transpile ").concat(t, " files on the fly"), e1);
                }
                const s = {
                    babelrc: false,
                    configFile: false,
                    sourceType: "unambiguous",
                    sourceMaps: "inline",
                    sourceFileName: _path().basename(e1),
                    presets: [
                        [
                            getTSPreset(e1),
                            Object.assign({
                                onlyRemoveTypeImports: true,
                                optimizeConstEnums: true
                            }, {
                                allowDeclareFields: true
                            })
                        ]
                    ]
                };
                let handler = function(e1, t) {
                    if (handler && t.endsWith(".cts")) {
                        try {
                            return e1._compile((0, a.transformFileSync)(t, Object.assign({}, s, {
                                filename: t
                            })).code, t);
                        } catch (e1) {
                            const t = r(1628);
                            if (_semver().lt(t.version, "7.21.4")) {
                                console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                            }
                            throw e1;
                        }
                    }
                    return /*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[".js"](e1, t);
                };
                /*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[t] = handler;
                try {
                    return n();
                } finally{
                    if (/*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[t] === handler) delete /*TURBOPACK member replacement*/ __turbopack_context__.t.extensions[t];
                    handler = undefined;
                }
            }
            function getTSPreset(e1) {
                try {
                    return r(8782);
                } catch (t) {
                    if (t.code !== "MODULE_NOT_FOUND") throw t;
                    let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
                    {
                        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.pnp) {
                            r += '\nIf you are using Yarn Plug\'n\'Play, you may also need to add the following configuration to your .yarnrc.yml file:\n\npackageExtensions:\n	"@babel/core@*":\n		peerDependencies:\n			"@babel/preset-typescript": "*"\n';
                        }
                    }
                    throw new i.default(r, e1);
                }
            }
            0 && 0;
        },
        847: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.findPackageData = findPackageData;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4207);
            var s = r(195);
            const i = "package.json";
            const a = (0, n.makeStaticFileCache)((e1, t)=>{
                let r;
                try {
                    r = JSON.parse(t);
                } catch (t) {
                    throw new s.default("Error while parsing JSON - ".concat(t.message), e1);
                }
                if (!r) throw new Error("".concat(e1, ": No config detected"));
                if (typeof r !== "object") {
                    throw new s.default("Config returned typeof ".concat(typeof r), e1);
                }
                if (Array.isArray(r)) {
                    throw new s.default("Expected config object but found array", e1);
                }
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    options: r
                };
            });
            function* findPackageData(e1) {
                let t = null;
                const r = [];
                let n = true;
                let s = _path().dirname(e1);
                while(!t && _path().basename(s) !== "node_modules"){
                    r.push(s);
                    t = yield* a(_path().join(s, i));
                    const e1 = _path().dirname(s);
                    if (s === e1) {
                        n = false;
                        break;
                    }
                    s = e1;
                }
                return {
                    filepath: e1,
                    directories: r,
                    pkg: t,
                    isPackage: n
                };
            }
            0 && 0;
        },
        266: (e2, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.loadPlugin = loadPlugin;
            t.loadPreset = loadPreset;
            t.resolvePreset = t.resolvePlugin = void 0;
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(7987);
            var s = r(7416);
            function _url() {
                const e1 = r(7310);
                _url = function() {
                    return e1;
                };
                return e1;
            }
            var i = r(2044);
            r(8188);
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            const a = _debug()("babel:config:loading:files:plugins");
            const o = /^module:/;
            const l = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
            const c = /^(?!@|module:|[^/]+\/|babel-preset-)/;
            const p = /^(@babel\/)(?!plugin-|[^/]+\/)/;
            const u = /^(@babel\/)(?!preset-|[^/]+\/)/;
            const d = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
            const f = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
            const h = /^(@(?!babel$)[^/]+)$/;
            const m = t.resolvePlugin = resolveStandardizedName.bind(null, "plugin");
            const y = t.resolvePreset = resolveStandardizedName.bind(null, "preset");
            function* loadPlugin(e1, t) {
                const { filepath: r, loader: s } = m(e1, t, (yield* (0, n.isAsync)()));
                const i = yield* requireModule("plugin", s, r);
                a("Loaded plugin %o from %o.", e1, t);
                return {
                    filepath: r,
                    value: i
                };
            }
            function* loadPreset(e1, t) {
                const { filepath: r, loader: s } = y(e1, t, (yield* (0, n.isAsync)()));
                const i = yield* requireModule("preset", s, r);
                a("Loaded preset %o from %o.", e1, t);
                return {
                    filepath: r,
                    value: i
                };
            }
            function standardizeName(e1, t) {
                if (_path().isAbsolute(t)) return t;
                const r = e1 === "preset";
                return t.replace(r ? c : l, "babel-".concat(e1, "-")).replace(r ? u : p, "$1".concat(e1, "-")).replace(r ? f : d, "$1babel-".concat(e1, "-")).replace(h, "$1/babel-".concat(e1)).replace(o, "");
            }
            function* resolveAlternativesHelper(e1, t) {
                const r = standardizeName(e1, t);
                const { error: n, value: s } = yield r;
                if (!n) return s;
                if (n.code !== "MODULE_NOT_FOUND") throw n;
                if (r !== t && !(yield t).error) {
                    n.message += '\n- If you want to resolve "'.concat(t, '", use "module:').concat(t, '"');
                }
                if (!(yield standardizeName(e1, "@babel/" + t)).error) {
                    n.message += '\n- Did you mean "@babel/'.concat(t, '"?');
                }
                const i = e1 === "preset" ? "plugin" : "preset";
                if (!(yield standardizeName(i, t)).error) {
                    n.message += "\n- Did you accidentally pass a ".concat(i, " as a ").concat(e1, "?");
                }
                if (e1 === "plugin") {
                    const e1 = r.replace("-proposal-", "-transform-");
                    if (e1 !== r && !(yield e1).error) {
                        n.message += '\n- Did you mean "'.concat(e1, '"?');
                    }
                }
                n.message += "\n\nMake sure that all the Babel plugins and presets you are using\nare defined as dependencies or devDependencies in your package.json\nfile. It's possible that the missing plugin is loaded by a preset\nyou are using that forgot to add the plugin to its dependencies: you\ncan workaround this problem by explicitly adding the missing package\nto your top-level package.json.\n";
                throw n;
            }
            function tryRequireResolve(e2, t) {
                try {
                    if (t) {
                        return {
                            error: null,
                            value: (((e1, t)=>(e1 = e1.split("."), t = t.split("."), +e1[0] > +t[0] || e1[0] == t[0] && +e1[1] >= +t[1]))(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node, "8.9") ? /*TURBOPACK member replacement*/ __turbopack_context__.t.resolve : function(e1, param) {
                                let { paths: [t] } = param, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r(8188);
                                let s = n._findPath(e1, n._nodeModulePaths(t).concat(t));
                                if (s) return s;
                                s = new Error("Cannot resolve module '".concat(e1, "'"));
                                s.code = "MODULE_NOT_FOUND";
                                throw s;
                            })(e2, {
                                paths: [
                                    t
                                ]
                            })
                        };
                    } else {
                        return {
                            error: null,
                            value: (()=>{
                                const e1 = new Error("Cannot find module as expression is too dynamic");
                                e1.code = 'MODULE_NOT_FOUND';
                                throw e1;
                            })()
                        };
                    }
                } catch (e1) {
                    return {
                        error: e1,
                        value: null
                    };
                }
            }
            function tryImportMetaResolve(e1, t) {
                try {
                    return {
                        error: null,
                        value: (0, i.resolve)(e1, t)
                    };
                } catch (e1) {
                    return {
                        error: e1,
                        value: null
                    };
                }
            }
            function resolveStandardizedNameForRequire(e1, t, r) {
                const n = resolveAlternativesHelper(e1, t);
                let s = n.next();
                while(!s.done){
                    s = n.next(tryRequireResolve(s.value, r));
                }
                return {
                    loader: "require",
                    filepath: s.value
                };
            }
            function resolveStandardizedNameForImport(e1, t, r) {
                const n = (0, _url().pathToFileURL)(_path().join(r, "./babel-virtual-resolve-base.js")).href;
                const s = resolveAlternativesHelper(e1, t);
                let i = s.next();
                while(!i.done){
                    i = s.next(tryImportMetaResolve(i.value, n));
                }
                return {
                    loader: "auto",
                    filepath: (0, _url().fileURLToPath)(i.value)
                };
            }
            function resolveStandardizedName(e1, t, r, n) {
                if (!s.supportsESM || !n) {
                    return resolveStandardizedNameForRequire(e1, t, r);
                }
                try {
                    const n = resolveStandardizedNameForImport(e1, t, r);
                    if (!(0, _fs().existsSync)(n.filepath)) {
                        throw Object.assign(new Error('Could not resolve "'.concat(t, '" in file ').concat(r, ".")), {
                            type: "MODULE_NOT_FOUND"
                        });
                    }
                    return n;
                } catch (n) {
                    try {
                        return resolveStandardizedNameForRequire(e1, t, r);
                    } catch (e1) {
                        if (n.type === "MODULE_NOT_FOUND") throw n;
                        if (e1.type === "MODULE_NOT_FOUND") throw e1;
                        throw n;
                    }
                }
            }
            {
                var g = new Set;
            }
            function* requireModule(e1, t, r) {
                {
                    if (!(yield* (0, n.isAsync)()) && g.has(r)) {
                        throw new Error("Reentrant ".concat(e1, ' detected trying to load "').concat(r, '". This module is not ignored ') + "and is trying to load itself while compiling itself, leading to a dependency cycle. " + 'We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.');
                    }
                }
                try {
                    {
                        g.add(r);
                    }
                    {
                        return yield* (0, s.default)(r, t, "You appear to be using a native ECMAScript module ".concat(e1, ", ") + "which is only supported when running Babel asynchronously " + "or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a ".concat(e1, " that contains top-level await, ") + "which is only supported when running Babel asynchronously.", true);
                    }
                } catch (e1) {
                    e1.message = "[BABEL]: ".concat(e1.message, " (While processing: ").concat(r, ")");
                    throw e1;
                } finally{
                    {
                        g.delete(r);
                    }
                }
            }
            0 && 0;
        },
        4207: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.makeStaticFileCache = makeStaticFileCache;
            var n = r(5732);
            var s = r(409);
            function _fs2() {
                const e1 = r(7147);
                _fs2 = function() {
                    return e1;
                };
                return e1;
            }
            function makeStaticFileCache(e1) {
                return (0, n.makeStrongCache)(function*(t, r) {
                    const n = r.invalidate(()=>fileMtime(t));
                    if (n === null) {
                        return null;
                    }
                    return e1(t, (yield* s.readFile(t, "utf8")));
                });
            }
            function fileMtime(e1) {
                if (!_fs2().existsSync(e1)) return null;
                try {
                    return +_fs2().statSync(e1).mtime;
                } catch (e1) {
                    if (e1.code !== "ENOENT" && e1.code !== "ENOTDIR") throw e1;
                }
                return null;
            }
            0 && 0;
        },
        1660: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(7987);
            var s = r(545);
            var i = r(2358);
            var a = r(2406);
            var o = r(8131);
            var l = r(9646);
            var c = r(8634);
            function _traverse() {
                const e1 = r(8026);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            var p = r(5732);
            var u = r(4320);
            var d = r(2088);
            var f = r(3165);
            var h = r(3019);
            var m = r(195);
            var y = t["default"] = _gensync()(function* loadFullConfig(e1) {
                var t;
                const r = yield* (0, h.default)(e1);
                if (!r) {
                    return null;
                }
                const { options: n, context: i, fileHandling: a } = r;
                if (a === "ignored") {
                    return null;
                }
                const l = {};
                const { plugins: p, presets: d } = n;
                if (!p || !d) {
                    throw new Error("Assertion failure - plugins and presets exist");
                }
                const f = Object.assign({}, i, {
                    targets: n.targets
                });
                const toDescriptor = (e1)=>{
                    const t = (0, o.getItemDescriptor)(e1);
                    if (!t) {
                        throw new Error("Assertion failure - must be config item");
                    }
                    return t;
                };
                const m = d.map(toDescriptor);
                const y = p.map(toDescriptor);
                const g = [
                    []
                ];
                const b = [];
                const T = [];
                const S = yield* enhanceError(i, function* recursePresetDescriptors(e1, t) {
                    const r = [];
                    for(let s = 0; s < e1.length; s++){
                        const i = e1[s];
                        if (i.options !== false) {
                            try {
                                var n = yield* loadPresetDescriptor(i, f);
                            } catch (t) {
                                if (t.code === "BABEL_UNKNOWN_OPTION") {
                                    (0, u.checkNoUnwrappedItemOptionPairs)(e1, s, "preset", t);
                                }
                                throw t;
                            }
                            T.push(n.externalDependencies);
                            if (i.ownPass) {
                                r.push({
                                    preset: n.chain,
                                    pass: []
                                });
                            } else {
                                r.unshift({
                                    preset: n.chain,
                                    pass: t
                                });
                            }
                        }
                    }
                    if (r.length > 0) {
                        g.splice(1, 0, ...r.map((e1)=>e1.pass).filter((e1)=>e1 !== t));
                        for (const { preset: e1, pass: t } of r){
                            if (!e1) return true;
                            t.push(...e1.plugins);
                            const r = yield* recursePresetDescriptors(e1.presets, t);
                            if (r) return true;
                            e1.options.forEach((e1)=>{
                                (0, s.mergeOptions)(l, e1);
                            });
                        }
                    }
                })(m, g[0]);
                if (S) return null;
                const x = l;
                (0, s.mergeOptions)(x, n);
                const E = Object.assign({}, f, {
                    assumptions: (t = x.assumptions) != null ? t : {}
                });
                yield* enhanceError(i, function* loadPluginDescriptors() {
                    g[0].unshift(...y);
                    for (const t of g){
                        const r = [];
                        b.push(r);
                        for(let n = 0; n < t.length; n++){
                            const s = t[n];
                            if (s.options !== false) {
                                try {
                                    var e1 = yield* loadPluginDescriptor(s, E);
                                } catch (e1) {
                                    if (e1.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                                        (0, u.checkNoUnwrappedItemOptionPairs)(t, n, "plugin", e1);
                                    }
                                    throw e1;
                                }
                                r.push(e1);
                                T.push(e1.externalDependencies);
                            }
                        }
                    }
                })();
                x.plugins = b[0];
                x.presets = b.slice(1).filter((e1)=>e1.length > 0).map((e1)=>({
                        plugins: e1
                    }));
                x.passPerPreset = x.presets.length > 0;
                return {
                    options: x,
                    passes: b,
                    externalDependencies: (0, c.finalize)(T)
                };
            });
            function enhanceError(e1, t) {
                return function*(r, n) {
                    try {
                        return yield* t(r, n);
                    } catch (t) {
                        if (!/^\[BABEL\]/.test(t.message)) {
                            var s;
                            t.message = "[BABEL] ".concat((s = e1.filename) != null ? s : "unknown file", ": ").concat(t.message);
                        }
                        throw t;
                    }
                };
            }
            const makeDescriptorLoader = (e1)=>(0, p.makeWeakCache)(function*(param, o) {
                    let { value: t, options: r, dirname: s, alias: a } = param;
                    if (r === false) throw new Error("Assertion failure");
                    r = r || {};
                    const l = [];
                    let p = t;
                    if (typeof t === "function") {
                        const c = (0, n.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
                        const u = Object.assign({}, i, e1(o, l));
                        try {
                            p = yield* c(u, r, s);
                        } catch (e1) {
                            if (a) {
                                e1.message += " (While processing: ".concat(JSON.stringify(a), ")");
                            }
                            throw e1;
                        }
                    }
                    if (!p || typeof p !== "object") {
                        throw new Error("Plugin/Preset did not return an object.");
                    }
                    if ((0, n.isThenable)(p)) {
                        yield* [];
                        throw new Error("You appear to be using a promise as a plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version. " + 'As an alternative, you can prefix the promise with "await". ' + "(While processing: ".concat(JSON.stringify(a), ")"));
                    }
                    if (l.length > 0 && (!o.configured() || o.mode() === "forever")) {
                        let e1 = "A plugin/preset has external untracked dependencies " + "(".concat(l[0], "), but the cache ");
                        if (!o.configured()) {
                            e1 += "has not been configured to be invalidated when the external dependencies change. ";
                        } else {
                            e1 += " has been configured to never be invalidated. ";
                        }
                        e1 += "Plugins/presets should configure their cache to be invalidated when the external " + "dependencies change, for example using `api.cache.invalidate(() => " + "statSync(filepath).mtimeMs)` or `api.cache.never()`\n" + "(While processing: ".concat(JSON.stringify(a), ")");
                        throw new Error(e1);
                    }
                    return {
                        value: p,
                        options: r,
                        dirname: s,
                        alias: a,
                        externalDependencies: (0, c.finalize)(l)
                    };
                });
            const g = makeDescriptorLoader(f.makePluginAPI);
            const b = makeDescriptorLoader(f.makePresetAPI);
            const T = (0, p.makeWeakCache)(function*(param, o) {
                let { value: e1, options: t, dirname: r, alias: s, externalDependencies: i } = param;
                const l = (0, d.validatePluginObject)(e1);
                const p = Object.assign({}, l);
                if (p.visitor) {
                    p.visitor = _traverse().default.explode(Object.assign({}, p.visitor));
                }
                if (p.inherits) {
                    const e1 = {
                        name: undefined,
                        alias: "".concat(s, "$inherits"),
                        value: p.inherits,
                        options: t,
                        dirname: r
                    };
                    const a = yield* (0, n.forwardAsync)(loadPluginDescriptor, (t)=>o.invalidate((r)=>t(e1, r)));
                    p.pre = chainMaybeAsync(a.pre, p.pre);
                    p.post = chainMaybeAsync(a.post, p.post);
                    p.manipulateOptions = chainMaybeAsync(a.manipulateOptions, p.manipulateOptions);
                    p.visitor = _traverse().default.visitors.merge([
                        a.visitor || {},
                        p.visitor || {}
                    ]);
                    if (a.externalDependencies.length > 0) {
                        if (i.length === 0) {
                            i = a.externalDependencies;
                        } else {
                            i = (0, c.finalize)([
                                i,
                                a.externalDependencies
                            ]);
                        }
                    }
                }
                return new a.default(p, t, s, i);
            });
            function* loadPluginDescriptor(e1, t) {
                if (e1.value instanceof a.default) {
                    if (e1.options) {
                        throw new Error("Passed options to an existing Plugin instance will not work.");
                    }
                    return e1.value;
                }
                return yield* T((yield* g(e1, t)), t);
            }
            const needsFilename = (e1)=>e1 && typeof e1 !== "function";
            const validateIfOptionNeedsFilename = (e1, t)=>{
                if (needsFilename(e1.test) || needsFilename(e1.include) || needsFilename(e1.exclude)) {
                    const e1 = t.name ? '"'.concat(t.name, '"') : "/* your preset */";
                    throw new m.default([
                        "Preset ".concat(e1, " requires a filename to be set when babel is called directly,"),
                        "```",
                        "babel.transformSync(code, { filename: 'file.ts', presets: [".concat(e1, "] });"),
                        "```",
                        "See https://babeljs.io/docs/en/options#filename for more information."
                    ].join("\n"));
                }
            };
            const validatePreset = (e1, t, r)=>{
                if (!t.filename) {
                    var n;
                    const { options: t } = e1;
                    validateIfOptionNeedsFilename(t, r);
                    (n = t.overrides) == null || n.forEach((e1)=>validateIfOptionNeedsFilename(e1, r));
                }
            };
            const S = (0, p.makeWeakCacheSync)((param)=>{
                let { value: e1, dirname: t, alias: r, externalDependencies: n } = param;
                return {
                    options: (0, u.validate)("preset", e1),
                    alias: r,
                    dirname: t,
                    externalDependencies: n
                };
            });
            function* loadPresetDescriptor(e1, t) {
                const r = S((yield* b(e1, t)));
                validatePreset(r, t, e1);
                return {
                    chain: yield* (0, l.buildPresetChain)(r, t),
                    externalDependencies: r.externalDependencies
                };
            }
            function chainMaybeAsync(e1, t) {
                if (!e1) return t;
                if (!t) return e1;
                return function() {
                    for(var _len = arguments.length, r = new Array(_len), _key = 0; _key < _len; _key++){
                        r[_key] = arguments[_key];
                    }
                    const n = e1.apply(this, r);
                    if (n && typeof n.then === "function") {
                        return n.then(()=>t.apply(this, r));
                    }
                    return t.apply(this, r);
                };
            }
            0 && 0;
        },
        3165: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.makeConfigAPI = makeConfigAPI;
            t.makePluginAPI = makePluginAPI;
            t.makePresetAPI = makePresetAPI;
            function _semver() {
                const e1 = r(7849);
                _semver = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2358);
            var s = r(5732);
            function makeConfigAPI(e1) {
                const env = (t)=>e1.using((e1)=>{
                        if (t === undefined) return e1.envName;
                        if (typeof t === "function") {
                            return (0, s.assertSimpleType)(t(e1.envName));
                        }
                        return (Array.isArray(t) ? t : [
                            t
                        ]).some((t)=>{
                            if (typeof t !== "string") {
                                throw new Error("Unexpected non-string value");
                            }
                            return t === e1.envName;
                        });
                    });
                const caller = (t)=>e1.using((e1)=>(0, s.assertSimpleType)(t(e1.caller)));
                return {
                    version: n.version,
                    cache: e1.simple(),
                    env: env,
                    async: ()=>false,
                    caller: caller,
                    assertVersion: assertVersion
                };
            }
            function makePresetAPI(e1, t) {
                const targets = ()=>JSON.parse(e1.using((e1)=>JSON.stringify(e1.targets)));
                const addExternalDependency = (e1)=>{
                    t.push(e1);
                };
                return Object.assign({}, makeConfigAPI(e1), {
                    targets: targets,
                    addExternalDependency: addExternalDependency
                });
            }
            function makePluginAPI(e1, t) {
                const assumption = (t)=>e1.using((e1)=>e1.assumptions[t]);
                return Object.assign({}, makePresetAPI(e1, t), {
                    assumption: assumption
                });
            }
            function assertVersion(e1) {
                if (typeof e1 === "number") {
                    if (!Number.isInteger(e1)) {
                        throw new Error("Expected string or integer value.");
                    }
                    e1 = "^".concat(e1, ".0.0-0");
                }
                if (typeof e1 !== "string") {
                    throw new Error("Expected string or integer value.");
                }
                if (e1 === "*" || _semver().satisfies(n.version, e1)) return;
                const t = Error.stackTraceLimit;
                if (typeof t === "number" && t < 25) {
                    Error.stackTraceLimit = 25;
                }
                const r = new Error('Requires Babel "'.concat(e1, '", but was loaded with "').concat(n.version, '". ') + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + 'the first entry that doesn\'t mention "@babel/core" or "babel-core" ' + "to see what is calling Babel.");
                if (typeof t === "number") {
                    Error.stackTraceLimit = t;
                }
                throw Object.assign(r, {
                    code: "BABEL_VERSION_UNSUPPORTED",
                    version: n.version,
                    range: e1
                });
            }
            0 && 0;
        },
        8634: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.finalize = finalize;
            t.flattenToSet = flattenToSet;
            function finalize(e1) {
                return Object.freeze(e1);
            }
            function flattenToSet(e1) {
                const t = new Set;
                const r = [
                    e1
                ];
                while(r.length > 0){
                    for (const e1 of r.pop()){
                        if (Array.isArray(e1)) r.push(e1);
                        else t.add(e1);
                    }
                }
                return t;
            }
            0 && 0;
        },
        5723: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getEnv = getEnv;
            function getEnv() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "development";
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_ENV || ("TURBOPACK compile-time value", "development") || e1;
            }
            0 && 0;
        },
        8842: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createConfigItem = createConfigItem;
            t.createConfigItemAsync = createConfigItemAsync;
            t.createConfigItemSync = createConfigItemSync;
            Object.defineProperty(t, "default", {
                enumerable: true,
                get: function() {
                    return n.default;
                }
            });
            t.loadOptions = loadOptions;
            t.loadOptionsAsync = loadOptionsAsync;
            t.loadOptionsSync = loadOptionsSync;
            t.loadPartialConfig = loadPartialConfig;
            t.loadPartialConfigAsync = loadPartialConfigAsync;
            t.loadPartialConfigSync = loadPartialConfigSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(1660);
            var s = r(3019);
            var i = r(8131);
            var a = r(8502);
            const o = _gensync()(s.loadPartialConfig);
            function loadPartialConfigAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(o.async)(...e1);
            }
            function loadPartialConfigSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(o.sync)(...e1);
            }
            function loadPartialConfig(e1, t) {
                if (t !== undefined) {
                    (0, a.beginHiddenCallStack)(o.errback)(e1, t);
                } else if (typeof e1 === "function") {
                    (0, a.beginHiddenCallStack)(o.errback)(undefined, e1);
                } else {
                    {
                        return loadPartialConfigSync(e1);
                    }
                }
            }
            function* loadOptionsImpl(e1) {
                var t;
                const r = yield* (0, n.default)(e1);
                return (t = r == null ? void 0 : r.options) != null ? t : null;
            }
            const l = _gensync()(loadOptionsImpl);
            function loadOptionsAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(l.async)(...e1);
            }
            function loadOptionsSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(l.sync)(...e1);
            }
            function loadOptions(e1, t) {
                if (t !== undefined) {
                    (0, a.beginHiddenCallStack)(l.errback)(e1, t);
                } else if (typeof e1 === "function") {
                    (0, a.beginHiddenCallStack)(l.errback)(undefined, e1);
                } else {
                    {
                        return loadOptionsSync(e1);
                    }
                }
            }
            const c = _gensync()(i.createConfigItem);
            function createConfigItemAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(c.async)(...e1);
            }
            function createConfigItemSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(c.sync)(...e1);
            }
            function createConfigItem(e1, t, r) {
                if (r !== undefined) {
                    (0, a.beginHiddenCallStack)(c.errback)(e1, t, r);
                } else if (typeof t === "function") {
                    (0, a.beginHiddenCallStack)(c.errback)(e1, undefined, r);
                } else {
                    {
                        return createConfigItemSync(e1, t);
                    }
                }
            }
            0 && 0;
        },
        8131: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createConfigItem = createConfigItem;
            t.createItemFromDescriptor = createItemFromDescriptor;
            t.getItemDescriptor = getItemDescriptor;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4449);
            function createItemFromDescriptor(e1) {
                return new ConfigItem(e1);
            }
            function* createConfigItem(e1) {
                let { dirname: t = ".", type: r } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const s = yield* (0, n.createDescriptor)(e1, _path().resolve(t), {
                    type: r,
                    alias: "programmatic item"
                });
                return createItemFromDescriptor(s);
            }
            const s = Symbol.for("@babel/core@7 - ConfigItem");
            function getItemDescriptor(e1) {
                if (e1 != null && e1[s]) {
                    return e1._descriptor;
                }
                return undefined;
            }
            class ConfigItem {
                constructor(e1){
                    this._descriptor = void 0;
                    this[s] = true;
                    this.value = void 0;
                    this.options = void 0;
                    this.dirname = void 0;
                    this.name = void 0;
                    this.file = void 0;
                    this._descriptor = e1;
                    Object.defineProperty(this, "_descriptor", {
                        enumerable: false
                    });
                    Object.defineProperty(this, s, {
                        enumerable: false
                    });
                    this.value = this._descriptor.value;
                    this.options = this._descriptor.options;
                    this.dirname = this._descriptor.dirname;
                    this.name = this._descriptor.name;
                    this.file = this._descriptor.file ? {
                        request: this._descriptor.file.request,
                        resolved: this._descriptor.file.resolved
                    } : undefined;
                    Object.freeze(this);
                }
            }
            Object.freeze(ConfigItem.prototype);
            0 && 0;
        },
        3019: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = loadPrivatePartialConfig;
            t.loadPartialConfig = loadPartialConfig;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2406);
            var s = r(545);
            var i = r(8131);
            var a = r(9646);
            var o = r(5723);
            var l = r(4320);
            var c = r(5329);
            var p = r(78);
            const u = [
                "showIgnoredFiles"
            ];
            function _objectWithoutPropertiesLoose(e1, t) {
                if (null == e1) return {};
                var r = {};
                for(var n in e1)if (({}).hasOwnProperty.call(e1, n)) {
                    if (-1 !== t.indexOf(n)) continue;
                    r[n] = e1[n];
                }
                return r;
            }
            function resolveRootMode(e1, t) {
                switch(t){
                    case "root":
                        return e1;
                    case "upward-optional":
                        {
                            const t = (0, c.findConfigUpwards)(e1);
                            return t === null ? e1 : t;
                        }
                    case "upward":
                        {
                            const t = (0, c.findConfigUpwards)(e1);
                            if (t !== null) return t;
                            throw Object.assign(new Error('Babel was run with rootMode:"upward" but a root could not ' + 'be found when searching upward from "'.concat(e1, '".\n') + "One of the following config files must be in the directory tree: " + '"'.concat(c.ROOT_CONFIG_FILENAMES.join(", "), '".')), {
                                code: "BABEL_ROOT_NOT_FOUND",
                                dirname: e1
                            });
                        }
                    default:
                        throw new Error("Assertion failure - unknown rootMode value.");
                }
            }
            function* loadPrivatePartialConfig(e1) {
                if (e1 != null && (typeof e1 !== "object" || Array.isArray(e1))) {
                    throw new Error("Babel options must be an object, null, or undefined");
                }
                const t = e1 ? (0, l.validate)("arguments", e1) : {};
                const { envName: r = (0, o.getEnv)(), cwd: n = ".", root: u = ".", rootMode: d = "root", caller: f, cloneInputAst: h = true } = t;
                const m = _path().resolve(n);
                const y = resolveRootMode(_path().resolve(m, u), d);
                const g = typeof t.filename === "string" ? _path().resolve(n, t.filename) : undefined;
                const b = yield* (0, c.resolveShowConfigPath)(m);
                const T = {
                    filename: g,
                    cwd: m,
                    root: y,
                    envName: r,
                    caller: f,
                    showConfig: b === g
                };
                const S = yield* (0, a.buildRootChain)(t, T);
                if (!S) return null;
                const x = {
                    assumptions: {}
                };
                S.options.forEach((e1)=>{
                    (0, s.mergeOptions)(x, e1);
                });
                const E = Object.assign({}, x, {
                    targets: (0, p.resolveTargets)(x, y),
                    cloneInputAst: h,
                    babelrc: false,
                    configFile: false,
                    browserslistConfigFile: false,
                    passPerPreset: false,
                    envName: T.envName,
                    cwd: T.cwd,
                    root: T.root,
                    rootMode: "root",
                    filename: typeof T.filename === "string" ? T.filename : undefined,
                    plugins: S.plugins.map((e1)=>(0, i.createItemFromDescriptor)(e1)),
                    presets: S.presets.map((e1)=>(0, i.createItemFromDescriptor)(e1))
                });
                return {
                    options: E,
                    context: T,
                    fileHandling: S.fileHandling,
                    ignore: S.ignore,
                    babelrc: S.babelrc,
                    config: S.config,
                    files: S.files
                };
            }
            function* loadPartialConfig(e1) {
                let t = false;
                if (typeof e1 === "object" && e1 !== null && !Array.isArray(e1)) {
                    var r = e1;
                    ({ showIgnoredFiles: t } = r);
                    e1 = _objectWithoutPropertiesLoose(r, u);
                    r;
                }
                const s = yield* loadPrivatePartialConfig(e1);
                if (!s) return null;
                const { options: i, babelrc: a, ignore: o, config: l, fileHandling: c, files: p } = s;
                if (c === "ignored" && !t) {
                    return null;
                }
                (i.plugins || []).forEach((e1)=>{
                    if (e1.value instanceof n.default) {
                        throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
                    }
                });
                return new PartialConfig(i, a ? a.filepath : undefined, o ? o.filepath : undefined, l ? l.filepath : undefined, c, p);
            }
            class PartialConfig {
                hasFilesystemConfig() {
                    return this.babelrc !== undefined || this.config !== undefined;
                }
                constructor(e1, t, r, n, s, i){
                    this.options = void 0;
                    this.babelrc = void 0;
                    this.babelignore = void 0;
                    this.config = void 0;
                    this.fileHandling = void 0;
                    this.files = void 0;
                    this.options = e1;
                    this.babelignore = r;
                    this.babelrc = t;
                    this.config = n;
                    this.fileHandling = s;
                    this.files = i;
                    Object.freeze(this);
                }
            }
            Object.freeze(PartialConfig.prototype);
            0 && 0;
        },
        5076: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = pathToPattern;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            const n = "\\".concat(_path().sep);
            const s = "(?:".concat(n, "|$)");
            const i = "[^".concat(n, "]+");
            const a = "(?:".concat(i).concat(n, ")");
            const o = "(?:".concat(i).concat(s, ")");
            const l = "".concat(a, "*?");
            const c = "".concat(a, "*?").concat(o, "?");
            function escapeRegExp(e1) {
                return e1.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
            }
            function pathToPattern(e1, t) {
                const r = _path().resolve(t, e1).split(_path().sep);
                return new RegExp([
                    "^",
                    ...r.map((e1, t)=>{
                        const p = t === r.length - 1;
                        if (e1 === "**") return p ? c : l;
                        if (e1 === "*") return p ? o : a;
                        if (e1.indexOf("*.") === 0) {
                            return i + escapeRegExp(e1.slice(1)) + (p ? s : n);
                        }
                        return escapeRegExp(e1) + (p ? s : n);
                    })
                ].join(""));
            }
            0 && 0;
        },
        2406: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(8634);
            class Plugin {
                constructor(e1, t, r, s = (0, n.finalize)([])){
                    this.key = void 0;
                    this.manipulateOptions = void 0;
                    this.post = void 0;
                    this.pre = void 0;
                    this.visitor = void 0;
                    this.parserOverride = void 0;
                    this.generatorOverride = void 0;
                    this.options = void 0;
                    this.externalDependencies = void 0;
                    this.key = e1.name || r;
                    this.manipulateOptions = e1.manipulateOptions;
                    this.post = e1.post;
                    this.pre = e1.pre;
                    this.visitor = e1.visitor || {};
                    this.parserOverride = e1.parserOverride;
                    this.generatorOverride = e1.generatorOverride;
                    this.options = t;
                    this.externalDependencies = s;
                }
            }
            t["default"] = Plugin;
            0 && 0;
        },
        669: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ConfigPrinter = t.ChainFormatter = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            const n = t.ChainFormatter = {
                Programmatic: 0,
                Config: 1
            };
            const s = {
                title (e1, t, r) {
                    let s = "";
                    if (e1 === n.Programmatic) {
                        s = "programmatic options";
                        if (t) {
                            s += " from " + t;
                        }
                    } else {
                        s = "config " + r;
                    }
                    return s;
                },
                loc (e1, t) {
                    let r = "";
                    if (e1 != null) {
                        r += ".overrides[".concat(e1, "]");
                    }
                    if (t != null) {
                        r += '.env["'.concat(t, '"]');
                    }
                    return r;
                },
                *optionsAndDescriptors (e1) {
                    const t = Object.assign({}, e1.options);
                    delete t.overrides;
                    delete t.env;
                    const r = [
                        ...yield* e1.plugins()
                    ];
                    if (r.length) {
                        t.plugins = r.map((e1)=>descriptorToConfig(e1));
                    }
                    const n = [
                        ...yield* e1.presets()
                    ];
                    if (n.length) {
                        t.presets = [
                            ...n
                        ].map((e1)=>descriptorToConfig(e1));
                    }
                    return JSON.stringify(t, undefined, 2);
                }
            };
            function descriptorToConfig(e1) {
                var t;
                let r = (t = e1.file) == null ? void 0 : t.request;
                if (r == null) {
                    if (typeof e1.value === "object") {
                        r = e1.value;
                    } else if (typeof e1.value === "function") {
                        r = "[Function: ".concat(e1.value.toString().slice(0, 50), " ... ]");
                    }
                }
                if (r == null) {
                    r = "[Unknown]";
                }
                if (e1.options === undefined) {
                    return r;
                } else if (e1.name == null) {
                    return [
                        r,
                        e1.options
                    ];
                } else {
                    return [
                        r,
                        e1.options,
                        e1.name
                    ];
                }
            }
            class ConfigPrinter {
                configure(e1, t, param) {
                    let { callerName: r, filepath: n } = param;
                    if (!e1) return ()=>{};
                    return (e1, s, i)=>{
                        this._stack.push({
                            type: t,
                            callerName: r,
                            filepath: n,
                            content: e1,
                            index: s,
                            envName: i
                        });
                    };
                }
                static *format(e1) {
                    let t = s.title(e1.type, e1.callerName, e1.filepath);
                    const r = s.loc(e1.index, e1.envName);
                    if (r) t += " ".concat(r);
                    const n = yield* s.optionsAndDescriptors(e1.content);
                    return "".concat(t, "\n").concat(n);
                }
                *output() {
                    if (this._stack.length === 0) return "";
                    const e1 = yield* _gensync().all(this._stack.map((e1)=>ConfigPrinter.format(e1)));
                    return e1.join("\n\n");
                }
                constructor(){
                    this._stack = [];
                }
            }
            t.ConfigPrinter = ConfigPrinter;
            0 && 0;
        },
        78: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;
            t.resolveTargets = resolveTargets;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _helperCompilationTargets() {
                const e1 = r(3924);
                _helperCompilationTargets = function() {
                    return e1;
                };
                return e1;
            }
            ({});
            function resolveBrowserslistConfigFile(e1, t) {
                return _path().resolve(t, e1);
            }
            function resolveTargets(e1, t) {
                const r = e1.targets;
                let n;
                if (typeof r === "string" || Array.isArray(r)) {
                    n = {
                        browsers: r
                    };
                } else if (r) {
                    if ("esmodules" in r) {
                        n = Object.assign({}, r, {
                            esmodules: "intersect"
                        });
                    } else {
                        n = r;
                    }
                }
                const { browserslistConfigFile: s } = e1;
                let i;
                let a = false;
                if (typeof s === "string") {
                    i = s;
                } else {
                    a = s === false;
                }
                return (0, _helperCompilationTargets().default)(n, {
                    ignoreBrowserslistConfig: a,
                    configFile: i,
                    configPath: t,
                    browserslistEnv: e1.browserslistEnv
                });
            }
            0 && 0;
        },
        545: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isIterableIterator = isIterableIterator;
            t.mergeOptions = mergeOptions;
            function mergeOptions(e1, t) {
                for (const r of Object.keys(t)){
                    if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
                        const n = t[r];
                        const s = e1[r] || (e1[r] = {});
                        mergeDefaultFields(s, n);
                    } else {
                        const n = t[r];
                        if (n !== undefined) e1[r] = n;
                    }
                }
            }
            function mergeDefaultFields(e1, t) {
                for (const r of Object.keys(t)){
                    const n = t[r];
                    if (n !== undefined) e1[r] = n;
                }
            }
            function isIterableIterator(e1) {
                return !!e1 && typeof e1.next === "function" && typeof e1[Symbol.iterator] === "function";
            }
            0 && 0;
        },
        4882: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.access = access;
            t.assertArray = assertArray;
            t.assertAssumptions = assertAssumptions;
            t.assertBabelrcSearch = assertBabelrcSearch;
            t.assertBoolean = assertBoolean;
            t.assertCallerMetadata = assertCallerMetadata;
            t.assertCompact = assertCompact;
            t.assertConfigApplicableTest = assertConfigApplicableTest;
            t.assertConfigFileSearch = assertConfigFileSearch;
            t.assertFunction = assertFunction;
            t.assertIgnoreList = assertIgnoreList;
            t.assertInputSourceMap = assertInputSourceMap;
            t.assertObject = assertObject;
            t.assertPluginList = assertPluginList;
            t.assertRootMode = assertRootMode;
            t.assertSourceMaps = assertSourceMaps;
            t.assertSourceType = assertSourceType;
            t.assertString = assertString;
            t.assertTargets = assertTargets;
            t.msg = msg;
            function _helperCompilationTargets() {
                const e1 = r(3924);
                _helperCompilationTargets = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4320);
            function msg(e1) {
                switch(e1.type){
                    case "root":
                        return "";
                    case "env":
                        return "".concat(msg(e1.parent), '.env["').concat(e1.name, '"]');
                    case "overrides":
                        return "".concat(msg(e1.parent), ".overrides[").concat(e1.index, "]");
                    case "option":
                        return "".concat(msg(e1.parent), ".").concat(e1.name);
                    case "access":
                        return "".concat(msg(e1.parent), "[").concat(JSON.stringify(e1.name), "]");
                    default:
                        throw new Error("Assertion failure: Unknown type ".concat(e1.type));
                }
            }
            function access(e1, t) {
                return {
                    type: "access",
                    name: t,
                    parent: e1
                };
            }
            function assertRootMode(e1, t) {
                if (t !== undefined && t !== "root" && t !== "upward" && t !== "upward-optional") {
                    throw new Error("".concat(msg(e1), ' must be a "root", "upward", "upward-optional" or undefined'));
                }
                return t;
            }
            function assertSourceMaps(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && t !== "inline" && t !== "both") {
                    throw new Error("".concat(msg(e1), ' must be a boolean, "inline", "both", or undefined'));
                }
                return t;
            }
            function assertCompact(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && t !== "auto") {
                    throw new Error("".concat(msg(e1), ' must be a boolean, "auto", or undefined'));
                }
                return t;
            }
            function assertSourceType(e1, t) {
                if (t !== undefined && t !== "module" && t !== "script" && t !== "unambiguous") {
                    throw new Error("".concat(msg(e1), ' must be "module", "script", "unambiguous", or undefined'));
                }
                return t;
            }
            function assertCallerMetadata(e1, t) {
                const r = assertObject(e1, t);
                if (r) {
                    if (typeof r.name !== "string") {
                        throw new Error("".concat(msg(e1), ' set but does not contain "name" property string'));
                    }
                    for (const t of Object.keys(r)){
                        const n = access(e1, t);
                        const s = r[t];
                        if (s != null && typeof s !== "boolean" && typeof s !== "string" && typeof s !== "number") {
                            throw new Error("".concat(msg(n), " must be null, undefined, a boolean, a string, or a number."));
                        }
                    }
                }
                return t;
            }
            function assertInputSourceMap(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && (typeof t !== "object" || !t)) {
                    throw new Error("".concat(msg(e1), " must be a boolean, object, or undefined"));
                }
                return t;
            }
            function assertString(e1, t) {
                if (t !== undefined && typeof t !== "string") {
                    throw new Error("".concat(msg(e1), " must be a string, or undefined"));
                }
                return t;
            }
            function assertFunction(e1, t) {
                if (t !== undefined && typeof t !== "function") {
                    throw new Error("".concat(msg(e1), " must be a function, or undefined"));
                }
                return t;
            }
            function assertBoolean(e1, t) {
                if (t !== undefined && typeof t !== "boolean") {
                    throw new Error("".concat(msg(e1), " must be a boolean, or undefined"));
                }
                return t;
            }
            function assertObject(e1, t) {
                if (t !== undefined && (typeof t !== "object" || Array.isArray(t) || !t)) {
                    throw new Error("".concat(msg(e1), " must be an object, or undefined"));
                }
                return t;
            }
            function assertArray(e1, t) {
                if (t != null && !Array.isArray(t)) {
                    throw new Error("".concat(msg(e1), " must be an array, or undefined"));
                }
                return t;
            }
            function assertIgnoreList(e1, t) {
                const r = assertArray(e1, t);
                r == null || r.forEach((t, r)=>assertIgnoreItem(access(e1, r), t));
                return r;
            }
            function assertIgnoreItem(e1, t) {
                if (typeof t !== "string" && typeof t !== "function" && !(t instanceof RegExp)) {
                    throw new Error("".concat(msg(e1), " must be an array of string/Function/RegExp values, or undefined"));
                }
                return t;
            }
            function assertConfigApplicableTest(e1, t) {
                if (t === undefined) {
                    return t;
                }
                if (Array.isArray(t)) {
                    t.forEach((t, r)=>{
                        if (!checkValidTest(t)) {
                            throw new Error("".concat(msg(access(e1, r)), " must be a string/Function/RegExp."));
                        }
                    });
                } else if (!checkValidTest(t)) {
                    throw new Error("".concat(msg(e1), " must be a string/Function/RegExp, or an array of those"));
                }
                return t;
            }
            function checkValidTest(e1) {
                return typeof e1 === "string" || typeof e1 === "function" || e1 instanceof RegExp;
            }
            function assertConfigFileSearch(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && typeof t !== "string") {
                    throw new Error("".concat(msg(e1), " must be a undefined, a boolean, a string, ") + "got ".concat(JSON.stringify(t)));
                }
                return t;
            }
            function assertBabelrcSearch(e1, t) {
                if (t === undefined || typeof t === "boolean") {
                    return t;
                }
                if (Array.isArray(t)) {
                    t.forEach((t, r)=>{
                        if (!checkValidTest(t)) {
                            throw new Error("".concat(msg(access(e1, r)), " must be a string/Function/RegExp."));
                        }
                    });
                } else if (!checkValidTest(t)) {
                    throw new Error("".concat(msg(e1), " must be a undefined, a boolean, a string/Function/RegExp ") + "or an array of those, got ".concat(JSON.stringify(t)));
                }
                return t;
            }
            function assertPluginList(e1, t) {
                const r = assertArray(e1, t);
                if (r) {
                    r.forEach((t, r)=>assertPluginItem(access(e1, r), t));
                }
                return r;
            }
            function assertPluginItem(e1, t) {
                if (Array.isArray(t)) {
                    if (t.length === 0) {
                        throw new Error("".concat(msg(e1), " must include an object"));
                    }
                    if (t.length > 3) {
                        throw new Error("".concat(msg(e1), " may only be a two-tuple or three-tuple"));
                    }
                    assertPluginTarget(access(e1, 0), t[0]);
                    if (t.length > 1) {
                        const r = t[1];
                        if (r !== undefined && r !== false && (typeof r !== "object" || Array.isArray(r) || r === null)) {
                            throw new Error("".concat(msg(access(e1, 1)), " must be an object, false, or undefined"));
                        }
                    }
                    if (t.length === 3) {
                        const r = t[2];
                        if (r !== undefined && typeof r !== "string") {
                            throw new Error("".concat(msg(access(e1, 2)), " must be a string, or undefined"));
                        }
                    }
                } else {
                    assertPluginTarget(e1, t);
                }
                return t;
            }
            function assertPluginTarget(e1, t) {
                if ((typeof t !== "object" || !t) && typeof t !== "string" && typeof t !== "function") {
                    throw new Error("".concat(msg(e1), " must be a string, object, function"));
                }
                return t;
            }
            function assertTargets(e1, t) {
                if ((0, _helperCompilationTargets().isBrowsersQueryValid)(t)) return t;
                if (typeof t !== "object" || !t || Array.isArray(t)) {
                    throw new Error("".concat(msg(e1), " must be a string, an array of strings or an object"));
                }
                const r = access(e1, "browsers");
                const n = access(e1, "esmodules");
                assertBrowsersList(r, t.browsers);
                assertBoolean(n, t.esmodules);
                for (const r of Object.keys(t)){
                    const n = t[r];
                    const s = access(e1, r);
                    if (r === "esmodules") assertBoolean(s, n);
                    else if (r === "browsers") assertBrowsersList(s, n);
                    else if (!hasOwnProperty.call(_helperCompilationTargets().TargetNames, r)) {
                        const e1 = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
                        throw new Error("".concat(msg(s), " is not a valid target. Supported targets are ").concat(e1));
                    } else assertBrowserVersion(s, n);
                }
                return t;
            }
            function assertBrowsersList(e1, t) {
                if (t !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(t)) {
                    throw new Error("".concat(msg(e1), " must be undefined, a string or an array of strings"));
                }
            }
            function assertBrowserVersion(e1, t) {
                if (typeof t === "number" && Math.round(t) === t) return;
                if (typeof t === "string") return;
                throw new Error("".concat(msg(e1), " must be a string or an integer number"));
            }
            function assertAssumptions(e1, t) {
                if (t === undefined) return;
                if (typeof t !== "object" || t === null) {
                    throw new Error("".concat(msg(e1), " must be an object or undefined."));
                }
                let r = e1;
                do {
                    r = r.parent;
                }while (r.type !== "root")
                const s = r.source === "preset";
                for (const r of Object.keys(t)){
                    const i = access(e1, r);
                    if (!n.assumptionsNames.has(r)) {
                        throw new Error("".concat(msg(i), " is not a supported assumption."));
                    }
                    if (typeof t[r] !== "boolean") {
                        throw new Error("".concat(msg(i), " must be a boolean."));
                    }
                    if (s && t[r] === false) {
                        throw new Error("".concat(msg(i), " cannot be set to 'false' inside presets."));
                    }
                }
                return t;
            }
            0 && 0;
        },
        4320: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assumptionsNames = void 0;
            t.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;
            t.validate = validate;
            var n = r(3789);
            var s = r(4882);
            var i = r(195);
            const a = {
                cwd: s.assertString,
                root: s.assertString,
                rootMode: s.assertRootMode,
                configFile: s.assertConfigFileSearch,
                caller: s.assertCallerMetadata,
                filename: s.assertString,
                filenameRelative: s.assertString,
                code: s.assertBoolean,
                ast: s.assertBoolean,
                cloneInputAst: s.assertBoolean,
                envName: s.assertString
            };
            const o = {
                babelrc: s.assertBoolean,
                babelrcRoots: s.assertBabelrcSearch
            };
            const l = {
                extends: s.assertString,
                ignore: s.assertIgnoreList,
                only: s.assertIgnoreList,
                targets: s.assertTargets,
                browserslistConfigFile: s.assertConfigFileSearch,
                browserslistEnv: s.assertString
            };
            const c = {
                inputSourceMap: s.assertInputSourceMap,
                presets: s.assertPluginList,
                plugins: s.assertPluginList,
                passPerPreset: s.assertBoolean,
                assumptions: s.assertAssumptions,
                env: assertEnvSet,
                overrides: assertOverridesList,
                test: s.assertConfigApplicableTest,
                include: s.assertConfigApplicableTest,
                exclude: s.assertConfigApplicableTest,
                retainLines: s.assertBoolean,
                comments: s.assertBoolean,
                shouldPrintComment: s.assertFunction,
                compact: s.assertCompact,
                minified: s.assertBoolean,
                auxiliaryCommentBefore: s.assertString,
                auxiliaryCommentAfter: s.assertString,
                sourceType: s.assertSourceType,
                wrapPluginVisitorMethod: s.assertFunction,
                highlightCode: s.assertBoolean,
                sourceMaps: s.assertSourceMaps,
                sourceMap: s.assertSourceMaps,
                sourceFileName: s.assertString,
                sourceRoot: s.assertString,
                parserOpts: s.assertObject,
                generatorOpts: s.assertObject
            };
            {
                Object.assign(c, {
                    getModuleId: s.assertFunction,
                    moduleRoot: s.assertString,
                    moduleIds: s.assertBoolean,
                    moduleId: s.assertString
                });
            }
            const p = [
                "arrayLikeIsIterable",
                "constantReexports",
                "constantSuper",
                "enumerableModuleMeta",
                "ignoreFunctionLength",
                "ignoreToPrimitiveHint",
                "iterableIsArray",
                "mutableTemplateObject",
                "noClassCalls",
                "noDocumentAll",
                "noIncompleteNsImportDetection",
                "noNewArrows",
                "noUninitializedPrivateFieldAccess",
                "objectRestNoSymbols",
                "privateFieldsAsSymbols",
                "privateFieldsAsProperties",
                "pureGetters",
                "setClassMethods",
                "setComputedProperties",
                "setPublicClassFields",
                "setSpreadProperties",
                "skipForOfIteratorClosing",
                "superIsCallableConstructor"
            ];
            const u = t.assumptionsNames = new Set(p);
            function getSource(e1) {
                return e1.type === "root" ? e1.source : getSource(e1.parent);
            }
            function validate(e1, t, r) {
                try {
                    return validateNested({
                        type: "root",
                        source: e1
                    }, t);
                } catch (e1) {
                    const t = new i.default(e1.message, r);
                    if (e1.code) t.code = e1.code;
                    throw t;
                }
            }
            function validateNested(e1, t) {
                const r = getSource(e1);
                assertNoDuplicateSourcemap(t);
                Object.keys(t).forEach((n)=>{
                    const i = {
                        type: "option",
                        name: n,
                        parent: e1
                    };
                    if (r === "preset" && l[n]) {
                        throw new Error("".concat((0, s.msg)(i), " is not allowed in preset options"));
                    }
                    if (r !== "arguments" && a[n]) {
                        throw new Error("".concat((0, s.msg)(i), " is only allowed in root programmatic options"));
                    }
                    if (r !== "arguments" && r !== "configfile" && o[n]) {
                        if (r === "babelrcfile" || r === "extendsfile") {
                            throw new Error("".concat((0, s.msg)(i), ' is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ') + "or babel.config.js/config file options");
                        }
                        throw new Error("".concat((0, s.msg)(i), " is only allowed in root programmatic options, or babel.config.js/config file options"));
                    }
                    const p = c[n] || l[n] || o[n] || a[n] || throwUnknownError;
                    p(i, t[n]);
                });
                return t;
            }
            function throwUnknownError(e1) {
                const t = e1.name;
                if (n.default[t]) {
                    const { message: r, version: i = 5 } = n.default[t];
                    throw new Error("Using removed Babel ".concat(i, " option: ").concat((0, s.msg)(e1), " - ").concat(r));
                } else {
                    const t = new Error("Unknown option: ".concat((0, s.msg)(e1), ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options."));
                    t.code = "BABEL_UNKNOWN_OPTION";
                    throw t;
                }
            }
            function assertNoDuplicateSourcemap(e1) {
                if (hasOwnProperty.call(e1, "sourceMap") && hasOwnProperty.call(e1, "sourceMaps")) {
                    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
                }
            }
            function assertEnvSet(e1, t) {
                if (e1.parent.type === "env") {
                    throw new Error("".concat((0, s.msg)(e1), " is not allowed inside of another .env block"));
                }
                const r = e1.parent;
                const n = (0, s.assertObject)(e1, t);
                if (n) {
                    for (const t of Object.keys(n)){
                        const i = (0, s.assertObject)((0, s.access)(e1, t), n[t]);
                        if (!i) continue;
                        const a = {
                            type: "env",
                            name: t,
                            parent: r
                        };
                        validateNested(a, i);
                    }
                }
                return n;
            }
            function assertOverridesList(e1, t) {
                if (e1.parent.type === "env") {
                    throw new Error("".concat((0, s.msg)(e1), " is not allowed inside an .env block"));
                }
                if (e1.parent.type === "overrides") {
                    throw new Error("".concat((0, s.msg)(e1), " is not allowed inside an .overrides block"));
                }
                const r = e1.parent;
                const n = (0, s.assertArray)(e1, t);
                if (n) {
                    for (const [t, i] of n.entries()){
                        const n = (0, s.access)(e1, t);
                        const a = (0, s.assertObject)(n, i);
                        if (!a) throw new Error("".concat((0, s.msg)(n), " must be an object"));
                        const o = {
                            type: "overrides",
                            index: t,
                            parent: r
                        };
                        validateNested(o, a);
                    }
                }
                return n;
            }
            function checkNoUnwrappedItemOptionPairs(e1, t, r, n) {
                if (t === 0) return;
                const s = e1[t - 1];
                const i = e1[t];
                if (s.file && s.options === undefined && typeof i.value === "object") {
                    n.message += "\n- Maybe you meant to use\n" + '"'.concat(r, 's": [\n  ["').concat(s.file.request, '", ').concat(JSON.stringify(i.value, undefined, 2), "]\n]\n") + "To be a valid ".concat(r, ", its name and options should be wrapped in a pair of brackets");
                }
            }
            0 && 0;
        },
        2088: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.validatePluginObject = validatePluginObject;
            var n = r(4882);
            const s = {
                name: n.assertString,
                manipulateOptions: n.assertFunction,
                pre: n.assertFunction,
                post: n.assertFunction,
                inherits: n.assertFunction,
                visitor: assertVisitorMap,
                parserOverride: n.assertFunction,
                generatorOverride: n.assertFunction
            };
            function assertVisitorMap(e1, t) {
                const r = (0, n.assertObject)(e1, t);
                if (r) {
                    Object.keys(r).forEach((e1)=>{
                        if (e1 !== "_exploded" && e1 !== "_verified") {
                            assertVisitorHandler(e1, r[e1]);
                        }
                    });
                    if (r.enter || r.exit) {
                        throw new Error("".concat((0, n.msg)(e1), ' cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.'));
                    }
                }
                return r;
            }
            function assertVisitorHandler(e1, t) {
                if (t && typeof t === "object") {
                    Object.keys(t).forEach((t)=>{
                        if (t !== "enter" && t !== "exit") {
                            throw new Error('.visitor["'.concat(e1, '"] may only have .enter and/or .exit handlers.'));
                        }
                    });
                } else if (typeof t !== "function") {
                    throw new Error('.visitor["'.concat(e1, '"] must be a function'));
                }
            }
            function validatePluginObject(e1) {
                const t = {
                    type: "root",
                    source: "plugin"
                };
                Object.keys(e1).forEach((r)=>{
                    const n = s[r];
                    if (n) {
                        const s = {
                            type: "option",
                            name: r,
                            parent: t
                        };
                        n(s, e1[r]);
                    } else {
                        const e1 = new Error(".".concat(r, " is not a valid Plugin property"));
                        e1.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
                        throw e1;
                    }
                });
                return e1;
            }
            0 && 0;
        },
        3789: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var r = t["default"] = {
                auxiliaryComment: {
                    message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
                },
                blacklist: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                breakConfig: {
                    message: "This is not a necessary option in Babel 6"
                },
                experimental: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                externalHelpers: {
                    message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
                },
                extra: {
                    message: ""
                },
                jsxPragma: {
                    message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
                },
                loose: {
                    message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
                },
                metadataUsedHelpers: {
                    message: "Not required anymore as this is enabled by default"
                },
                modules: {
                    message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
                },
                nonStandard: {
                    message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
                },
                optional: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                sourceMapName: {
                    message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
                },
                stage: {
                    message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
                },
                whitelist: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                resolveModuleSource: {
                    version: 6,
                    message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
                },
                metadata: {
                    version: 6,
                    message: "Generated plugin metadata is always included in the output result"
                },
                sourceMapTarget: {
                    version: 6,
                    message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
                }
            };
            0 && 0;
        },
        195: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(8502);
            class ConfigError extends Error {
                constructor(e1, t){
                    super(e1);
                    (0, n.expectedError)(this);
                    if (t) (0, n.injectVirtualStackFrame)(this, t);
                }
            }
            t["default"] = ConfigError;
            0 && 0;
        },
        8502: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.beginHiddenCallStack = beginHiddenCallStack;
            t.endHiddenCallStack = endHiddenCallStack;
            t.expectedError = expectedError;
            t.injectVirtualStackFrame = injectVirtualStackFrame;
            var r;
            const n = Function.call.bind(Error.prototype.toString);
            const s = !!Error.captureStackTrace && ((r = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : r.writable) === true;
            const i = "startHiding - secret - don't use this - v1";
            const a = "stopHiding - secret - don't use this - v1";
            const o = new WeakSet;
            const l = new WeakMap;
            function CallSite(e1) {
                return Object.create({
                    isNative: ()=>false,
                    isConstructor: ()=>false,
                    isToplevel: ()=>true,
                    getFileName: ()=>e1,
                    getLineNumber: ()=>undefined,
                    getColumnNumber: ()=>undefined,
                    getFunctionName: ()=>undefined,
                    getMethodName: ()=>undefined,
                    getTypeName: ()=>undefined,
                    toString: ()=>e1
                });
            }
            function injectVirtualStackFrame(e1, t) {
                if (!s) return;
                let r = l.get(e1);
                if (!r) l.set(e1, r = []);
                r.push(CallSite(t));
                return e1;
            }
            function expectedError(e1) {
                if (!s) return;
                o.add(e1);
                return e1;
            }
            function beginHiddenCallStack(e1) {
                if (!s) return e1;
                return Object.defineProperty(function() {
                    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                        t[_key] = arguments[_key];
                    }
                    setupPrepareStackTrace();
                    return e1(...t);
                }, "name", {
                    value: a
                });
            }
            function endHiddenCallStack(e1) {
                if (!s) return e1;
                return Object.defineProperty(function() {
                    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                        t[_key] = arguments[_key];
                    }
                    return e1(...t);
                }, "name", {
                    value: i
                });
            }
            function setupPrepareStackTrace() {
                setupPrepareStackTrace = ()=>{};
                const { prepareStackTrace: e1 = defaultPrepareStackTrace } = Error;
                const t = 50;
                Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t));
                Error.prepareStackTrace = function stackTraceRewriter(t, r) {
                    let n = [];
                    const s = o.has(t);
                    let c = s ? "hiding" : "unknown";
                    for(let e1 = 0; e1 < r.length; e1++){
                        const s = r[e1].getFunctionName();
                        if (s === i) {
                            c = "hiding";
                        } else if (s === a) {
                            if (c === "hiding") {
                                c = "showing";
                                if (l.has(t)) {
                                    n.unshift(...l.get(t));
                                }
                            } else if (c === "unknown") {
                                n = r;
                                break;
                            }
                        } else if (c !== "hiding") {
                            n.push(r[e1]);
                        }
                    }
                    return e1(t, n);
                };
            }
            function defaultPrepareStackTrace(e1, t) {
                if (t.length === 0) return n(e1);
                return "".concat(n(e1), "\n    at ").concat(t.join("\n    at "));
            }
            0 && 0;
        },
        7987: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.forwardAsync = forwardAsync;
            t.isAsync = void 0;
            t.isThenable = isThenable;
            t.maybeAsync = maybeAsync;
            t.waitFor = t.onFirstPause = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            function asyncGeneratorStep(e1, t, r, n, s, i, a) {
                try {
                    var o = e1[i](a), l = o.value;
                } catch (e1) {
                    return void r(e1);
                }
                o.done ? t(l) : Promise.resolve(l).then(n, s);
            }
            function _asyncToGenerator(e1) {
                return function() {
                    var t = this, r = arguments;
                    return new Promise(function(n, s) {
                        var i = e1.apply(t, r);
                        function _next(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "next", e1);
                        }
                        function _throw(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "throw", e1);
                        }
                        _next(void 0);
                    });
                };
            }
            const n = _gensync()(function*(e1) {
                return yield* e1;
            });
            const s = t.isAsync = _gensync()({
                sync: ()=>false,
                errback: (e1)=>e1(null, true)
            });
            function maybeAsync(e1, t) {
                return _gensync()({
                    sync () {
                        for(var _len = arguments.length, r = new Array(_len), _key = 0; _key < _len; _key++){
                            r[_key] = arguments[_key];
                        }
                        const n = e1.apply(this, r);
                        if (isThenable(n)) throw new Error(t);
                        return n;
                    },
                    async () {
                        for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                            t[_key] = arguments[_key];
                        }
                        return Promise.resolve(e1.apply(this, t));
                    }
                });
            }
            const i = _gensync()({
                sync: (e1)=>e1("sync"),
                async: function() {
                    var e1 = _asyncToGenerator(function*(e1) {
                        return e1("async");
                    });
                    return function async(t) {
                        return e1.apply(this, arguments);
                    };
                }()
            });
            function forwardAsync(e1, t) {
                const r = _gensync()(e1);
                return i((e1)=>{
                    const n = r[e1];
                    return t(n);
                });
            }
            const a = t.onFirstPause = _gensync()({
                name: "onFirstPause",
                arity: 2,
                sync: function(e1) {
                    return n.sync(e1);
                },
                errback: function(e1, t, r) {
                    let s = false;
                    n.errback(e1, (e1, t)=>{
                        s = true;
                        r(e1, t);
                    });
                    if (!s) {
                        t();
                    }
                }
            });
            const o = t.waitFor = _gensync()({
                sync: (e1)=>e1,
                async: function() {
                    var e1 = _asyncToGenerator(function*(e1) {
                        return e1;
                    });
                    return function async(t) {
                        return e1.apply(this, arguments);
                    };
                }()
            });
            function isThenable(e1) {
                return !!e1 && (typeof e1 === "object" || typeof e1 === "function") && !!e1.then && typeof e1.then === "function";
            }
            0 && 0;
        },
        409: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.stat = t.readFile = void 0;
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            const n = t.readFile = _gensync()({
                sync: _fs().readFileSync,
                errback: _fs().readFile
            });
            const s = t.stat = _gensync()({
                sync: _fs().statSync,
                errback: _fs().stat
            });
            0 && 0;
        },
        9516: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.once = once;
            var n = r(7987);
            function once(e1) {
                let t;
                let r;
                let s = false;
                return function*() {
                    if (!t) {
                        if (r) {
                            s = true;
                            return yield* (0, n.waitFor)(r);
                        }
                        if (!(yield* (0, n.isAsync)())) {
                            try {
                                t = {
                                    ok: true,
                                    value: yield* e1()
                                };
                            } catch (e1) {
                                t = {
                                    ok: false,
                                    value: e1
                                };
                            }
                        } else {
                            let n, i;
                            r = new Promise((e1, t)=>{
                                n = e1;
                                i = t;
                            });
                            try {
                                t = {
                                    ok: true,
                                    value: yield* e1()
                                };
                                r = null;
                                if (s) n(t.value);
                            } catch (e1) {
                                t = {
                                    ok: false,
                                    value: e1
                                };
                                r = null;
                                if (s) i(e1);
                            }
                        }
                    }
                    if (t.ok) return t.value;
                    else throw t.value;
                };
            }
            0 && 0;
        },
        2358: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DEFAULT_EXTENSIONS = void 0;
            Object.defineProperty(t, "File", {
                enumerable: true,
                get: function() {
                    return n.default;
                }
            });
            Object.defineProperty(t, "buildExternalHelpers", {
                enumerable: true,
                get: function() {
                    return s.default;
                }
            });
            Object.defineProperty(t, "createConfigItem", {
                enumerable: true,
                get: function() {
                    return o.createConfigItem;
                }
            });
            Object.defineProperty(t, "createConfigItemAsync", {
                enumerable: true,
                get: function() {
                    return o.createConfigItemAsync;
                }
            });
            Object.defineProperty(t, "createConfigItemSync", {
                enumerable: true,
                get: function() {
                    return o.createConfigItemSync;
                }
            });
            Object.defineProperty(t, "getEnv", {
                enumerable: true,
                get: function() {
                    return a.getEnv;
                }
            });
            Object.defineProperty(t, "loadOptions", {
                enumerable: true,
                get: function() {
                    return o.loadOptions;
                }
            });
            Object.defineProperty(t, "loadOptionsAsync", {
                enumerable: true,
                get: function() {
                    return o.loadOptionsAsync;
                }
            });
            Object.defineProperty(t, "loadOptionsSync", {
                enumerable: true,
                get: function() {
                    return o.loadOptionsSync;
                }
            });
            Object.defineProperty(t, "loadPartialConfig", {
                enumerable: true,
                get: function() {
                    return o.loadPartialConfig;
                }
            });
            Object.defineProperty(t, "loadPartialConfigAsync", {
                enumerable: true,
                get: function() {
                    return o.loadPartialConfigAsync;
                }
            });
            Object.defineProperty(t, "loadPartialConfigSync", {
                enumerable: true,
                get: function() {
                    return o.loadPartialConfigSync;
                }
            });
            Object.defineProperty(t, "parse", {
                enumerable: true,
                get: function() {
                    return u.parse;
                }
            });
            Object.defineProperty(t, "parseAsync", {
                enumerable: true,
                get: function() {
                    return u.parseAsync;
                }
            });
            Object.defineProperty(t, "parseSync", {
                enumerable: true,
                get: function() {
                    return u.parseSync;
                }
            });
            t.resolvePreset = t.resolvePlugin = void 0;
            Object.defineProperty((0, t), "template", {
                enumerable: true,
                get: function() {
                    return _template().default;
                }
            });
            Object.defineProperty((0, t), "tokTypes", {
                enumerable: true,
                get: function() {
                    return _parser().tokTypes;
                }
            });
            Object.defineProperty(t, "transform", {
                enumerable: true,
                get: function() {
                    return l.transform;
                }
            });
            Object.defineProperty(t, "transformAsync", {
                enumerable: true,
                get: function() {
                    return l.transformAsync;
                }
            });
            Object.defineProperty(t, "transformFile", {
                enumerable: true,
                get: function() {
                    return c.transformFile;
                }
            });
            Object.defineProperty(t, "transformFileAsync", {
                enumerable: true,
                get: function() {
                    return c.transformFileAsync;
                }
            });
            Object.defineProperty(t, "transformFileSync", {
                enumerable: true,
                get: function() {
                    return c.transformFileSync;
                }
            });
            Object.defineProperty(t, "transformFromAst", {
                enumerable: true,
                get: function() {
                    return p.transformFromAst;
                }
            });
            Object.defineProperty(t, "transformFromAstAsync", {
                enumerable: true,
                get: function() {
                    return p.transformFromAstAsync;
                }
            });
            Object.defineProperty(t, "transformFromAstSync", {
                enumerable: true,
                get: function() {
                    return p.transformFromAstSync;
                }
            });
            Object.defineProperty(t, "transformSync", {
                enumerable: true,
                get: function() {
                    return l.transformSync;
                }
            });
            Object.defineProperty((0, t), "traverse", {
                enumerable: true,
                get: function() {
                    return _traverse().default;
                }
            });
            t.version = t.types = void 0;
            var n = r(2302);
            var s = r(5085);
            var i = r(5329);
            var a = r(5723);
            function _types() {
                const e1 = r(3061);
                _types = function() {
                    return e1;
                };
                return e1;
            }
            Object.defineProperty((0, t), "types", {
                enumerable: true,
                get: function() {
                    return _types();
                }
            });
            function _parser() {
                const e1 = r(9849);
                _parser = function() {
                    return e1;
                };
                return e1;
            }
            function _traverse() {
                const e1 = r(8026);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            function _template() {
                const e1 = r(5326);
                _template = function() {
                    return e1;
                };
                return e1;
            }
            var o = r(8842);
            var l = r(2175);
            var c = r(7111);
            var p = r(4087);
            var u = r(9154);
            const d = t.version = "7.26.10";
            const resolvePlugin = (e1, t)=>i.resolvePlugin(e1, t, false).filepath;
            t.resolvePlugin = resolvePlugin;
            const resolvePreset = (e1, t)=>i.resolvePreset(e1, t, false).filepath;
            t.resolvePreset = resolvePreset;
            const f = t.DEFAULT_EXTENSIONS = Object.freeze([
                ".js",
                ".jsx",
                ".es6",
                ".es",
                ".mjs",
                ".cjs"
            ]);
            {
                t.OptionManager = class OptionManager {
                    init(e1) {
                        return (0, o.loadOptionsSync)(e1);
                    }
                };
                t.Plugin = function Plugin(e1) {
                    throw new Error("The (".concat(e1, ") Babel 5 plugin is being run with an unsupported Babel version."));
                };
            }
            0 && 0;
        },
        9154: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.parse = void 0;
            t.parseAsync = parseAsync;
            t.parseSync = parseSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(8842);
            var s = r(8015);
            var i = r(6351);
            var a = r(8502);
            const o = _gensync()(function* parse(e1, t) {
                const r = yield* (0, n.default)(t);
                if (r === null) {
                    return null;
                }
                return yield* (0, s.default)(r.passes, (0, i.default)(r), e1);
            });
            const l = t.parse = function parse(e1, t, r) {
                if (typeof t === "function") {
                    r = t;
                    t = undefined;
                }
                if (r === undefined) {
                    {
                        return (0, a.beginHiddenCallStack)(o.sync)(e1, t);
                    }
                }
                (0, a.beginHiddenCallStack)(o.errback)(e1, t, r);
            };
            function parseSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(o.sync)(...e1);
            }
            function parseAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, a.beginHiddenCallStack)(o.async)(...e1);
            }
            0 && 0;
        },
        8015: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = parser;
            function _parser() {
                const e1 = r(9849);
                _parser = function() {
                    return e1;
                };
                return e1;
            }
            function _codeFrame() {
                const e1 = r(3554);
                _codeFrame = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(6338);
            function* parser(e1, param, i) {
                let { parserOpts: t, highlightCode: r = true, filename: s = "unknown" } = param;
                try {
                    const r = [];
                    for (const n of e1){
                        for (const e1 of n){
                            const { parserOverride: n } = e1;
                            if (n) {
                                const e1 = n(i, t, _parser().parse);
                                if (e1 !== undefined) r.push(e1);
                            }
                        }
                    }
                    if (r.length === 0) {
                        return (0, _parser().parse)(i, t);
                    } else if (r.length === 1) {
                        yield* [];
                        if (typeof r[0].then === "function") {
                            throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
                        }
                        return r[0];
                    }
                    throw new Error("More than one plugin attempted to override parsing.");
                } catch (e1) {
                    if (e1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
                        e1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
                    }
                    const { loc: t, missingPlugin: a } = e1;
                    if (t) {
                        const o = (0, _codeFrame().codeFrameColumns)(i, {
                            start: {
                                line: t.line,
                                column: t.column + 1
                            }
                        }, {
                            highlightCode: r
                        });
                        if (a) {
                            e1.message = "".concat(s, ": ") + (0, n.default)(a[0], t, o, s);
                        } else {
                            e1.message = "".concat(s, ": ").concat(e1.message, "\n\n") + o;
                        }
                        e1.code = "BABEL_PARSE_ERROR";
                    }
                    throw e1;
                }
            }
            0 && 0;
        },
        6338: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = generateMissingPluginMessage;
            const r = {
                asyncDoExpressions: {
                    syntax: {
                        name: "@babel/plugin-syntax-async-do-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
                    }
                },
                decimal: {
                    syntax: {
                        name: "@babel/plugin-syntax-decimal",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
                    }
                },
                decorators: {
                    syntax: {
                        name: "@babel/plugin-syntax-decorators",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-decorators",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
                    }
                },
                doExpressions: {
                    syntax: {
                        name: "@babel/plugin-syntax-do-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-do-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
                    }
                },
                exportDefaultFrom: {
                    syntax: {
                        name: "@babel/plugin-syntax-export-default-from",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-export-default-from",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
                    }
                },
                flow: {
                    syntax: {
                        name: "@babel/plugin-syntax-flow",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
                    },
                    transform: {
                        name: "@babel/preset-flow",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
                    }
                },
                functionBind: {
                    syntax: {
                        name: "@babel/plugin-syntax-function-bind",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-function-bind",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
                    }
                },
                functionSent: {
                    syntax: {
                        name: "@babel/plugin-syntax-function-sent",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-function-sent",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
                    }
                },
                jsx: {
                    syntax: {
                        name: "@babel/plugin-syntax-jsx",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
                    },
                    transform: {
                        name: "@babel/preset-react",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
                    }
                },
                pipelineOperator: {
                    syntax: {
                        name: "@babel/plugin-syntax-pipeline-operator",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-pipeline-operator",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
                    }
                },
                recordAndTuple: {
                    syntax: {
                        name: "@babel/plugin-syntax-record-and-tuple",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
                    }
                },
                throwExpressions: {
                    syntax: {
                        name: "@babel/plugin-syntax-throw-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-throw-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
                    }
                },
                typescript: {
                    syntax: {
                        name: "@babel/plugin-syntax-typescript",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
                    },
                    transform: {
                        name: "@babel/preset-typescript",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
                    }
                }
            };
            {
                Object.assign(r, {
                    asyncGenerators: {
                        syntax: {
                            name: "@babel/plugin-syntax-async-generators",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
                        },
                        transform: {
                            name: "@babel/plugin-transform-async-generator-functions",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
                        }
                    },
                    classProperties: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
                        },
                        transform: {
                            name: "@babel/plugin-transform-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
                        }
                    },
                    classPrivateProperties: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
                        },
                        transform: {
                            name: "@babel/plugin-transform-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
                        }
                    },
                    classPrivateMethods: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
                        },
                        transform: {
                            name: "@babel/plugin-transform-private-methods",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
                        }
                    },
                    classStaticBlock: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-static-block",
                            url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
                        },
                        transform: {
                            name: "@babel/plugin-transform-class-static-block",
                            url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
                        }
                    },
                    dynamicImport: {
                        syntax: {
                            name: "@babel/plugin-syntax-dynamic-import",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
                        }
                    },
                    exportNamespaceFrom: {
                        syntax: {
                            name: "@babel/plugin-syntax-export-namespace-from",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
                        },
                        transform: {
                            name: "@babel/plugin-transform-export-namespace-from",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
                        }
                    },
                    importAssertions: {
                        syntax: {
                            name: "@babel/plugin-syntax-import-assertions",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
                        }
                    },
                    importAttributes: {
                        syntax: {
                            name: "@babel/plugin-syntax-import-attributes",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
                        }
                    },
                    importMeta: {
                        syntax: {
                            name: "@babel/plugin-syntax-import-meta",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
                        }
                    },
                    logicalAssignment: {
                        syntax: {
                            name: "@babel/plugin-syntax-logical-assignment-operators",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
                        },
                        transform: {
                            name: "@babel/plugin-transform-logical-assignment-operators",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
                        }
                    },
                    moduleStringNames: {
                        syntax: {
                            name: "@babel/plugin-syntax-module-string-names",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
                        }
                    },
                    numericSeparator: {
                        syntax: {
                            name: "@babel/plugin-syntax-numeric-separator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
                        },
                        transform: {
                            name: "@babel/plugin-transform-numeric-separator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
                        }
                    },
                    nullishCoalescingOperator: {
                        syntax: {
                            name: "@babel/plugin-syntax-nullish-coalescing-operator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
                        },
                        transform: {
                            name: "@babel/plugin-transform-nullish-coalescing-operator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
                        }
                    },
                    objectRestSpread: {
                        syntax: {
                            name: "@babel/plugin-syntax-object-rest-spread",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
                        },
                        transform: {
                            name: "@babel/plugin-transform-object-rest-spread",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
                        }
                    },
                    optionalCatchBinding: {
                        syntax: {
                            name: "@babel/plugin-syntax-optional-catch-binding",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
                        },
                        transform: {
                            name: "@babel/plugin-transform-optional-catch-binding",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
                        }
                    },
                    optionalChaining: {
                        syntax: {
                            name: "@babel/plugin-syntax-optional-chaining",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
                        },
                        transform: {
                            name: "@babel/plugin-transform-optional-chaining",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
                        }
                    },
                    privateIn: {
                        syntax: {
                            name: "@babel/plugin-syntax-private-property-in-object",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
                        },
                        transform: {
                            name: "@babel/plugin-transform-private-property-in-object",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
                        }
                    },
                    regexpUnicodeSets: {
                        syntax: {
                            name: "@babel/plugin-syntax-unicode-sets-regex",
                            url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
                        },
                        transform: {
                            name: "@babel/plugin-transform-unicode-sets-regex",
                            url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
                        }
                    }
                });
            }
            const getNameURLCombination = (param)=>{
                let { name: e1, url: t } = param;
                return "".concat(e1, " (").concat(t, ")");
            };
            function generateMissingPluginMessage(e1, t, n, s) {
                let i = "Support for the experimental syntax '".concat(e1, "' isn't currently enabled ") + "(".concat(t.line, ":").concat(t.column + 1, "):\n\n") + n;
                const a = r[e1];
                if (a) {
                    const { syntax: e1, transform: t } = a;
                    if (e1) {
                        const r = getNameURLCombination(e1);
                        if (t) {
                            const e1 = getNameURLCombination(t);
                            const n = t.name.startsWith("@babel/plugin") ? "plugins" : "presets";
                            i += "\n\nAdd ".concat(e1, " to the '").concat(n, "' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ").concat(r, " to the 'plugins' section to enable parsing.");
                        } else {
                            i += "\n\nAdd ".concat(r, " to the 'plugins' section of your Babel config ") + "to enable parsing.";
                        }
                    }
                }
                const o = s === "unknown" ? "<name of the input file>" : s;
                i += "\n\nIf you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.\nYou can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:\n	npx cross-env BABEL_SHOW_CONFIG_FOR=".concat(o, " <your build command>\nSee https://babeljs.io/docs/configuration#print-effective-configs for more info.\n");
                return i;
            }
            0 && 0;
        },
        5085: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            function helpers() {
                const e1 = r(8796);
                helpers = function() {
                    return e1;
                };
                return e1;
            }
            function _generator() {
                const e1 = r(1605);
                _generator = function() {
                    return e1;
                };
                return e1;
            }
            function _template() {
                const e1 = r(5326);
                _template = function() {
                    return e1;
                };
                return e1;
            }
            function _t() {
                const e1 = r(3061);
                _t = function() {
                    return e1;
                };
                return e1;
            }
            const { arrayExpression: n, assignmentExpression: s, binaryExpression: i, blockStatement: a, callExpression: o, cloneNode: l, conditionalExpression: c, exportNamedDeclaration: p, exportSpecifier: u, expressionStatement: d, functionExpression: f, identifier: h, memberExpression: m, objectExpression: y, program: g, stringLiteral: b, unaryExpression: T, variableDeclaration: S, variableDeclarator: x } = _t();
            const buildUmdWrapper = (e1)=>_template().default.statement(_templateObject())(e1);
            function buildGlobal(e1) {
                const t = h("babelHelpers");
                const r = [];
                const n = f(null, [
                    h("global")
                ], a(r));
                const l = g([
                    d(o(n, [
                        c(i("===", T("typeof", h("global")), b("undefined")), h("self"), h("global"))
                    ]))
                ]);
                r.push(S("var", [
                    x(t, s("=", m(h("global"), t), y([])))
                ]));
                buildHelpers(r, t, e1);
                return l;
            }
            function buildModule(e1) {
                const t = [];
                const r = buildHelpers(t, null, e1);
                t.unshift(p(null, Object.keys(r).map((e1)=>u(l(r[e1]), h(e1)))));
                return g(t, [], "module");
            }
            function buildUmd(e1) {
                const t = h("babelHelpers");
                const r = [];
                r.push(S("var", [
                    x(t, h("global"))
                ]));
                buildHelpers(r, t, e1);
                return g([
                    buildUmdWrapper({
                        FACTORY_PARAMETERS: h("global"),
                        BROWSER_ARGUMENTS: s("=", m(h("root"), t), y([])),
                        COMMON_ARGUMENTS: h("exports"),
                        AMD_ARGUMENTS: n([
                            b("exports")
                        ]),
                        FACTORY_BODY: r,
                        UMD_ROOT: h("this")
                    })
                ]);
            }
            function buildVar(e1) {
                const t = h("babelHelpers");
                const r = [];
                r.push(S("var", [
                    x(t, y([]))
                ]));
                const n = g(r);
                buildHelpers(r, t, e1);
                r.push(d(t));
                return n;
            }
            function buildHelpers(e1, t, r) {
                const getHelperReference = (e1)=>t ? m(t, h(e1)) : h("_".concat(e1));
                const n = {};
                helpers().list.forEach(function(i) {
                    if (r && !r.includes(i)) return;
                    const a = n[i] = getHelperReference(i);
                    const { nodes: o } = helpers().get(i, getHelperReference, t ? null : "_".concat(i), [], t ? (e1, t, r)=>{
                        r((e1)=>s("=", a, e1));
                        e1.body.push(d(s("=", a, h(t))));
                    } : null);
                    e1.push(...o);
                });
                return n;
            }
            function _default(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "global";
                let r;
                const n = {
                    global: buildGlobal,
                    module: buildModule,
                    umd: buildUmd,
                    var: buildVar
                }[t];
                if (n) {
                    r = n(e1);
                } else {
                    throw new Error("Unsupported output type ".concat(t));
                }
                return (0, _generator().default)(r).code;
            }
            0 && 0;
        },
        4087: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transformFromAst = void 0;
            t.transformFromAstAsync = transformFromAstAsync;
            t.transformFromAstSync = transformFromAstSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(8842);
            var s = r(1714);
            var i = r(8502);
            const a = _gensync()(function*(e1, t, r) {
                const i = yield* (0, n.default)(r);
                if (i === null) return null;
                if (!e1) throw new Error("No AST given");
                return yield* (0, s.run)(i, t, e1);
            });
            const o = t.transformFromAst = function transformFromAst(e1, t, r, n) {
                let s;
                let o;
                if (typeof r === "function") {
                    o = r;
                    s = undefined;
                } else {
                    s = r;
                    o = n;
                }
                if (o === undefined) {
                    {
                        return (0, i.beginHiddenCallStack)(a.sync)(e1, t, s);
                    }
                }
                (0, i.beginHiddenCallStack)(a.errback)(e1, t, s, o);
            };
            function transformFromAstSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, i.beginHiddenCallStack)(a.sync)(...e1);
            }
            function transformFromAstAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, i.beginHiddenCallStack)(a.async)(...e1);
            }
            0 && 0;
        },
        7111: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transformFile = transformFile;
            t.transformFileAsync = transformFileAsync;
            t.transformFileSync = transformFileSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(8842);
            var s = r(1714);
            var i = r(409);
            ({});
            const a = _gensync()(function*(e1, t) {
                const r = Object.assign({}, t, {
                    filename: e1
                });
                const a = yield* (0, n.default)(r);
                if (a === null) return null;
                const o = yield* i.readFile(e1, "utf8");
                return yield* (0, s.run)(a, o);
            });
            function transformFile() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                a.errback(...e1);
            }
            function transformFileSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return a.sync(...e1);
            }
            function transformFileAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return a.async(...e1);
            }
            0 && 0;
        },
        2175: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transform = void 0;
            t.transformAsync = transformAsync;
            t.transformSync = transformSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(8842);
            var s = r(1714);
            var i = r(8502);
            const a = _gensync()(function* transform(e1, t) {
                const r = yield* (0, n.default)(t);
                if (r === null) return null;
                return yield* (0, s.run)(r, e1);
            });
            const o = t.transform = function transform(e1, t, r) {
                let n;
                let s;
                if (typeof t === "function") {
                    s = t;
                    n = undefined;
                } else {
                    n = t;
                    s = r;
                }
                if (s === undefined) {
                    {
                        return (0, i.beginHiddenCallStack)(a.sync)(e1, n);
                    }
                }
                (0, i.beginHiddenCallStack)(a.errback)(e1, n, s);
            };
            function transformSync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, i.beginHiddenCallStack)(a.sync)(...e1);
            }
            function transformAsync() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return (0, i.beginHiddenCallStack)(a.async)(...e1);
            }
            0 && 0;
        },
        9273: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = loadBlockHoistPlugin;
            function _traverse() {
                const e1 = r(8026);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2406);
            let s;
            const i = {
                name: "internal.blockHoist",
                visitor: {
                    Block: {
                        exit (param) {
                            let { node: e1 } = param;
                            e1.body = performHoisting(e1.body);
                        }
                    },
                    SwitchCase: {
                        exit (param) {
                            let { node: e1 } = param;
                            e1.consequent = performHoisting(e1.consequent);
                        }
                    }
                }
            };
            function performHoisting(e1) {
                let t = Math.pow(2, 30) - 1;
                let r = false;
                for(let n = 0; n < e1.length; n++){
                    const s = e1[n];
                    const i = priority(s);
                    if (i > t) {
                        r = true;
                        break;
                    }
                    t = i;
                }
                if (!r) return e1;
                return stableSort(e1.slice());
            }
            function loadBlockHoistPlugin() {
                if (!s) {
                    s = new n.default(Object.assign({}, i, {
                        visitor: _traverse().default.explode(i.visitor)
                    }), {});
                }
                return s;
            }
            function priority(e1) {
                const t = e1 == null ? void 0 : e1._blockHoist;
                if (t == null) return 1;
                if (t === true) return 2;
                return t;
            }
            function stableSort(e1) {
                const t = Object.create(null);
                for(let r = 0; r < e1.length; r++){
                    const n = e1[r];
                    const s = priority(n);
                    const i = t[s] || (t[s] = []);
                    i.push(n);
                }
                const r = Object.keys(t).map((e1)=>+e1).sort((e1, t)=>t - e1);
                let n = 0;
                for (const s of r){
                    const r = t[s];
                    for (const t of r){
                        e1[n++] = t;
                    }
                }
                return e1;
            }
            0 && 0;
        },
        2302: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            function helpers() {
                const e1 = r(8796);
                helpers = function() {
                    return e1;
                };
                return e1;
            }
            function _traverse() {
                const e1 = r(8026);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            function _codeFrame() {
                const e1 = r(3554);
                _codeFrame = function() {
                    return e1;
                };
                return e1;
            }
            function _t() {
                const e1 = r(3061);
                _t = function() {
                    return e1;
                };
                return e1;
            }
            function _semver() {
                const e1 = r(7849);
                _semver = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(9938);
            const { cloneNode: s, interpreterDirective: i } = _t();
            const a = {
                enter (e1, t) {
                    const r = e1.node.loc;
                    if (r) {
                        t.loc = r;
                        e1.stop();
                    }
                }
            };
            class File {
                get shebang() {
                    const { interpreter: e1 } = this.path.node;
                    return e1 ? e1.value : "";
                }
                set shebang(e1) {
                    if (e1) {
                        this.path.get("interpreter").replaceWith(i(e1));
                    } else {
                        this.path.get("interpreter").remove();
                    }
                }
                set(e1, t) {
                    {
                        if (e1 === "helpersNamespace") {
                            throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
                        }
                    }
                    this._map.set(e1, t);
                }
                get(e1) {
                    return this._map.get(e1);
                }
                has(e1) {
                    return this._map.has(e1);
                }
                availableHelper(e1, t) {
                    let r;
                    try {
                        r = helpers().minVersion(e1);
                    } catch (e1) {
                        if (e1.code !== "BABEL_HELPER_UNKNOWN") throw e1;
                        return false;
                    }
                    if (typeof t !== "string") return true;
                    if (_semver().valid(t)) t = "^".concat(t);
                    {
                        return !_semver().intersects("<".concat(r), t) && !_semver().intersects(">=8.0.0", t);
                    }
                }
                addHelper(e1) {
                    const t = this.declarations[e1];
                    if (t) return s(t);
                    const r = this.get("helperGenerator");
                    if (r) {
                        const t = r(e1);
                        if (t) return t;
                    }
                    helpers().minVersion(e1);
                    const n = this.declarations[e1] = this.scope.generateUidIdentifier(e1);
                    const i = {};
                    for (const t of helpers().getDependencies(e1)){
                        i[t] = this.addHelper(t);
                    }
                    const { nodes: a, globals: o } = helpers().get(e1, (e1)=>i[e1], n.name, Object.keys(this.scope.getAllBindings()));
                    o.forEach((e1)=>{
                        if (this.path.scope.hasBinding(e1, true)) {
                            this.path.scope.rename(e1);
                        }
                    });
                    a.forEach((e1)=>{
                        e1._compact = true;
                    });
                    const l = this.path.unshiftContainer("body", a);
                    for (const e1 of l){
                        if (e1.isVariableDeclaration()) this.scope.registerDeclaration(e1);
                    }
                    return n;
                }
                buildCodeFrameError(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : SyntaxError;
                    let n = e1 == null ? void 0 : e1.loc;
                    if (!n && e1) {
                        const r = {
                            loc: null
                        };
                        (0, _traverse().default)(e1, a, this.scope, r);
                        n = r.loc;
                        let s = "This is an error on an internal node. Probably an internal error.";
                        if (n) s += " Location has been estimated.";
                        t += " (".concat(s, ")");
                    }
                    if (n) {
                        const { highlightCode: e1 = true } = this.opts;
                        t += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, {
                            start: {
                                line: n.start.line,
                                column: n.start.column + 1
                            },
                            end: n.end && n.start.line === n.end.line ? {
                                line: n.end.line,
                                column: n.end.column + 1
                            } : undefined
                        }, {
                            highlightCode: e1
                        });
                    }
                    return new r(t);
                }
                constructor(e1, { code: t, ast: r, inputMap: n }){
                    this._map = new Map;
                    this.opts = void 0;
                    this.declarations = {};
                    this.path = void 0;
                    this.ast = void 0;
                    this.scope = void 0;
                    this.metadata = {};
                    this.code = "";
                    this.inputMap = void 0;
                    this.hub = {
                        file: this,
                        getCode: ()=>this.code,
                        getScope: ()=>this.scope,
                        addHelper: this.addHelper.bind(this),
                        buildError: this.buildCodeFrameError.bind(this)
                    };
                    this.opts = e1;
                    this.code = t;
                    this.ast = r;
                    this.inputMap = n;
                    this.path = _traverse().NodePath.get({
                        hub: this.hub,
                        parentPath: null,
                        parent: this.ast,
                        container: this.ast,
                        key: "program"
                    }).setContext();
                    this.scope = this.path.scope;
                }
            }
            t["default"] = File;
            {
                File.prototype.addImport = function addImport() {
                    throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
                };
                File.prototype.addTemplateObject = function addTemplateObject() {
                    throw new Error("This function has been moved into the template literal transform itself.");
                };
                {
                    File.prototype.getModuleName = function getModuleName() {
                        return n.getModuleName()(this.opts, this.opts);
                    };
                }
            }
            0 && 0;
        },
        915: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = generateCode;
            function _convertSourceMap() {
                const e1 = r(133);
                _convertSourceMap = function() {
                    return e1;
                };
                return e1;
            }
            function _generator() {
                const e1 = r(1605);
                _generator = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(3464);
            function generateCode(e1, t) {
                const { opts: r, ast: s, code: i, inputMap: a } = t;
                const { generatorOpts: o } = r;
                o.inputSourceMap = a == null ? void 0 : a.toObject();
                const l = [];
                for (const t of e1){
                    for (const e1 of t){
                        const { generatorOverride: t } = e1;
                        if (t) {
                            const e1 = t(s, o, i, _generator().default);
                            if (e1 !== undefined) l.push(e1);
                        }
                    }
                }
                let c;
                if (l.length === 0) {
                    c = (0, _generator().default)(s, o, i);
                } else if (l.length === 1) {
                    c = l[0];
                    if (typeof c.then === "function") {
                        throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
                    }
                } else {
                    throw new Error("More than one plugin attempted to override codegen.");
                }
                let { code: p, decodedMap: u = c.map } = c;
                if (c.__mergedMap) {
                    u = Object.assign({}, c.map);
                } else {
                    if (u) {
                        if (a) {
                            u = (0, n.default)(a.toObject(), u, o.sourceFileName);
                        } else {
                            u = c.map;
                        }
                    }
                }
                if (r.sourceMaps === "inline" || r.sourceMaps === "both") {
                    p += "\n" + _convertSourceMap().fromObject(u).toComment();
                }
                if (r.sourceMaps === "inline") {
                    u = null;
                }
                return {
                    outputCode: p,
                    outputMap: u
                };
            }
            0 && 0;
        },
        3464: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = mergeSourceMap;
            function _remapping() {
                const e1 = r(3914);
                _remapping = function() {
                    return e1;
                };
                return e1;
            }
            function mergeSourceMap(e1, t, r) {
                const n = r.replace(/\\/g, "/");
                let s = false;
                const i = _remapping()(rootless(t), (t, r)=>{
                    if (t === n && !s) {
                        s = true;
                        r.source = "";
                        return rootless(e1);
                    }
                    return null;
                });
                if (typeof e1.sourceRoot === "string") {
                    i.sourceRoot = e1.sourceRoot;
                }
                return Object.assign({}, i);
            }
            function rootless(e1) {
                return Object.assign({}, e1, {
                    sourceRoot: null
                });
            }
            0 && 0;
        },
        1714: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.run = run;
            function _traverse() {
                const e1 = r(8026);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(3878);
            var s = r(9273);
            var i = r(6351);
            var a = r(6380);
            var o = r(915);
            var l = r(8634);
            var c = r(7987);
            function* run(e1, t, r) {
                const n = yield* (0, a.default)(e1.passes, (0, i.default)(e1), t, r);
                const s = n.opts;
                try {
                    yield* transformFile(n, e1.passes);
                } catch (e1) {
                    var c;
                    e1.message = "".concat((c = s.filename) != null ? c : "unknown file", ": ").concat(e1.message);
                    if (!e1.code) {
                        e1.code = "BABEL_TRANSFORM_ERROR";
                    }
                    throw e1;
                }
                let p, u;
                try {
                    if (s.code !== false) {
                        ({ outputCode: p, outputMap: u } = (0, o.default)(e1.passes, n));
                    }
                } catch (e1) {
                    var d;
                    e1.message = "".concat((d = s.filename) != null ? d : "unknown file", ": ").concat(e1.message);
                    if (!e1.code) {
                        e1.code = "BABEL_GENERATE_ERROR";
                    }
                    throw e1;
                }
                return {
                    metadata: n.metadata,
                    options: s,
                    ast: s.ast === true ? n.ast : null,
                    code: p === undefined ? null : p,
                    map: u === undefined ? null : u,
                    sourceType: n.ast.program.sourceType,
                    externalDependencies: (0, l.flattenToSet)(e1.externalDependencies)
                };
            }
            function* transformFile(e1, t) {
                const r = yield* (0, c.isAsync)();
                for (const i of t){
                    const t = [];
                    const a = [];
                    const o = [];
                    for (const l of i.concat([
                        (0, s.default)()
                    ])){
                        const s = new n.default(e1, l.key, l.options, r);
                        t.push([
                            l,
                            s
                        ]);
                        a.push(s);
                        o.push(l.visitor);
                    }
                    for (const [r, n] of t){
                        if (r.pre) {
                            const t = (0, c.maybeAsync)(r.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
                            yield* t.call(n, e1);
                        }
                    }
                    const l = _traverse().default.visitors.merge(o, a, e1.opts.wrapPluginVisitorMethod);
                    {
                        (0, _traverse().default)(e1.ast, l, e1.scope);
                    }
                    for (const [r, n] of t){
                        if (r.post) {
                            const t = (0, c.maybeAsync)(r.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
                            yield* t.call(n, e1);
                        }
                    }
                }
            }
            0 && 0;
        },
        6380: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = normalizeFile;
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            function _t() {
                const e1 = r(3061);
                _t = function() {
                    return e1;
                };
                return e1;
            }
            function _convertSourceMap() {
                const e1 = r(133);
                _convertSourceMap = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2302);
            var s = r(8015);
            var i = r(2983);
            const { file: a, traverseFast: o } = _t();
            const l = _debug()("babel:transform:file");
            const c = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/;
            const p = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
            function* normalizeFile(e1, t, r, o) {
                r = "".concat(r || "");
                if (o) {
                    if (o.type === "Program") {
                        o = a(o, [], []);
                    } else if (o.type !== "File") {
                        throw new Error("AST root must be a Program or File node");
                    }
                    if (t.cloneInputAst) {
                        o = (0, i.default)(o);
                    }
                } else {
                    o = yield* (0, s.default)(e1, t, r);
                }
                let u = null;
                if (t.inputSourceMap !== false) {
                    if (typeof t.inputSourceMap === "object") {
                        u = _convertSourceMap().fromObject(t.inputSourceMap);
                    }
                    if (!u) {
                        const e1 = extractComments(c, o);
                        if (e1) {
                            try {
                                u = _convertSourceMap().fromComment("//" + e1);
                            } catch (e1) {
                                {
                                    l("discarding unknown inline input sourcemap");
                                }
                            }
                        }
                    }
                    if (!u) {
                        const e1 = extractComments(p, o);
                        if (typeof t.filename === "string" && e1) {
                            try {
                                const r = p.exec(e1);
                                const n = _fs().readFileSync(_path().resolve(_path().dirname(t.filename), r[1]), "utf8");
                                u = _convertSourceMap().fromJSON(n);
                            } catch (e1) {
                                l("discarding unknown file input sourcemap", e1);
                            }
                        } else if (e1) {
                            l("discarding un-loadable file input sourcemap");
                        }
                    }
                }
                return new n.default(t, {
                    code: r,
                    ast: o,
                    inputMap: u
                });
            }
            function extractCommentsFromList(e1, t, r) {
                if (t) {
                    t = t.filter((param)=>{
                        let { value: t } = param;
                        if (e1.test(t)) {
                            r = t;
                            return false;
                        }
                        return true;
                    });
                }
                return [
                    t,
                    r
                ];
            }
            function extractComments(e1, t) {
                let r = null;
                o(t, (t)=>{
                    [t.leadingComments, r] = extractCommentsFromList(e1, t.leadingComments, r);
                    [t.innerComments, r] = extractCommentsFromList(e1, t.innerComments, r);
                    [t.trailingComments, r] = extractCommentsFromList(e1, t.trailingComments, r);
                });
                return r;
            }
            0 && 0;
        },
        6351: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = normalizeOptions;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function normalizeOptions(e1) {
                const { filename: t, cwd: r, filenameRelative: n = typeof t === "string" ? _path().relative(r, t) : "unknown", sourceType: s = "module", inputSourceMap: i, sourceMaps: a = !!i, sourceRoot: o = e1.options.moduleRoot, sourceFileName: l = _path().basename(n), comments: c = true, compact: p = "auto" } = e1.options;
                const u = e1.options;
                const d = Object.assign({}, u, {
                    parserOpts: Object.assign({
                        sourceType: _path().extname(n) === ".mjs" ? "module" : s,
                        sourceFileName: t,
                        plugins: []
                    }, u.parserOpts),
                    generatorOpts: Object.assign({
                        filename: t,
                        auxiliaryCommentBefore: u.auxiliaryCommentBefore,
                        auxiliaryCommentAfter: u.auxiliaryCommentAfter,
                        retainLines: u.retainLines,
                        comments: c,
                        shouldPrintComment: u.shouldPrintComment,
                        compact: p,
                        minified: u.minified,
                        sourceMaps: a,
                        sourceRoot: o,
                        sourceFileName: l
                    }, u.generatorOpts)
                });
                for (const t of e1.passes){
                    for (const e1 of t){
                        if (e1.manipulateOptions) {
                            e1.manipulateOptions(d, d.parserOpts);
                        }
                    }
                }
                return d;
            }
            0 && 0;
        },
        3878: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class PluginPass {
                set(e1, t) {
                    this._map.set(e1, t);
                }
                get(e1) {
                    return this._map.get(e1);
                }
                availableHelper(e1, t) {
                    return this.file.availableHelper(e1, t);
                }
                addHelper(e1) {
                    return this.file.addHelper(e1);
                }
                buildCodeFrameError(e1, t, r) {
                    return this.file.buildCodeFrameError(e1, t, r);
                }
                constructor(e1, t, r, n){
                    this._map = new Map;
                    this.key = void 0;
                    this.file = void 0;
                    this.opts = void 0;
                    this.cwd = void 0;
                    this.filename = void 0;
                    this.isAsync = void 0;
                    this.key = t;
                    this.file = e1;
                    this.opts = r || {};
                    this.cwd = e1.opts.cwd;
                    this.filename = e1.opts.filename;
                    this.isAsync = n;
                }
            }
            t["default"] = PluginPass;
            {
                PluginPass.prototype.getModuleName = function getModuleName() {
                    return this.file.getModuleName();
                };
                PluginPass.prototype.addImport = function addImport() {
                    this.file.addImport();
                };
            }
            0 && 0;
        },
        2983: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            const r = new Set;
            let n = 0;
            function deepClone(e1, t, s) {
                if (e1 !== null) {
                    if (s) {
                        if (t.has(e1)) return t.get(e1);
                    } else if (++n > 250) {
                        if (r.has(e1)) {
                            n = 0;
                            r.clear();
                            throw new Error("Babel-deepClone: Cycles are not allowed in AST");
                        }
                        r.add(e1);
                    }
                    let i;
                    if (Array.isArray(e1)) {
                        i = new Array(e1.length);
                        if (s) t.set(e1, i);
                        for(let r = 0; r < e1.length; r++){
                            i[r] = typeof e1[r] !== "object" ? e1[r] : deepClone(e1[r], t, s);
                        }
                    } else {
                        i = {};
                        if (s) t.set(e1, i);
                        const r = Object.keys(e1);
                        for(let n = 0; n < r.length; n++){
                            const a = r[n];
                            i[a] = typeof e1[a] !== "object" ? e1[a] : deepClone(e1[a], t, s || a === "leadingComments" || a === "innerComments" || a === "trailingComments" || a === "extra");
                        }
                    }
                    if (!s) {
                        if (n-- > 250) r.delete(e1);
                    }
                    return i;
                }
                return e1;
            }
            function _default(e1) {
                if (typeof e1 !== "object") return e1;
                {
                    try {
                        return deepClone(e1, new Map, true);
                    } catch (t) {
                        return structuredClone(e1);
                    }
                }
            }
            0 && 0;
        },
        2044: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.moduleResolve = moduleResolve;
            t.resolve = resolve;
            function _assert() {
                const e1 = r(9491);
                _assert = function() {
                    return e1;
                };
                return e1;
            }
            function _fs() {
                const e1 = _interopRequireWildcard(r(7147), true);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _process() {
                const e1 = r(7282);
                _process = function() {
                    return e1;
                };
                return e1;
            }
            function _url() {
                const e1 = r(7310);
                _url = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _module() {
                const e1 = r(8188);
                _module = function() {
                    return e1;
                };
                return e1;
            }
            function _v() {
                const e1 = r(4655);
                _v = function() {
                    return e1;
                };
                return e1;
            }
            function _util() {
                const e1 = r(3837);
                _util = function() {
                    return e1;
                };
                return e1;
            }
            function _getRequireWildcardCache(e1) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap, r = new WeakMap;
                return (_getRequireWildcardCache = function(e1) {
                    return e1 ? r : t;
                })(e1);
            }
            function _interopRequireWildcard(e1, t) {
                if (!t && e1 && e1.__esModule) return e1;
                if (null === e1 || "object" != typeof e1 && "function" != typeof e1) return {
                    default: e1
                };
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e1)) return r.get(e1);
                var n = {
                    __proto__: null
                }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var i in e1)if ("default" !== i && ({}).hasOwnProperty.call(e1, i)) {
                    var a = s ? Object.getOwnPropertyDescriptor(e1, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(n, i, a) : n[i] = e1[i];
                }
                return n.default = e1, r && r.set(e1, n), n;
            }
            const n = {}.hasOwnProperty;
            const s = /^([A-Z][a-z\d]*)+$/;
            const i = new Set([
                "string",
                "function",
                "number",
                "object",
                "Function",
                "Object",
                "boolean",
                "bigint",
                "symbol"
            ]);
            const a = {};
            function formatList(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "and";
                return e1.length < 3 ? e1.join(" ".concat(t, " ")) : "".concat(e1.slice(0, -1).join(", "), ", ").concat(t, " ").concat(e1[e1.length - 1]);
            }
            const o = new Map;
            const l = "__node_internal_";
            let c;
            a.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (e1, t, r)=>{
                _assert()(typeof e1 === "string", "'name' must be a string");
                if (!Array.isArray(t)) {
                    t = [
                        t
                    ];
                }
                let n = "The ";
                if (e1.endsWith(" argument")) {
                    n += "".concat(e1, " ");
                } else {
                    const t = e1.includes(".") ? "property" : "argument";
                    n += '"'.concat(e1, '" ').concat(t, " ");
                }
                n += "must be ";
                const a = [];
                const o = [];
                const l = [];
                for (const e1 of t){
                    _assert()(typeof e1 === "string", "All expected entries have to be of type string");
                    if (i.has(e1)) {
                        a.push(e1.toLowerCase());
                    } else if (s.exec(e1) === null) {
                        _assert()(e1 !== "object", 'The value "object" should be written as "Object"');
                        l.push(e1);
                    } else {
                        o.push(e1);
                    }
                }
                if (o.length > 0) {
                    const e1 = a.indexOf("object");
                    if (e1 !== -1) {
                        a.slice(e1, 1);
                        o.push("Object");
                    }
                }
                if (a.length > 0) {
                    n += "".concat(a.length > 1 ? "one of type" : "of type", " ").concat(formatList(a, "or"));
                    if (o.length > 0 || l.length > 0) n += " or ";
                }
                if (o.length > 0) {
                    n += "an instance of ".concat(formatList(o, "or"));
                    if (l.length > 0) n += " or ";
                }
                if (l.length > 0) {
                    if (l.length > 1) {
                        n += "one of ".concat(formatList(l, "or"));
                    } else {
                        if (l[0].toLowerCase() !== l[0]) n += "an ";
                        n += "".concat(l[0]);
                    }
                }
                n += ". Received ".concat(determineSpecificType(r));
                return n;
            }, TypeError);
            a.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", function(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : undefined;
                return 'Invalid module "'.concat(e1, '" ').concat(t).concat(r ? " imported from ".concat(r) : "");
            }, TypeError);
            a.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (e1, t, r)=>"Invalid package config ".concat(e1).concat(t ? " while importing ".concat(t) : "").concat(r ? ". ".concat(r) : ""), Error);
            a.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", function(e1, t, r) {
                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : undefined;
                const i = typeof r === "string" && !n && r.length > 0 && !r.startsWith("./");
                if (t === ".") {
                    _assert()(n === false);
                    return 'Invalid "exports" main target '.concat(JSON.stringify(r), " defined ") + "in the package config ".concat(e1, "package.json").concat(s ? " imported from ".concat(s) : "").concat(i ? '; targets must start with "./"' : "");
                }
                return 'Invalid "'.concat(n ? "imports" : "exports", '" target ').concat(JSON.stringify(r), " defined for '").concat(t, "' in the package config ").concat(e1, "package.json").concat(s ? " imported from ".concat(s) : "").concat(i ? '; targets must start with "./"' : "");
            }, Error);
            a.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", function(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                return "Cannot find ".concat(r ? "module" : "package", " '").concat(e1, "' imported from ").concat(t);
            }, Error);
            a.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
            a.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e1, t, r)=>'Package import specifier "'.concat(e1, '" is not defined').concat(t ? " in package ".concat(t, "package.json") : "", " imported from ").concat(r), TypeError);
            a.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", function(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : undefined;
                if (t === ".") return 'No "exports" main defined in '.concat(e1, "package.json").concat(r ? " imported from ".concat(r) : "");
                return "Package subpath '".concat(t, '\' is not defined by "exports" in ').concat(e1, "package.json").concat(r ? " imported from ".concat(r) : "");
            }, Error);
            a.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported " + "resolving ES modules imported from %s", Error);
            a.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError);
            a.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (e1, t)=>'Unknown file extension "'.concat(e1, '" for ').concat(t), TypeError);
            a.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", function(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
                let n = (0, _util().inspect)(t);
                if (n.length > 128) {
                    n = "".concat(n.slice(0, 128), "...");
                }
                const s = e1.includes(".") ? "property" : "argument";
                return "The ".concat(s, " '").concat(e1, "' ").concat(r, ". Received ").concat(n);
            }, TypeError);
            function createError(e1, t, r) {
                o.set(e1, t);
                return makeNodeErrorWithCode(r, e1);
            }
            function makeNodeErrorWithCode(e1, t) {
                return NodeError;
                //TURBOPACK unreachable
                ;
                function NodeError() {
                    for(var _len = arguments.length, r = new Array(_len), _key = 0; _key < _len; _key++){
                        r[_key] = arguments[_key];
                    }
                    const n = Error.stackTraceLimit;
                    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
                    const s = new e1;
                    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = n;
                    const i = getMessage(t, r, s);
                    Object.defineProperties(s, {
                        message: {
                            value: i,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        },
                        toString: {
                            value () {
                                return "".concat(this.name, " [").concat(t, "]: ").concat(this.message);
                            },
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    p(s);
                    s.code = t;
                    return s;
                }
            }
            function isErrorStackTraceLimitWritable() {
                try {
                    if (_v().startupSnapshot.isBuildingSnapshot()) {
                        return false;
                    }
                } catch (e1) {}
                const e1 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
                if (e1 === undefined) {
                    return Object.isExtensible(Error);
                }
                return n.call(e1, "writable") && e1.writable !== undefined ? e1.writable : e1.set !== undefined;
            }
            function hideStackFrames(e1) {
                const t = l + e1.name;
                Object.defineProperty(e1, "name", {
                    value: t
                });
                return e1;
            }
            const p = hideStackFrames(function(e1) {
                const t = isErrorStackTraceLimitWritable();
                if (t) {
                    c = Error.stackTraceLimit;
                    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
                }
                Error.captureStackTrace(e1);
                if (t) Error.stackTraceLimit = c;
                return e1;
            });
            function getMessage(e1, t, r) {
                const n = o.get(e1);
                _assert()(n !== undefined, "expected `message` to be found");
                if (typeof n === "function") {
                    _assert()(n.length <= t.length, "Code: ".concat(e1, "; The provided arguments length (").concat(t.length, ") does not ") + "match the required ones (".concat(n.length, ")."));
                    return Reflect.apply(n, r, t);
                }
                const s = /%[dfijoOs]/g;
                let i = 0;
                while(s.exec(n) !== null)i++;
                _assert()(i === t.length, "Code: ".concat(e1, "; The provided arguments length (").concat(t.length, ") does not ") + "match the required ones (".concat(i, ")."));
                if (t.length === 0) return n;
                t.unshift(n);
                return Reflect.apply(_util().format, null, t);
            }
            function determineSpecificType(e1) {
                if (e1 === null || e1 === undefined) {
                    return String(e1);
                }
                if (typeof e1 === "function" && e1.name) {
                    return "function ".concat(e1.name);
                }
                if (typeof e1 === "object") {
                    if (e1.constructor && e1.constructor.name) {
                        return "an instance of ".concat(e1.constructor.name);
                    }
                    return "".concat((0, _util().inspect)(e1, {
                        depth: -1
                    }));
                }
                let t = (0, _util().inspect)(e1, {
                    colors: false
                });
                if (t.length > 28) {
                    t = "".concat(t.slice(0, 25), "...");
                }
                return "type ".concat(typeof e1, " (").concat(t, ")");
            }
            const u = {}.hasOwnProperty;
            const { ERR_INVALID_PACKAGE_CONFIG: d } = a;
            const f = new Map;
            function read(e1, param) {
                let { base: t, specifier: r } = param;
                const n = f.get(e1);
                if (n) {
                    return n;
                }
                let s;
                try {
                    s = _fs().default.readFileSync(_path().toNamespacedPath(e1), "utf8");
                } catch (e1) {
                    const t = e1;
                    if (t.code !== "ENOENT") {
                        throw t;
                    }
                }
                const i = {
                    exists: false,
                    pjsonPath: e1,
                    main: undefined,
                    name: undefined,
                    type: "none",
                    exports: undefined,
                    imports: undefined
                };
                if (s !== undefined) {
                    let n;
                    try {
                        n = JSON.parse(s);
                    } catch (n) {
                        const s = n;
                        const i = new d(e1, (t ? '"'.concat(r, '" from ') : "") + (0, _url().fileURLToPath)(t || r), s.message);
                        i.cause = s;
                        throw i;
                    }
                    i.exists = true;
                    if (u.call(n, "name") && typeof n.name === "string") {
                        i.name = n.name;
                    }
                    if (u.call(n, "main") && typeof n.main === "string") {
                        i.main = n.main;
                    }
                    if (u.call(n, "exports")) {
                        i.exports = n.exports;
                    }
                    if (u.call(n, "imports")) {
                        i.imports = n.imports;
                    }
                    if (u.call(n, "type") && (n.type === "commonjs" || n.type === "module")) {
                        i.type = n.type;
                    }
                }
                f.set(e1, i);
                return i;
            }
            function getPackageScopeConfig(e1) {
                let t = new URL("package.json", e1);
                while(true){
                    const r = t.pathname;
                    if (r.endsWith("node_modules/package.json")) {
                        break;
                    }
                    const n = read((0, _url().fileURLToPath)(t), {
                        specifier: e1
                    });
                    if (n.exists) {
                        return n;
                    }
                    const s = t;
                    t = new URL("../package.json", t);
                    if (t.pathname === s.pathname) {
                        break;
                    }
                }
                const r = (0, _url().fileURLToPath)(t);
                return {
                    pjsonPath: r,
                    exists: false,
                    type: "none"
                };
            }
            function getPackageType(e1) {
                return getPackageScopeConfig(e1).type;
            }
            const { ERR_UNKNOWN_FILE_EXTENSION: h } = a;
            const m = {}.hasOwnProperty;
            const y = {
                __proto__: null,
                ".cjs": "commonjs",
                ".js": "module",
                ".json": "json",
                ".mjs": "module"
            };
            function mimeToFormat(e1) {
                if (e1 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e1)) return "module";
                if (e1 === "application/json") return "json";
                return null;
            }
            const g = {
                __proto__: null,
                "data:": getDataProtocolModuleFormat,
                "file:": getFileProtocolModuleFormat,
                "http:": getHttpProtocolModuleFormat,
                "https:": getHttpProtocolModuleFormat,
                "node:" () {
                    return "builtin";
                }
            };
            function getDataProtocolModuleFormat(e1) {
                const { 1: t } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e1.pathname) || [
                    null,
                    null,
                    null
                ];
                return mimeToFormat(t);
            }
            function extname(e1) {
                const t = e1.pathname;
                let r = t.length;
                while(r--){
                    const e1 = t.codePointAt(r);
                    if (e1 === 47) {
                        return "";
                    }
                    if (e1 === 46) {
                        return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
                    }
                }
                return "";
            }
            function getFileProtocolModuleFormat(e1, t, r) {
                const n = extname(e1);
                if (n === ".js") {
                    const t = getPackageType(e1);
                    if (t !== "none") {
                        return t;
                    }
                    return "commonjs";
                }
                if (n === "") {
                    const t = getPackageType(e1);
                    if (t === "none" || t === "commonjs") {
                        return "commonjs";
                    }
                    return "module";
                }
                const s = y[n];
                if (s) return s;
                if (r) {
                    return undefined;
                }
                const i = (0, _url().fileURLToPath)(e1);
                throw new h(n, i);
            }
            function getHttpProtocolModuleFormat() {}
            function defaultGetFormatWithoutErrors(e1, t) {
                const r = e1.protocol;
                if (!m.call(g, r)) {
                    return null;
                }
                return g[r](e1, t, true) || null;
            }
            const { ERR_INVALID_ARG_VALUE: b } = a;
            const T = Object.freeze([
                "node",
                "import"
            ]);
            const S = new Set(T);
            function getDefaultConditions() {
                return T;
            }
            function getDefaultConditionsSet() {
                return S;
            }
            function getConditionsSet(e1) {
                if (e1 !== undefined && e1 !== getDefaultConditions()) {
                    if (!Array.isArray(e1)) {
                        throw new b("conditions", e1, "expected an array");
                    }
                    return new Set(e1);
                }
                return getDefaultConditionsSet();
            }
            const x = RegExp.prototype[Symbol.replace];
            const { ERR_NETWORK_IMPORT_DISALLOWED: E, ERR_INVALID_MODULE_SPECIFIER: P, ERR_INVALID_PACKAGE_CONFIG: v, ERR_INVALID_PACKAGE_TARGET: A, ERR_MODULE_NOT_FOUND: w, ERR_PACKAGE_IMPORT_NOT_DEFINED: I, ERR_PACKAGE_PATH_NOT_EXPORTED: C, ERR_UNSUPPORTED_DIR_IMPORT: O, ERR_UNSUPPORTED_RESOLVE_REQUEST: N } = a;
            const k = {}.hasOwnProperty;
            const _ = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
            const D = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
            const M = /^\.|%|\\/;
            const L = /\*/g;
            const j = /%2f|%5c/i;
            const F = new Set;
            const B = /[/\\]{2}/;
            function emitInvalidSegmentDeprecation(e1, t, r, n, s, i, a) {
                if (_process().noDeprecation) {
                    return;
                }
                const o = (0, _url().fileURLToPath)(n);
                const l = B.exec(a ? e1 : t) !== null;
                _process().emitWarning("Use of deprecated ".concat(l ? "double slash" : "leading or trailing slash matching", ' resolving "').concat(e1, '" for module ') + 'request "'.concat(t, '" ').concat(t === r ? "" : 'matched to "'.concat(r, '" '), 'in the "').concat(s ? "imports" : "exports", '" field module resolution of the package at ').concat(o).concat(i ? " imported from ".concat((0, _url().fileURLToPath)(i)) : "", "."), "DeprecationWarning", "DEP0166");
            }
            function emitLegacyIndexDeprecation(e1, t, r, n) {
                if (_process().noDeprecation) {
                    return;
                }
                const s = defaultGetFormatWithoutErrors(e1, {
                    parentURL: r.href
                });
                if (s !== "module") return;
                const i = (0, _url().fileURLToPath)(e1.href);
                const a = (0, _url().fileURLToPath)(new (_url()).URL(".", t));
                const o = (0, _url().fileURLToPath)(r);
                if (!n) {
                    _process().emitWarning('No "main" or "exports" field defined in the package.json for '.concat(a, ' resolving the main entry point "').concat(i.slice(a.length), '", imported from ').concat(o, '.\nDefault "index" lookups for the main are deprecated for ES modules.'), "DeprecationWarning", "DEP0151");
                } else if (_path().resolve(a, n) !== i) {
                    _process().emitWarning("Package ".concat(a, ' has a "main" field set to "').concat(n, '", ') + 'excluding the full filename and extension to the resolved file at "'.concat(i.slice(a.length), '", imported from ').concat(o, '.\n Automatic extension resolution of the "main" field is ') + "deprecated for ES modules.", "DeprecationWarning", "DEP0151");
                }
            }
            function tryStatSync(e1) {
                try {
                    return (0, _fs().statSync)(e1);
                } catch (e1) {}
            }
            function fileExists(e1) {
                const t = (0, _fs().statSync)(e1, {
                    throwIfNoEntry: false
                });
                const r = t ? t.isFile() : undefined;
                return r === null || r === undefined ? false : r;
            }
            function legacyMainResolve(e1, t, r) {
                let n;
                if (t.main !== undefined) {
                    n = new (_url()).URL(t.main, e1);
                    if (fileExists(n)) return n;
                    const s = [
                        "./".concat(t.main, ".js"),
                        "./".concat(t.main, ".json"),
                        "./".concat(t.main, ".node"),
                        "./".concat(t.main, "/index.js"),
                        "./".concat(t.main, "/index.json"),
                        "./".concat(t.main, "/index.node")
                    ];
                    let i = -1;
                    while(++i < s.length){
                        n = new (_url()).URL(s[i], e1);
                        if (fileExists(n)) break;
                        n = undefined;
                    }
                    if (n) {
                        emitLegacyIndexDeprecation(n, e1, r, t.main);
                        return n;
                    }
                }
                const s = [
                    "./index.js",
                    "./index.json",
                    "./index.node"
                ];
                let i = -1;
                while(++i < s.length){
                    n = new (_url()).URL(s[i], e1);
                    if (fileExists(n)) break;
                    n = undefined;
                }
                if (n) {
                    emitLegacyIndexDeprecation(n, e1, r, t.main);
                    return n;
                }
                throw new w((0, _url().fileURLToPath)(new (_url()).URL(".", e1)), (0, _url().fileURLToPath)(r));
            }
            function finalizeResolution(e1, t, r) {
                if (j.exec(e1.pathname) !== null) {
                    throw new P(e1.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(t));
                }
                let n;
                try {
                    n = (0, _url().fileURLToPath)(e1);
                } catch (r) {
                    const n = r;
                    Object.defineProperty(n, "input", {
                        value: String(e1)
                    });
                    Object.defineProperty(n, "module", {
                        value: String(t)
                    });
                    throw n;
                }
                const s = tryStatSync(n.endsWith("/") ? n.slice(-1) : n);
                if (s && s.isDirectory()) {
                    const r = new O(n, (0, _url().fileURLToPath)(t));
                    r.url = String(e1);
                    throw r;
                }
                if (!s || !s.isFile()) {
                    const r = new w(n || e1.pathname, t && (0, _url().fileURLToPath)(t), true);
                    r.url = String(e1);
                    throw r;
                }
                if (!r) {
                    const t = (0, _fs().realpathSync)(n);
                    const { search: r, hash: s } = e1;
                    e1 = (0, _url().pathToFileURL)(t + (n.endsWith(_path().sep) ? "/" : ""));
                    e1.search = r;
                    e1.hash = s;
                }
                return e1;
            }
            function importNotDefined(e1, t, r) {
                return new I(e1, t && (0, _url().fileURLToPath)(new (_url()).URL(".", t)), (0, _url().fileURLToPath)(r));
            }
            function exportsNotFound(e1, t, r) {
                return new C((0, _url().fileURLToPath)(new (_url()).URL(".", t)), e1, r && (0, _url().fileURLToPath)(r));
            }
            function throwInvalidSubpath(e1, t, r, n, s) {
                const i = 'request is not a valid match in pattern "'.concat(t, '" for the "').concat(n ? "imports" : "exports", '" resolution of ').concat((0, _url().fileURLToPath)(r));
                throw new P(e1, i, s && (0, _url().fileURLToPath)(s));
            }
            function invalidPackageTarget(e1, t, r, n, s) {
                t = typeof t === "object" && t !== null ? JSON.stringify(t, null, "") : "".concat(t);
                return new A((0, _url().fileURLToPath)(new (_url()).URL(".", r)), e1, t, n, s && (0, _url().fileURLToPath)(s));
            }
            function resolvePackageTargetString(e1, t, r, n, s, i, a, o, l) {
                if (t !== "" && !i && e1[e1.length - 1] !== "/") throw invalidPackageTarget(r, e1, n, a, s);
                if (!e1.startsWith("./")) {
                    if (a && !e1.startsWith("../") && !e1.startsWith("/")) {
                        let r = false;
                        try {
                            new (_url()).URL(e1);
                            r = true;
                        } catch (e1) {}
                        if (!r) {
                            const r = i ? x.call(L, e1, ()=>t) : e1 + t;
                            return packageResolve(r, n, l);
                        }
                    }
                    throw invalidPackageTarget(r, e1, n, a, s);
                }
                if (_.exec(e1.slice(2)) !== null) {
                    if (D.exec(e1.slice(2)) === null) {
                        if (!o) {
                            const o = i ? r.replace("*", ()=>t) : r + t;
                            const l = i ? x.call(L, e1, ()=>t) : e1;
                            emitInvalidSegmentDeprecation(l, o, r, n, a, s, true);
                        }
                    } else {
                        throw invalidPackageTarget(r, e1, n, a, s);
                    }
                }
                const c = new (_url()).URL(e1, n);
                const p = c.pathname;
                const u = new (_url()).URL(".", n).pathname;
                if (!p.startsWith(u)) throw invalidPackageTarget(r, e1, n, a, s);
                if (t === "") return c;
                if (_.exec(t) !== null) {
                    const l = i ? r.replace("*", ()=>t) : r + t;
                    if (D.exec(t) === null) {
                        if (!o) {
                            const o = i ? x.call(L, e1, ()=>t) : e1;
                            emitInvalidSegmentDeprecation(o, l, r, n, a, s, false);
                        }
                    } else {
                        throwInvalidSubpath(l, r, n, a, s);
                    }
                }
                if (i) {
                    return new (_url()).URL(x.call(L, c.href, ()=>t));
                }
                return new (_url()).URL(t, c);
            }
            function isArrayIndex(e1) {
                const t = Number(e1);
                if ("".concat(t) !== e1) return false;
                return t >= 0 && t < 4294967295;
            }
            function resolvePackageTarget(e1, t, r, n, s, i, a, o, l) {
                if (typeof t === "string") {
                    return resolvePackageTargetString(t, r, n, e1, s, i, a, o, l);
                }
                if (Array.isArray(t)) {
                    const c = t;
                    if (c.length === 0) return null;
                    let p;
                    let u = -1;
                    while(++u < c.length){
                        const t = c[u];
                        let d;
                        try {
                            d = resolvePackageTarget(e1, t, r, n, s, i, a, o, l);
                        } catch (e1) {
                            const t = e1;
                            p = t;
                            if (t.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                            throw e1;
                        }
                        if (d === undefined) continue;
                        if (d === null) {
                            p = null;
                            continue;
                        }
                        return d;
                    }
                    if (p === undefined || p === null) {
                        return null;
                    }
                    throw p;
                }
                if (typeof t === "object" && t !== null) {
                    const c = Object.getOwnPropertyNames(t);
                    let p = -1;
                    while(++p < c.length){
                        const t = c[p];
                        if (isArrayIndex(t)) {
                            throw new v((0, _url().fileURLToPath)(e1), s, '"exports" cannot contain numeric property keys.');
                        }
                    }
                    p = -1;
                    while(++p < c.length){
                        const u = c[p];
                        if (u === "default" || l && l.has(u)) {
                            const c = t[u];
                            const p = resolvePackageTarget(e1, c, r, n, s, i, a, o, l);
                            if (p === undefined) continue;
                            return p;
                        }
                    }
                    return null;
                }
                if (t === null) {
                    return null;
                }
                throw invalidPackageTarget(n, t, e1, a, s);
            }
            function isConditionalExportsMainSugar(e1, t, r) {
                if (typeof e1 === "string" || Array.isArray(e1)) return true;
                if (typeof e1 !== "object" || e1 === null) return false;
                const n = Object.getOwnPropertyNames(e1);
                let s = false;
                let i = 0;
                let a = -1;
                while(++a < n.length){
                    const e1 = n[a];
                    const o = e1 === "" || e1[0] !== ".";
                    if (i++ === 0) {
                        s = o;
                    } else if (s !== o) {
                        throw new v((0, _url().fileURLToPath)(t), r, "\"exports\" cannot contain some keys starting with '.' and some not." + " The exports object must either be an object of package subpath keys" + " or an object of main entry condition name keys only.");
                    }
                }
                return s;
            }
            function emitTrailingSlashPatternDeprecation(e1, t, r) {
                if (_process().noDeprecation) {
                    return;
                }
                const n = (0, _url().fileURLToPath)(t);
                if (F.has(n + "|" + e1)) return;
                F.add(n + "|" + e1);
                _process().emitWarning('Use of deprecated trailing slash pattern mapping "'.concat(e1, '" in the ') + '"exports" field module resolution of the package at '.concat(n).concat(r ? " imported from ".concat((0, _url().fileURLToPath)(r)) : "", '. Mapping specifiers ending in "/" is no longer supported.'), "DeprecationWarning", "DEP0155");
            }
            function packageExportsResolve(e1, t, r, n, s) {
                let i = r.exports;
                if (isConditionalExportsMainSugar(i, e1, n)) {
                    i = {
                        ".": i
                    };
                }
                if (k.call(i, t) && !t.includes("*") && !t.endsWith("/")) {
                    const r = i[t];
                    const a = resolvePackageTarget(e1, r, "", t, n, false, false, false, s);
                    if (a === null || a === undefined) {
                        throw exportsNotFound(t, e1, n);
                    }
                    return a;
                }
                let a = "";
                let o = "";
                const l = Object.getOwnPropertyNames(i);
                let c = -1;
                while(++c < l.length){
                    const r = l[c];
                    const s = r.indexOf("*");
                    if (s !== -1 && t.startsWith(r.slice(0, s))) {
                        if (t.endsWith("/")) {
                            emitTrailingSlashPatternDeprecation(t, e1, n);
                        }
                        const i = r.slice(s + 1);
                        if (t.length >= r.length && t.endsWith(i) && patternKeyCompare(a, r) === 1 && r.lastIndexOf("*") === s) {
                            a = r;
                            o = t.slice(s, t.length - i.length);
                        }
                    }
                }
                if (a) {
                    const r = i[a];
                    const l = resolvePackageTarget(e1, r, o, a, n, true, false, t.endsWith("/"), s);
                    if (l === null || l === undefined) {
                        throw exportsNotFound(t, e1, n);
                    }
                    return l;
                }
                throw exportsNotFound(t, e1, n);
            }
            function patternKeyCompare(e1, t) {
                const r = e1.indexOf("*");
                const n = t.indexOf("*");
                const s = r === -1 ? e1.length : r + 1;
                const i = n === -1 ? t.length : n + 1;
                if (s > i) return -1;
                if (i > s) return 1;
                if (r === -1) return 1;
                if (n === -1) return -1;
                if (e1.length > t.length) return -1;
                if (t.length > e1.length) return 1;
                return 0;
            }
            function packageImportsResolve(e1, t, r) {
                if (e1 === "#" || e1.startsWith("#/") || e1.endsWith("/")) {
                    const r = "is not a valid internal imports specifier name";
                    throw new P(e1, r, (0, _url().fileURLToPath)(t));
                }
                let n;
                const s = getPackageScopeConfig(t);
                if (s.exists) {
                    n = (0, _url().pathToFileURL)(s.pjsonPath);
                    const i = s.imports;
                    if (i) {
                        if (k.call(i, e1) && !e1.includes("*")) {
                            const s = resolvePackageTarget(n, i[e1], "", e1, t, false, true, false, r);
                            if (s !== null && s !== undefined) {
                                return s;
                            }
                        } else {
                            let s = "";
                            let a = "";
                            const o = Object.getOwnPropertyNames(i);
                            let l = -1;
                            while(++l < o.length){
                                const t = o[l];
                                const r = t.indexOf("*");
                                if (r !== -1 && e1.startsWith(t.slice(0, -1))) {
                                    const n = t.slice(r + 1);
                                    if (e1.length >= t.length && e1.endsWith(n) && patternKeyCompare(s, t) === 1 && t.lastIndexOf("*") === r) {
                                        s = t;
                                        a = e1.slice(r, e1.length - n.length);
                                    }
                                }
                            }
                            if (s) {
                                const e1 = i[s];
                                const o = resolvePackageTarget(n, e1, a, s, t, true, true, false, r);
                                if (o !== null && o !== undefined) {
                                    return o;
                                }
                            }
                        }
                    }
                }
                throw importNotDefined(e1, n, t);
            }
            function parsePackageName(e1, t) {
                let r = e1.indexOf("/");
                let n = true;
                let s = false;
                if (e1[0] === "@") {
                    s = true;
                    if (r === -1 || e1.length === 0) {
                        n = false;
                    } else {
                        r = e1.indexOf("/", r + 1);
                    }
                }
                const i = r === -1 ? e1 : e1.slice(0, r);
                if (M.exec(i) !== null) {
                    n = false;
                }
                if (!n) {
                    throw new P(e1, "is not a valid package name", (0, _url().fileURLToPath)(t));
                }
                const a = "." + (r === -1 ? "" : e1.slice(r));
                return {
                    packageName: i,
                    packageSubpath: a,
                    isScoped: s
                };
            }
            function packageResolve(e1, t, r) {
                if (_module().builtinModules.includes(e1)) {
                    return new (_url()).URL("node:" + e1);
                }
                const { packageName: n, packageSubpath: s, isScoped: i } = parsePackageName(e1, t);
                const a = getPackageScopeConfig(t);
                if (a.exists) {
                    const e1 = (0, _url().pathToFileURL)(a.pjsonPath);
                    if (a.name === n && a.exports !== undefined && a.exports !== null) {
                        return packageExportsResolve(e1, s, a, t, r);
                    }
                }
                let o = new (_url()).URL("./node_modules/" + n + "/package.json", t);
                let l = (0, _url().fileURLToPath)(o);
                let c;
                do {
                    const a = tryStatSync(l.slice(0, -13));
                    if (!a || !a.isDirectory()) {
                        c = l;
                        o = new (_url()).URL((i ? "../../../../node_modules/" : "../../../node_modules/") + n + "/package.json", o);
                        l = (0, _url().fileURLToPath)(o);
                        continue;
                    }
                    const p = read(l, {
                        base: t,
                        specifier: e1
                    });
                    if (p.exports !== undefined && p.exports !== null) {
                        return packageExportsResolve(o, s, p, t, r);
                    }
                    if (s === ".") {
                        return legacyMainResolve(o, p, t);
                    }
                    return new (_url()).URL(s, o);
                }while (l.length !== c.length)
                throw new w(n, (0, _url().fileURLToPath)(t), false);
            }
            function isRelativeSpecifier(e1) {
                if (e1[0] === ".") {
                    if (e1.length === 1 || e1[1] === "/") return true;
                    if (e1[1] === "." && (e1.length === 2 || e1[2] === "/")) {
                        return true;
                    }
                }
                return false;
            }
            function shouldBeTreatedAsRelativeOrAbsolutePath(e1) {
                if (e1 === "") return false;
                if (e1[0] === "/") return true;
                return isRelativeSpecifier(e1);
            }
            function moduleResolve(e1, t, r, n) {
                const s = t.protocol;
                const i = s === "data:";
                const a = i || s === "http:" || s === "https:";
                let o;
                if (shouldBeTreatedAsRelativeOrAbsolutePath(e1)) {
                    try {
                        o = new (_url()).URL(e1, t);
                    } catch (r) {
                        const n = new N(e1, t);
                        n.cause = r;
                        throw n;
                    }
                } else if (s === "file:" && e1[0] === "#") {
                    o = packageImportsResolve(e1, t, r);
                } else {
                    try {
                        o = new (_url()).URL(e1);
                    } catch (n) {
                        if (a && !_module().builtinModules.includes(e1)) {
                            const r = new N(e1, t);
                            r.cause = n;
                            throw r;
                        }
                        o = packageResolve(e1, t, r);
                    }
                }
                _assert()(o !== undefined, "expected to be defined");
                if (o.protocol !== "file:") {
                    return o;
                }
                return finalizeResolution(o, t, n);
            }
            function checkIfDisallowedImport(e1, t, r) {
                if (r) {
                    const n = r.protocol;
                    if (n === "http:" || n === "https:") {
                        if (shouldBeTreatedAsRelativeOrAbsolutePath(e1)) {
                            const n = t == null ? void 0 : t.protocol;
                            if (n && n !== "https:" && n !== "http:") {
                                throw new E(e1, r, "remote imports cannot import from a local location.");
                            }
                            return {
                                url: (t == null ? void 0 : t.href) || ""
                            };
                        }
                        if (_module().builtinModules.includes(e1)) {
                            throw new E(e1, r, "remote imports cannot import from a local location.");
                        }
                        throw new E(e1, r, "only relative and absolute specifiers are supported.");
                    }
                }
            }
            function isURL(e1) {
                return Boolean(e1 && typeof e1 === "object" && "href" in e1 && typeof e1.href === "string" && "protocol" in e1 && typeof e1.protocol === "string" && e1.href && e1.protocol);
            }
            function throwIfInvalidParentURL(e1) {
                if (e1 === undefined) {
                    return;
                }
                if (typeof e1 !== "string" && !isURL(e1)) {
                    throw new a.ERR_INVALID_ARG_TYPE("parentURL", [
                        "string",
                        "URL"
                    ], e1);
                }
            }
            function defaultResolve(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const { parentURL: r } = t;
                _assert()(r !== undefined, "expected `parentURL` to be defined");
                throwIfInvalidParentURL(r);
                let n;
                if (r) {
                    try {
                        n = new (_url()).URL(r);
                    } catch (e1) {}
                }
                let s;
                let i;
                try {
                    s = shouldBeTreatedAsRelativeOrAbsolutePath(e1) ? new (_url()).URL(e1, n) : new (_url()).URL(e1);
                    i = s.protocol;
                    if (i === "data:") {
                        return {
                            url: s.href,
                            format: null
                        };
                    }
                } catch (e1) {}
                const a = checkIfDisallowedImport(e1, s, n);
                if (a) return a;
                if (i === undefined && s) {
                    i = s.protocol;
                }
                if (i === "node:") {
                    return {
                        url: e1
                    };
                }
                if (s && s.protocol === "node:") return {
                    url: e1
                };
                const o = getConditionsSet(t.conditions);
                const l = moduleResolve(e1, new (_url()).URL(r), o, false);
                return {
                    url: l.href,
                    format: defaultGetFormatWithoutErrors(l, {
                        parentURL: r
                    })
                };
            }
            function resolve(e1, t) {
                if (!t) {
                    throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
                }
                try {
                    return defaultResolve(e1, {
                        parentURL: t
                    }).url;
                } catch (e1) {
                    const t = e1;
                    if ((t.code === "ERR_UNSUPPORTED_DIR_IMPORT" || t.code === "ERR_MODULE_NOT_FOUND") && typeof t.url === "string") {
                        return t.url;
                    }
                    throw e1;
                }
            }
            0 && 0;
        },
        6031: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class Buffer {
                _allocQueue() {
                    const e1 = this._queue;
                    for(let t = 0; t < 16; t++){
                        e1.push({
                            char: 0,
                            repeat: 1,
                            line: undefined,
                            column: undefined,
                            identifierName: undefined,
                            identifierNamePos: undefined,
                            filename: ""
                        });
                    }
                }
                _pushQueue(e1, t, r, n, s) {
                    const i = this._queueCursor;
                    if (i === this._queue.length) {
                        this._allocQueue();
                    }
                    const a = this._queue[i];
                    a.char = e1;
                    a.repeat = t;
                    a.line = r;
                    a.column = n;
                    a.filename = s;
                    this._queueCursor++;
                }
                _popQueue() {
                    if (this._queueCursor === 0) {
                        throw new Error("Cannot pop from empty queue");
                    }
                    return this._queue[--this._queueCursor];
                }
                get() {
                    this._flush();
                    const e1 = this._map;
                    const t = {
                        code: (this._buf + this._str).trimRight(),
                        decodedMap: e1 == null ? void 0 : e1.getDecoded(),
                        get __mergedMap () {
                            return this.map;
                        },
                        get map () {
                            const r = e1 ? e1.get() : null;
                            t.map = r;
                            return r;
                        },
                        set map (e){
                            Object.defineProperty(t, "map", {
                                value: e,
                                writable: true
                            });
                        },
                        get rawMappings () {
                            const r = e1 == null ? void 0 : e1.getRawMappings();
                            t.rawMappings = r;
                            return r;
                        },
                        set rawMappings (e){
                            Object.defineProperty(t, "rawMappings", {
                                value: e,
                                writable: true
                            });
                        }
                    };
                    return t;
                }
                append(e1, t) {
                    this._flush();
                    this._append(e1, this._sourcePosition, t);
                }
                appendChar(e1) {
                    this._flush();
                    this._appendChar(e1, 1, this._sourcePosition);
                }
                queue(e1) {
                    if (e1 === 10) {
                        while(this._queueCursor !== 0){
                            const e1 = this._queue[this._queueCursor - 1].char;
                            if (e1 !== 32 && e1 !== 9) {
                                break;
                            }
                            this._queueCursor--;
                        }
                    }
                    const t = this._sourcePosition;
                    this._pushQueue(e1, 1, t.line, t.column, t.filename);
                }
                queueIndentation(e1) {
                    if (e1 === 0) return;
                    this._pushQueue(-1, e1, undefined, undefined, undefined);
                }
                _flush() {
                    const e1 = this._queueCursor;
                    const t = this._queue;
                    for(let r = 0; r < e1; r++){
                        const e1 = t[r];
                        this._appendChar(e1.char, e1.repeat, e1);
                    }
                    this._queueCursor = 0;
                }
                _appendChar(e1, t, r) {
                    this._last = e1;
                    if (e1 === -1) {
                        const e1 = this._fastIndentations[t];
                        if (e1 !== undefined) {
                            this._str += e1;
                        } else {
                            this._str += t > 1 ? this._indentChar.repeat(t) : this._indentChar;
                        }
                    } else {
                        this._str += t > 1 ? String.fromCharCode(e1).repeat(t) : String.fromCharCode(e1);
                    }
                    if (e1 !== 10) {
                        this._mark(r.line, r.column, r.identifierName, r.identifierNamePos, r.filename);
                        this._position.column += t;
                    } else {
                        this._position.line++;
                        this._position.column = 0;
                    }
                    if (this._canMarkIdName) {
                        r.identifierName = undefined;
                        r.identifierNamePos = undefined;
                    }
                }
                _append(e1, t, r) {
                    const n = e1.length;
                    const s = this._position;
                    this._last = e1.charCodeAt(n - 1);
                    if (++this._appendCount > 4096) {
                        +this._str;
                        this._buf += this._str;
                        this._str = e1;
                        this._appendCount = 0;
                    } else {
                        this._str += e1;
                    }
                    if (!r && !this._map) {
                        s.column += n;
                        return;
                    }
                    const { column: i, identifierName: a, identifierNamePos: o, filename: l } = t;
                    let c = t.line;
                    if ((a != null || o != null) && this._canMarkIdName) {
                        t.identifierName = undefined;
                        t.identifierNamePos = undefined;
                    }
                    let p = e1.indexOf("\n");
                    let u = 0;
                    if (p !== 0) {
                        this._mark(c, i, a, o, l);
                    }
                    while(p !== -1){
                        s.line++;
                        s.column = 0;
                        u = p + 1;
                        if (u < n && c !== undefined) {
                            this._mark(++c, 0, null, null, l);
                        }
                        p = e1.indexOf("\n", u);
                    }
                    s.column += n - u;
                }
                _mark(e1, t, r, n, s) {
                    var i;
                    (i = this._map) == null || i.mark(this._position, e1, t, r, n, s);
                }
                removeTrailingNewline() {
                    const e1 = this._queueCursor;
                    if (e1 !== 0 && this._queue[e1 - 1].char === 10) {
                        this._queueCursor--;
                    }
                }
                removeLastSemicolon() {
                    const e1 = this._queueCursor;
                    if (e1 !== 0 && this._queue[e1 - 1].char === 59) {
                        this._queueCursor--;
                    }
                }
                getLastChar() {
                    const e1 = this._queueCursor;
                    return e1 !== 0 ? this._queue[e1 - 1].char : this._last;
                }
                getNewlineCount() {
                    const e1 = this._queueCursor;
                    let t = 0;
                    if (e1 === 0) return this._last === 10 ? 1 : 0;
                    for(let r = e1 - 1; r >= 0; r--){
                        if (this._queue[r].char !== 10) {
                            break;
                        }
                        t++;
                    }
                    return t === e1 && this._last === 10 ? t + 1 : t;
                }
                endsWithCharAndNewline() {
                    const e1 = this._queue;
                    const t = this._queueCursor;
                    if (t !== 0) {
                        const r = e1[t - 1].char;
                        if (r !== 10) return;
                        if (t > 1) {
                            return e1[t - 2].char;
                        } else {
                            return this._last;
                        }
                    }
                }
                hasContent() {
                    return this._queueCursor !== 0 || !!this._last;
                }
                exactSource(e1, t) {
                    if (!this._map) {
                        t();
                        return;
                    }
                    this.source("start", e1);
                    const r = e1.identifierName;
                    const n = this._sourcePosition;
                    if (r) {
                        this._canMarkIdName = false;
                        n.identifierName = r;
                    }
                    t();
                    if (r) {
                        this._canMarkIdName = true;
                        n.identifierName = undefined;
                        n.identifierNamePos = undefined;
                    }
                    this.source("end", e1);
                }
                source(e1, t) {
                    if (!this._map) return;
                    this._normalizePosition(e1, t, 0);
                }
                sourceWithOffset(e1, t, r) {
                    if (!this._map) return;
                    this._normalizePosition(e1, t, r);
                }
                _normalizePosition(e1, t, r) {
                    const n = t[e1];
                    const s = this._sourcePosition;
                    if (n) {
                        s.line = n.line;
                        s.column = Math.max(n.column + r, 0);
                        s.filename = t.filename;
                    }
                }
                getCurrentColumn() {
                    const e1 = this._queue;
                    const t = this._queueCursor;
                    let r = -1;
                    let n = 0;
                    for(let s = 0; s < t; s++){
                        const t = e1[s];
                        if (t.char === 10) {
                            r = n;
                        }
                        n += t.repeat;
                    }
                    return r === -1 ? this._position.column + n : n - 1 - r;
                }
                getCurrentLine() {
                    let e1 = 0;
                    const t = this._queue;
                    for(let r = 0; r < this._queueCursor; r++){
                        if (t[r].char === 10) {
                            e1++;
                        }
                    }
                    return this._position.line + e1;
                }
                constructor(e1, t){
                    this._map = null;
                    this._buf = "";
                    this._str = "";
                    this._appendCount = 0;
                    this._last = 0;
                    this._queue = [];
                    this._queueCursor = 0;
                    this._canMarkIdName = true;
                    this._indentChar = "";
                    this._fastIndentations = [];
                    this._position = {
                        line: 1,
                        column: 0
                    };
                    this._sourcePosition = {
                        identifierName: undefined,
                        identifierNamePos: undefined,
                        line: undefined,
                        column: undefined,
                        filename: undefined
                    };
                    this._map = e1;
                    this._indentChar = t;
                    for(let e1 = 0; e1 < 64; e1++){
                        this._fastIndentations.push(t.repeat(e1));
                    }
                    this._allocQueue();
                }
            }
            t["default"] = Buffer;
        },
        1647: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BlockStatement = BlockStatement;
            t.Directive = Directive;
            t.DirectiveLiteral = DirectiveLiteral;
            t.File = File;
            t.InterpreterDirective = InterpreterDirective;
            t.Placeholder = Placeholder;
            t.Program = Program;
            function File(e1) {
                if (e1.program) {
                    this.print(e1.program.interpreter);
                }
                this.print(e1.program);
            }
            function Program(e1) {
                var t;
                this.noIndentInnerCommentsHere();
                this.printInnerComments();
                const r = (t = e1.directives) == null ? void 0 : t.length;
                if (r) {
                    var n;
                    const t = e1.body.length ? 2 : 1;
                    this.printSequence(e1.directives, undefined, t);
                    if (!((n = e1.directives[r - 1].trailingComments) != null && n.length)) {
                        this.newline(t);
                    }
                }
                this.printSequence(e1.body);
            }
            function BlockStatement(e1) {
                var t;
                this.tokenChar(123);
                const r = this.enterDelimited();
                const n = (t = e1.directives) == null ? void 0 : t.length;
                if (n) {
                    var s;
                    const t = e1.body.length ? 2 : 1;
                    this.printSequence(e1.directives, true, t);
                    if (!((s = e1.directives[n - 1].trailingComments) != null && s.length)) {
                        this.newline(t);
                    }
                }
                this.printSequence(e1.body, true);
                r();
                this.rightBrace(e1);
            }
            function Directive(e1) {
                this.print(e1.value);
                this.semicolon();
            }
            const r = /(?:^|[^\\])(?:\\\\)*'/;
            const n = /(?:^|[^\\])(?:\\\\)*"/;
            function DirectiveLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.token(t);
                    return;
                }
                const { value: s } = e1;
                if (!n.test(s)) {
                    this.token('"'.concat(s, '"'));
                } else if (!r.test(s)) {
                    this.token("'".concat(s, "'"));
                } else {
                    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
                }
            }
            function InterpreterDirective(e1) {
                this.token("#!".concat(e1.value));
                this.newline(1, true);
            }
            function Placeholder(e1) {
                this.token("%%");
                this.print(e1.name);
                this.token("%%");
                if (e1.expectedNode === "Statement") {
                    this.semicolon();
                }
            }
        },
        5953: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ClassAccessorProperty = ClassAccessorProperty;
            t.ClassBody = ClassBody;
            t.ClassExpression = t.ClassDeclaration = ClassDeclaration;
            t.ClassMethod = ClassMethod;
            t.ClassPrivateMethod = ClassPrivateMethod;
            t.ClassPrivateProperty = ClassPrivateProperty;
            t.ClassProperty = ClassProperty;
            t.StaticBlock = StaticBlock;
            t._classMethodHead = _classMethodHead;
            var n = r(3061);
            const { isExportDefaultDeclaration: s, isExportNamedDeclaration: i } = n;
            function ClassDeclaration(e1, t) {
                const r = s(t) || i(t);
                if (!r || !this._shouldPrintDecoratorsBeforeExport(t)) {
                    this.printJoin(e1.decorators);
                }
                if (e1.declare) {
                    this.word("declare");
                    this.space();
                }
                if (e1.abstract) {
                    this.word("abstract");
                    this.space();
                }
                this.word("class");
                if (e1.id) {
                    this.space();
                    this.print(e1.id);
                }
                this.print(e1.typeParameters);
                if (e1.superClass) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.print(e1.superClass);
                    this.print(e1.superTypeParameters);
                }
                if (e1.implements) {
                    this.space();
                    this.word("implements");
                    this.space();
                    this.printList(e1.implements);
                }
                this.space();
                this.print(e1.body);
            }
            function ClassBody(e1) {
                this.tokenChar(123);
                if (e1.body.length === 0) {
                    this.tokenChar(125);
                } else {
                    this.newline();
                    const t = classBodyEmptySemicolonsPrinter(this, e1);
                    t == null || t(-1);
                    const r = this.enterDelimited();
                    this.printJoin(e1.body, true, true, t, true);
                    r();
                    if (!this.endsWith(10)) this.newline();
                    this.rightBrace(e1);
                }
            }
            function classBodyEmptySemicolonsPrinter(e1, t) {
                if (!e1.tokenMap || t.start == null || t.end == null) {
                    return null;
                }
                const r = e1.tokenMap.getIndexes(t);
                if (!r) return null;
                let n = 1;
                let s = 0;
                let i = 0;
                const advanceNextLocIndex = ()=>{
                    while(i < t.body.length && t.body[i].start == null){
                        i++;
                    }
                };
                advanceNextLocIndex();
                return (a)=>{
                    if (i <= a) {
                        i = a + 1;
                        advanceNextLocIndex();
                    }
                    const o = i === t.body.length ? t.end : t.body[i].start;
                    let l;
                    while(n < r.length && e1.tokenMap.matchesOriginal(l = e1._tokens[r[n]], ";") && l.start < o){
                        e1.token(";", undefined, s++);
                        n++;
                    }
                };
            }
            function ClassProperty(e1) {
                this.printJoin(e1.decorators);
                if (!e1.static && !this.format.preserveFormat) {
                    var t;
                    const r = (t = e1.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
                    if (r) this.catchUp(r);
                }
                this.tsPrintClassMemberModifiers(e1);
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(e1.key);
                    this.tokenChar(93);
                } else {
                    this._variance(e1);
                    this.print(e1.key);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
                if (e1.definite) {
                    this.tokenChar(33);
                }
                this.print(e1.typeAnnotation);
                if (e1.value) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.value);
                }
                this.semicolon();
            }
            function ClassAccessorProperty(e1) {
                var t;
                this.printJoin(e1.decorators);
                const r = (t = e1.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
                if (r) this.catchUp(r);
                this.tsPrintClassMemberModifiers(e1);
                this.word("accessor", true);
                this.space();
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(e1.key);
                    this.tokenChar(93);
                } else {
                    this._variance(e1);
                    this.print(e1.key);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
                if (e1.definite) {
                    this.tokenChar(33);
                }
                this.print(e1.typeAnnotation);
                if (e1.value) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.value);
                }
                this.semicolon();
            }
            function ClassPrivateProperty(e1) {
                this.printJoin(e1.decorators);
                this.tsPrintClassMemberModifiers(e1);
                this.print(e1.key);
                if (e1.optional) {
                    this.tokenChar(63);
                }
                if (e1.definite) {
                    this.tokenChar(33);
                }
                this.print(e1.typeAnnotation);
                if (e1.value) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.value);
                }
                this.semicolon();
            }
            function ClassMethod(e1) {
                this._classMethodHead(e1);
                this.space();
                this.print(e1.body);
            }
            function ClassPrivateMethod(e1) {
                this._classMethodHead(e1);
                this.space();
                this.print(e1.body);
            }
            function _classMethodHead(e1) {
                this.printJoin(e1.decorators);
                if (!this.format.preserveFormat) {
                    var t;
                    const r = (t = e1.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
                    if (r) this.catchUp(r);
                }
                this.tsPrintClassMemberModifiers(e1);
                this._methodHead(e1);
            }
            function StaticBlock(e1) {
                this.word("static");
                this.space();
                this.tokenChar(123);
                if (e1.body.length === 0) {
                    this.tokenChar(125);
                } else {
                    this.newline();
                    this.printSequence(e1.body, true);
                    this.rightBrace(e1);
                }
            }
        },
        2943: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.addDeprecatedGenerators = addDeprecatedGenerators;
            function addDeprecatedGenerators(e1) {
                {
                    const t = {
                        Noop () {},
                        TSExpressionWithTypeArguments (e1) {
                            this.print(e1.expression);
                            this.print(e1.typeParameters);
                        },
                        DecimalLiteral (e1) {
                            const t = this.getPossibleRaw(e1);
                            if (!this.format.minified && t !== undefined) {
                                this.word(t);
                                return;
                            }
                            this.word(e1.value + "m");
                        }
                    };
                    Object.assign(e1.prototype, t);
                }
            }
        },
        1270: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LogicalExpression = t.BinaryExpression = t.AssignmentExpression = AssignmentExpression;
            t.AssignmentPattern = AssignmentPattern;
            t.AwaitExpression = AwaitExpression;
            t.BindExpression = BindExpression;
            t.CallExpression = CallExpression;
            t.ConditionalExpression = ConditionalExpression;
            t.Decorator = Decorator;
            t.DoExpression = DoExpression;
            t.EmptyStatement = EmptyStatement;
            t.ExpressionStatement = ExpressionStatement;
            t.Import = Import;
            t.MemberExpression = MemberExpression;
            t.MetaProperty = MetaProperty;
            t.ModuleExpression = ModuleExpression;
            t.NewExpression = NewExpression;
            t.OptionalCallExpression = OptionalCallExpression;
            t.OptionalMemberExpression = OptionalMemberExpression;
            t.ParenthesizedExpression = ParenthesizedExpression;
            t.PrivateName = PrivateName;
            t.SequenceExpression = SequenceExpression;
            t.Super = Super;
            t.ThisExpression = ThisExpression;
            t.UnaryExpression = UnaryExpression;
            t.UpdateExpression = UpdateExpression;
            t.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
            t.YieldExpression = YieldExpression;
            t._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
            var n = r(3061);
            var s = r(8694);
            const { isCallExpression: i, isLiteral: a, isMemberExpression: o, isNewExpression: l, isPattern: c } = n;
            function UnaryExpression(e1) {
                const { operator: t } = e1;
                if (t === "void" || t === "delete" || t === "typeof" || t === "throw") {
                    this.word(t);
                    this.space();
                } else {
                    this.token(t);
                }
                this.print(e1.argument);
            }
            function DoExpression(e1) {
                if (e1.async) {
                    this.word("async", true);
                    this.space();
                }
                this.word("do");
                this.space();
                this.print(e1.body);
            }
            function ParenthesizedExpression(e1) {
                this.tokenChar(40);
                const t = this.enterDelimited();
                this.print(e1.expression);
                t();
                this.rightParens(e1);
            }
            function UpdateExpression(e1) {
                if (e1.prefix) {
                    this.token(e1.operator);
                    this.print(e1.argument);
                } else {
                    this.print(e1.argument, true);
                    this.token(e1.operator);
                }
            }
            function ConditionalExpression(e1) {
                this.print(e1.test);
                this.space();
                this.tokenChar(63);
                this.space();
                this.print(e1.consequent);
                this.space();
                this.tokenChar(58);
                this.space();
                this.print(e1.alternate);
            }
            function NewExpression(e1, t) {
                this.word("new");
                this.space();
                this.print(e1.callee);
                if (this.format.minified && e1.arguments.length === 0 && !e1.optional && !i(t, {
                    callee: e1
                }) && !o(t) && !l(t)) {
                    return;
                }
                this.print(e1.typeArguments);
                {
                    this.print(e1.typeParameters);
                }
                if (e1.optional) {
                    this.token("?.");
                }
                if (e1.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(e1, ")")) {
                    return;
                }
                this.tokenChar(40);
                const r = this.enterDelimited();
                this.printList(e1.arguments, this.shouldPrintTrailingComma(")"));
                r();
                this.rightParens(e1);
            }
            function SequenceExpression(e1) {
                this.printList(e1.expressions);
            }
            function ThisExpression() {
                this.word("this");
            }
            function Super() {
                this.word("super");
            }
            function _shouldPrintDecoratorsBeforeExport(e1) {
                if (typeof this.format.decoratorsBeforeExport === "boolean") {
                    return this.format.decoratorsBeforeExport;
                }
                return typeof e1.start === "number" && e1.start === e1.declaration.start;
            }
            function Decorator(e1) {
                this.tokenChar(64);
                this.print(e1.expression);
                this.newline();
            }
            function OptionalMemberExpression(e1) {
                let { computed: t } = e1;
                const { optional: r, property: n } = e1;
                this.print(e1.object);
                if (!t && o(n)) {
                    throw new TypeError("Got a MemberExpression for MemberExpression property");
                }
                if (a(n) && typeof n.value === "number") {
                    t = true;
                }
                if (r) {
                    this.token("?.");
                }
                if (t) {
                    this.tokenChar(91);
                    this.print(n);
                    this.tokenChar(93);
                } else {
                    if (!r) {
                        this.tokenChar(46);
                    }
                    this.print(n);
                }
            }
            function OptionalCallExpression(e1) {
                this.print(e1.callee);
                {
                    this.print(e1.typeParameters);
                }
                if (e1.optional) {
                    this.token("?.");
                }
                this.print(e1.typeArguments);
                this.tokenChar(40);
                const t = this.enterDelimited();
                this.printList(e1.arguments);
                t();
                this.rightParens(e1);
            }
            function CallExpression(e1) {
                this.print(e1.callee);
                this.print(e1.typeArguments);
                {
                    this.print(e1.typeParameters);
                }
                this.tokenChar(40);
                const t = this.enterDelimited();
                this.printList(e1.arguments, this.shouldPrintTrailingComma(")"));
                t();
                this.rightParens(e1);
            }
            function Import() {
                this.word("import");
            }
            function AwaitExpression(e1) {
                this.word("await");
                if (e1.argument) {
                    this.space();
                    this.printTerminatorless(e1.argument);
                }
            }
            function YieldExpression(e1) {
                this.word("yield", true);
                if (e1.delegate) {
                    this.tokenChar(42);
                    if (e1.argument) {
                        this.space();
                        this.print(e1.argument);
                    }
                } else {
                    if (e1.argument) {
                        this.space();
                        this.printTerminatorless(e1.argument);
                    }
                }
            }
            function EmptyStatement() {
                this.semicolon(true);
            }
            function ExpressionStatement(e1) {
                this.tokenContext |= s.TokenContext.expressionStatement;
                this.print(e1.expression);
                this.semicolon();
            }
            function AssignmentPattern(e1) {
                this.print(e1.left);
                if (e1.left.type === "Identifier" || c(e1.left)) {
                    if (e1.left.optional) this.tokenChar(63);
                    this.print(e1.left.typeAnnotation);
                }
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(e1.right);
            }
            function AssignmentExpression(e1) {
                this.print(e1.left);
                this.space();
                if (e1.operator === "in" || e1.operator === "instanceof") {
                    this.word(e1.operator);
                } else {
                    this.token(e1.operator);
                    this._endsWithDiv = e1.operator === "/";
                }
                this.space();
                this.print(e1.right);
            }
            function BindExpression(e1) {
                this.print(e1.object);
                this.token("::");
                this.print(e1.callee);
            }
            function MemberExpression(e1) {
                this.print(e1.object);
                if (!e1.computed && o(e1.property)) {
                    throw new TypeError("Got a MemberExpression for MemberExpression property");
                }
                let t = e1.computed;
                if (a(e1.property) && typeof e1.property.value === "number") {
                    t = true;
                }
                if (t) {
                    const t = this.enterDelimited();
                    this.tokenChar(91);
                    this.print(e1.property);
                    this.tokenChar(93);
                    t();
                } else {
                    this.tokenChar(46);
                    this.print(e1.property);
                }
            }
            function MetaProperty(e1) {
                this.print(e1.meta);
                this.tokenChar(46);
                this.print(e1.property);
            }
            function PrivateName(e1) {
                this.tokenChar(35);
                this.print(e1.id);
            }
            function V8IntrinsicIdentifier(e1) {
                this.tokenChar(37);
                this.word(e1.name);
            }
            function ModuleExpression(e1) {
                this.word("module", true);
                this.space();
                this.tokenChar(123);
                this.indent();
                const { body: t } = e1;
                if (t.body.length || t.directives.length) {
                    this.newline();
                }
                this.print(t);
                this.dedent();
                this.rightBrace(e1);
            }
        },
        299: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AnyTypeAnnotation = AnyTypeAnnotation;
            t.ArrayTypeAnnotation = ArrayTypeAnnotation;
            t.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
            t.BooleanTypeAnnotation = BooleanTypeAnnotation;
            t.DeclareClass = DeclareClass;
            t.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
            t.DeclareExportDeclaration = DeclareExportDeclaration;
            t.DeclareFunction = DeclareFunction;
            t.DeclareInterface = DeclareInterface;
            t.DeclareModule = DeclareModule;
            t.DeclareModuleExports = DeclareModuleExports;
            t.DeclareOpaqueType = DeclareOpaqueType;
            t.DeclareTypeAlias = DeclareTypeAlias;
            t.DeclareVariable = DeclareVariable;
            t.DeclaredPredicate = DeclaredPredicate;
            t.EmptyTypeAnnotation = EmptyTypeAnnotation;
            t.EnumBooleanBody = EnumBooleanBody;
            t.EnumBooleanMember = EnumBooleanMember;
            t.EnumDeclaration = EnumDeclaration;
            t.EnumDefaultedMember = EnumDefaultedMember;
            t.EnumNumberBody = EnumNumberBody;
            t.EnumNumberMember = EnumNumberMember;
            t.EnumStringBody = EnumStringBody;
            t.EnumStringMember = EnumStringMember;
            t.EnumSymbolBody = EnumSymbolBody;
            t.ExistsTypeAnnotation = ExistsTypeAnnotation;
            t.FunctionTypeAnnotation = FunctionTypeAnnotation;
            t.FunctionTypeParam = FunctionTypeParam;
            t.IndexedAccessType = IndexedAccessType;
            t.InferredPredicate = InferredPredicate;
            t.InterfaceDeclaration = InterfaceDeclaration;
            t.GenericTypeAnnotation = t.ClassImplements = t.InterfaceExtends = InterfaceExtends;
            t.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
            t.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
            t.MixedTypeAnnotation = MixedTypeAnnotation;
            t.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
            t.NullableTypeAnnotation = NullableTypeAnnotation;
            Object.defineProperty(t, "NumberLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return a.NumericLiteral;
                }
            });
            t.NumberTypeAnnotation = NumberTypeAnnotation;
            t.ObjectTypeAnnotation = ObjectTypeAnnotation;
            t.ObjectTypeCallProperty = ObjectTypeCallProperty;
            t.ObjectTypeIndexer = ObjectTypeIndexer;
            t.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
            t.ObjectTypeProperty = ObjectTypeProperty;
            t.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
            t.OpaqueType = OpaqueType;
            t.OptionalIndexedAccessType = OptionalIndexedAccessType;
            t.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
            Object.defineProperty(t, "StringLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return a.StringLiteral;
                }
            });
            t.StringTypeAnnotation = StringTypeAnnotation;
            t.SymbolTypeAnnotation = SymbolTypeAnnotation;
            t.ThisTypeAnnotation = ThisTypeAnnotation;
            t.TupleTypeAnnotation = TupleTypeAnnotation;
            t.TypeAlias = TypeAlias;
            t.TypeAnnotation = TypeAnnotation;
            t.TypeCastExpression = TypeCastExpression;
            t.TypeParameter = TypeParameter;
            t.TypeParameterDeclaration = t.TypeParameterInstantiation = TypeParameterInstantiation;
            t.TypeofTypeAnnotation = TypeofTypeAnnotation;
            t.UnionTypeAnnotation = UnionTypeAnnotation;
            t.Variance = Variance;
            t.VoidTypeAnnotation = VoidTypeAnnotation;
            t._interfaceish = _interfaceish;
            t._variance = _variance;
            var n = r(3061);
            var s = r(2415);
            var i = r(8694);
            var a = r(7154);
            const { isDeclareExportDeclaration: o, isStatement: l } = n;
            function AnyTypeAnnotation() {
                this.word("any");
            }
            function ArrayTypeAnnotation(e1) {
                this.print(e1.elementType, true);
                this.tokenChar(91);
                this.tokenChar(93);
            }
            function BooleanTypeAnnotation() {
                this.word("boolean");
            }
            function BooleanLiteralTypeAnnotation(e1) {
                this.word(e1.value ? "true" : "false");
            }
            function NullLiteralTypeAnnotation() {
                this.word("null");
            }
            function DeclareClass(e1, t) {
                if (!o(t)) {
                    this.word("declare");
                    this.space();
                }
                this.word("class");
                this.space();
                this._interfaceish(e1);
            }
            function DeclareFunction(e1, t) {
                if (!o(t)) {
                    this.word("declare");
                    this.space();
                }
                this.word("function");
                this.space();
                this.print(e1.id);
                this.print(e1.id.typeAnnotation.typeAnnotation);
                if (e1.predicate) {
                    this.space();
                    this.print(e1.predicate);
                }
                this.semicolon();
            }
            function InferredPredicate() {
                this.tokenChar(37);
                this.word("checks");
            }
            function DeclaredPredicate(e1) {
                this.tokenChar(37);
                this.word("checks");
                this.tokenChar(40);
                this.print(e1.value);
                this.tokenChar(41);
            }
            function DeclareInterface(e1) {
                this.word("declare");
                this.space();
                this.InterfaceDeclaration(e1);
            }
            function DeclareModule(e1) {
                this.word("declare");
                this.space();
                this.word("module");
                this.space();
                this.print(e1.id);
                this.space();
                this.print(e1.body);
            }
            function DeclareModuleExports(e1) {
                this.word("declare");
                this.space();
                this.word("module");
                this.tokenChar(46);
                this.word("exports");
                this.print(e1.typeAnnotation);
            }
            function DeclareTypeAlias(e1) {
                this.word("declare");
                this.space();
                this.TypeAlias(e1);
            }
            function DeclareOpaqueType(e1, t) {
                if (!o(t)) {
                    this.word("declare");
                    this.space();
                }
                this.OpaqueType(e1);
            }
            function DeclareVariable(e1, t) {
                if (!o(t)) {
                    this.word("declare");
                    this.space();
                }
                this.word("var");
                this.space();
                this.print(e1.id);
                this.print(e1.id.typeAnnotation);
                this.semicolon();
            }
            function DeclareExportDeclaration(e1) {
                this.word("declare");
                this.space();
                this.word("export");
                this.space();
                if (e1.default) {
                    this.word("default");
                    this.space();
                }
                FlowExportDeclaration.call(this, e1);
            }
            function DeclareExportAllDeclaration(e1) {
                this.word("declare");
                this.space();
                s.ExportAllDeclaration.call(this, e1);
            }
            function EnumDeclaration(e1) {
                const { id: t, body: r } = e1;
                this.word("enum");
                this.space();
                this.print(t);
                this.print(r);
            }
            function enumExplicitType(e1, t, r) {
                if (r) {
                    e1.space();
                    e1.word("of");
                    e1.space();
                    e1.word(t);
                }
                e1.space();
            }
            function enumBody(e1, t) {
                const { members: r } = t;
                e1.token("{");
                e1.indent();
                e1.newline();
                for (const t of r){
                    e1.print(t);
                    e1.newline();
                }
                if (t.hasUnknownMembers) {
                    e1.token("...");
                    e1.newline();
                }
                e1.dedent();
                e1.token("}");
            }
            function EnumBooleanBody(e1) {
                const { explicitType: t } = e1;
                enumExplicitType(this, "boolean", t);
                enumBody(this, e1);
            }
            function EnumNumberBody(e1) {
                const { explicitType: t } = e1;
                enumExplicitType(this, "number", t);
                enumBody(this, e1);
            }
            function EnumStringBody(e1) {
                const { explicitType: t } = e1;
                enumExplicitType(this, "string", t);
                enumBody(this, e1);
            }
            function EnumSymbolBody(e1) {
                enumExplicitType(this, "symbol", true);
                enumBody(this, e1);
            }
            function EnumDefaultedMember(e1) {
                const { id: t } = e1;
                this.print(t);
                this.tokenChar(44);
            }
            function enumInitializedMember(e1, t) {
                e1.print(t.id);
                e1.space();
                e1.token("=");
                e1.space();
                e1.print(t.init);
                e1.token(",");
            }
            function EnumBooleanMember(e1) {
                enumInitializedMember(this, e1);
            }
            function EnumNumberMember(e1) {
                enumInitializedMember(this, e1);
            }
            function EnumStringMember(e1) {
                enumInitializedMember(this, e1);
            }
            function FlowExportDeclaration(e1) {
                if (e1.declaration) {
                    const t = e1.declaration;
                    this.print(t);
                    if (!l(t)) this.semicolon();
                } else {
                    this.tokenChar(123);
                    if (e1.specifiers.length) {
                        this.space();
                        this.printList(e1.specifiers);
                        this.space();
                    }
                    this.tokenChar(125);
                    if (e1.source) {
                        this.space();
                        this.word("from");
                        this.space();
                        this.print(e1.source);
                    }
                    this.semicolon();
                }
            }
            function ExistsTypeAnnotation() {
                this.tokenChar(42);
            }
            function FunctionTypeAnnotation(e1, t) {
                this.print(e1.typeParameters);
                this.tokenChar(40);
                if (e1.this) {
                    this.word("this");
                    this.tokenChar(58);
                    this.space();
                    this.print(e1.this.typeAnnotation);
                    if (e1.params.length || e1.rest) {
                        this.tokenChar(44);
                        this.space();
                    }
                }
                this.printList(e1.params);
                if (e1.rest) {
                    if (e1.params.length) {
                        this.tokenChar(44);
                        this.space();
                    }
                    this.token("...");
                    this.print(e1.rest);
                }
                this.tokenChar(41);
                const r = t == null ? void 0 : t.type;
                if (r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" && t.method)) {
                    this.tokenChar(58);
                } else {
                    this.space();
                    this.token("=>");
                }
                this.space();
                this.print(e1.returnType);
            }
            function FunctionTypeParam(e1) {
                this.print(e1.name);
                if (e1.optional) this.tokenChar(63);
                if (e1.name) {
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.typeAnnotation);
            }
            function InterfaceExtends(e1) {
                this.print(e1.id);
                this.print(e1.typeParameters, true);
            }
            function _interfaceish(e1) {
                var t;
                this.print(e1.id);
                this.print(e1.typeParameters);
                if ((t = e1.extends) != null && t.length) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.printList(e1.extends);
                }
                if (e1.type === "DeclareClass") {
                    var r, n;
                    if ((r = e1.mixins) != null && r.length) {
                        this.space();
                        this.word("mixins");
                        this.space();
                        this.printList(e1.mixins);
                    }
                    if ((n = e1.implements) != null && n.length) {
                        this.space();
                        this.word("implements");
                        this.space();
                        this.printList(e1.implements);
                    }
                }
                this.space();
                this.print(e1.body);
            }
            function _variance(e1) {
                var t;
                const r = (t = e1.variance) == null ? void 0 : t.kind;
                if (r != null) {
                    if (r === "plus") {
                        this.tokenChar(43);
                    } else if (r === "minus") {
                        this.tokenChar(45);
                    }
                }
            }
            function InterfaceDeclaration(e1) {
                this.word("interface");
                this.space();
                this._interfaceish(e1);
            }
            function andSeparator(e1) {
                this.space();
                this.token("&", false, e1);
                this.space();
            }
            function InterfaceTypeAnnotation(e1) {
                var t;
                this.word("interface");
                if ((t = e1.extends) != null && t.length) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.printList(e1.extends);
                }
                this.space();
                this.print(e1.body);
            }
            function IntersectionTypeAnnotation(e1) {
                this.printJoin(e1.types, undefined, undefined, andSeparator);
            }
            function MixedTypeAnnotation() {
                this.word("mixed");
            }
            function EmptyTypeAnnotation() {
                this.word("empty");
            }
            function NullableTypeAnnotation(e1) {
                this.tokenChar(63);
                this.print(e1.typeAnnotation);
            }
            function NumberTypeAnnotation() {
                this.word("number");
            }
            function StringTypeAnnotation() {
                this.word("string");
            }
            function ThisTypeAnnotation() {
                this.word("this");
            }
            function TupleTypeAnnotation(e1) {
                this.tokenChar(91);
                this.printList(e1.types);
                this.tokenChar(93);
            }
            function TypeofTypeAnnotation(e1) {
                this.word("typeof");
                this.space();
                this.print(e1.argument);
            }
            function TypeAlias(e1) {
                this.word("type");
                this.space();
                this.print(e1.id);
                this.print(e1.typeParameters);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(e1.right);
                this.semicolon();
            }
            function TypeAnnotation(e1, t) {
                this.tokenChar(58);
                this.space();
                if (t.type === "ArrowFunctionExpression") {
                    this.tokenContext |= i.TokenContext.arrowFlowReturnType;
                } else if (e1.optional) {
                    this.tokenChar(63);
                }
                this.print(e1.typeAnnotation);
            }
            function TypeParameterInstantiation(e1) {
                this.tokenChar(60);
                this.printList(e1.params);
                this.tokenChar(62);
            }
            function TypeParameter(e1) {
                this._variance(e1);
                this.word(e1.name);
                if (e1.bound) {
                    this.print(e1.bound);
                }
                if (e1.default) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.default);
                }
            }
            function OpaqueType(e1) {
                this.word("opaque");
                this.space();
                this.word("type");
                this.space();
                this.print(e1.id);
                this.print(e1.typeParameters);
                if (e1.supertype) {
                    this.tokenChar(58);
                    this.space();
                    this.print(e1.supertype);
                }
                if (e1.impltype) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.impltype);
                }
                this.semicolon();
            }
            function ObjectTypeAnnotation(e1) {
                if (e1.exact) {
                    this.token("{|");
                } else {
                    this.tokenChar(123);
                }
                const t = [
                    ...e1.properties,
                    ...e1.callProperties || [],
                    ...e1.indexers || [],
                    ...e1.internalSlots || []
                ];
                if (t.length) {
                    this.newline();
                    this.space();
                    this.printJoin(t, true, true, undefined, undefined, function addNewlines(e1) {
                        if (e1 && !t[0]) return 1;
                    }, ()=>{
                        if (t.length !== 1 || e1.inexact) {
                            this.tokenChar(44);
                            this.space();
                        }
                    });
                    this.space();
                }
                if (e1.inexact) {
                    this.indent();
                    this.token("...");
                    if (t.length) {
                        this.newline();
                    }
                    this.dedent();
                }
                if (e1.exact) {
                    this.token("|}");
                } else {
                    this.tokenChar(125);
                }
            }
            function ObjectTypeInternalSlot(e1) {
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this.tokenChar(91);
                this.tokenChar(91);
                this.print(e1.id);
                this.tokenChar(93);
                this.tokenChar(93);
                if (e1.optional) this.tokenChar(63);
                if (!e1.method) {
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.value);
            }
            function ObjectTypeCallProperty(e1) {
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this.print(e1.value);
            }
            function ObjectTypeIndexer(e1) {
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this._variance(e1);
                this.tokenChar(91);
                if (e1.id) {
                    this.print(e1.id);
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.key);
                this.tokenChar(93);
                this.tokenChar(58);
                this.space();
                this.print(e1.value);
            }
            function ObjectTypeProperty(e1) {
                if (e1.proto) {
                    this.word("proto");
                    this.space();
                }
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                if (e1.kind === "get" || e1.kind === "set") {
                    this.word(e1.kind);
                    this.space();
                }
                this._variance(e1);
                this.print(e1.key);
                if (e1.optional) this.tokenChar(63);
                if (!e1.method) {
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.value);
            }
            function ObjectTypeSpreadProperty(e1) {
                this.token("...");
                this.print(e1.argument);
            }
            function QualifiedTypeIdentifier(e1) {
                this.print(e1.qualification);
                this.tokenChar(46);
                this.print(e1.id);
            }
            function SymbolTypeAnnotation() {
                this.word("symbol");
            }
            function orSeparator(e1) {
                this.space();
                this.token("|", false, e1);
                this.space();
            }
            function UnionTypeAnnotation(e1) {
                this.printJoin(e1.types, undefined, undefined, orSeparator);
            }
            function TypeCastExpression(e1) {
                this.tokenChar(40);
                this.print(e1.expression);
                this.print(e1.typeAnnotation);
                this.tokenChar(41);
            }
            function Variance(e1) {
                if (e1.kind === "plus") {
                    this.tokenChar(43);
                } else {
                    this.tokenChar(45);
                }
            }
            function VoidTypeAnnotation() {
                this.word("void");
            }
            function IndexedAccessType(e1) {
                this.print(e1.objectType, true);
                this.tokenChar(91);
                this.print(e1.indexType);
                this.tokenChar(93);
            }
            function OptionalIndexedAccessType(e1) {
                this.print(e1.objectType);
                if (e1.optional) {
                    this.token("?.");
                }
                this.tokenChar(91);
                this.print(e1.indexType);
                this.tokenChar(93);
            }
        },
        476: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(6826);
            Object.keys(n).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === n[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return n[e1];
                    }
                });
            });
            var s = r(1270);
            Object.keys(s).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === s[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return s[e1];
                    }
                });
            });
            var i = r(9213);
            Object.keys(i).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === i[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return i[e1];
                    }
                });
            });
            var a = r(5953);
            Object.keys(a).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === a[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return a[e1];
                    }
                });
            });
            var o = r(684);
            Object.keys(o).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === o[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return o[e1];
                    }
                });
            });
            var l = r(2415);
            Object.keys(l).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === l[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return l[e1];
                    }
                });
            });
            var c = r(7154);
            Object.keys(c).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === c[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return c[e1];
                    }
                });
            });
            var p = r(299);
            Object.keys(p).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === p[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return p[e1];
                    }
                });
            });
            var u = r(1647);
            Object.keys(u).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === u[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return u[e1];
                    }
                });
            });
            var d = r(2647);
            Object.keys(d).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === d[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return d[e1];
                    }
                });
            });
            var f = r(7544);
            Object.keys(f).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === f[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return f[e1];
                    }
                });
            });
        },
        2647: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.JSXAttribute = JSXAttribute;
            t.JSXClosingElement = JSXClosingElement;
            t.JSXClosingFragment = JSXClosingFragment;
            t.JSXElement = JSXElement;
            t.JSXEmptyExpression = JSXEmptyExpression;
            t.JSXExpressionContainer = JSXExpressionContainer;
            t.JSXFragment = JSXFragment;
            t.JSXIdentifier = JSXIdentifier;
            t.JSXMemberExpression = JSXMemberExpression;
            t.JSXNamespacedName = JSXNamespacedName;
            t.JSXOpeningElement = JSXOpeningElement;
            t.JSXOpeningFragment = JSXOpeningFragment;
            t.JSXSpreadAttribute = JSXSpreadAttribute;
            t.JSXSpreadChild = JSXSpreadChild;
            t.JSXText = JSXText;
            function JSXAttribute(e1) {
                this.print(e1.name);
                if (e1.value) {
                    this.tokenChar(61);
                    this.print(e1.value);
                }
            }
            function JSXIdentifier(e1) {
                this.word(e1.name);
            }
            function JSXNamespacedName(e1) {
                this.print(e1.namespace);
                this.tokenChar(58);
                this.print(e1.name);
            }
            function JSXMemberExpression(e1) {
                this.print(e1.object);
                this.tokenChar(46);
                this.print(e1.property);
            }
            function JSXSpreadAttribute(e1) {
                this.tokenChar(123);
                this.token("...");
                this.print(e1.argument);
                this.rightBrace(e1);
            }
            function JSXExpressionContainer(e1) {
                this.tokenChar(123);
                this.print(e1.expression);
                this.rightBrace(e1);
            }
            function JSXSpreadChild(e1) {
                this.tokenChar(123);
                this.token("...");
                this.print(e1.expression);
                this.rightBrace(e1);
            }
            function JSXText(e1) {
                const t = this.getPossibleRaw(e1);
                if (t !== undefined) {
                    this.token(t, true);
                } else {
                    this.token(e1.value, true);
                }
            }
            function JSXElement(e1) {
                const t = e1.openingElement;
                this.print(t);
                if (t.selfClosing) return;
                this.indent();
                for (const t of e1.children){
                    this.print(t);
                }
                this.dedent();
                this.print(e1.closingElement);
            }
            function spaceSeparator() {
                this.space();
            }
            function JSXOpeningElement(e1) {
                this.tokenChar(60);
                this.print(e1.name);
                {
                    if (e1.typeArguments) {
                        this.print(e1.typeArguments);
                    }
                    this.print(e1.typeParameters);
                }
                if (e1.attributes.length > 0) {
                    this.space();
                    this.printJoin(e1.attributes, undefined, undefined, spaceSeparator);
                }
                if (e1.selfClosing) {
                    this.space();
                    this.tokenChar(47);
                }
                this.tokenChar(62);
            }
            function JSXClosingElement(e1) {
                this.tokenChar(60);
                this.tokenChar(47);
                this.print(e1.name);
                this.tokenChar(62);
            }
            function JSXEmptyExpression() {
                this.printInnerComments();
            }
            function JSXFragment(e1) {
                this.print(e1.openingFragment);
                this.indent();
                for (const t of e1.children){
                    this.print(t);
                }
                this.dedent();
                this.print(e1.closingFragment);
            }
            function JSXOpeningFragment() {
                this.tokenChar(60);
                this.tokenChar(62);
            }
            function JSXClosingFragment() {
                this.token("</");
                this.tokenChar(62);
            }
        },
        684: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArrowFunctionExpression = ArrowFunctionExpression;
            t.FunctionDeclaration = t.FunctionExpression = FunctionExpression;
            t._functionHead = _functionHead;
            t._methodHead = _methodHead;
            t._param = _param;
            t._parameters = _parameters;
            t._params = _params;
            t._predicate = _predicate;
            t._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
            var n = r(3061);
            var s = r(8694);
            const { isIdentifier: i } = n;
            function _params(e1, t, r) {
                this.print(e1.typeParameters);
                const n = _getFuncIdName.call(this, t, r);
                if (n) {
                    this.sourceIdentifierName(n.name, n.pos);
                }
                this.tokenChar(40);
                this._parameters(e1.params, ")");
                const s = e1.type === "ArrowFunctionExpression";
                this.print(e1.returnType, s);
                this._noLineTerminator = s;
            }
            function _parameters(e1, t) {
                const r = this.enterDelimited();
                const n = this.shouldPrintTrailingComma(t);
                const s = e1.length;
                for(let t = 0; t < s; t++){
                    this._param(e1[t]);
                    if (n || t < s - 1) {
                        this.token(",", null, t);
                        this.space();
                    }
                }
                this.token(t);
                r();
            }
            function _param(e1) {
                this.printJoin(e1.decorators);
                this.print(e1);
                if (e1.optional) {
                    this.tokenChar(63);
                }
                this.print(e1.typeAnnotation);
            }
            function _methodHead(e1) {
                const t = e1.kind;
                const r = e1.key;
                if (t === "get" || t === "set") {
                    this.word(t);
                    this.space();
                }
                if (e1.async) {
                    this.word("async", true);
                    this.space();
                }
                if (t === "method" || t === "init") {
                    if (e1.generator) {
                        this.tokenChar(42);
                    }
                }
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(r);
                    this.tokenChar(93);
                } else {
                    this.print(r);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
                this._params(e1, e1.computed && e1.key.type !== "StringLiteral" ? undefined : e1.key, undefined);
            }
            function _predicate(e1, t) {
                if (e1.predicate) {
                    if (!e1.returnType) {
                        this.tokenChar(58);
                    }
                    this.space();
                    this.print(e1.predicate, t);
                }
            }
            function _functionHead(e1, t) {
                if (e1.async) {
                    this.word("async");
                    if (!this.format.preserveFormat) {
                        this._endsWithInnerRaw = false;
                    }
                    this.space();
                }
                this.word("function");
                if (e1.generator) {
                    if (!this.format.preserveFormat) {
                        this._endsWithInnerRaw = false;
                    }
                    this.tokenChar(42);
                }
                this.space();
                if (e1.id) {
                    this.print(e1.id);
                }
                this._params(e1, e1.id, t);
                if (e1.type !== "TSDeclareFunction") {
                    this._predicate(e1);
                }
            }
            function FunctionExpression(e1, t) {
                this._functionHead(e1, t);
                this.space();
                this.print(e1.body);
            }
            function ArrowFunctionExpression(e1, t) {
                if (e1.async) {
                    this.word("async", true);
                    this.space();
                }
                if (this._shouldPrintArrowParamsParens(e1)) {
                    this._params(e1, undefined, t);
                } else {
                    this.print(e1.params[0], true);
                }
                this._predicate(e1, true);
                this.space();
                this.printInnerComments();
                this.token("=>");
                this.space();
                this.tokenContext |= s.TokenContext.arrowBody;
                this.print(e1.body);
            }
            function _shouldPrintArrowParamsParens(e1) {
                var t, r;
                if (e1.params.length !== 1) return true;
                if (e1.typeParameters || e1.returnType || e1.predicate) {
                    return true;
                }
                const n = e1.params[0];
                if (!i(n) || n.typeAnnotation || n.optional || (t = n.leadingComments) != null && t.length || (r = n.trailingComments) != null && r.length) {
                    return true;
                }
                if (this.tokenMap) {
                    if (e1.loc == null) return true;
                    if (this.tokenMap.findMatching(e1, "(") !== null) return true;
                    const t = this.tokenMap.findMatching(e1, "=>");
                    if ((t == null ? void 0 : t.loc) == null) return true;
                    return t.loc.start.line !== e1.loc.start.line;
                }
                if (this.format.retainLines) return true;
                return false;
            }
            function _getFuncIdName(e1, t) {
                let r = e1;
                if (!r && t) {
                    const e1 = t.type;
                    if (e1 === "VariableDeclarator") {
                        r = t.id;
                    } else if (e1 === "AssignmentExpression" || e1 === "AssignmentPattern") {
                        r = t.left;
                    } else if (e1 === "ObjectProperty" || e1 === "ClassProperty") {
                        if (!t.computed || t.key.type === "StringLiteral") {
                            r = t.key;
                        }
                    } else if (e1 === "ClassPrivateProperty" || e1 === "ClassAccessorProperty") {
                        r = t.key;
                    }
                }
                if (!r) return;
                let n;
                if (r.type === "Identifier") {
                    var s, i;
                    n = {
                        pos: (s = r.loc) == null ? void 0 : s.start,
                        name: ((i = r.loc) == null ? void 0 : i.identifierName) || r.name
                    };
                } else if (r.type === "PrivateName") {
                    var a;
                    n = {
                        pos: (a = r.loc) == null ? void 0 : a.start,
                        name: "#" + r.id.name
                    };
                } else if (r.type === "StringLiteral") {
                    var o;
                    n = {
                        pos: (o = r.loc) == null ? void 0 : o.start,
                        name: r.value
                    };
                }
                return n;
            }
        },
        2415: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ExportAllDeclaration = ExportAllDeclaration;
            t.ExportDefaultDeclaration = ExportDefaultDeclaration;
            t.ExportDefaultSpecifier = ExportDefaultSpecifier;
            t.ExportNamedDeclaration = ExportNamedDeclaration;
            t.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
            t.ExportSpecifier = ExportSpecifier;
            t.ImportAttribute = ImportAttribute;
            t.ImportDeclaration = ImportDeclaration;
            t.ImportDefaultSpecifier = ImportDefaultSpecifier;
            t.ImportExpression = ImportExpression;
            t.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            t.ImportSpecifier = ImportSpecifier;
            t._printAttributes = _printAttributes;
            var n = r(3061);
            var s = r(8694);
            const { isClassDeclaration: i, isExportDefaultSpecifier: a, isExportNamespaceSpecifier: o, isImportDefaultSpecifier: l, isImportNamespaceSpecifier: c, isStatement: p } = n;
            function ImportSpecifier(e1) {
                if (e1.importKind === "type" || e1.importKind === "typeof") {
                    this.word(e1.importKind);
                    this.space();
                }
                this.print(e1.imported);
                if (e1.local && e1.local.name !== e1.imported.name) {
                    this.space();
                    this.word("as");
                    this.space();
                    this.print(e1.local);
                }
            }
            function ImportDefaultSpecifier(e1) {
                this.print(e1.local);
            }
            function ExportDefaultSpecifier(e1) {
                this.print(e1.exported);
            }
            function ExportSpecifier(e1) {
                if (e1.exportKind === "type") {
                    this.word("type");
                    this.space();
                }
                this.print(e1.local);
                if (e1.exported && e1.local.name !== e1.exported.name) {
                    this.space();
                    this.word("as");
                    this.space();
                    this.print(e1.exported);
                }
            }
            function ExportNamespaceSpecifier(e1) {
                this.tokenChar(42);
                this.space();
                this.word("as");
                this.space();
                this.print(e1.exported);
            }
            let u = false;
            function _printAttributes(e1, t) {
                var r;
                const { importAttributesKeyword: n } = this.format;
                const { attributes: s, assertions: i } = e1;
                if (s && !n && e1.extra && (e1.extra.deprecatedAssertSyntax || e1.extra.deprecatedWithLegacySyntax) && !u) {
                    u = true;
                    console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n');
                }
                const a = n === "assert" || !n && i;
                this.word(a ? "assert" : "with");
                this.space();
                if (!a && (n === "with-legacy" || !n && (r = e1.extra) != null && r.deprecatedWithLegacySyntax)) {
                    this.printList(s || i);
                    return;
                }
                const o = t ? 1 : 0;
                this.token("{", null, o);
                this.space();
                this.printList(s || i, this.shouldPrintTrailingComma("}"));
                this.space();
                this.token("}", null, o);
            }
            function ExportAllDeclaration(e1) {
                var t, r;
                this.word("export");
                this.space();
                if (e1.exportKind === "type") {
                    this.word("type");
                    this.space();
                }
                this.tokenChar(42);
                this.space();
                this.word("from");
                this.space();
                if ((t = e1.attributes) != null && t.length || (r = e1.assertions) != null && r.length) {
                    this.print(e1.source, true);
                    this.space();
                    this._printAttributes(e1, false);
                } else {
                    this.print(e1.source);
                }
                this.semicolon();
            }
            function maybePrintDecoratorsBeforeExport(e1, t) {
                if (i(t.declaration) && e1._shouldPrintDecoratorsBeforeExport(t)) {
                    e1.printJoin(t.declaration.decorators);
                }
            }
            function ExportNamedDeclaration(e1) {
                maybePrintDecoratorsBeforeExport(this, e1);
                this.word("export");
                this.space();
                if (e1.declaration) {
                    const t = e1.declaration;
                    this.print(t);
                    if (!p(t)) this.semicolon();
                } else {
                    if (e1.exportKind === "type") {
                        this.word("type");
                        this.space();
                    }
                    const n = e1.specifiers.slice(0);
                    let s = false;
                    for(;;){
                        const e1 = n[0];
                        if (a(e1) || o(e1)) {
                            s = true;
                            this.print(n.shift());
                            if (n.length) {
                                this.tokenChar(44);
                                this.space();
                            }
                        } else {
                            break;
                        }
                    }
                    let i = false;
                    if (n.length || !n.length && !s) {
                        i = true;
                        this.tokenChar(123);
                        if (n.length) {
                            this.space();
                            this.printList(n, this.shouldPrintTrailingComma("}"));
                            this.space();
                        }
                        this.tokenChar(125);
                    }
                    if (e1.source) {
                        var t, r;
                        this.space();
                        this.word("from");
                        this.space();
                        if ((t = e1.attributes) != null && t.length || (r = e1.assertions) != null && r.length) {
                            this.print(e1.source, true);
                            this.space();
                            this._printAttributes(e1, i);
                        } else {
                            this.print(e1.source);
                        }
                    }
                    this.semicolon();
                }
            }
            function ExportDefaultDeclaration(e1) {
                maybePrintDecoratorsBeforeExport(this, e1);
                this.word("export");
                this.noIndentInnerCommentsHere();
                this.space();
                this.word("default");
                this.space();
                this.tokenContext |= s.TokenContext.exportDefault;
                const t = e1.declaration;
                this.print(t);
                if (!p(t)) this.semicolon();
            }
            function ImportDeclaration(e1) {
                var t, r;
                this.word("import");
                this.space();
                const n = e1.importKind === "type" || e1.importKind === "typeof";
                if (n) {
                    this.noIndentInnerCommentsHere();
                    this.word(e1.importKind);
                    this.space();
                } else if (e1.module) {
                    this.noIndentInnerCommentsHere();
                    this.word("module");
                    this.space();
                } else if (e1.phase) {
                    this.noIndentInnerCommentsHere();
                    this.word(e1.phase);
                    this.space();
                }
                const s = e1.specifiers.slice(0);
                const i = !!s.length;
                while(i){
                    const e1 = s[0];
                    if (l(e1) || c(e1)) {
                        this.print(s.shift());
                        if (s.length) {
                            this.tokenChar(44);
                            this.space();
                        }
                    } else {
                        break;
                    }
                }
                let a = false;
                if (s.length) {
                    a = true;
                    this.tokenChar(123);
                    this.space();
                    this.printList(s, this.shouldPrintTrailingComma("}"));
                    this.space();
                    this.tokenChar(125);
                } else if (n && !i) {
                    a = true;
                    this.tokenChar(123);
                    this.tokenChar(125);
                }
                if (i || n) {
                    this.space();
                    this.word("from");
                    this.space();
                }
                if ((t = e1.attributes) != null && t.length || (r = e1.assertions) != null && r.length) {
                    this.print(e1.source, true);
                    this.space();
                    this._printAttributes(e1, a);
                } else {
                    this.print(e1.source);
                }
                this.semicolon();
            }
            function ImportAttribute(e1) {
                this.print(e1.key);
                this.tokenChar(58);
                this.space();
                this.print(e1.value);
            }
            function ImportNamespaceSpecifier(e1) {
                this.tokenChar(42);
                this.space();
                this.word("as");
                this.space();
                this.print(e1.local);
            }
            function ImportExpression(e1) {
                this.word("import");
                if (e1.phase) {
                    this.tokenChar(46);
                    this.word(e1.phase);
                }
                this.tokenChar(40);
                this.print(e1.source);
                if (e1.options != null) {
                    this.tokenChar(44);
                    this.space();
                    this.print(e1.options);
                }
                this.tokenChar(41);
            }
        },
        9213: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BreakStatement = BreakStatement;
            t.CatchClause = CatchClause;
            t.ContinueStatement = ContinueStatement;
            t.DebuggerStatement = DebuggerStatement;
            t.DoWhileStatement = DoWhileStatement;
            t.ForOfStatement = t.ForInStatement = void 0;
            t.ForStatement = ForStatement;
            t.IfStatement = IfStatement;
            t.LabeledStatement = LabeledStatement;
            t.ReturnStatement = ReturnStatement;
            t.SwitchCase = SwitchCase;
            t.SwitchStatement = SwitchStatement;
            t.ThrowStatement = ThrowStatement;
            t.TryStatement = TryStatement;
            t.VariableDeclaration = VariableDeclaration;
            t.VariableDeclarator = VariableDeclarator;
            t.WhileStatement = WhileStatement;
            t.WithStatement = WithStatement;
            var n = r(3061);
            var s = r(8694);
            const { isFor: i, isForStatement: a, isIfStatement: o, isStatement: l } = n;
            function WithStatement(e1) {
                this.word("with");
                this.space();
                this.tokenChar(40);
                this.print(e1.object);
                this.tokenChar(41);
                this.printBlock(e1);
            }
            function IfStatement(e1) {
                this.word("if");
                this.space();
                this.tokenChar(40);
                this.print(e1.test);
                this.tokenChar(41);
                this.space();
                const t = e1.alternate && o(getLastStatement(e1.consequent));
                if (t) {
                    this.tokenChar(123);
                    this.newline();
                    this.indent();
                }
                this.printAndIndentOnComments(e1.consequent);
                if (t) {
                    this.dedent();
                    this.newline();
                    this.tokenChar(125);
                }
                if (e1.alternate) {
                    if (this.endsWith(125)) this.space();
                    this.word("else");
                    this.space();
                    this.printAndIndentOnComments(e1.alternate);
                }
            }
            function getLastStatement(e1) {
                const { body: t } = e1;
                if (l(t) === false) {
                    return e1;
                }
                return getLastStatement(t);
            }
            function ForStatement(e1) {
                this.word("for");
                this.space();
                this.tokenChar(40);
                {
                    const t = this.enterForStatementInit();
                    this.tokenContext |= s.TokenContext.forHead;
                    this.print(e1.init);
                    t();
                }
                this.tokenChar(59);
                if (e1.test) {
                    this.space();
                    this.print(e1.test);
                }
                this.token(";", false, 1);
                if (e1.update) {
                    this.space();
                    this.print(e1.update);
                }
                this.tokenChar(41);
                this.printBlock(e1);
            }
            function WhileStatement(e1) {
                this.word("while");
                this.space();
                this.tokenChar(40);
                this.print(e1.test);
                this.tokenChar(41);
                this.printBlock(e1);
            }
            function ForXStatement(e1) {
                this.word("for");
                this.space();
                const t = e1.type === "ForOfStatement";
                if (t && e1.await) {
                    this.word("await");
                    this.space();
                }
                this.noIndentInnerCommentsHere();
                this.tokenChar(40);
                {
                    const r = t ? null : this.enterForStatementInit();
                    this.tokenContext |= t ? s.TokenContext.forOfHead : s.TokenContext.forInHead;
                    this.print(e1.left);
                    r == null || r();
                }
                this.space();
                this.word(t ? "of" : "in");
                this.space();
                this.print(e1.right);
                this.tokenChar(41);
                this.printBlock(e1);
            }
            const c = t.ForInStatement = ForXStatement;
            const p = t.ForOfStatement = ForXStatement;
            function DoWhileStatement(e1) {
                this.word("do");
                this.space();
                this.print(e1.body);
                this.space();
                this.word("while");
                this.space();
                this.tokenChar(40);
                this.print(e1.test);
                this.tokenChar(41);
                this.semicolon();
            }
            function printStatementAfterKeyword(e1, t) {
                if (t) {
                    e1.space();
                    e1.printTerminatorless(t);
                }
                e1.semicolon();
            }
            function BreakStatement(e1) {
                this.word("break");
                printStatementAfterKeyword(this, e1.label);
            }
            function ContinueStatement(e1) {
                this.word("continue");
                printStatementAfterKeyword(this, e1.label);
            }
            function ReturnStatement(e1) {
                this.word("return");
                printStatementAfterKeyword(this, e1.argument);
            }
            function ThrowStatement(e1) {
                this.word("throw");
                printStatementAfterKeyword(this, e1.argument);
            }
            function LabeledStatement(e1) {
                this.print(e1.label);
                this.tokenChar(58);
                this.space();
                this.print(e1.body);
            }
            function TryStatement(e1) {
                this.word("try");
                this.space();
                this.print(e1.block);
                this.space();
                if (e1.handlers) {
                    this.print(e1.handlers[0]);
                } else {
                    this.print(e1.handler);
                }
                if (e1.finalizer) {
                    this.space();
                    this.word("finally");
                    this.space();
                    this.print(e1.finalizer);
                }
            }
            function CatchClause(e1) {
                this.word("catch");
                this.space();
                if (e1.param) {
                    this.tokenChar(40);
                    this.print(e1.param);
                    this.print(e1.param.typeAnnotation);
                    this.tokenChar(41);
                    this.space();
                }
                this.print(e1.body);
            }
            function SwitchStatement(e1) {
                this.word("switch");
                this.space();
                this.tokenChar(40);
                this.print(e1.discriminant);
                this.tokenChar(41);
                this.space();
                this.tokenChar(123);
                this.printSequence(e1.cases, true, undefined, function addNewlines(t, r) {
                    if (!t && e1.cases[e1.cases.length - 1] === r) return -1;
                });
                this.rightBrace(e1);
            }
            function SwitchCase(e1) {
                if (e1.test) {
                    this.word("case");
                    this.space();
                    this.print(e1.test);
                    this.tokenChar(58);
                } else {
                    this.word("default");
                    this.tokenChar(58);
                }
                if (e1.consequent.length) {
                    this.newline();
                    this.printSequence(e1.consequent, true);
                }
            }
            function DebuggerStatement() {
                this.word("debugger");
                this.semicolon();
            }
            function VariableDeclaration(e1, t) {
                if (e1.declare) {
                    this.word("declare");
                    this.space();
                }
                const { kind: r } = e1;
                if (r === "await using") {
                    this.word("await");
                    this.space();
                    this.word("using", true);
                } else {
                    this.word(r, r === "using");
                }
                this.space();
                let n = false;
                if (!i(t)) {
                    for (const t of e1.declarations){
                        if (t.init) {
                            n = true;
                        }
                    }
                }
                this.printList(e1.declarations, undefined, undefined, e1.declarations.length > 1, n ? function(e1) {
                    this.token(",", false, e1);
                    this.newline();
                } : undefined);
                if (i(t)) {
                    if (a(t)) {
                        if (t.init === e1) return;
                    } else {
                        if (t.left === e1) return;
                    }
                }
                this.semicolon();
            }
            function VariableDeclarator(e1) {
                this.print(e1.id);
                if (e1.definite) this.tokenChar(33);
                this.print(e1.id.typeAnnotation);
                if (e1.init) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.init);
                }
            }
        },
        6826: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TaggedTemplateExpression = TaggedTemplateExpression;
            t.TemplateElement = TemplateElement;
            t.TemplateLiteral = TemplateLiteral;
            t._printTemplate = _printTemplate;
            function TaggedTemplateExpression(e1) {
                this.print(e1.tag);
                {
                    this.print(e1.typeParameters);
                }
                this.print(e1.quasi);
            }
            function TemplateElement() {
                throw new Error("TemplateElement printing is handled in TemplateLiteral");
            }
            function _printTemplate(e1, t) {
                const r = e1.quasis;
                let n = "`";
                for(let s = 0; s < r.length - 1; s++){
                    n += r[s].value.raw;
                    this.token(n + "${", true);
                    this.print(t[s]);
                    n = "}";
                    if (this.tokenMap) {
                        const t = this.tokenMap.findMatching(e1, "}", s);
                        if (t) this._catchUpTo(t.loc.start);
                    }
                }
                n += r[r.length - 1].value.raw;
                this.token(n + "`", true);
            }
            function TemplateLiteral(e1) {
                this._printTemplate(e1, e1.expressions);
            }
        },
        7154: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArgumentPlaceholder = ArgumentPlaceholder;
            t.ArrayPattern = t.ArrayExpression = ArrayExpression;
            t.BigIntLiteral = BigIntLiteral;
            t.BooleanLiteral = BooleanLiteral;
            t.Identifier = Identifier;
            t.NullLiteral = NullLiteral;
            t.NumericLiteral = NumericLiteral;
            t.ObjectPattern = t.ObjectExpression = ObjectExpression;
            t.ObjectMethod = ObjectMethod;
            t.ObjectProperty = ObjectProperty;
            t.PipelineBareFunction = PipelineBareFunction;
            t.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
            t.PipelineTopicExpression = PipelineTopicExpression;
            t.RecordExpression = RecordExpression;
            t.RegExpLiteral = RegExpLiteral;
            t.SpreadElement = t.RestElement = RestElement;
            t.StringLiteral = StringLiteral;
            t.TopicReference = TopicReference;
            t.TupleExpression = TupleExpression;
            t._getRawIdentifier = _getRawIdentifier;
            var n = r(3061);
            var s = r(4849);
            const { isAssignmentPattern: i, isIdentifier: a } = n;
            let o = null;
            let l = "";
            function _getRawIdentifier(e1) {
                if (e1 === o) return l;
                o = e1;
                const { name: t } = e1;
                const r = this.tokenMap.find(e1, (e1)=>e1.value === t);
                if (r) {
                    l = this._originalCode.slice(r.start, r.end);
                    return l;
                }
                return l = e1.name;
            }
            function Identifier(e1) {
                var t;
                this.sourceIdentifierName(((t = e1.loc) == null ? void 0 : t.identifierName) || e1.name);
                this.word(this.tokenMap ? this._getRawIdentifier(e1) : e1.name);
            }
            function ArgumentPlaceholder() {
                this.tokenChar(63);
            }
            function RestElement(e1) {
                this.token("...");
                this.print(e1.argument);
            }
            function ObjectExpression(e1) {
                const t = e1.properties;
                this.tokenChar(123);
                if (t.length) {
                    const e1 = this.enterDelimited();
                    this.space();
                    this.printList(t, this.shouldPrintTrailingComma("}"), true, true);
                    this.space();
                    e1();
                }
                this.sourceWithOffset("end", e1.loc, -1);
                this.tokenChar(125);
            }
            function ObjectMethod(e1) {
                this.printJoin(e1.decorators);
                this._methodHead(e1);
                this.space();
                this.print(e1.body);
            }
            function ObjectProperty(e1) {
                this.printJoin(e1.decorators);
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(e1.key);
                    this.tokenChar(93);
                } else {
                    if (i(e1.value) && a(e1.key) && e1.key.name === e1.value.left.name) {
                        this.print(e1.value);
                        return;
                    }
                    this.print(e1.key);
                    if (e1.shorthand && a(e1.key) && a(e1.value) && e1.key.name === e1.value.name) {
                        return;
                    }
                }
                this.tokenChar(58);
                this.space();
                this.print(e1.value);
            }
            function ArrayExpression(e1) {
                const t = e1.elements;
                const r = t.length;
                this.tokenChar(91);
                const n = this.enterDelimited();
                for(let e1 = 0; e1 < t.length; e1++){
                    const n = t[e1];
                    if (n) {
                        if (e1 > 0) this.space();
                        this.print(n);
                        if (e1 < r - 1 || this.shouldPrintTrailingComma("]")) {
                            this.token(",", false, e1);
                        }
                    } else {
                        this.token(",", false, e1);
                    }
                }
                n();
                this.tokenChar(93);
            }
            function RecordExpression(e1) {
                const t = e1.properties;
                let r;
                let n;
                {
                    if (this.format.recordAndTupleSyntaxType === "bar") {
                        r = "{|";
                        n = "|}";
                    } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
                        throw new Error('The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" ('.concat(JSON.stringify(this.format.recordAndTupleSyntaxType), " received)."));
                    } else {
                        r = "#{";
                        n = "}";
                    }
                }
                this.token(r);
                if (t.length) {
                    this.space();
                    this.printList(t, this.shouldPrintTrailingComma(n), true, true);
                    this.space();
                }
                this.token(n);
            }
            function TupleExpression(e1) {
                const t = e1.elements;
                const r = t.length;
                let n;
                let s;
                {
                    if (this.format.recordAndTupleSyntaxType === "bar") {
                        n = "[|";
                        s = "|]";
                    } else if (this.format.recordAndTupleSyntaxType === "hash") {
                        n = "#[";
                        s = "]";
                    } else {
                        throw new Error("".concat(this.format.recordAndTupleSyntaxType, " is not a valid recordAndTuple syntax type"));
                    }
                }
                this.token(n);
                for(let e1 = 0; e1 < t.length; e1++){
                    const n = t[e1];
                    if (n) {
                        if (e1 > 0) this.space();
                        this.print(n);
                        if (e1 < r - 1 || this.shouldPrintTrailingComma(s)) {
                            this.token(",", false, e1);
                        }
                    }
                }
                this.token(s);
            }
            function RegExpLiteral(e1) {
                this.word("/".concat(e1.pattern, "/").concat(e1.flags));
            }
            function BooleanLiteral(e1) {
                this.word(e1.value ? "true" : "false");
            }
            function NullLiteral() {
                this.word("null");
            }
            function NumericLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                const r = this.format.jsescOption;
                const n = e1.value;
                const i = n + "";
                if (r.numbers) {
                    this.number(s(n, r), n);
                } else if (t == null) {
                    this.number(i, n);
                } else if (this.format.minified) {
                    this.number(t.length < i.length ? t : i, n);
                } else {
                    this.number(t, n);
                }
            }
            function StringLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.token(t);
                    return;
                }
                const r = s(e1.value, this.format.jsescOption);
                this.token(r);
            }
            function BigIntLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.word(t);
                    return;
                }
                this.word(e1.value + "n");
            }
            const c = new Set([
                "^^",
                "@@",
                "^",
                "%",
                "#"
            ]);
            function TopicReference() {
                const { topicToken: e1 } = this.format;
                if (c.has(e1)) {
                    this.token(e1);
                } else {
                    const t = JSON.stringify(e1);
                    const r = Array.from(c, (e1)=>JSON.stringify(e1));
                    throw new Error('The "topicToken" generator option must be one of ' + "".concat(r.join(", "), " (").concat(t, " received instead)."));
                }
            }
            function PipelineTopicExpression(e1) {
                this.print(e1.expression);
            }
            function PipelineBareFunction(e1) {
                this.print(e1.callee);
            }
            function PipelinePrimaryTopicReference() {
                this.tokenChar(35);
            }
        },
        7544: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TSAnyKeyword = TSAnyKeyword;
            t.TSArrayType = TSArrayType;
            t.TSSatisfiesExpression = t.TSAsExpression = TSTypeExpression;
            t.TSBigIntKeyword = TSBigIntKeyword;
            t.TSBooleanKeyword = TSBooleanKeyword;
            t.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
            t.TSInterfaceHeritage = t.TSClassImplements = TSClassImplements;
            t.TSConditionalType = TSConditionalType;
            t.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
            t.TSConstructorType = TSConstructorType;
            t.TSDeclareFunction = TSDeclareFunction;
            t.TSDeclareMethod = TSDeclareMethod;
            t.TSEnumBody = TSEnumBody;
            t.TSEnumDeclaration = TSEnumDeclaration;
            t.TSEnumMember = TSEnumMember;
            t.TSExportAssignment = TSExportAssignment;
            t.TSExternalModuleReference = TSExternalModuleReference;
            t.TSFunctionType = TSFunctionType;
            t.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
            t.TSImportType = TSImportType;
            t.TSIndexSignature = TSIndexSignature;
            t.TSIndexedAccessType = TSIndexedAccessType;
            t.TSInferType = TSInferType;
            t.TSInstantiationExpression = TSInstantiationExpression;
            t.TSInterfaceBody = TSInterfaceBody;
            t.TSInterfaceDeclaration = TSInterfaceDeclaration;
            t.TSIntersectionType = TSIntersectionType;
            t.TSIntrinsicKeyword = TSIntrinsicKeyword;
            t.TSLiteralType = TSLiteralType;
            t.TSMappedType = TSMappedType;
            t.TSMethodSignature = TSMethodSignature;
            t.TSModuleBlock = TSModuleBlock;
            t.TSModuleDeclaration = TSModuleDeclaration;
            t.TSNamedTupleMember = TSNamedTupleMember;
            t.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
            t.TSNeverKeyword = TSNeverKeyword;
            t.TSNonNullExpression = TSNonNullExpression;
            t.TSNullKeyword = TSNullKeyword;
            t.TSNumberKeyword = TSNumberKeyword;
            t.TSObjectKeyword = TSObjectKeyword;
            t.TSOptionalType = TSOptionalType;
            t.TSParameterProperty = TSParameterProperty;
            t.TSParenthesizedType = TSParenthesizedType;
            t.TSPropertySignature = TSPropertySignature;
            t.TSQualifiedName = TSQualifiedName;
            t.TSRestType = TSRestType;
            t.TSStringKeyword = TSStringKeyword;
            t.TSSymbolKeyword = TSSymbolKeyword;
            t.TSTemplateLiteralType = TSTemplateLiteralType;
            t.TSThisType = TSThisType;
            t.TSTupleType = TSTupleType;
            t.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
            t.TSTypeAnnotation = TSTypeAnnotation;
            t.TSTypeAssertion = TSTypeAssertion;
            t.TSTypeLiteral = TSTypeLiteral;
            t.TSTypeOperator = TSTypeOperator;
            t.TSTypeParameter = TSTypeParameter;
            t.TSTypeParameterDeclaration = t.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
            t.TSTypePredicate = TSTypePredicate;
            t.TSTypeQuery = TSTypeQuery;
            t.TSTypeReference = TSTypeReference;
            t.TSUndefinedKeyword = TSUndefinedKeyword;
            t.TSUnionType = TSUnionType;
            t.TSUnknownKeyword = TSUnknownKeyword;
            t.TSVoidKeyword = TSVoidKeyword;
            t.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
            t.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
            t.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
            t.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
            function TSTypeAnnotation(e1, t) {
                this.token((t.type === "TSFunctionType" || t.type === "TSConstructorType") && t.typeAnnotation === e1 ? "=>" : ":");
                this.space();
                if (e1.optional) this.tokenChar(63);
                this.print(e1.typeAnnotation);
            }
            function TSTypeParameterInstantiation(e1, t) {
                this.tokenChar(60);
                let r = t.type === "ArrowFunctionExpression" && e1.params.length === 1;
                if (this.tokenMap && e1.start != null && e1.end != null) {
                    r && (r = !!this.tokenMap.find(e1, (e1)=>this.tokenMap.matchesOriginal(e1, ",")));
                    r || (r = this.shouldPrintTrailingComma(">"));
                }
                this.printList(e1.params, r);
                this.tokenChar(62);
            }
            function TSTypeParameter(e1) {
                if (e1.in) {
                    this.word("in");
                    this.space();
                }
                if (e1.out) {
                    this.word("out");
                    this.space();
                }
                this.word(e1.name);
                if (e1.constraint) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.print(e1.constraint);
                }
                if (e1.default) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.default);
                }
            }
            function TSParameterProperty(e1) {
                if (e1.accessibility) {
                    this.word(e1.accessibility);
                    this.space();
                }
                if (e1.readonly) {
                    this.word("readonly");
                    this.space();
                }
                this._param(e1.parameter);
            }
            function TSDeclareFunction(e1, t) {
                if (e1.declare) {
                    this.word("declare");
                    this.space();
                }
                this._functionHead(e1, t);
                this.semicolon();
            }
            function TSDeclareMethod(e1) {
                this._classMethodHead(e1);
                this.semicolon();
            }
            function TSQualifiedName(e1) {
                this.print(e1.left);
                this.tokenChar(46);
                this.print(e1.right);
            }
            function TSCallSignatureDeclaration(e1) {
                this.tsPrintSignatureDeclarationBase(e1);
                maybePrintTrailingCommaOrSemicolon(this, e1);
            }
            function maybePrintTrailingCommaOrSemicolon(e1, t) {
                if (!e1.tokenMap || !t.start || !t.end) {
                    e1.semicolon();
                    return;
                }
                if (e1.tokenMap.endMatches(t, ",")) {
                    e1.token(",");
                } else if (e1.tokenMap.endMatches(t, ";")) {
                    e1.semicolon();
                }
            }
            function TSConstructSignatureDeclaration(e1) {
                this.word("new");
                this.space();
                this.tsPrintSignatureDeclarationBase(e1);
                maybePrintTrailingCommaOrSemicolon(this, e1);
            }
            function TSPropertySignature(e1) {
                const { readonly: t } = e1;
                if (t) {
                    this.word("readonly");
                    this.space();
                }
                this.tsPrintPropertyOrMethodName(e1);
                this.print(e1.typeAnnotation);
                maybePrintTrailingCommaOrSemicolon(this, e1);
            }
            function tsPrintPropertyOrMethodName(e1) {
                if (e1.computed) {
                    this.tokenChar(91);
                }
                this.print(e1.key);
                if (e1.computed) {
                    this.tokenChar(93);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
            }
            function TSMethodSignature(e1) {
                const { kind: t } = e1;
                if (t === "set" || t === "get") {
                    this.word(t);
                    this.space();
                }
                this.tsPrintPropertyOrMethodName(e1);
                this.tsPrintSignatureDeclarationBase(e1);
                maybePrintTrailingCommaOrSemicolon(this, e1);
            }
            function TSIndexSignature(e1) {
                const { readonly: t, static: r } = e1;
                if (r) {
                    this.word("static");
                    this.space();
                }
                if (t) {
                    this.word("readonly");
                    this.space();
                }
                this.tokenChar(91);
                this._parameters(e1.parameters, "]");
                this.print(e1.typeAnnotation);
                maybePrintTrailingCommaOrSemicolon(this, e1);
            }
            function TSAnyKeyword() {
                this.word("any");
            }
            function TSBigIntKeyword() {
                this.word("bigint");
            }
            function TSUnknownKeyword() {
                this.word("unknown");
            }
            function TSNumberKeyword() {
                this.word("number");
            }
            function TSObjectKeyword() {
                this.word("object");
            }
            function TSBooleanKeyword() {
                this.word("boolean");
            }
            function TSStringKeyword() {
                this.word("string");
            }
            function TSSymbolKeyword() {
                this.word("symbol");
            }
            function TSVoidKeyword() {
                this.word("void");
            }
            function TSUndefinedKeyword() {
                this.word("undefined");
            }
            function TSNullKeyword() {
                this.word("null");
            }
            function TSNeverKeyword() {
                this.word("never");
            }
            function TSIntrinsicKeyword() {
                this.word("intrinsic");
            }
            function TSThisType() {
                this.word("this");
            }
            function TSFunctionType(e1) {
                this.tsPrintFunctionOrConstructorType(e1);
            }
            function TSConstructorType(e1) {
                if (e1.abstract) {
                    this.word("abstract");
                    this.space();
                }
                this.word("new");
                this.space();
                this.tsPrintFunctionOrConstructorType(e1);
            }
            function tsPrintFunctionOrConstructorType(e1) {
                const { typeParameters: t } = e1;
                const r = e1.parameters;
                this.print(t);
                this.tokenChar(40);
                this._parameters(r, ")");
                this.space();
                const n = e1.typeAnnotation;
                this.print(n);
            }
            function TSTypeReference(e1) {
                const t = e1.typeParameters;
                this.print(e1.typeName, !!t);
                this.print(t);
            }
            function TSTypePredicate(e1) {
                if (e1.asserts) {
                    this.word("asserts");
                    this.space();
                }
                this.print(e1.parameterName);
                if (e1.typeAnnotation) {
                    this.space();
                    this.word("is");
                    this.space();
                    this.print(e1.typeAnnotation.typeAnnotation);
                }
            }
            function TSTypeQuery(e1) {
                this.word("typeof");
                this.space();
                this.print(e1.exprName);
                const t = e1.typeParameters;
                if (t) {
                    this.print(t);
                }
            }
            function TSTypeLiteral(e1) {
                printBraced(this, e1, ()=>this.printJoin(e1.members, true, true));
            }
            function TSArrayType(e1) {
                this.print(e1.elementType, true);
                this.tokenChar(91);
                this.tokenChar(93);
            }
            function TSTupleType(e1) {
                this.tokenChar(91);
                this.printList(e1.elementTypes, this.shouldPrintTrailingComma("]"));
                this.tokenChar(93);
            }
            function TSOptionalType(e1) {
                this.print(e1.typeAnnotation);
                this.tokenChar(63);
            }
            function TSRestType(e1) {
                this.token("...");
                this.print(e1.typeAnnotation);
            }
            function TSNamedTupleMember(e1) {
                this.print(e1.label);
                if (e1.optional) this.tokenChar(63);
                this.tokenChar(58);
                this.space();
                this.print(e1.elementType);
            }
            function TSUnionType(e1) {
                tsPrintUnionOrIntersectionType(this, e1, "|");
            }
            function TSIntersectionType(e1) {
                tsPrintUnionOrIntersectionType(this, e1, "&");
            }
            function tsPrintUnionOrIntersectionType(e1, t, r) {
                var n;
                let s = 0;
                if ((n = e1.tokenMap) != null && n.startMatches(t, r)) {
                    s = 1;
                    e1.token(r);
                }
                e1.printJoin(t.types, undefined, undefined, function(e1) {
                    this.space();
                    this.token(r, null, e1 + s);
                    this.space();
                });
            }
            function TSConditionalType(e1) {
                this.print(e1.checkType);
                this.space();
                this.word("extends");
                this.space();
                this.print(e1.extendsType);
                this.space();
                this.tokenChar(63);
                this.space();
                this.print(e1.trueType);
                this.space();
                this.tokenChar(58);
                this.space();
                this.print(e1.falseType);
            }
            function TSInferType(e1) {
                this.word("infer");
                this.print(e1.typeParameter);
            }
            function TSParenthesizedType(e1) {
                this.tokenChar(40);
                this.print(e1.typeAnnotation);
                this.tokenChar(41);
            }
            function TSTypeOperator(e1) {
                this.word(e1.operator);
                this.space();
                this.print(e1.typeAnnotation);
            }
            function TSIndexedAccessType(e1) {
                this.print(e1.objectType, true);
                this.tokenChar(91);
                this.print(e1.indexType);
                this.tokenChar(93);
            }
            function TSMappedType(e1) {
                const { nameType: t, optional: r, readonly: n, typeAnnotation: s } = e1;
                this.tokenChar(123);
                const i = this.enterDelimited();
                this.space();
                if (n) {
                    tokenIfPlusMinus(this, n);
                    this.word("readonly");
                    this.space();
                }
                this.tokenChar(91);
                {
                    this.word(e1.typeParameter.name);
                }
                this.space();
                this.word("in");
                this.space();
                {
                    this.print(e1.typeParameter.constraint);
                }
                if (t) {
                    this.space();
                    this.word("as");
                    this.space();
                    this.print(t);
                }
                this.tokenChar(93);
                if (r) {
                    tokenIfPlusMinus(this, r);
                    this.tokenChar(63);
                }
                if (s) {
                    this.tokenChar(58);
                    this.space();
                    this.print(s);
                }
                this.space();
                i();
                this.tokenChar(125);
            }
            function tokenIfPlusMinus(e1, t) {
                if (t !== true) {
                    e1.token(t);
                }
            }
            function TSTemplateLiteralType(e1) {
                this._printTemplate(e1, e1.types);
            }
            function TSLiteralType(e1) {
                this.print(e1.literal);
            }
            function TSClassImplements(e1) {
                this.print(e1.expression);
                this.print(e1.typeArguments);
            }
            function TSInterfaceDeclaration(e1) {
                const { declare: t, id: r, typeParameters: n, extends: s, body: i } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                this.word("interface");
                this.space();
                this.print(r);
                this.print(n);
                if (s != null && s.length) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.printList(s);
                }
                this.space();
                this.print(i);
            }
            function TSInterfaceBody(e1) {
                printBraced(this, e1, ()=>this.printJoin(e1.body, true, true));
            }
            function TSTypeAliasDeclaration(e1) {
                const { declare: t, id: r, typeParameters: n, typeAnnotation: s } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                this.word("type");
                this.space();
                this.print(r);
                this.print(n);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(s);
                this.semicolon();
            }
            function TSTypeExpression(e1) {
                const { type: t, expression: r, typeAnnotation: n } = e1;
                this.print(r, true);
                this.space();
                this.word(t === "TSAsExpression" ? "as" : "satisfies");
                this.space();
                this.print(n);
            }
            function TSTypeAssertion(e1) {
                const { typeAnnotation: t, expression: r } = e1;
                this.tokenChar(60);
                this.print(t);
                this.tokenChar(62);
                this.space();
                this.print(r);
            }
            function TSInstantiationExpression(e1) {
                this.print(e1.expression);
                {
                    this.print(e1.typeParameters);
                }
            }
            function TSEnumDeclaration(e1) {
                const { declare: t, const: r, id: n } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                if (r) {
                    this.word("const");
                    this.space();
                }
                this.word("enum");
                this.space();
                this.print(n);
                this.space();
                {
                    TSEnumBody.call(this, e1);
                }
            }
            function TSEnumBody(e1) {
                printBraced(this, e1, ()=>{
                    var t;
                    return this.printList(e1.members, (t = this.shouldPrintTrailingComma("}")) != null ? t : true, true, true);
                });
            }
            function TSEnumMember(e1) {
                const { id: t, initializer: r } = e1;
                this.print(t);
                if (r) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(r);
                }
            }
            function TSModuleDeclaration(e1) {
                const { declare: t, id: r, kind: n } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                {
                    if (!e1.global) {
                        this.word(n != null ? n : r.type === "Identifier" ? "namespace" : "module");
                        this.space();
                    }
                    this.print(r);
                    if (!e1.body) {
                        this.semicolon();
                        return;
                    }
                    let t = e1.body;
                    while(t.type === "TSModuleDeclaration"){
                        this.tokenChar(46);
                        this.print(t.id);
                        t = t.body;
                    }
                    this.space();
                    this.print(t);
                }
            }
            function TSModuleBlock(e1) {
                printBraced(this, e1, ()=>this.printSequence(e1.body, true));
            }
            function TSImportType(e1) {
                const { argument: t, qualifier: r, options: n } = e1;
                this.word("import");
                this.tokenChar(40);
                this.print(t);
                if (n) {
                    this.tokenChar(44);
                    this.print(n);
                }
                this.tokenChar(41);
                if (r) {
                    this.tokenChar(46);
                    this.print(r);
                }
                const s = e1.typeParameters;
                if (s) {
                    this.print(s);
                }
            }
            function TSImportEqualsDeclaration(e1) {
                const { id: t, moduleReference: r } = e1;
                if (e1.isExport) {
                    this.word("export");
                    this.space();
                }
                this.word("import");
                this.space();
                this.print(t);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(r);
                this.semicolon();
            }
            function TSExternalModuleReference(e1) {
                this.token("require(");
                this.print(e1.expression);
                this.tokenChar(41);
            }
            function TSNonNullExpression(e1) {
                this.print(e1.expression);
                this.tokenChar(33);
            }
            function TSExportAssignment(e1) {
                this.word("export");
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(e1.expression);
                this.semicolon();
            }
            function TSNamespaceExportDeclaration(e1) {
                this.word("export");
                this.space();
                this.word("as");
                this.space();
                this.word("namespace");
                this.space();
                this.print(e1.id);
                this.semicolon();
            }
            function tsPrintSignatureDeclarationBase(e1) {
                const { typeParameters: t } = e1;
                const r = e1.parameters;
                this.print(t);
                this.tokenChar(40);
                this._parameters(r, ")");
                const n = e1.typeAnnotation;
                this.print(n);
            }
            function tsPrintClassMemberModifiers(e1) {
                const t = e1.type === "ClassPrivateProperty";
                const r = e1.type === "ClassAccessorProperty" || e1.type === "ClassProperty";
                printModifiersList(this, e1, [
                    r && e1.declare && "declare",
                    !t && e1.accessibility
                ]);
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                printModifiersList(this, e1, [
                    !t && e1.abstract && "abstract",
                    !t && e1.override && "override",
                    (r || t) && e1.readonly && "readonly"
                ]);
            }
            function printBraced(e1, t, r) {
                e1.token("{");
                const n = e1.enterDelimited();
                r();
                n();
                e1.rightBrace(t);
            }
            function printModifiersList(e1, t, r) {
                var n;
                const s = new Set;
                for (const e1 of r){
                    if (e1) s.add(e1);
                }
                (n = e1.tokenMap) == null || n.find(t, (t)=>{
                    if (s.has(t.value)) {
                        e1.token(t.value);
                        e1.space();
                        s.delete(t.value);
                        return s.size === 0;
                    }
                });
                for (const t of s){
                    e1.word(t);
                    e1.space();
                }
            }
        },
        1605: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            t.generate = generate;
            var n = r(3852);
            var s = r(1896);
            function normalizeOptions(e1, t, r) {
                if (t.experimental_preserveFormat) {
                    if (typeof e1 !== "string") {
                        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
                    }
                    if (!t.retainLines) {
                        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
                    }
                    if (t.compact && t.compact !== "auto") {
                        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
                    }
                    if (t.minified) {
                        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
                    }
                    if (t.jsescOption) {
                        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
                    }
                    if (!Array.isArray(r.tokens)) {
                        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
                    }
                }
                const n = {
                    auxiliaryCommentBefore: t.auxiliaryCommentBefore,
                    auxiliaryCommentAfter: t.auxiliaryCommentAfter,
                    shouldPrintComment: t.shouldPrintComment,
                    preserveFormat: t.experimental_preserveFormat,
                    retainLines: t.retainLines,
                    retainFunctionParens: t.retainFunctionParens,
                    comments: t.comments == null || t.comments,
                    compact: t.compact,
                    minified: t.minified,
                    concise: t.concise,
                    indent: {
                        adjustMultilineComment: true,
                        style: "  "
                    },
                    jsescOption: Object.assign({
                        quotes: "double",
                        wrap: true,
                        minimal: false
                    }, t.jsescOption),
                    topicToken: t.topicToken,
                    importAttributesKeyword: t.importAttributesKeyword
                };
                {
                    var s;
                    n.decoratorsBeforeExport = t.decoratorsBeforeExport;
                    n.jsescOption.json = t.jsonCompatibleStrings;
                    n.recordAndTupleSyntaxType = (s = t.recordAndTupleSyntaxType) != null ? s : "hash";
                }
                if (n.minified) {
                    n.compact = true;
                    n.shouldPrintComment = n.shouldPrintComment || (()=>n.comments);
                } else {
                    n.shouldPrintComment = n.shouldPrintComment || ((e1)=>n.comments || e1.includes("@license") || e1.includes("@preserve"));
                }
                if (n.compact === "auto") {
                    n.compact = typeof e1 === "string" && e1.length > 5e5;
                    if (n.compact) {
                        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + "".concat(t.filename, " as it exceeds the max of ", "500KB", "."));
                    }
                }
                if (n.compact || n.preserveFormat) {
                    n.indent.adjustMultilineComment = false;
                }
                const { auxiliaryCommentBefore: i, auxiliaryCommentAfter: a, shouldPrintComment: o } = n;
                if (i && !o(i)) {
                    n.auxiliaryCommentBefore = undefined;
                }
                if (a && !o(a)) {
                    n.auxiliaryCommentAfter = undefined;
                }
                return n;
            }
            {
                t.CodeGenerator = class CodeGenerator {
                    generate() {
                        const e1 = new s.default(this._format, this._map);
                        return e1.generate(this._ast);
                    }
                    constructor(e1, t = {}, r){
                        this._ast = void 0;
                        this._format = void 0;
                        this._map = void 0;
                        this._ast = e1;
                        this._format = normalizeOptions(r, t, e1);
                        this._map = t.sourceMaps ? new n.default(t, r) : null;
                    }
                };
            }
            function generate(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0;
                const i = normalizeOptions(r, t, e1);
                const a = t.sourceMaps ? new n.default(t, r) : null;
                const o = new s.default(i, a, e1.tokens, typeof r === "string" ? r : null);
                return o.generate(e1);
            }
            var i = t["default"] = generate;
        },
        8694: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TokenContext = void 0;
            t.isLastChild = isLastChild;
            t.needsParens = needsParens;
            t.needsWhitespace = needsWhitespace;
            t.needsWhitespaceAfter = needsWhitespaceAfter;
            t.needsWhitespaceBefore = needsWhitespaceBefore;
            var n = r(3232);
            var s = r(1818);
            var i = r(3061);
            const { FLIPPED_ALIAS_KEYS: a, VISITOR_KEYS: o, isCallExpression: l, isDecorator: c, isExpressionStatement: p, isMemberExpression: u, isNewExpression: d, isParenthesizedExpression: f } = i;
            const h = t.TokenContext = {
                expressionStatement: 1,
                arrowBody: 2,
                exportDefault: 4,
                forHead: 8,
                forInHead: 16,
                forOfHead: 32,
                arrowFlowReturnType: 64
            };
            function expandAliases(e1) {
                const t = new Map;
                function add(e1, r) {
                    const n = t.get(e1);
                    t.set(e1, n ? function(e1, t, s, i, a) {
                        var o;
                        return (o = n(e1, t, s, i, a)) != null ? o : r(e1, t, s, i, a);
                    } : r);
                }
                for (const t of Object.keys(e1)){
                    const r = a[t];
                    if (r) {
                        for (const n of r){
                            add(n, e1[t]);
                        }
                    } else {
                        add(t, e1[t]);
                    }
                }
                return t;
            }
            const m = expandAliases(s);
            const y = expandAliases(n.nodes);
            function isOrHasCallExpression(e1) {
                if (l(e1)) {
                    return true;
                }
                return u(e1) && isOrHasCallExpression(e1.object);
            }
            function needsWhitespace(e1, t, r) {
                var n;
                if (!e1) return false;
                if (p(e1)) {
                    e1 = e1.expression;
                }
                const s = (n = y.get(e1.type)) == null ? void 0 : n(e1, t);
                if (typeof s === "number") {
                    return (s & r) !== 0;
                }
                return false;
            }
            function needsWhitespaceBefore(e1, t) {
                return needsWhitespace(e1, t, 1);
            }
            function needsWhitespaceAfter(e1, t) {
                return needsWhitespace(e1, t, 2);
            }
            function needsParens(e1, t, r, n, s) {
                var i;
                if (!t) return false;
                if (d(t) && t.callee === e1) {
                    if (isOrHasCallExpression(e1)) return true;
                }
                if (c(t)) {
                    return !isDecoratorMemberExpression(e1) && !(l(e1) && isDecoratorMemberExpression(e1.callee)) && !f(e1);
                }
                return (i = m.get(e1.type)) == null ? void 0 : i(e1, t, r, n, s);
            }
            function isDecoratorMemberExpression(e1) {
                switch(e1.type){
                    case "Identifier":
                        return true;
                    case "MemberExpression":
                        return !e1.computed && e1.property.type === "Identifier" && isDecoratorMemberExpression(e1.object);
                    default:
                        return false;
                }
            }
            function isLastChild(e1, t) {
                const r = o[e1.type];
                for(let n = r.length - 1; n >= 0; n--){
                    const s = e1[r[n]];
                    if (s === t) {
                        return true;
                    } else if (Array.isArray(s)) {
                        let e1 = s.length - 1;
                        while(e1 >= 0 && s[e1] === null)e1--;
                        return e1 >= 0 && s[e1] === t;
                    } else if (s) {
                        return false;
                    }
                }
                return false;
            }
        },
        1818: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AssignmentExpression = AssignmentExpression;
            t.Binary = Binary;
            t.BinaryExpression = BinaryExpression;
            t.ClassExpression = ClassExpression;
            t.ArrowFunctionExpression = t.ConditionalExpression = ConditionalExpression;
            t.DoExpression = DoExpression;
            t.FunctionExpression = FunctionExpression;
            t.FunctionTypeAnnotation = FunctionTypeAnnotation;
            t.Identifier = Identifier;
            t.LogicalExpression = LogicalExpression;
            t.NullableTypeAnnotation = NullableTypeAnnotation;
            t.ObjectExpression = ObjectExpression;
            t.OptionalIndexedAccessType = OptionalIndexedAccessType;
            t.OptionalCallExpression = t.OptionalMemberExpression = OptionalMemberExpression;
            t.SequenceExpression = SequenceExpression;
            t.TSSatisfiesExpression = t.TSAsExpression = TSAsExpression;
            t.TSConditionalType = TSConditionalType;
            t.TSConstructorType = t.TSFunctionType = TSFunctionType;
            t.TSInferType = TSInferType;
            t.TSInstantiationExpression = TSInstantiationExpression;
            t.TSIntersectionType = TSIntersectionType;
            t.UnaryLike = t.TSTypeAssertion = UnaryLike;
            t.TSTypeOperator = TSTypeOperator;
            t.TSUnionType = TSUnionType;
            t.IntersectionTypeAnnotation = t.UnionTypeAnnotation = UnionTypeAnnotation;
            t.UpdateExpression = UpdateExpression;
            t.AwaitExpression = t.YieldExpression = YieldExpression;
            var n = r(3061);
            var s = r(8694);
            const { isArrayTypeAnnotation: i, isBinaryExpression: a, isCallExpression: o, isForOfStatement: l, isIndexedAccessType: c, isMemberExpression: p, isObjectPattern: u, isOptionalMemberExpression: d, isYieldExpression: f, isStatement: h } = n;
            const m = new Map([
                [
                    "||",
                    0
                ],
                [
                    "??",
                    0
                ],
                [
                    "|>",
                    0
                ],
                [
                    "&&",
                    1
                ],
                [
                    "|",
                    2
                ],
                [
                    "^",
                    3
                ],
                [
                    "&",
                    4
                ],
                [
                    "==",
                    5
                ],
                [
                    "===",
                    5
                ],
                [
                    "!=",
                    5
                ],
                [
                    "!==",
                    5
                ],
                [
                    "<",
                    6
                ],
                [
                    ">",
                    6
                ],
                [
                    "<=",
                    6
                ],
                [
                    ">=",
                    6
                ],
                [
                    "in",
                    6
                ],
                [
                    "instanceof",
                    6
                ],
                [
                    ">>",
                    7
                ],
                [
                    "<<",
                    7
                ],
                [
                    ">>>",
                    7
                ],
                [
                    "+",
                    8
                ],
                [
                    "-",
                    8
                ],
                [
                    "*",
                    9
                ],
                [
                    "/",
                    9
                ],
                [
                    "%",
                    9
                ],
                [
                    "**",
                    10
                ]
            ]);
            function getBinaryPrecedence(e1, t) {
                if (t === "BinaryExpression" || t === "LogicalExpression") {
                    return m.get(e1.operator);
                }
                if (t === "TSAsExpression" || t === "TSSatisfiesExpression") {
                    return m.get("in");
                }
            }
            function isTSTypeExpression(e1) {
                return e1 === "TSAsExpression" || e1 === "TSSatisfiesExpression" || e1 === "TSTypeAssertion";
            }
            const isClassExtendsClause = (e1, t)=>{
                const r = t.type;
                return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e1;
            };
            const hasPostfixPart = (e1, t)=>{
                const r = t.type;
                return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e1 || (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression") && t.callee === e1 || r === "TaggedTemplateExpression" && t.tag === e1 || r === "TSNonNullExpression";
            };
            function NullableTypeAnnotation(e1, t) {
                return i(t);
            }
            function FunctionTypeAnnotation(e1, t, r) {
                const n = t.type;
                return n === "UnionTypeAnnotation" || n === "IntersectionTypeAnnotation" || n === "ArrayTypeAnnotation" || Boolean(r & s.TokenContext.arrowFlowReturnType);
            }
            function UpdateExpression(e1, t) {
                return hasPostfixPart(e1, t) || isClassExtendsClause(e1, t);
            }
            function needsParenBeforeExpressionBrace(e1) {
                return Boolean(e1 & (s.TokenContext.expressionStatement | s.TokenContext.arrowBody));
            }
            function ObjectExpression(e1, t, r) {
                return needsParenBeforeExpressionBrace(r);
            }
            function DoExpression(e1, t, r) {
                return !e1.async && Boolean(r & s.TokenContext.expressionStatement);
            }
            function Binary(e1, t) {
                const r = t.type;
                if (e1.type === "BinaryExpression" && e1.operator === "**" && r === "BinaryExpression" && t.operator === "**") {
                    return t.left === e1;
                }
                if (isClassExtendsClause(e1, t)) {
                    return true;
                }
                if (hasPostfixPart(e1, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression") {
                    return true;
                }
                const n = getBinaryPrecedence(t, r);
                if (n != null) {
                    const s = getBinaryPrecedence(e1, e1.type);
                    if (n === s && r === "BinaryExpression" && t.right === e1 || n > s) {
                        return true;
                    }
                }
                return undefined;
            }
            function UnionTypeAnnotation(e1, t) {
                const r = t.type;
                return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
            }
            function OptionalIndexedAccessType(e1, t) {
                return c(t) && t.objectType === e1;
            }
            function TSAsExpression(e1, t) {
                if ((t.type === "AssignmentExpression" || t.type === "AssignmentPattern") && t.left === e1) {
                    return true;
                }
                if (t.type === "BinaryExpression" && (t.operator === "|" || t.operator === "&") && e1 === t.left) {
                    return true;
                }
                return Binary(e1, t);
            }
            function TSConditionalType(e1, t) {
                const r = t.type;
                if (r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e1 || r === "TSOptionalType" || r === "TSTypeOperator" || r === "TSTypeParameter") {
                    return true;
                }
                if ((r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e1) {
                    return true;
                }
                if (r === "TSConditionalType" && (t.checkType === e1 || t.extendsType === e1)) {
                    return true;
                }
                return false;
            }
            function TSUnionType(e1, t) {
                const r = t.type;
                return r === "TSIntersectionType" || r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e1 || r === "TSOptionalType";
            }
            function TSIntersectionType(e1, t) {
                const r = t.type;
                return r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e1 || r === "TSOptionalType";
            }
            function TSInferType(e1, t) {
                const r = t.type;
                if (r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e1 || r === "TSOptionalType") {
                    return true;
                }
                if (e1.typeParameter.constraint) {
                    if ((r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e1) {
                        return true;
                    }
                }
                return false;
            }
            function TSTypeOperator(e1, t) {
                const r = t.type;
                return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e1 || r === "TSOptionalType";
            }
            function TSInstantiationExpression(e1, t) {
                const r = t.type;
                return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
            }
            function TSFunctionType(e1, t) {
                const r = t.type;
                return r === "TSIntersectionType" || r === "TSUnionType" || r === "TSTypeOperator" || r === "TSOptionalType" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e1 || r === "TSConditionalType" && (t.checkType === e1 || t.extendsType === e1);
            }
            function BinaryExpression(e1, t, r, n) {
                return e1.operator === "in" && n;
            }
            function SequenceExpression(e1, t) {
                const r = t.type;
                if (r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && t.property === e1 || r === "OptionalMemberExpression" && t.property === e1 || r === "TemplateLiteral") {
                    return false;
                }
                if (r === "ClassDeclaration") {
                    return true;
                }
                if (r === "ForOfStatement") {
                    return t.right === e1;
                }
                if (r === "ExportDefaultDeclaration") {
                    return true;
                }
                return !h(t);
            }
            function YieldExpression(e1, t) {
                const r = t.type;
                return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || hasPostfixPart(e1, t) || r === "AwaitExpression" && f(e1) || r === "ConditionalExpression" && e1 === t.test || isClassExtendsClause(e1, t) || isTSTypeExpression(r);
            }
            function ClassExpression(e1, t, r) {
                return Boolean(r & (s.TokenContext.expressionStatement | s.TokenContext.exportDefault));
            }
            function UnaryLike(e1, t) {
                return hasPostfixPart(e1, t) || a(t) && t.operator === "**" && t.left === e1 || isClassExtendsClause(e1, t);
            }
            function FunctionExpression(e1, t, r) {
                return Boolean(r & (s.TokenContext.expressionStatement | s.TokenContext.exportDefault));
            }
            function ConditionalExpression(e1, t) {
                const r = t.type;
                if (r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalExpression" && t.test === e1 || r === "AwaitExpression" || isTSTypeExpression(r)) {
                    return true;
                }
                return UnaryLike(e1, t);
            }
            function OptionalMemberExpression(e1, t) {
                return o(t) && t.callee === e1 || p(t) && t.object === e1;
            }
            function AssignmentExpression(e1, t, r) {
                if (needsParenBeforeExpressionBrace(r) && u(e1.left)) {
                    return true;
                } else {
                    return ConditionalExpression(e1, t);
                }
            }
            function LogicalExpression(e1, t) {
                const r = t.type;
                if (isTSTypeExpression(r)) return true;
                if (r !== "LogicalExpression") return false;
                switch(e1.operator){
                    case "||":
                        return t.operator === "??" || t.operator === "&&";
                    case "&&":
                        return t.operator === "??";
                    case "??":
                        return t.operator !== "??";
                }
            }
            function Identifier(e1, t, r, n, i) {
                var a;
                const o = t.type;
                if ((a = e1.extra) != null && a.parenthesized && o === "AssignmentExpression" && t.left === e1) {
                    const e1 = t.right.type;
                    if ((e1 === "FunctionExpression" || e1 === "ClassExpression") && t.right.id == null) {
                        return true;
                    }
                }
                if (i && i(e1) !== e1.name) {
                    return false;
                }
                if (e1.name === "let") {
                    const n = p(t, {
                        object: e1,
                        computed: true
                    }) || d(t, {
                        object: e1,
                        computed: true,
                        optional: false
                    });
                    if (n && r & (s.TokenContext.expressionStatement | s.TokenContext.forHead | s.TokenContext.forInHead)) {
                        return true;
                    }
                    return Boolean(r & s.TokenContext.forOfHead);
                }
                return e1.name === "async" && l(t, {
                    left: e1,
                    await: false
                });
            }
        },
        3232: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.nodes = void 0;
            var n = r(3061);
            const { FLIPPED_ALIAS_KEYS: s, isArrayExpression: i, isAssignmentExpression: a, isBinary: o, isBlockStatement: l, isCallExpression: c, isFunction: p, isIdentifier: u, isLiteral: d, isMemberExpression: f, isObjectExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: y, isStringLiteral: g } = n;
            function crawlInternal(e1, t) {
                if (!e1) return t;
                if (f(e1) || y(e1)) {
                    crawlInternal(e1.object, t);
                    if (e1.computed) crawlInternal(e1.property, t);
                } else if (o(e1) || a(e1)) {
                    crawlInternal(e1.left, t);
                    crawlInternal(e1.right, t);
                } else if (c(e1) || m(e1)) {
                    t.hasCall = true;
                    crawlInternal(e1.callee, t);
                } else if (p(e1)) {
                    t.hasFunction = true;
                } else if (u(e1)) {
                    t.hasHelper = t.hasHelper || e1.callee && isHelper(e1.callee);
                }
                return t;
            }
            function crawl(e1) {
                return crawlInternal(e1, {
                    hasCall: false,
                    hasFunction: false,
                    hasHelper: false
                });
            }
            function isHelper(e1) {
                if (!e1) return false;
                if (f(e1)) {
                    return isHelper(e1.object) || isHelper(e1.property);
                } else if (u(e1)) {
                    return e1.name === "require" || e1.name.charCodeAt(0) === 95;
                } else if (c(e1)) {
                    return isHelper(e1.callee);
                } else if (o(e1) || a(e1)) {
                    return u(e1.left) && isHelper(e1.left) || isHelper(e1.right);
                } else {
                    return false;
                }
            }
            function isType(e1) {
                return d(e1) || h(e1) || i(e1) || u(e1) || f(e1);
            }
            const b = t.nodes = {
                AssignmentExpression (e1) {
                    const t = crawl(e1.right);
                    if (t.hasCall && t.hasHelper || t.hasFunction) {
                        return t.hasFunction ? 1 | 2 : 2;
                    }
                },
                SwitchCase (e1, t) {
                    return (!!e1.consequent.length || t.cases[0] === e1 ? 1 : 0) | (!e1.consequent.length && t.cases[t.cases.length - 1] === e1 ? 2 : 0);
                },
                LogicalExpression (e1) {
                    if (p(e1.left) || p(e1.right)) {
                        return 2;
                    }
                },
                Literal (e1) {
                    if (g(e1) && e1.value === "use strict") {
                        return 2;
                    }
                },
                CallExpression (e1) {
                    if (p(e1.callee) || isHelper(e1)) {
                        return 1 | 2;
                    }
                },
                OptionalCallExpression (e1) {
                    if (p(e1.callee)) {
                        return 1 | 2;
                    }
                },
                VariableDeclaration (e1) {
                    for(let t = 0; t < e1.declarations.length; t++){
                        const r = e1.declarations[t];
                        let n = isHelper(r.id) && !isType(r.init);
                        if (!n && r.init) {
                            const e1 = crawl(r.init);
                            n = isHelper(r.init) && e1.hasCall || e1.hasFunction;
                        }
                        if (n) {
                            return 1 | 2;
                        }
                    }
                },
                IfStatement (e1) {
                    if (l(e1.consequent)) {
                        return 1 | 2;
                    }
                }
            };
            b.ObjectProperty = b.ObjectTypeProperty = b.ObjectMethod = function(e1, t) {
                if (t.properties[0] === e1) {
                    return 1;
                }
            };
            b.ObjectTypeCallProperty = function(e1, t) {
                var r;
                if (t.callProperties[0] === e1 && !((r = t.properties) != null && r.length)) {
                    return 1;
                }
            };
            b.ObjectTypeIndexer = function(e1, t) {
                var r, n;
                if (t.indexers[0] === e1 && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length)) {
                    return 1;
                }
            };
            b.ObjectTypeInternalSlot = function(e1, t) {
                var r, n, s;
                if (t.internalSlots[0] === e1 && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length) && !((s = t.indexers) != null && s.length)) {
                    return 1;
                }
            };
            [
                [
                    "Function",
                    true
                ],
                [
                    "Class",
                    true
                ],
                [
                    "Loop",
                    true
                ],
                [
                    "LabeledStatement",
                    true
                ],
                [
                    "SwitchStatement",
                    true
                ],
                [
                    "TryStatement",
                    true
                ]
            ].forEach(function(param) {
                let [e1, t] = param;
                [
                    e1
                ].concat(s[e1] || []).forEach(function(e1) {
                    const r = t ? 1 | 2 : 0;
                    b[e1] = ()=>r;
                });
            });
        },
        1896: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(6031);
            var s = r(8694);
            var i = r(3061);
            var a = r(9694);
            var o = r(476);
            var l = r(2943);
            const { isExpression: c, isFunction: p, isStatement: u, isClassBody: d, isTSInterfaceBody: f, isTSEnumMember: h } = i;
            const m = /e/i;
            const y = /\.0+$/;
            const g = /[\n\r\u2028\u2029]/;
            const b = /[\n\r\u2028\u2029]|\*\//;
            function commentIsNewline(e1) {
                return e1.type === "CommentLine" || g.test(e1.value);
            }
            const { needsParens: T } = s;
            class Printer {
                enterForStatementInit() {
                    if (this.inForStatementInit) return ()=>{};
                    this.inForStatementInit = true;
                    return ()=>{
                        this.inForStatementInit = false;
                    };
                }
                enterDelimited() {
                    const e1 = this.inForStatementInit;
                    const t = this._noLineTerminatorAfterNode;
                    if (e1 === false && t === null) {
                        return ()=>{};
                    }
                    this.inForStatementInit = false;
                    this._noLineTerminatorAfterNode = null;
                    return ()=>{
                        this.inForStatementInit = e1;
                        this._noLineTerminatorAfterNode = t;
                    };
                }
                generate(e1) {
                    if (this.format.preserveFormat) {
                        this.tokenMap = new a.TokenMap(e1, this._tokens, this._originalCode);
                    }
                    this.print(e1);
                    this._maybeAddAuxComment();
                    return this._buf.get();
                }
                indent() {
                    const { format: e1 } = this;
                    if (e1.preserveFormat || e1.compact || e1.concise) {
                        return;
                    }
                    this._indent++;
                }
                dedent() {
                    const { format: e1 } = this;
                    if (e1.preserveFormat || e1.compact || e1.concise) {
                        return;
                    }
                    this._indent--;
                }
                semicolon() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    this._maybeAddAuxComment();
                    if (e1) {
                        this._appendChar(59);
                        this._noLineTerminator = false;
                        return;
                    }
                    if (this.tokenMap) {
                        const e1 = this._currentNode;
                        if (e1.start != null && e1.end != null) {
                            if (!this.tokenMap.endMatches(e1, ";")) {
                                this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
                                return;
                            }
                            const t = this.tokenMap.getIndexes(this._currentNode);
                            this._catchUpTo(this._tokens[t[t.length - 1]].loc.start);
                        }
                    }
                    this._queue(59);
                    this._noLineTerminator = false;
                }
                rightBrace(e1) {
                    if (this.format.minified) {
                        this._buf.removeLastSemicolon();
                    }
                    this.sourceWithOffset("end", e1.loc, -1);
                    this.tokenChar(125);
                }
                rightParens(e1) {
                    this.sourceWithOffset("end", e1.loc, -1);
                    this.tokenChar(41);
                }
                space() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    const { format: t } = this;
                    if (t.compact || t.preserveFormat) return;
                    if (e1) {
                        this._space();
                    } else if (this._buf.hasContent()) {
                        const e1 = this.getLastChar();
                        if (e1 !== 32 && e1 !== 10) {
                            this._space();
                        }
                    }
                }
                word(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    this.tokenContext = 0;
                    this._maybePrintInnerComments(e1);
                    this._maybeAddAuxComment();
                    if (this.tokenMap) this._catchUpToCurrentToken(e1);
                    if (this._endsWithWord || this._endsWithDiv && e1.charCodeAt(0) === 47) {
                        this._space();
                    }
                    this._append(e1, false);
                    this._endsWithWord = true;
                    this._noLineTerminator = t;
                }
                number(e1, t) {
                    function isNonDecimalLiteral(e1) {
                        if (e1.length > 2 && e1.charCodeAt(0) === 48) {
                            const t = e1.charCodeAt(1);
                            return t === 98 || t === 111 || t === 120;
                        }
                        return false;
                    }
                    this.word(e1);
                    this._endsWithInteger = Number.isInteger(t) && !isNonDecimalLiteral(e1) && !m.test(e1) && !y.test(e1) && e1.charCodeAt(e1.length - 1) !== 46;
                }
                token(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                    this.tokenContext = 0;
                    this._maybePrintInnerComments(e1, r);
                    this._maybeAddAuxComment();
                    if (this.tokenMap) this._catchUpToCurrentToken(e1, r);
                    const n = this.getLastChar();
                    const s = e1.charCodeAt(0);
                    if (n === 33 && (e1 === "--" || s === 61) || s === 43 && n === 43 || s === 45 && n === 45 || s === 46 && this._endsWithInteger) {
                        this._space();
                    }
                    this._append(e1, t);
                    this._noLineTerminator = false;
                }
                tokenChar(e1) {
                    this.tokenContext = 0;
                    const t = String.fromCharCode(e1);
                    this._maybePrintInnerComments(t);
                    this._maybeAddAuxComment();
                    if (this.tokenMap) this._catchUpToCurrentToken(t);
                    const r = this.getLastChar();
                    if (e1 === 43 && r === 43 || e1 === 45 && r === 45 || e1 === 46 && this._endsWithInteger) {
                        this._space();
                    }
                    this._appendChar(e1);
                    this._noLineTerminator = false;
                }
                newline() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, t = arguments.length > 1 ? arguments[1] : void 0;
                    if (e1 <= 0) return;
                    if (!t) {
                        if (this.format.retainLines || this.format.compact) return;
                        if (this.format.concise) {
                            this.space();
                            return;
                        }
                    }
                    if (e1 > 2) e1 = 2;
                    e1 -= this._buf.getNewlineCount();
                    for(let t = 0; t < e1; t++){
                        this._newline();
                    }
                    return;
                }
                endsWith(e1) {
                    return this.getLastChar() === e1;
                }
                getLastChar() {
                    return this._buf.getLastChar();
                }
                endsWithCharAndNewline() {
                    return this._buf.endsWithCharAndNewline();
                }
                removeTrailingNewline() {
                    this._buf.removeTrailingNewline();
                }
                exactSource(e1, t) {
                    if (!e1) {
                        t();
                        return;
                    }
                    this._catchUp("start", e1);
                    this._buf.exactSource(e1, t);
                }
                source(e1, t) {
                    if (!t) return;
                    this._catchUp(e1, t);
                    this._buf.source(e1, t);
                }
                sourceWithOffset(e1, t, r) {
                    if (!t || this.format.preserveFormat) return;
                    this._catchUp(e1, t);
                    this._buf.sourceWithOffset(e1, t, r);
                }
                sourceIdentifierName(e1, t) {
                    if (!this._buf._canMarkIdName) return;
                    const r = this._buf._sourcePosition;
                    r.identifierNamePos = t;
                    r.identifierName = e1;
                }
                _space() {
                    this._queue(32);
                }
                _newline() {
                    this._queue(10);
                }
                _catchUpToCurrentToken(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                    const r = this.tokenMap.findMatching(this._currentNode, e1, t);
                    if (r) this._catchUpTo(r.loc.start);
                    if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
                        this._buf.appendChar(59);
                        this._endsWithWord = false;
                        this._endsWithInteger = false;
                        this._endsWithDiv = false;
                    }
                    this._printSemicolonBeforeNextToken = -1;
                    this._printSemicolonBeforeNextNode = -1;
                }
                _append(e1, t) {
                    this._maybeIndent(e1.charCodeAt(0));
                    this._buf.append(e1, t);
                    this._endsWithWord = false;
                    this._endsWithInteger = false;
                    this._endsWithDiv = false;
                }
                _appendChar(e1) {
                    this._maybeIndent(e1);
                    this._buf.appendChar(e1);
                    this._endsWithWord = false;
                    this._endsWithInteger = false;
                    this._endsWithDiv = false;
                }
                _queue(e1) {
                    this._maybeIndent(e1);
                    this._buf.queue(e1);
                    this._endsWithWord = false;
                    this._endsWithInteger = false;
                }
                _maybeIndent(e1) {
                    if (this._indent && e1 !== 10 && this.endsWith(10)) {
                        this._buf.queueIndentation(this._getIndent());
                    }
                }
                _shouldIndent(e1) {
                    if (this._indent && e1 !== 10 && this.endsWith(10)) {
                        return true;
                    }
                }
                catchUp(e1) {
                    if (!this.format.retainLines) return;
                    const t = e1 - this._buf.getCurrentLine();
                    for(let e1 = 0; e1 < t; e1++){
                        this._newline();
                    }
                }
                _catchUp(e1, t) {
                    const { format: r } = this;
                    if (!r.preserveFormat) {
                        if (r.retainLines && t != null && t[e1]) {
                            this.catchUp(t[e1].line);
                        }
                        return;
                    }
                    const n = t == null ? void 0 : t[e1];
                    if (n != null) this._catchUpTo(n);
                }
                _catchUpTo(param) {
                    let { line: e1, column: t, index: r } = param;
                    const n = e1 - this._buf.getCurrentLine();
                    if (n > 0 && this._noLineTerminator) {
                        return;
                    }
                    for(let e1 = 0; e1 < n; e1++){
                        this._newline();
                    }
                    const s = n > 0 ? t : t - this._buf.getCurrentColumn();
                    if (s > 0) {
                        const e1 = this._originalCode ? this._originalCode.slice(r - s, r).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(s);
                        this._append(e1, false);
                    }
                }
                _getIndent() {
                    return this._indentRepeat * this._indent;
                }
                printTerminatorless(e1) {
                    this._noLineTerminator = true;
                    this.print(e1);
                }
                print(e1, t, r) {
                    var n, i, a;
                    if (!e1) return;
                    this._endsWithInnerRaw = false;
                    const o = e1.type;
                    const l = this.format;
                    const p = l.concise;
                    if (e1._compact) {
                        l.concise = true;
                    }
                    const u = this[o];
                    if (u === undefined) {
                        throw new ReferenceError("unknown node of type ".concat(JSON.stringify(o), " with constructor ").concat(JSON.stringify(e1.constructor.name)));
                    }
                    const d = this._currentNode;
                    this._currentNode = e1;
                    if (this.tokenMap) {
                        this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
                    }
                    const f = this._insideAux;
                    this._insideAux = e1.loc == null;
                    this._maybeAddAuxComment(this._insideAux && !f);
                    const h = (n = e1.extra) == null ? void 0 : n.parenthesized;
                    let m = h && l.preserveFormat || h && l.retainFunctionParens && o === "FunctionExpression" || T(e1, d, this.tokenContext, this.inForStatementInit, l.preserveFormat ? this._boundGetRawIdentifier : undefined);
                    if (!m && h && (i = e1.leadingComments) != null && i.length && e1.leadingComments[0].type === "CommentBlock") {
                        const t = d == null ? void 0 : d.type;
                        switch(t){
                            case "ExpressionStatement":
                            case "VariableDeclarator":
                            case "AssignmentExpression":
                            case "ReturnStatement":
                                break;
                            case "CallExpression":
                            case "OptionalCallExpression":
                            case "NewExpression":
                                if (d.callee !== e1) break;
                            default:
                                m = true;
                        }
                    }
                    let y = false;
                    if (!m && this._noLineTerminator && ((a = e1.leadingComments) != null && a.some(commentIsNewline) || this.format.retainLines && e1.loc && e1.loc.start.line > this._buf.getCurrentLine())) {
                        m = true;
                        y = true;
                    }
                    let g;
                    let b;
                    if (!m) {
                        t || (t = d && this._noLineTerminatorAfterNode === d && s.isLastChild(d, e1));
                        if (t) {
                            var S;
                            if ((S = e1.trailingComments) != null && S.some(commentIsNewline)) {
                                if (c(e1)) m = true;
                            } else {
                                g = this._noLineTerminatorAfterNode;
                                this._noLineTerminatorAfterNode = e1;
                            }
                        }
                    }
                    if (m) {
                        this.tokenChar(40);
                        if (y) this.indent();
                        this._endsWithInnerRaw = false;
                        if (this.inForStatementInit) {
                            b = true;
                            this.inForStatementInit = false;
                        }
                        g = this._noLineTerminatorAfterNode;
                        this._noLineTerminatorAfterNode = null;
                    }
                    this._lastCommentLine = 0;
                    this._printLeadingComments(e1, d);
                    const x = o === "Program" || o === "File" ? null : e1.loc;
                    this.exactSource(x, u.bind(this, e1, d));
                    if (m) {
                        this._printTrailingComments(e1, d);
                        if (y) {
                            this.dedent();
                            this.newline();
                        }
                        this.tokenChar(41);
                        this._noLineTerminator = t;
                        if (b) this.inForStatementInit = true;
                    } else if (t && !this._noLineTerminator) {
                        this._noLineTerminator = true;
                        this._printTrailingComments(e1, d);
                    } else {
                        this._printTrailingComments(e1, d, r);
                    }
                    this._currentNode = d;
                    l.concise = p;
                    this._insideAux = f;
                    if (g !== undefined) {
                        this._noLineTerminatorAfterNode = g;
                    }
                    this._endsWithInnerRaw = false;
                }
                _maybeAddAuxComment(e1) {
                    if (e1) this._printAuxBeforeComment();
                    if (!this._insideAux) this._printAuxAfterComment();
                }
                _printAuxBeforeComment() {
                    if (this._printAuxAfterOnNextUserNode) return;
                    this._printAuxAfterOnNextUserNode = true;
                    const e1 = this.format.auxiliaryCommentBefore;
                    if (e1) {
                        this._printComment({
                            type: "CommentBlock",
                            value: e1
                        }, 0);
                    }
                }
                _printAuxAfterComment() {
                    if (!this._printAuxAfterOnNextUserNode) return;
                    this._printAuxAfterOnNextUserNode = false;
                    const e1 = this.format.auxiliaryCommentAfter;
                    if (e1) {
                        this._printComment({
                            type: "CommentBlock",
                            value: e1
                        }, 0);
                    }
                }
                getPossibleRaw(e1) {
                    const t = e1.extra;
                    if ((t == null ? void 0 : t.raw) != null && t.rawValue != null && e1.value === t.rawValue) {
                        return t.raw;
                    }
                }
                printJoin(e1, t, r, n, s, i, a, o) {
                    if (!(e1 != null && e1.length)) return;
                    if (r == null && this.format.retainLines) {
                        var l;
                        const t = (l = e1[0].loc) == null ? void 0 : l.start.line;
                        if (t != null && t !== this._buf.getCurrentLine()) {
                            r = true;
                        }
                    }
                    if (r) this.indent();
                    const c = {
                        addNewlines: i,
                        nextNodeStartLine: 0
                    };
                    const p = n == null ? void 0 : n.bind(this);
                    const u = e1.length;
                    for(let r = 0; r < u; r++){
                        const n = e1[r];
                        if (!n) continue;
                        if (t) this._printNewline(r === 0, c);
                        this.print(n, undefined, o || 0);
                        a == null || a(n, r);
                        if (p != null) {
                            if (r < u - 1) p(r, false);
                            else if (s) p(r, true);
                        }
                        if (t) {
                            var d;
                            if (!((d = n.trailingComments) != null && d.length)) {
                                this._lastCommentLine = 0;
                            }
                            if (r + 1 === u) {
                                this.newline(1);
                            } else {
                                var f;
                                const t = e1[r + 1];
                                c.nextNodeStartLine = ((f = t.loc) == null ? void 0 : f.start.line) || 0;
                                this._printNewline(true, c);
                            }
                        }
                    }
                    if (r) this.dedent();
                }
                printAndIndentOnComments(e1) {
                    const t = e1.leadingComments && e1.leadingComments.length > 0;
                    if (t) this.indent();
                    this.print(e1);
                    if (t) this.dedent();
                }
                printBlock(e1) {
                    const t = e1.body;
                    if (t.type !== "EmptyStatement") {
                        this.space();
                    }
                    this.print(t);
                }
                _printTrailingComments(e1, t, r) {
                    const { innerComments: n, trailingComments: s } = e1;
                    if (n != null && n.length) {
                        this._printComments(2, n, e1, t, r);
                    }
                    if (s != null && s.length) {
                        this._printComments(2, s, e1, t, r);
                    }
                }
                _printLeadingComments(e1, t) {
                    const r = e1.leadingComments;
                    if (!(r != null && r.length)) return;
                    this._printComments(0, r, e1, t);
                }
                _maybePrintInnerComments(e1, t) {
                    if (this._endsWithInnerRaw) {
                        var r;
                        this.printInnerComments((r = this.tokenMap) == null ? void 0 : r.findMatching(this._currentNode, e1, t));
                    }
                    this._endsWithInnerRaw = true;
                    this._indentInnerComments = true;
                }
                printInnerComments(e1) {
                    const t = this._currentNode;
                    const r = t.innerComments;
                    if (!(r != null && r.length)) return;
                    const n = this.endsWith(32);
                    const s = this._indentInnerComments;
                    const i = this._printedComments.size;
                    if (s) this.indent();
                    this._printComments(1, r, t, undefined, undefined, e1);
                    if (n && i !== this._printedComments.size) {
                        this.space();
                    }
                    if (s) this.dedent();
                }
                noIndentInnerCommentsHere() {
                    this._indentInnerComments = false;
                }
                printSequence(e1, t, r, n) {
                    this.printJoin(e1, true, t != null ? t : false, undefined, undefined, n, undefined, r);
                }
                printList(e1, t, r, n, s, i) {
                    this.printJoin(e1, r, n, s != null ? s : commaSeparator, t, undefined, i);
                }
                shouldPrintTrailingComma(e1) {
                    if (!this.tokenMap) return null;
                    const t = this.tokenMap.findLastIndex(this._currentNode, (t)=>this.tokenMap.matchesOriginal(t, e1));
                    if (t <= 0) return null;
                    return this.tokenMap.matchesOriginal(this._tokens[t - 1], ",");
                }
                _printNewline(e1, t) {
                    const r = this.format;
                    if (r.retainLines || r.compact) return;
                    if (r.concise) {
                        this.space();
                        return;
                    }
                    if (!e1) {
                        return;
                    }
                    const n = t.nextNodeStartLine;
                    const s = this._lastCommentLine;
                    if (n > 0 && s > 0) {
                        const e1 = n - s;
                        if (e1 >= 0) {
                            this.newline(e1 || 1);
                            return;
                        }
                    }
                    if (this._buf.hasContent()) {
                        this.newline(1);
                    }
                }
                _shouldPrintComment(e1, t) {
                    if (e1.ignore) return 0;
                    if (this._printedComments.has(e1)) return 0;
                    if (this._noLineTerminator && b.test(e1.value)) {
                        return 2;
                    }
                    if (t && this.tokenMap) {
                        const r = this.tokenMap.find(this._currentNode, (t)=>t.value === e1.value);
                        if (r && r.start > t.start) {
                            return 2;
                        }
                    }
                    this._printedComments.add(e1);
                    if (!this.format.shouldPrintComment(e1.value)) {
                        return 0;
                    }
                    return 1;
                }
                _printComment(e1, t) {
                    const r = this._noLineTerminator;
                    const n = e1.type === "CommentBlock";
                    const s = n && t !== 1 && !this._noLineTerminator;
                    if (s && this._buf.hasContent() && t !== 2) {
                        this.newline(1);
                    }
                    const i = this.getLastChar();
                    if (i !== 91 && i !== 123 && i !== 40) {
                        this.space();
                    }
                    let a;
                    if (n) {
                        a = "/*".concat(e1.value, "*/");
                        if (this.format.indent.adjustMultilineComment) {
                            var o;
                            const t = (o = e1.loc) == null ? void 0 : o.start.column;
                            if (t) {
                                const e1 = new RegExp("\\n\\s{1," + t + "}", "g");
                                a = a.replace(e1, "\n");
                            }
                            if (this.format.concise) {
                                a = a.replace(/\n(?!$)/g, "\n");
                            } else {
                                let e1 = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                                if (this._shouldIndent(47) || this.format.retainLines) {
                                    e1 += this._getIndent();
                                }
                                a = a.replace(/\n(?!$)/g, "\n".concat(" ".repeat(e1)));
                            }
                        }
                    } else if (!r) {
                        a = "//".concat(e1.value);
                    } else {
                        a = "/*".concat(e1.value, "*/");
                    }
                    if (this._endsWithDiv) this._space();
                    if (this.tokenMap) {
                        const { _printSemicolonBeforeNextToken: t, _printSemicolonBeforeNextNode: r } = this;
                        this._printSemicolonBeforeNextToken = -1;
                        this._printSemicolonBeforeNextNode = -1;
                        this.source("start", e1.loc);
                        this._append(a, n);
                        this._printSemicolonBeforeNextNode = r;
                        this._printSemicolonBeforeNextToken = t;
                    } else {
                        this.source("start", e1.loc);
                        this._append(a, n);
                    }
                    if (!n && !r) {
                        this.newline(1, true);
                    }
                    if (s && t !== 3) {
                        this.newline(1);
                    }
                }
                _printComments(e1, t, r, n) {
                    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, i = arguments.length > 5 ? arguments[5] : void 0;
                    const a = r.loc;
                    const o = t.length;
                    let l = !!a;
                    const c = l ? a.start.line : 0;
                    const m = l ? a.end.line : 0;
                    let y = 0;
                    let b = 0;
                    const T = this._noLineTerminator ? function() {} : this.newline.bind(this);
                    for(let a = 0; a < o; a++){
                        const S = t[a];
                        const x = this._shouldPrintComment(S, i);
                        if (x === 2) {
                            l = false;
                            break;
                        }
                        if (l && S.loc && x === 1) {
                            const t = S.loc.start.line;
                            const r = S.loc.end.line;
                            if (e1 === 0) {
                                let e1 = 0;
                                if (a === 0) {
                                    if (this._buf.hasContent() && (S.type === "CommentLine" || t !== r)) {
                                        e1 = b = 1;
                                    }
                                } else {
                                    e1 = t - y;
                                }
                                y = r;
                                T(e1);
                                this._printComment(S, 1);
                                if (a + 1 === o) {
                                    T(Math.max(c - y, b));
                                    y = c;
                                }
                            } else if (e1 === 1) {
                                const e1 = t - (a === 0 ? c : y);
                                y = r;
                                T(e1);
                                this._printComment(S, 1);
                                if (a + 1 === o) {
                                    T(Math.min(1, m - y));
                                    y = m;
                                }
                            } else {
                                const e1 = t - (a === 0 ? m - s : y);
                                y = r;
                                T(e1);
                                this._printComment(S, 1);
                            }
                        } else {
                            l = false;
                            if (x !== 1) {
                                continue;
                            }
                            if (o === 1) {
                                const t = S.loc ? S.loc.start.line === S.loc.end.line : !g.test(S.value);
                                const s = t && !u(r) && !d(n) && !f(n) && !h(r);
                                if (e1 === 0) {
                                    this._printComment(S, s && r.type !== "ObjectExpression" || t && p(n, {
                                        body: r
                                    }) ? 1 : 0);
                                } else if (s && e1 === 2) {
                                    this._printComment(S, 1);
                                } else {
                                    this._printComment(S, 0);
                                }
                            } else if (e1 === 1 && !(r.type === "ObjectExpression" && r.properties.length > 1) && r.type !== "ClassBody" && r.type !== "TSInterfaceBody") {
                                this._printComment(S, a === 0 ? 2 : a === o - 1 ? 3 : 0);
                            } else {
                                this._printComment(S, 0);
                            }
                        }
                    }
                    if (e1 === 2 && l && y) {
                        this._lastCommentLine = y;
                    }
                }
                constructor(e1, t, r, s){
                    this.inForStatementInit = false;
                    this.tokenContext = 0;
                    this._tokens = null;
                    this._originalCode = null;
                    this._currentNode = null;
                    this._indent = 0;
                    this._indentRepeat = 0;
                    this._insideAux = false;
                    this._noLineTerminator = false;
                    this._noLineTerminatorAfterNode = null;
                    this._printAuxAfterOnNextUserNode = false;
                    this._printedComments = new Set;
                    this._endsWithInteger = false;
                    this._endsWithWord = false;
                    this._endsWithDiv = false;
                    this._lastCommentLine = 0;
                    this._endsWithInnerRaw = false;
                    this._indentInnerComments = true;
                    this.tokenMap = null;
                    this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
                    this._printSemicolonBeforeNextNode = -1;
                    this._printSemicolonBeforeNextToken = -1;
                    this.format = e1;
                    this._tokens = r;
                    this._originalCode = s;
                    this._indentRepeat = e1.indent.style.length;
                    this._inputMap = t == null ? void 0 : t._inputMap;
                    this._buf = new n.default(t, e1.indent.style[0]);
                }
            }
            Object.assign(Printer.prototype, o);
            {
                (0, l.addDeprecatedGenerators)(Printer);
            }
            var S = t["default"] = Printer;
            function commaSeparator(e1, t) {
                this.token(",", false, e1);
                if (!t) this.space();
            }
        },
        3852: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(7237);
            var s = r(8536);
            class SourceMap {
                get() {
                    return (0, n.toEncodedMap)(this._map);
                }
                getDecoded() {
                    return (0, n.toDecodedMap)(this._map);
                }
                getRawMappings() {
                    return this._rawMappings || (this._rawMappings = (0, n.allMappings)(this._map));
                }
                mark(e1, t, r, i, a, o) {
                    var l;
                    this._rawMappings = undefined;
                    let c;
                    if (t != null) {
                        if (this._inputMap) {
                            c = (0, s.originalPositionFor)(this._inputMap, {
                                line: t,
                                column: r
                            });
                            if (!c.name && a) {
                                const e1 = (0, s.originalPositionFor)(this._inputMap, a);
                                if (e1.name) {
                                    i = e1.name;
                                }
                            }
                        } else {
                            c = {
                                source: (o == null ? void 0 : o.replace(/\\/g, "/")) || this._sourceFileName,
                                line: t,
                                column: r
                            };
                        }
                    }
                    (0, n.maybeAddMapping)(this._map, {
                        name: i,
                        generated: e1,
                        source: (l = c) == null ? void 0 : l.source,
                        original: c
                    });
                }
                constructor(e1, t){
                    var r;
                    this._map = void 0;
                    this._rawMappings = void 0;
                    this._sourceFileName = void 0;
                    this._lastGenLine = 0;
                    this._lastSourceLine = 0;
                    this._lastSourceColumn = 0;
                    this._inputMap = void 0;
                    const i = this._map = new n.GenMapping({
                        sourceRoot: e1.sourceRoot
                    });
                    this._sourceFileName = (r = e1.sourceFileName) == null ? void 0 : r.replace(/\\/g, "/");
                    this._rawMappings = undefined;
                    if (e1.inputSourceMap) {
                        this._inputMap = new s.TraceMap(e1.inputSourceMap);
                        const t = this._inputMap.resolvedSources;
                        if (t.length) {
                            for(let e1 = 0; e1 < t.length; e1++){
                                var a;
                                (0, n.setSourceContent)(i, t[e1], (a = this._inputMap.sourcesContent) == null ? void 0 : a[e1]);
                            }
                        }
                    }
                    if (typeof t === "string" && !e1.inputSourceMap) {
                        (0, n.setSourceContent)(i, this._sourceFileName, t);
                    } else if (typeof t === "object") {
                        for (const e1 of Object.keys(t)){
                            (0, n.setSourceContent)(i, e1.replace(/\\/g, "/"), t[e1]);
                        }
                    }
                }
            }
            t["default"] = SourceMap;
        },
        9694: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TokenMap = void 0;
            var n = r(3061);
            const { traverseFast: s, VISITOR_KEYS: i } = n;
            class TokenMap {
                has(e1) {
                    return this._nodesToTokenIndexes.has(e1);
                }
                getIndexes(e1) {
                    return this._nodesToTokenIndexes.get(e1);
                }
                find(e1, t) {
                    const r = this._nodesToTokenIndexes.get(e1);
                    if (r) {
                        for(let e1 = 0; e1 < r.length; e1++){
                            const n = r[e1];
                            const s = this._tokens[n];
                            if (t(s, n)) return s;
                        }
                    }
                    return null;
                }
                findLastIndex(e1, t) {
                    const r = this._nodesToTokenIndexes.get(e1);
                    if (r) {
                        for(let e1 = r.length - 1; e1 >= 0; e1--){
                            const n = r[e1];
                            const s = this._tokens[n];
                            if (t(s, n)) return n;
                        }
                    }
                    return -1;
                }
                findMatching(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                    const n = this._nodesToTokenIndexes.get(e1);
                    if (n) {
                        let s = 0;
                        const i = r;
                        if (i > 1) {
                            const n = this._nodesOccurrencesCountCache.get(e1);
                            if (n && n.test === t && n.count < i) {
                                s = n.i + 1;
                                r -= n.count + 1;
                            }
                        }
                        for(; s < n.length; s++){
                            const a = this._tokens[n[s]];
                            if (this.matchesOriginal(a, t)) {
                                if (r === 0) {
                                    if (i > 0) {
                                        this._nodesOccurrencesCountCache.set(e1, {
                                            test: t,
                                            count: i,
                                            i: s
                                        });
                                    }
                                    return a;
                                }
                                r--;
                            }
                        }
                    }
                    return null;
                }
                matchesOriginal(e1, t) {
                    if (e1.end - e1.start !== t.length) return false;
                    if (e1.value != null) return e1.value === t;
                    return this._source.startsWith(t, e1.start);
                }
                startMatches(e1, t) {
                    const r = this._nodesToTokenIndexes.get(e1);
                    if (!r) return false;
                    const n = this._tokens[r[0]];
                    if (n.start !== e1.start) return false;
                    return this.matchesOriginal(n, t);
                }
                endMatches(e1, t) {
                    const r = this._nodesToTokenIndexes.get(e1);
                    if (!r) return false;
                    const n = this._tokens[r[r.length - 1]];
                    if (n.end !== e1.end) return false;
                    return this.matchesOriginal(n, t);
                }
                _getTokensIndexesOfNode(e1) {
                    if (e1.start == null || e1.end == null) return [];
                    const { first: t, last: r } = this._findTokensOfNode(e1, 0, this._tokens.length - 1);
                    let n = t;
                    const s = childrenIterator(e1);
                    if ((e1.type === "ExportNamedDeclaration" || e1.type === "ExportDefaultDeclaration") && e1.declaration && e1.declaration.type === "ClassDeclaration") {
                        s.next();
                    }
                    const i = [];
                    for (const e1 of s){
                        if (e1 == null) continue;
                        if (e1.start == null || e1.end == null) continue;
                        const t = this._findTokensOfNode(e1, n, r);
                        const s = t.first;
                        for(let e1 = n; e1 < s; e1++)i.push(e1);
                        n = t.last + 1;
                    }
                    for(let e1 = n; e1 <= r; e1++)i.push(e1);
                    return i;
                }
                _findTokensOfNode(e1, t, r) {
                    const n = this._tokensCache.get(e1);
                    if (n) return n;
                    const s = this._findFirstTokenOfNode(e1.start, t, r);
                    const i = this._findLastTokenOfNode(e1.end, s, r);
                    this._tokensCache.set(e1, {
                        first: s,
                        last: i
                    });
                    return {
                        first: s,
                        last: i
                    };
                }
                _findFirstTokenOfNode(e1, t, r) {
                    while(t <= r){
                        const n = r + t >> 1;
                        if (e1 < this._tokens[n].start) {
                            r = n - 1;
                        } else if (e1 > this._tokens[n].start) {
                            t = n + 1;
                        } else {
                            return n;
                        }
                    }
                    return t;
                }
                _findLastTokenOfNode(e1, t, r) {
                    while(t <= r){
                        const n = r + t >> 1;
                        if (e1 < this._tokens[n].end) {
                            r = n - 1;
                        } else if (e1 > this._tokens[n].end) {
                            t = n + 1;
                        } else {
                            return n;
                        }
                    }
                    return r;
                }
                constructor(e1, t, r){
                    this._tokens = void 0;
                    this._source = void 0;
                    this._nodesToTokenIndexes = new Map;
                    this._nodesOccurrencesCountCache = new Map;
                    this._tokensCache = new Map;
                    this._tokens = t;
                    this._source = r;
                    s(e1, (e1)=>{
                        const t = this._getTokensIndexesOfNode(e1);
                        if (t.length > 0) this._nodesToTokenIndexes.set(e1, t);
                    });
                    this._tokensCache = null;
                }
            }
            t.TokenMap = TokenMap;
            function* childrenIterator(e1) {
                if (e1.type === "TemplateLiteral") {
                    yield e1.quasis[0];
                    for(let t = 1; t < e1.quasis.length; t++){
                        yield e1.expressions[t - 1];
                        yield e1.quasis[t];
                    }
                    return;
                }
                const t = i[e1.type];
                for (const r of t){
                    const t = e1[r];
                    if (!t) continue;
                    if (Array.isArray(t)) {
                        yield* t;
                    } else {
                        yield t;
                    }
                }
            }
        },
        344: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = annotateAsPure;
            var n = r(3061);
            const { addComment: s } = n;
            const i = "#__PURE__";
            const isPureAnnotated = (param)=>{
                let { leadingComments: e1 } = param;
                return !!e1 && e1.some((e1)=>/[@#]__PURE__/.test(e1.value));
            };
            function annotateAsPure(e1) {
                const t = e1["node"] || e1;
                if (isPureAnnotated(t)) {
                    return;
                }
                s(t, "leading", i);
            }
        },
        6484: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getInclusionReasons = getInclusionReasons;
            var n = r(7849);
            var s = r(3359);
            var i = r(7409);
            function getInclusionReasons(e1, t, r) {
                const a = r[e1] || {};
                return Object.keys(t).reduce((e1, r)=>{
                    const o = (0, i.getLowestImplementedVersion)(a, r);
                    const l = t[r];
                    if (!o) {
                        e1[r] = (0, s.prettifyVersion)(l);
                    } else {
                        const t = (0, i.isUnreleasedVersion)(o, r);
                        const a = (0, i.isUnreleasedVersion)(l, r);
                        if (!a && (t || n.lt(l.toString(), (0, i.semverify)(o)))) {
                            e1[r] = (0, s.prettifyVersion)(l);
                        }
                    }
                    return e1;
                }, {});
            }
        },
        9822: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = filterItems;
            t.isRequired = isRequired;
            t.targetsSupported = targetsSupported;
            var n = r(7849);
            var s = r(2810);
            var i = r(7409);
            function targetsSupported(e1, t) {
                const r = Object.keys(e1);
                if (r.length === 0) {
                    return false;
                }
                const s = r.filter((r)=>{
                    const s = (0, i.getLowestImplementedVersion)(t, r);
                    if (!s) {
                        return true;
                    }
                    const a = e1[r];
                    if ((0, i.isUnreleasedVersion)(a, r)) {
                        return false;
                    }
                    if ((0, i.isUnreleasedVersion)(s, r)) {
                        return true;
                    }
                    if (!n.valid(a.toString())) {
                        throw new Error('Invalid version passed for target "'.concat(r, '": "').concat(a, '". ') + "Versions must be in semver format (major.minor.patch)");
                    }
                    return n.gt((0, i.semverify)(s), a.toString());
                });
                return s.length === 0;
            }
            function isRequired(e1, t) {
                let { compatData: r = s, includes: n, excludes: i } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                if (i != null && i.has(e1)) return false;
                if (n != null && n.has(e1)) return true;
                return !targetsSupported(t, r[e1]);
            }
            function filterItems(e1, t, r, n, s, i, a) {
                const o = new Set;
                const l = {
                    compatData: e1,
                    includes: t,
                    excludes: r
                };
                for(const t in e1){
                    if (isRequired(t, n, l)) {
                        o.add(t);
                    } else if (a) {
                        const e1 = a.get(t);
                        if (e1) {
                            o.add(e1);
                        }
                    }
                }
                s == null || s.forEach((e1)=>!r.has(e1) && o.add(e1));
                i == null || i.forEach((e1)=>!t.has(e1) && o.delete(e1));
                return o;
            }
        },
        3924: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "TargetNames", {
                enumerable: true,
                get: function() {
                    return c.TargetNames;
                }
            });
            t["default"] = getTargets;
            Object.defineProperty(t, "filterItems", {
                enumerable: true,
                get: function() {
                    return d.default;
                }
            });
            Object.defineProperty(t, "getInclusionReasons", {
                enumerable: true,
                get: function() {
                    return u.getInclusionReasons;
                }
            });
            t.isBrowsersQueryValid = isBrowsersQueryValid;
            Object.defineProperty(t, "isRequired", {
                enumerable: true,
                get: function() {
                    return d.isRequired;
                }
            });
            Object.defineProperty(t, "prettifyTargets", {
                enumerable: true,
                get: function() {
                    return p.prettifyTargets;
                }
            });
            Object.defineProperty(t, "unreleasedLabels", {
                enumerable: true,
                get: function() {
                    return l.unreleasedLabels;
                }
            });
            var n = r(4907);
            var s = r(3146);
            var i = r(8566);
            var a = r(7330);
            var o = r(7409);
            var l = r(9961);
            var c = r(4858);
            var p = r(3359);
            var u = r(6484);
            var d = r(9822);
            const f = i["es6.module"];
            const h = new s.OptionValidator("@babel/helper-compilation-targets");
            function validateTargetNames(e1) {
                const t = Object.keys(c.TargetNames);
                for (const r of Object.keys(e1)){
                    if (!(r in c.TargetNames)) {
                        throw new Error(h.formatMessage("'".concat(r, "' is not a valid target\n- Did you mean '").concat((0, s.findSuggestion)(r, t), "'?")));
                    }
                }
                return e1;
            }
            function isBrowsersQueryValid(e1) {
                return typeof e1 === "string" || Array.isArray(e1) && e1.every((e1)=>typeof e1 === "string");
            }
            function validateBrowsers(e1) {
                h.invariant(e1 === undefined || isBrowsersQueryValid(e1), "'".concat(String(e1), "' is not a valid browserslist query"));
                return e1;
            }
            function getLowestVersions(e1) {
                return e1.reduce((e1, t)=>{
                    const [r, n] = t.split(" ");
                    const s = l.browserNameMap[r];
                    if (!s) {
                        return e1;
                    }
                    try {
                        const t = n.split("-")[0].toLowerCase();
                        const r = (0, o.isUnreleasedVersion)(t, s);
                        if (!e1[s]) {
                            e1[s] = r ? t : (0, o.semverify)(t);
                            return e1;
                        }
                        const i = e1[s];
                        const a = (0, o.isUnreleasedVersion)(i, s);
                        if (a && r) {
                            e1[s] = (0, o.getLowestUnreleased)(i, t, s);
                        } else if (a) {
                            e1[s] = (0, o.semverify)(t);
                        } else if (!a && !r) {
                            const r = (0, o.semverify)(t);
                            e1[s] = (0, o.semverMin)(i, r);
                        }
                    } catch (e1) {}
                    return e1;
                }, {});
            }
            function outputDecimalWarning(e1) {
                if (!e1.length) {
                    return;
                }
                console.warn("Warning, the following targets are using a decimal version:\n");
                e1.forEach((param)=>{
                    let { target: e1, value: t } = param;
                    return console.warn("  ".concat(e1, ": ").concat(t));
                });
                console.warn("\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n");
            }
            function semverifyTarget(e1, t) {
                try {
                    return (0, o.semverify)(t);
                } catch (r) {
                    throw new Error(h.formatMessage("'".concat(t, "' is not a valid value for 'targets.").concat(e1, "'.")));
                }
            }
            function nodeTargetParser(e1) {
                const t = e1 === true || e1 === "current" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node.split("-")[0] : semverifyTarget("node", e1);
                return [
                    "node",
                    t
                ];
            }
            function defaultTargetParser(e1, t) {
                const r = (0, o.isUnreleasedVersion)(t, e1) ? t.toLowerCase() : semverifyTarget(e1, t);
                return [
                    e1,
                    r
                ];
            }
            function generateTargets(e1) {
                const t = Object.assign({}, e1);
                delete t.esmodules;
                delete t.browsers;
                return t;
            }
            function resolveTargets(e1, t) {
                const r = n(e1, {
                    mobileToDesktop: true,
                    env: t
                });
                return getLowestVersions(r);
            }
            const m = new a({
                max: 64
            });
            function resolveTargetsCached(e1, t) {
                const r = typeof e1 === "string" ? e1 : e1.join() + t;
                let n = m.get(r);
                if (!n) {
                    n = resolveTargets(e1, t);
                    m.set(r, n);
                }
                return Object.assign({}, n);
            }
            function getTargets() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var r, s;
                let { browsers: i, esmodules: a } = e1;
                const { configPath: l = ".", onBrowserslistConfigFound: c } = t;
                validateBrowsers(i);
                const p = generateTargets(e1);
                let u = validateTargetNames(p);
                const d = !!i;
                const h = d || Object.keys(u).length > 0;
                const m = !t.ignoreBrowserslistConfig && !h;
                if (!i && m) {
                    i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BROWSERSLIST;
                    if (!i) {
                        const e1 = t.configFile || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BROWSERSLIST_CONFIG || n.findConfigFile(l);
                        if (e1 != null) {
                            c == null || c(e1);
                            i = n.loadConfig({
                                config: e1,
                                env: t.browserslistEnv
                            });
                        }
                    }
                    if (i == null) {
                        {
                            i = [];
                        }
                    }
                }
                if (a && (a !== "intersect" || !((r = i) != null && r.length))) {
                    i = Object.keys(f).map((e1)=>"".concat(e1, " >= ").concat(f[e1])).join(", ");
                    a = false;
                }
                if ((s = i) != null && s.length) {
                    const e1 = resolveTargetsCached(i, t.browserslistEnv);
                    if (a === "intersect") {
                        for (const t of Object.keys(e1)){
                            if (t !== "deno" && t !== "ie") {
                                const r = f[t === "opera_mobile" ? "op_mob" : t];
                                if (r) {
                                    const n = e1[t];
                                    e1[t] = (0, o.getHighestUnreleased)(n, (0, o.semverify)(r), t);
                                } else {
                                    delete e1[t];
                                }
                            } else {
                                delete e1[t];
                            }
                        }
                    }
                    u = Object.assign(e1, u);
                }
                const y = {};
                const g = [];
                for (const e1 of Object.keys(u).sort()){
                    const t = u[e1];
                    if (typeof t === "number" && t % 1 !== 0) {
                        g.push({
                            target: e1,
                            value: t
                        });
                    }
                    const [r, n] = e1 === "node" ? nodeTargetParser(t) : defaultTargetParser(e1, t);
                    if (n) {
                        y[r] = n;
                    }
                }
                outputDecimalWarning(g);
                return y;
            }
        },
        4858: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TargetNames = void 0;
            const r = t.TargetNames = {
                node: "node",
                deno: "deno",
                chrome: "chrome",
                opera: "opera",
                edge: "edge",
                firefox: "firefox",
                safari: "safari",
                ie: "ie",
                ios: "ios",
                android: "android",
                electron: "electron",
                samsung: "samsung",
                rhino: "rhino",
                opera_mobile: "opera_mobile"
            };
        },
        3359: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.prettifyTargets = prettifyTargets;
            t.prettifyVersion = prettifyVersion;
            var n = r(7849);
            var s = r(9961);
            function prettifyVersion(e1) {
                if (typeof e1 !== "string") {
                    return e1;
                }
                const { major: t, minor: r, patch: s } = n.parse(e1);
                const i = [
                    t
                ];
                if (r || s) {
                    i.push(r);
                }
                if (s) {
                    i.push(s);
                }
                return i.join(".");
            }
            function prettifyTargets(e1) {
                return Object.keys(e1).reduce((t, r)=>{
                    let n = e1[r];
                    const i = s.unreleasedLabels[r];
                    if (typeof n === "string" && i !== n) {
                        n = prettifyVersion(n);
                    }
                    t[r] = n;
                    return t;
                }, {});
            }
        },
        9961: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.unreleasedLabels = t.browserNameMap = void 0;
            const r = t.unreleasedLabels = {
                safari: "tp"
            };
            const n = t.browserNameMap = {
                and_chr: "chrome",
                and_ff: "firefox",
                android: "android",
                chrome: "chrome",
                edge: "edge",
                firefox: "firefox",
                ie: "ie",
                ie_mob: "ie",
                ios_saf: "ios",
                node: "node",
                deno: "deno",
                op_mob: "opera_mobile",
                opera: "opera",
                safari: "safari",
                samsung: "samsung"
            };
        },
        7409: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getHighestUnreleased = getHighestUnreleased;
            t.getLowestImplementedVersion = getLowestImplementedVersion;
            t.getLowestUnreleased = getLowestUnreleased;
            t.isUnreleasedVersion = isUnreleasedVersion;
            t.semverMin = semverMin;
            t.semverify = semverify;
            var n = r(7849);
            var s = r(3146);
            var i = r(9961);
            const a = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/;
            const o = new s.OptionValidator("@babel/helper-compilation-targets");
            function semverMin(e1, t) {
                return e1 && n.lt(e1, t) ? e1 : t;
            }
            function semverify(e1) {
                if (typeof e1 === "string" && n.valid(e1)) {
                    return e1;
                }
                o.invariant(typeof e1 === "number" || typeof e1 === "string" && a.test(e1), "'".concat(e1, "' is not a valid version"));
                e1 = e1.toString();
                let t = 0;
                let r = 0;
                while((t = e1.indexOf(".", t + 1)) > 0){
                    r++;
                }
                return e1 + ".0".repeat(2 - r);
            }
            function isUnreleasedVersion(e1, t) {
                const r = i.unreleasedLabels[t];
                return !!r && r === e1.toString().toLowerCase();
            }
            function getLowestUnreleased(e1, t, r) {
                const n = i.unreleasedLabels[r];
                if (e1 === n) {
                    return t;
                }
                if (t === n) {
                    return e1;
                }
                return semverMin(e1, t);
            }
            function getHighestUnreleased(e1, t, r) {
                return getLowestUnreleased(e1, t, r) === e1 ? t : e1;
            }
            function getLowestImplementedVersion(e1, t) {
                const r = e1[t];
                if (!r && t === "android") {
                    return e1.chrome;
                }
                return r;
            }
        },
        4073: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildDecoratedClass = buildDecoratedClass;
            var n = r(2358);
            var s = r(6721);
            function prop(e1, t) {
                if (!t) return null;
                return n.types.objectProperty(n.types.identifier(e1), t);
            }
            function method(e1, t) {
                return n.types.objectMethod("method", n.types.identifier(e1), [], n.types.blockStatement(t));
            }
            function takeDecorators(e1) {
                let t;
                if (e1.decorators && e1.decorators.length > 0) {
                    t = n.types.arrayExpression(e1.decorators.map((e1)=>e1.expression));
                }
                e1.decorators = undefined;
                return t;
            }
            function getKey(e1) {
                if (e1.computed) {
                    return e1.key;
                } else if (n.types.isIdentifier(e1.key)) {
                    return n.types.stringLiteral(e1.key.name);
                } else {
                    return n.types.stringLiteral(String(e1.key.value));
                }
            }
            function extractElementDescriptor(e1, t, i, a) {
                const o = a.isClassMethod();
                if (a.isPrivate()) {
                    throw a.buildCodeFrameError("Private ".concat(o ? "methods" : "fields", " in decorated classes are not supported yet."));
                }
                if (a.node.type === "ClassAccessorProperty") {
                    throw a.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
                }
                if (a.node.type === "StaticBlock") {
                    throw a.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
                }
                const { node: l, scope: c } = a;
                if (!a.isTSDeclareMethod()) {
                    new s.default({
                        methodPath: a,
                        objectRef: t,
                        superRef: i,
                        file: e1,
                        refToPreserve: t
                    }).replace();
                }
                const p = [
                    prop("kind", n.types.stringLiteral(n.types.isClassMethod(l) ? l.kind : "field")),
                    prop("decorators", takeDecorators(l)),
                    prop("static", l.static && n.types.booleanLiteral(true)),
                    prop("key", getKey(l))
                ].filter(Boolean);
                if (o) {
                    {
                        var u;
                        (u = a.ensureFunctionName) != null ? u : a.ensureFunctionName = r(8026).NodePath.prototype.ensureFunctionName;
                    }
                    a.ensureFunctionName(false);
                    p.push(prop("value", n.types.toExpression(a.node)));
                } else if (n.types.isClassProperty(l) && l.value) {
                    p.push(method("value", n.template.statements.ast(_templateObject1(), l.value)));
                } else {
                    p.push(prop("value", c.buildUndefinedNode()));
                }
                a.remove();
                return n.types.objectExpression(p);
            }
            function addDecorateHelper(e1) {
                return e1.addHelper("decorate");
            }
            function buildDecoratedClass(e1, t, r, s) {
                const { node: i, scope: a } = t;
                const o = a.generateUidIdentifier("initialize");
                const l = i.id && t.isDeclaration();
                const c = t.isInStrictMode();
                const { superClass: p } = i;
                i.type = "ClassDeclaration";
                if (!i.id) i.id = n.types.cloneNode(e1);
                let u;
                if (p) {
                    u = a.generateUidIdentifierBasedOnNode(i.superClass, "super");
                    i.superClass = u;
                }
                const d = takeDecorators(i);
                const f = n.types.arrayExpression(r.filter((e1)=>!e1.node.abstract && e1.node.type !== "TSIndexSignature").map((e1)=>extractElementDescriptor(s, i.id, u, e1)));
                const h = n.template.expression.ast(_templateObject2(), addDecorateHelper(s), d || n.types.nullLiteral(), o, p ? n.types.cloneNode(u) : null, i, n.types.cloneNode(i.id), f, p);
                if (!c) {
                    h.arguments[1].body.directives.push(n.types.directive(n.types.directiveLiteral("use strict")));
                }
                let m = h;
                let y = "arguments.1.body.body.0";
                if (l) {
                    m = n.template.statement.ast(_templateObject3(), e1, h);
                    y = "declarations.0.init." + y;
                }
                return {
                    instanceNodes: [
                        n.template.statement.ast(_templateObject4(), n.types.cloneNode(o))
                    ],
                    wrapClass (e1) {
                        e1.replaceWith(m);
                        return e1.get(y);
                    }
                };
            }
        },
        7009: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            t.hasDecorators = hasDecorators;
            t.hasOwnDecorators = hasOwnDecorators;
            var n = r(2358);
            var s = r(6721);
            var i = r(9102);
            var a = r(4697);
            var o = r(5040);
            function hasOwnDecorators(e1) {
                var t;
                return !!((t = e1.decorators) != null && t.length);
            }
            function hasDecorators(e1) {
                return hasOwnDecorators(e1) || e1.body.body.some(hasOwnDecorators);
            }
            function incrementId(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e1.length - 1;
                if (t === -1) {
                    e1.unshift(65);
                    return;
                }
                const r = e1[t];
                if (r === 90) {
                    e1[t] = 97;
                } else if (r === 122) {
                    e1[t] = 65;
                    incrementId(e1, t - 1);
                } else {
                    e1[t] = r + 1;
                }
            }
            function createPrivateUidGeneratorForClass(e1) {
                const t = [];
                const r = new Set;
                e1.traverse({
                    PrivateName (e1) {
                        r.add(e1.node.id.name);
                    }
                });
                return ()=>{
                    let e1;
                    do {
                        incrementId(t);
                        e1 = String.fromCharCode(...t);
                    }while (r.has(e1))
                    return n.types.privateName(n.types.identifier(e1));
                };
            }
            function createLazyPrivateUidGeneratorForClass(e1) {
                let t;
                return ()=>{
                    if (!t) {
                        t = createPrivateUidGeneratorForClass(e1);
                    }
                    return t();
                };
            }
            function replaceClassWithVar(e1, t) {
                const r = e1.node.id;
                const s = e1.scope;
                if (e1.type === "ClassDeclaration") {
                    const t = r.name;
                    const i = s.generateUidIdentifierBasedOnNode(r);
                    const a = n.types.identifier(t);
                    s.rename(t, i.name);
                    e1.get("id").replaceWith(a);
                    return {
                        id: n.types.cloneNode(i),
                        path: e1
                    };
                } else {
                    let i;
                    if (r) {
                        t = r.name;
                        i = generateLetUidIdentifier(s.parent, t);
                        s.rename(t, i.name);
                    } else {
                        i = generateLetUidIdentifier(s.parent, typeof t === "string" ? t : "decorated_class");
                    }
                    const a = n.types.classExpression(typeof t === "string" ? n.types.identifier(t) : null, e1.node.superClass, e1.node.body);
                    const [o] = e1.replaceWith(n.types.sequenceExpression([
                        a,
                        i
                    ]));
                    return {
                        id: n.types.cloneNode(i),
                        path: o.get("expressions.0")
                    };
                }
            }
            function generateClassProperty(e1, t, r) {
                if (e1.type === "PrivateName") {
                    return n.types.classPrivateProperty(e1, t, undefined, r);
                } else {
                    return n.types.classProperty(e1, t, undefined, undefined, r);
                }
            }
            function assignIdForAnonymousClass(e1, t) {
                if (!e1.node.id) {
                    e1.node.id = typeof t === "string" ? n.types.identifier(t) : e1.scope.generateUidIdentifier("Class");
                }
            }
            function addProxyAccessorsFor(e1, t, r, s, i, a, o, l) {
                const c = (l === "2023-11" || l === "2023-05") && o ? e1 : n.types.thisExpression();
                const p = n.types.blockStatement([
                    n.types.returnStatement(n.types.memberExpression(n.types.cloneNode(c), n.types.cloneNode(i)))
                ]);
                const u = n.types.blockStatement([
                    n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(n.types.cloneNode(c), n.types.cloneNode(i)), n.types.identifier("v")))
                ]);
                let d, f;
                if (r.type === "PrivateName") {
                    d = n.types.classPrivateMethod("get", r, [], p, o);
                    f = n.types.classPrivateMethod("set", s, [
                        n.types.identifier("v")
                    ], u, o);
                } else {
                    d = n.types.classMethod("get", r, [], p, a, o);
                    f = n.types.classMethod("set", s, [
                        n.types.identifier("v")
                    ], u, a, o);
                }
                t.insertAfter(f);
                t.insertAfter(d);
            }
            function extractProxyAccessorsFor(e1, t) {
                if (t !== "2023-11" && t !== "2023-05" && t !== "2023-01") {
                    return [
                        n.template.expression.ast(_templateObject5(), n.types.cloneNode(e1)),
                        n.template.expression.ast(_templateObject6(), n.types.cloneNode(e1))
                    ];
                }
                return [
                    n.template.expression.ast(_templateObject7(), n.types.cloneNode(e1)),
                    n.template.expression.ast(_templateObject8(), n.types.cloneNode(e1))
                ];
            }
            function getComputedKeyLastElement(e1) {
                e1 = (0, i.skipTransparentExprWrappers)(e1);
                if (e1.isSequenceExpression()) {
                    const t = e1.get("expressions");
                    return getComputedKeyLastElement(t[t.length - 1]);
                }
                return e1;
            }
            function getComputedKeyMemoiser(e1) {
                const t = getComputedKeyLastElement(e1);
                if (t.isConstantExpression()) {
                    return n.types.cloneNode(e1.node);
                } else if (t.isIdentifier() && e1.scope.hasUid(t.node.name)) {
                    return n.types.cloneNode(e1.node);
                } else if (t.isAssignmentExpression() && t.get("left").isIdentifier()) {
                    return n.types.cloneNode(t.node.left);
                } else {
                    throw new Error("Internal Error: the computed key ".concat(e1.toString(), " has not yet been memoised."));
                }
            }
            function prependExpressionsToComputedKey(e1, t) {
                const r = t.get("key");
                if (r.isSequenceExpression()) {
                    e1.push(...r.node.expressions);
                } else {
                    e1.push(r.node);
                }
                r.replaceWith(maybeSequenceExpression(e1));
            }
            function appendExpressionsToComputedKey(e1, t) {
                const r = t.get("key");
                const s = getComputedKeyLastElement(r);
                if (s.isConstantExpression()) {
                    prependExpressionsToComputedKey(e1, t);
                } else {
                    const i = r.scope.parent;
                    const a = (0, o.memoiseComputedKey)(s.node, i, i.generateUid("computedKey"));
                    if (!a) {
                        prependExpressionsToComputedKey(e1, t);
                    } else {
                        const t = [
                            ...e1,
                            n.types.cloneNode(a.left)
                        ];
                        const r = s.parentPath;
                        if (r.isSequenceExpression()) {
                            r.pushContainer("expressions", t);
                        } else {
                            s.replaceWith(maybeSequenceExpression([
                                n.types.cloneNode(a),
                                ...t
                            ]));
                        }
                    }
                }
            }
            function prependExpressionsToFieldInitializer(e1, t) {
                const r = t.get("value");
                if (r.node) {
                    e1.push(r.node);
                } else if (e1.length > 0) {
                    e1[e1.length - 1] = n.types.unaryExpression("void", e1[e1.length - 1]);
                }
                r.replaceWith(maybeSequenceExpression(e1));
            }
            function prependExpressionsToStaticBlock(e1, t) {
                t.unshiftContainer("body", n.types.expressionStatement(maybeSequenceExpression(e1)));
            }
            function prependExpressionsToConstructor(e1, t) {
                t.node.body.body.unshift(n.types.expressionStatement(maybeSequenceExpression(e1)));
            }
            function isProtoInitCallExpression(e1, t) {
                return n.types.isCallExpression(e1) && n.types.isIdentifier(e1.callee, {
                    name: t.name
                });
            }
            function optimizeSuperCallAndExpressions(e1, t) {
                if (t) {
                    if (e1.length >= 2 && isProtoInitCallExpression(e1[1], t)) {
                        const r = n.types.callExpression(n.types.cloneNode(t), [
                            e1[0]
                        ]);
                        e1.splice(0, 2, r);
                    }
                    if (e1.length >= 2 && n.types.isThisExpression(e1[e1.length - 1]) && isProtoInitCallExpression(e1[e1.length - 2], t)) {
                        e1.splice(e1.length - 1, 1);
                    }
                }
                return maybeSequenceExpression(e1);
            }
            function insertExpressionsAfterSuperCallAndOptimize(e1, t, r) {
                t.traverse({
                    CallExpression: {
                        exit (t) {
                            if (!t.get("callee").isSuper()) return;
                            const s = [
                                t.node,
                                ...e1.map((e1)=>n.types.cloneNode(e1))
                            ];
                            if (t.isCompletionRecord()) {
                                s.push(n.types.thisExpression());
                            }
                            t.replaceWith(optimizeSuperCallAndExpressions(s, r));
                            t.skip();
                        }
                    },
                    ClassMethod (e1) {
                        if (e1.node.kind === "constructor") {
                            e1.skip();
                        }
                    }
                });
            }
            function createConstructorFromExpressions(e1, t) {
                const r = [
                    n.types.expressionStatement(maybeSequenceExpression(e1))
                ];
                if (t) {
                    r.unshift(n.types.expressionStatement(n.types.callExpression(n.types.super(), [
                        n.types.spreadElement(n.types.identifier("args"))
                    ])));
                }
                return n.types.classMethod("constructor", n.types.identifier("constructor"), t ? [
                    n.types.restElement(n.types.identifier("args"))
                ] : [], n.types.blockStatement(r));
            }
            function createStaticBlockFromExpressions(e1) {
                return n.types.staticBlock([
                    n.types.expressionStatement(maybeSequenceExpression(e1))
                ]);
            }
            const l = 0;
            const c = 1;
            const p = 2;
            const u = 3;
            const d = 4;
            const f = 5;
            const h = 8;
            const m = 16;
            function getElementKind(e1) {
                switch(e1.node.type){
                    case "ClassProperty":
                    case "ClassPrivateProperty":
                        return l;
                    case "ClassAccessorProperty":
                        return c;
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                        if (e1.node.kind === "get") {
                            return u;
                        } else if (e1.node.kind === "set") {
                            return d;
                        } else {
                            return p;
                        }
                }
            }
            function toSortedDecoratorInfo(e1) {
                return [
                    ...e1.filter((e1)=>e1.isStatic && e1.kind >= c && e1.kind <= d),
                    ...e1.filter((e1)=>!e1.isStatic && e1.kind >= c && e1.kind <= d),
                    ...e1.filter((e1)=>e1.isStatic && e1.kind === l),
                    ...e1.filter((e1)=>!e1.isStatic && e1.kind === l)
                ];
            }
            function generateDecorationList(e1, t, r) {
                const s = e1.length;
                const i = t.some(Boolean);
                const a = [];
                for(let o = 0; o < s; o++){
                    if ((r === "2023-11" || r === "2023-05") && i) {
                        a.push(t[o] || n.types.unaryExpression("void", n.types.numericLiteral(0)));
                    }
                    a.push(e1[o].expression);
                }
                return {
                    haveThis: i,
                    decs: a
                };
            }
            function generateDecorationExprs(e1, t) {
                return n.types.arrayExpression(e1.map((e1)=>{
                    let r = e1.kind;
                    if (e1.isStatic) {
                        r += t === "2023-11" || t === "2023-05" ? h : f;
                    }
                    if (e1.decoratorsHaveThis) r += m;
                    return n.types.arrayExpression([
                        e1.decoratorsArray,
                        n.types.numericLiteral(r),
                        e1.name,
                        ...e1.privateMethods || []
                    ]);
                }));
            }
            function extractElementLocalAssignments(e1) {
                const t = [];
                for (const r of e1){
                    const { locals: e1 } = r;
                    if (Array.isArray(e1)) {
                        t.push(...e1);
                    } else if (e1 !== undefined) {
                        t.push(e1);
                    }
                }
                return t;
            }
            function addCallAccessorsFor(e1, t, r, s, i, a) {
                t.insertAfter(n.types.classPrivateMethod("get", n.types.cloneNode(r), [], n.types.blockStatement([
                    n.types.returnStatement(n.types.callExpression(n.types.cloneNode(s), e1 === "2023-11" && a ? [] : [
                        n.types.thisExpression()
                    ]))
                ]), a));
                t.insertAfter(n.types.classPrivateMethod("set", n.types.cloneNode(r), [
                    n.types.identifier("v")
                ], n.types.blockStatement([
                    n.types.expressionStatement(n.types.callExpression(n.types.cloneNode(i), e1 === "2023-11" && a ? [
                        n.types.identifier("v")
                    ] : [
                        n.types.thisExpression(),
                        n.types.identifier("v")
                    ]))
                ]), a));
            }
            function movePrivateAccessor(e1, t, r, s) {
                let i;
                let a;
                if (e1.node.kind === "set") {
                    i = [
                        n.types.identifier("v")
                    ];
                    a = [
                        n.types.expressionStatement(n.types.callExpression(r, [
                            n.types.thisExpression(),
                            n.types.identifier("v")
                        ]))
                    ];
                } else {
                    i = [];
                    a = [
                        n.types.returnStatement(n.types.callExpression(r, [
                            n.types.thisExpression()
                        ]))
                    ];
                }
                e1.replaceWith(n.types.classPrivateMethod(e1.node.kind, n.types.cloneNode(t), i, n.types.blockStatement(a), s));
            }
            function isClassDecoratableElementPath(e1) {
                const { type: t } = e1;
                return t !== "TSDeclareMethod" && t !== "TSIndexSignature" && t !== "StaticBlock";
            }
            function staticBlockToIIFE(e1) {
                return n.types.callExpression(n.types.arrowFunctionExpression([], n.types.blockStatement(e1.body)), []);
            }
            function staticBlockToFunctionClosure(e1) {
                return n.types.functionExpression(null, [], n.types.blockStatement(e1.body));
            }
            function fieldInitializerToClosure(e1) {
                return n.types.functionExpression(null, [], n.types.blockStatement([
                    n.types.returnStatement(e1)
                ]));
            }
            function maybeSequenceExpression(e1) {
                if (e1.length === 0) return n.types.unaryExpression("void", n.types.numericLiteral(0));
                if (e1.length === 1) return e1[0];
                return n.types.sequenceExpression(e1);
            }
            function createFunctionExpressionFromPrivateMethod(e1) {
                const { params: t, body: r, generator: s, async: i } = e1;
                return n.types.functionExpression(undefined, t, r, s, i);
            }
            function createSetFunctionNameCall(e1, t) {
                return n.types.callExpression(e1.addHelper("setFunctionName"), [
                    n.types.thisExpression(),
                    t
                ]);
            }
            function createToPropertyKeyCall(e1, t) {
                return n.types.callExpression(e1.addHelper("toPropertyKey"), [
                    t
                ]);
            }
            function createPrivateBrandCheckClosure(e1) {
                return n.types.arrowFunctionExpression([
                    n.types.identifier("_")
                ], n.types.binaryExpression("in", n.types.cloneNode(e1), n.types.identifier("_")));
            }
            function usesPrivateField(e1) {
                {
                    try {
                        n.types.traverseFast(e1, (e1)=>{
                            if (n.types.isPrivateName(e1)) {
                                throw null;
                            }
                        });
                        return false;
                    } catch (e1) {
                        return true;
                    }
                }
            }
            function convertToComputedKey(e1) {
                const { node: t } = e1;
                t.computed = true;
                if (n.types.isIdentifier(t.key)) {
                    t.key = n.types.stringLiteral(t.key.name);
                }
            }
            function hasInstancePrivateAccess(e1, t) {
                let r = false;
                if (t.length > 0) {
                    const n = (0, a.privateNameVisitorFactory)({
                        PrivateName (e1, t) {
                            if (t.privateNamesMap.has(e1.node.id.name)) {
                                r = true;
                                e1.stop();
                            }
                        }
                    });
                    const s = new Map;
                    for (const e1 of t){
                        s.set(e1, null);
                    }
                    e1.traverse(n, {
                        privateNamesMap: s
                    });
                }
                return r;
            }
            function checkPrivateMethodUpdateError(e1, t) {
                const r = (0, a.privateNameVisitorFactory)({
                    PrivateName (e1, t) {
                        if (!t.privateNamesMap.has(e1.node.id.name)) return;
                        const r = e1.parentPath;
                        const n = r.parentPath;
                        if (n.node.type === "AssignmentExpression" && n.node.left === r.node || n.node.type === "UpdateExpression" || n.node.type === "RestElement" || n.node.type === "ArrayPattern" || n.node.type === "ObjectProperty" && n.node.value === r.node && n.parentPath.type === "ObjectPattern" || n.node.type === "ForOfStatement" && n.node.left === r.node) {
                            throw e1.buildCodeFrameError('Decorated private methods are read-only, but "#'.concat(e1.node.id.name, '" is updated via this expression.'));
                        }
                    }
                });
                const n = new Map;
                for (const e1 of t){
                    n.set(e1, null);
                }
                e1.traverse(r, {
                    privateNamesMap: n
                });
            }
            function transformClass(e1, t, r, i, a, p, f) {
                var h;
                const m = e1.get("body.body");
                const y = e1.node.decorators;
                let g = false;
                let b = false;
                let T = false;
                const S = createLazyPrivateUidGeneratorForClass(e1);
                const x = [];
                const E = e1.scope.parent;
                const memoiseExpression = (e1, t, r)=>{
                    const s = generateLetUidIdentifier(E, t);
                    r.push(n.types.assignmentExpression("=", s, e1));
                    return n.types.cloneNode(s);
                };
                let P;
                let v;
                const A = (h = e1.node.id) == null ? void 0 : h.name;
                const w = typeof a === "object" ? a : undefined;
                const usesFunctionContextOrYieldAwait = (e1)=>{
                    {
                        try {
                            n.types.traverseFast(e1, (e1)=>{
                                if (n.types.isThisExpression(e1) || n.types.isSuper(e1) || n.types.isYieldExpression(e1) || n.types.isAwaitExpression(e1) || n.types.isIdentifier(e1, {
                                    name: "arguments"
                                }) || A && n.types.isIdentifier(e1, {
                                    name: A
                                }) || n.types.isMetaProperty(e1) && e1.meta.name !== "import") {
                                    throw null;
                                }
                            });
                            return false;
                        } catch (e1) {
                            return true;
                        }
                    }
                };
                const I = [];
                for (const r of m){
                    if (!isClassDecoratableElementPath(r)) {
                        continue;
                    }
                    const s = r.node;
                    if (!s.static && n.types.isPrivateName(s.key)) {
                        I.push(s.key.id.name);
                    }
                    if (isDecorated(s)) {
                        switch(s.type){
                            case "ClassProperty":
                                p.ClassProperty(r, t);
                                break;
                            case "ClassPrivateProperty":
                                p.ClassPrivateProperty(r, t);
                                break;
                            case "ClassAccessorProperty":
                                p.ClassAccessorProperty(r, t);
                                if (f === "2023-11") {
                                    break;
                                }
                            default:
                                if (s.static) {
                                    v != null ? v : v = generateLetUidIdentifier(E, "initStatic");
                                } else {
                                    P != null ? P : P = generateLetUidIdentifier(E, "initProto");
                                }
                                break;
                        }
                        g = true;
                        T || (T = s.decorators.some(usesFunctionContextOrYieldAwait));
                    } else if (s.type === "ClassAccessorProperty") {
                        p.ClassAccessorProperty(r, t);
                        const { key: i, value: l, static: c, computed: u } = s;
                        const d = S();
                        const h = generateClassProperty(d, l, c);
                        const m = r.get("key");
                        const [y] = r.replaceWith(h);
                        let g, b;
                        if (u && !m.isConstantExpression()) {
                            g = (0, o.memoiseComputedKey)(createToPropertyKeyCall(t, i), E, E.generateUid("computedKey"));
                            b = n.types.cloneNode(g.left);
                        } else {
                            g = n.types.cloneNode(i);
                            b = n.types.cloneNode(i);
                        }
                        assignIdForAnonymousClass(e1, a);
                        addProxyAccessorsFor(e1.node.id, y, g, b, d, u, c, f);
                    }
                    if ("computed" in r.node && r.node.computed) {
                        b || (b = !E.isStatic(r.node.key));
                    }
                }
                if (!y && !g) {
                    if (!e1.node.id && typeof a === "string") {
                        e1.node.id = n.types.identifier(a);
                    }
                    if (w) {
                        e1.node.body.body.unshift(createStaticBlockFromExpressions([
                            createSetFunctionNameCall(t, w)
                        ]));
                    }
                    return;
                }
                const C = [];
                let O;
                const N = new Set;
                let k, _;
                let D = null;
                function handleDecorators(e1) {
                    let t = false;
                    let r = false;
                    const s = [];
                    for (const i of e1){
                        const { expression: e1 } = i;
                        let a;
                        if ((f === "2023-11" || f === "2023-05") && n.types.isMemberExpression(e1)) {
                            if (n.types.isSuper(e1.object)) {
                                a = n.types.thisExpression();
                            } else if (E.isStatic(e1.object)) {
                                a = n.types.cloneNode(e1.object);
                            } else {
                                D != null ? D : D = generateLetUidIdentifier(E, "obj");
                                a = n.types.assignmentExpression("=", n.types.cloneNode(D), e1.object);
                                e1.object = n.types.cloneNode(D);
                            }
                        }
                        s.push(a);
                        t || (t = !E.isStatic(e1));
                        r || (r = usesFunctionContextOrYieldAwait(i));
                    }
                    return {
                        hasSideEffects: t,
                        usesFnContext: r,
                        decoratorsThis: s
                    };
                }
                const M = b || T || f !== "2023-11";
                let L = false;
                let j = 0;
                let F = [];
                let B;
                let R = [];
                if (y) {
                    k = generateLetUidIdentifier(E, "initClass");
                    L = e1.isClassDeclaration();
                    ({ id: _, path: e1 } = replaceClassWithVar(e1, a));
                    e1.node.decorators = null;
                    const t = y.some(usesPrivateField);
                    const { hasSideEffects: r, usesFnContext: s, decoratorsThis: i } = handleDecorators(y);
                    const { haveThis: l, decs: c } = generateDecorationList(y, i, f);
                    j = l ? 1 : 0;
                    F = c;
                    if (s || r && M || t) {
                        B = memoiseExpression(n.types.arrayExpression(F), "classDecs", x);
                    }
                    if (!g) {
                        for (const t of e1.get("body.body")){
                            const { node: e1 } = t;
                            const r = "computed" in e1 && e1.computed;
                            if (r) {
                                if (t.isClassProperty({
                                    static: true
                                })) {
                                    if (!t.get("key").isConstantExpression()) {
                                        const t = e1.key;
                                        const r = (0, o.memoiseComputedKey)(t, E, E.generateUid("computedKey"));
                                        if (r != null) {
                                            e1.key = n.types.cloneNode(r.left);
                                            R.push(r);
                                        }
                                    }
                                } else if (R.length > 0) {
                                    prependExpressionsToComputedKey(R, t);
                                    R = [];
                                }
                            }
                        }
                    }
                } else {
                    assignIdForAnonymousClass(e1, a);
                    _ = n.types.cloneNode(e1.node.id);
                }
                let U;
                let K = false;
                let V = [];
                let W = [];
                if (g) {
                    if (P) {
                        const e1 = n.types.callExpression(n.types.cloneNode(P), [
                            n.types.thisExpression()
                        ]);
                        V.push(e1);
                    }
                    for (const i of m){
                        if (!isClassDecoratableElementPath(i)) {
                            if (W.length > 0 && i.isStaticBlock()) {
                                prependExpressionsToStaticBlock(W, i);
                                W = [];
                            }
                            continue;
                        }
                        const { node: p } = i;
                        const h = p.decorators;
                        const m = !!(h != null && h.length);
                        const g = "computed" in p && p.computed;
                        let b = "computedKey";
                        if (p.key.type === "PrivateName") {
                            b = p.key.id.name;
                        } else if (!g && p.key.type === "Identifier") {
                            b = p.key.name;
                        }
                        let T;
                        let x;
                        if (m) {
                            const { hasSideEffects: e1, usesFnContext: t, decoratorsThis: r } = handleDecorators(h);
                            const { decs: s, haveThis: i } = generateDecorationList(h, r, f);
                            x = i;
                            T = s.length === 1 ? s[0] : n.types.arrayExpression(s);
                            if (t || e1 && M) {
                                T = memoiseExpression(T, b + "Decs", R);
                            }
                        }
                        if (g) {
                            if (!i.get("key").isConstantExpression()) {
                                const e1 = p.key;
                                const r = (0, o.memoiseComputedKey)(m ? createToPropertyKeyCall(t, e1) : e1, E, E.generateUid("computedKey"));
                                if (r != null) {
                                    if (y && i.isClassProperty({
                                        static: true
                                    })) {
                                        p.key = n.types.cloneNode(r.left);
                                        R.push(r);
                                    } else {
                                        p.key = r;
                                    }
                                }
                            }
                        }
                        const { key: P, static: v } = p;
                        const A = P.type === "PrivateName";
                        const w = getElementKind(i);
                        if (A && !v) {
                            if (m) {
                                K = true;
                            }
                            if (n.types.isClassPrivateProperty(p) || !U) {
                                U = P;
                            }
                        }
                        if (i.isClassMethod({
                            kind: "constructor"
                        })) {
                            O = i;
                        }
                        let I;
                        if (m) {
                            let o;
                            let p;
                            if (g) {
                                p = getComputedKeyMemoiser(i.get("key"));
                            } else if (P.type === "PrivateName") {
                                p = n.types.stringLiteral(P.id.name);
                            } else if (P.type === "Identifier") {
                                p = n.types.stringLiteral(P.name);
                            } else {
                                p = n.types.cloneNode(P);
                            }
                            if (w === c) {
                                const { value: t } = i.node;
                                const r = f === "2023-11" && v ? [] : [
                                    n.types.thisExpression()
                                ];
                                if (t) {
                                    r.push(n.types.cloneNode(t));
                                }
                                const s = S();
                                const l = generateLetUidIdentifier(E, "init_".concat(b));
                                const c = n.types.callExpression(n.types.cloneNode(l), r);
                                const p = generateClassProperty(s, c, v);
                                const [u] = i.replaceWith(p);
                                if (A) {
                                    o = extractProxyAccessorsFor(s, f);
                                    const e1 = generateLetUidIdentifier(E, "get_".concat(b));
                                    const t = generateLetUidIdentifier(E, "set_".concat(b));
                                    addCallAccessorsFor(f, u, P, e1, t, v);
                                    I = [
                                        l,
                                        e1,
                                        t
                                    ];
                                } else {
                                    assignIdForAnonymousClass(e1, a);
                                    addProxyAccessorsFor(e1.node.id, u, n.types.cloneNode(P), n.types.isAssignmentExpression(P) ? n.types.cloneNode(P.left) : n.types.cloneNode(P), s, g, v, f);
                                    I = [
                                        l
                                    ];
                                }
                            } else if (w === l) {
                                const e1 = generateLetUidIdentifier(E, "init_".concat(b));
                                const t = i.get("value");
                                const r = f === "2023-11" && v ? [] : [
                                    n.types.thisExpression()
                                ];
                                if (t.node) r.push(t.node);
                                t.replaceWith(n.types.callExpression(n.types.cloneNode(e1), r));
                                I = [
                                    e1
                                ];
                                if (A) {
                                    o = extractProxyAccessorsFor(P, f);
                                }
                            } else if (A) {
                                const a = generateLetUidIdentifier(E, "call_".concat(b));
                                I = [
                                    a
                                ];
                                const l = new s.default({
                                    constantSuper: r,
                                    methodPath: i,
                                    objectRef: _,
                                    superRef: e1.node.superClass,
                                    file: t.file,
                                    refToPreserve: _
                                });
                                l.replace();
                                o = [
                                    createFunctionExpressionFromPrivateMethod(i.node)
                                ];
                                if (w === u || w === d) {
                                    movePrivateAccessor(i, n.types.cloneNode(P), n.types.cloneNode(a), v);
                                } else {
                                    const t = i.node;
                                    e1.node.body.body.unshift(n.types.classPrivateProperty(P, n.types.cloneNode(a), [], t.static));
                                    N.add(P.id.name);
                                    i.remove();
                                }
                            }
                            C.push({
                                kind: w,
                                decoratorsArray: T,
                                decoratorsHaveThis: x,
                                name: p,
                                isStatic: v,
                                privateMethods: o,
                                locals: I
                            });
                            if (i.node) {
                                i.node.decorators = null;
                            }
                        }
                        if (g && R.length > 0) {
                            if (y && i.isClassProperty({
                                static: true
                            })) {} else {
                                prependExpressionsToComputedKey(R, w === c ? i.getNextSibling() : i);
                                R = [];
                            }
                        }
                        if (V.length > 0 && !v && (w === l || w === c)) {
                            prependExpressionsToFieldInitializer(V, i);
                            V = [];
                        }
                        if (W.length > 0 && v && (w === l || w === c)) {
                            prependExpressionsToFieldInitializer(W, i);
                            W = [];
                        }
                        if (m && f === "2023-11") {
                            if (w === l || w === c) {
                                const e1 = generateLetUidIdentifier(E, "init_extra_".concat(b));
                                I.push(e1);
                                const t = n.types.callExpression(n.types.cloneNode(e1), v ? [] : [
                                    n.types.thisExpression()
                                ]);
                                if (!v) {
                                    V.push(t);
                                } else {
                                    W.push(t);
                                }
                            }
                        }
                    }
                }
                if (R.length > 0) {
                    const t = e1.get("body.body");
                    let r;
                    for(let e1 = t.length - 1; e1 >= 0; e1--){
                        const s = t[e1];
                        const i = s.node;
                        if (i.computed) {
                            if (y && n.types.isClassProperty(i, {
                                static: true
                            })) {
                                continue;
                            }
                            r = s;
                            break;
                        }
                    }
                    if (r != null) {
                        appendExpressionsToComputedKey(R, r);
                        R = [];
                    } else {}
                }
                if (V.length > 0) {
                    const t = !!e1.node.superClass;
                    if (O) {
                        if (t) {
                            insertExpressionsAfterSuperCallAndOptimize(V, O, P);
                        } else {
                            prependExpressionsToConstructor(V, O);
                        }
                    } else {
                        e1.node.body.body.unshift(createConstructorFromExpressions(V, t));
                    }
                    V = [];
                }
                if (W.length > 0) {
                    e1.node.body.body.push(createStaticBlockFromExpressions(W));
                    W = [];
                }
                const $ = toSortedDecoratorInfo(C);
                const q = generateDecorationExprs(f === "2023-11" ? C : $, f);
                const H = extractElementLocalAssignments($);
                if (P) {
                    H.push(P);
                }
                if (v) {
                    H.push(v);
                }
                const G = [];
                let J = false;
                const z = k && n.types.callExpression(n.types.cloneNode(k), []);
                let X = e1;
                const Y = e1.node;
                const Q = [];
                if (y) {
                    G.push(_, k);
                    const a = [];
                    e1.get("body.body").forEach((o)=>{
                        if (o.isStaticBlock()) {
                            if (hasInstancePrivateAccess(o, I)) {
                                const e1 = memoiseExpression(staticBlockToFunctionClosure(o.node), "staticBlock", Q);
                                W.push(n.types.callExpression(n.types.memberExpression(e1, n.types.identifier("call")), [
                                    n.types.thisExpression()
                                ]));
                            } else {
                                W.push(staticBlockToIIFE(o.node));
                            }
                            o.remove();
                            return;
                        }
                        if ((o.isClassProperty() || o.isClassPrivateProperty()) && o.node.static) {
                            const e1 = o.get("value");
                            if (hasInstancePrivateAccess(e1, I)) {
                                const t = memoiseExpression(fieldInitializerToClosure(e1.node), "fieldValue", Q);
                                e1.replaceWith(n.types.callExpression(n.types.memberExpression(t, n.types.identifier("call")), [
                                    n.types.thisExpression()
                                ]));
                            }
                            if (W.length > 0) {
                                prependExpressionsToFieldInitializer(W, o);
                                W = [];
                            }
                            o.node.static = false;
                            a.push(o.node);
                            o.remove();
                        } else if (o.isClassPrivateMethod({
                            static: true
                        })) {
                            if (hasInstancePrivateAccess(o, I)) {
                                const a = new s.default({
                                    constantSuper: r,
                                    methodPath: o,
                                    objectRef: _,
                                    superRef: e1.node.superClass,
                                    file: t.file,
                                    refToPreserve: _
                                });
                                a.replace();
                                const l = memoiseExpression(createFunctionExpressionFromPrivateMethod(o.node), o.get("key.id").node.name, Q);
                                if (i) {
                                    o.node.params = [
                                        n.types.restElement(n.types.identifier("arg"))
                                    ];
                                    o.node.body = n.types.blockStatement([
                                        n.types.returnStatement(n.types.callExpression(n.types.memberExpression(l, n.types.identifier("apply")), [
                                            n.types.thisExpression(),
                                            n.types.identifier("arg")
                                        ]))
                                    ]);
                                } else {
                                    o.node.params = o.node.params.map((e1, t)=>{
                                        if (n.types.isRestElement(e1)) {
                                            return n.types.restElement(n.types.identifier("arg"));
                                        } else {
                                            return n.types.identifier("_" + t);
                                        }
                                    });
                                    o.node.body = n.types.blockStatement([
                                        n.types.returnStatement(n.types.callExpression(n.types.memberExpression(l, n.types.identifier("apply")), [
                                            n.types.thisExpression(),
                                            n.types.identifier("arguments")
                                        ]))
                                    ]);
                                }
                            }
                            o.node.static = false;
                            a.push(o.node);
                            o.remove();
                        }
                    });
                    if (a.length > 0 || W.length > 0) {
                        const r = n.template.expression.ast(_templateObject9(), t.addHelper("identity"));
                        r.body.body = [
                            n.types.classProperty(n.types.toExpression(Y), undefined, undefined, undefined, true, true),
                            ...a
                        ];
                        const s = [];
                        const i = n.types.newExpression(r, []);
                        if (W.length > 0) {
                            s.push(...W);
                        }
                        if (z) {
                            J = true;
                            s.push(z);
                        }
                        if (s.length > 0) {
                            s.unshift(n.types.callExpression(n.types.super(), [
                                n.types.cloneNode(_)
                            ]));
                            r.body.body.push(createConstructorFromExpressions(s, false));
                        } else {
                            i.arguments.push(n.types.cloneNode(_));
                        }
                        const [o] = e1.replaceWith(i);
                        X = o.get("callee").get("body").get("body.0.key");
                    }
                }
                if (!J && z) {
                    e1.node.body.body.push(n.types.staticBlock([
                        n.types.expressionStatement(z)
                    ]));
                }
                let { superClass: Z } = Y;
                if (Z && (f === "2023-11" || f === "2023-05")) {
                    const t = e1.scope.maybeGenerateMemoised(Z);
                    if (t) {
                        Y.superClass = n.types.assignmentExpression("=", t, Z);
                        Z = t;
                    }
                }
                const ee = n.types.staticBlock([]);
                Y.body.body.unshift(ee);
                const te = ee.body;
                if (R.length > 0) {
                    const e1 = X.get("body.body");
                    let t;
                    for (const r of e1){
                        if ((r.isClassProperty() || r.isClassMethod()) && r.node.kind !== "constructor") {
                            t = r;
                            break;
                        }
                    }
                    if (t != null) {
                        convertToComputedKey(t);
                        prependExpressionsToComputedKey(R, t);
                    } else {
                        Y.body.body.unshift(n.types.classProperty(n.types.sequenceExpression([
                            ...R,
                            n.types.stringLiteral("_")
                        ]), undefined, undefined, undefined, true, true));
                        te.push(n.types.expressionStatement(n.types.unaryExpression("delete", n.types.memberExpression(n.types.thisExpression(), n.types.identifier("_")))));
                    }
                    R = [];
                }
                te.push(n.types.expressionStatement(createLocalsAssignment(H, G, q, B != null ? B : n.types.arrayExpression(F), n.types.numericLiteral(j), K ? U : null, w, n.types.cloneNode(Z), t, f)));
                if (v) {
                    te.push(n.types.expressionStatement(n.types.callExpression(n.types.cloneNode(v), [
                        n.types.thisExpression()
                    ])));
                }
                if (Q.length > 0) {
                    te.push(...Q.map((e1)=>n.types.expressionStatement(e1)));
                }
                e1.insertBefore(x.map((e1)=>n.types.expressionStatement(e1)));
                if (L) {
                    const t = E.getBinding(_.name);
                    if (!t.constantViolations.length) {
                        e1.insertBefore(n.types.variableDeclaration("let", [
                            n.types.variableDeclarator(n.types.cloneNode(_))
                        ]));
                    } else {
                        const t = E.generateUidIdentifier("t" + _.name);
                        const r = _;
                        e1.replaceWithMultiple([
                            n.types.variableDeclaration("let", [
                                n.types.variableDeclarator(n.types.cloneNode(r)),
                                n.types.variableDeclarator(t)
                            ]),
                            n.types.blockStatement([
                                n.types.variableDeclaration("let", [
                                    n.types.variableDeclarator(n.types.cloneNode(_))
                                ]),
                                e1.node,
                                n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(t), n.types.cloneNode(_)))
                            ]),
                            n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(r), n.types.cloneNode(t)))
                        ]);
                    }
                }
                if (N.size > 0) {
                    checkPrivateMethodUpdateError(e1, N);
                }
                e1.scope.crawl();
                return e1;
            }
            function createLocalsAssignment(e1, t, r, s, i, a, o, l, c, p) {
                let u, d;
                const f = [
                    o ? createSetFunctionNameCall(c, o) : n.types.thisExpression(),
                    s,
                    r
                ];
                {
                    if (p !== "2023-11") {
                        f.splice(1, 2, r, s);
                    }
                    if (p === "2021-12" || p === "2022-03" && !c.availableHelper("applyDecs2203R")) {
                        u = n.types.arrayPattern([
                            ...e1,
                            ...t
                        ]);
                        d = n.types.callExpression(c.addHelper(p === "2021-12" ? "applyDecs" : "applyDecs2203"), f);
                        return n.types.assignmentExpression("=", u, d);
                    } else if (p === "2022-03") {
                        d = n.types.callExpression(c.addHelper("applyDecs2203R"), f);
                    } else if (p === "2023-01") {
                        if (a) {
                            f.push(createPrivateBrandCheckClosure(a));
                        }
                        d = n.types.callExpression(c.addHelper("applyDecs2301"), f);
                    } else if (p === "2023-05") {
                        if (a || l || i.value !== 0) {
                            f.push(i);
                        }
                        if (a) {
                            f.push(createPrivateBrandCheckClosure(a));
                        } else if (l) {
                            f.push(n.types.unaryExpression("void", n.types.numericLiteral(0)));
                        }
                        if (l) f.push(l);
                        d = n.types.callExpression(c.addHelper("applyDecs2305"), f);
                    }
                }
                if (p === "2023-11") {
                    if (a || l || i.value !== 0) {
                        f.push(i);
                    }
                    if (a) {
                        f.push(createPrivateBrandCheckClosure(a));
                    } else if (l) {
                        f.push(n.types.unaryExpression("void", n.types.numericLiteral(0)));
                    }
                    if (l) f.push(l);
                    d = n.types.callExpression(c.addHelper("applyDecs2311"), f);
                }
                if (e1.length > 0) {
                    if (t.length > 0) {
                        u = n.types.objectPattern([
                            n.types.objectProperty(n.types.identifier("e"), n.types.arrayPattern(e1)),
                            n.types.objectProperty(n.types.identifier("c"), n.types.arrayPattern(t))
                        ]);
                    } else {
                        u = n.types.arrayPattern(e1);
                        d = n.types.memberExpression(d, n.types.identifier("e"), false, false);
                    }
                } else {
                    u = n.types.arrayPattern(t);
                    d = n.types.memberExpression(d, n.types.identifier("c"), false, false);
                }
                return n.types.assignmentExpression("=", u, d);
            }
            function isProtoKey(e1) {
                return e1.type === "Identifier" ? e1.name === "__proto__" : e1.value === "__proto__";
            }
            function isDecorated(e1) {
                return e1.decorators && e1.decorators.length > 0;
            }
            function shouldTransformElement(e1) {
                switch(e1.type){
                    case "ClassAccessorProperty":
                        return true;
                    case "ClassMethod":
                    case "ClassProperty":
                    case "ClassPrivateMethod":
                    case "ClassPrivateProperty":
                        return isDecorated(e1);
                    default:
                        return false;
                }
            }
            function shouldTransformClass(e1) {
                return isDecorated(e1) || e1.body.body.some(shouldTransformElement);
            }
            function NamedEvaluationVisitoryFactory(e1, t) {
                function handleComputedProperty(e1, t, r) {
                    switch(t.type){
                        case "StringLiteral":
                            return n.types.stringLiteral(t.value);
                        case "NumericLiteral":
                        case "BigIntLiteral":
                            {
                                const r = t.value + "";
                                e1.get("key").replaceWith(n.types.stringLiteral(r));
                                return n.types.stringLiteral(r);
                            }
                        default:
                            {
                                const s = e1.scope.maybeGenerateMemoised(t);
                                e1.get("key").replaceWith(n.types.assignmentExpression("=", s, createToPropertyKeyCall(r, t)));
                                return n.types.cloneNode(s);
                            }
                    }
                }
                return {
                    VariableDeclarator (r, n) {
                        const s = r.node.id;
                        if (s.type === "Identifier") {
                            const a = (0, i.skipTransparentExprWrappers)(r.get("init"));
                            if (e1(a)) {
                                const e1 = s.name;
                                t(a, n, e1);
                            }
                        }
                    },
                    AssignmentExpression (r, n) {
                        const s = r.node.left;
                        if (s.type === "Identifier") {
                            const a = (0, i.skipTransparentExprWrappers)(r.get("right"));
                            if (e1(a)) {
                                switch(r.node.operator){
                                    case "=":
                                    case "&&=":
                                    case "||=":
                                    case "??=":
                                        t(a, n, s.name);
                                }
                            }
                        }
                    },
                    AssignmentPattern (r, n) {
                        const s = r.node.left;
                        if (s.type === "Identifier") {
                            const a = (0, i.skipTransparentExprWrappers)(r.get("right"));
                            if (e1(a)) {
                                const e1 = s.name;
                                t(a, n, e1);
                            }
                        }
                    },
                    ObjectExpression (r, s) {
                        for (const a of r.get("properties")){
                            if (!a.isObjectProperty()) continue;
                            const { node: r } = a;
                            const o = r.key;
                            const l = (0, i.skipTransparentExprWrappers)(a.get("value"));
                            if (e1(l)) {
                                if (!r.computed) {
                                    if (!isProtoKey(o)) {
                                        if (o.type === "Identifier") {
                                            t(l, s, o.name);
                                        } else {
                                            const e1 = n.types.stringLiteral(o.value + "");
                                            t(l, s, e1);
                                        }
                                    }
                                } else {
                                    const e1 = handleComputedProperty(a, o, s);
                                    t(l, s, e1);
                                }
                            }
                        }
                    },
                    ClassPrivateProperty (r, s) {
                        const { node: a } = r;
                        const o = (0, i.skipTransparentExprWrappers)(r.get("value"));
                        if (e1(o)) {
                            const e1 = n.types.stringLiteral("#" + a.key.id.name);
                            t(o, s, e1);
                        }
                    },
                    ClassAccessorProperty (r, s) {
                        const { node: a } = r;
                        const o = a.key;
                        const l = (0, i.skipTransparentExprWrappers)(r.get("value"));
                        if (e1(l)) {
                            if (!a.computed) {
                                if (o.type === "Identifier") {
                                    t(l, s, o.name);
                                } else if (o.type === "PrivateName") {
                                    const e1 = n.types.stringLiteral("#" + o.id.name);
                                    t(l, s, e1);
                                } else {
                                    const e1 = n.types.stringLiteral(o.value + "");
                                    t(l, s, e1);
                                }
                            } else {
                                const e1 = handleComputedProperty(r, o, s);
                                t(l, s, e1);
                            }
                        }
                    },
                    ClassProperty (r, s) {
                        const { node: a } = r;
                        const o = a.key;
                        const l = (0, i.skipTransparentExprWrappers)(r.get("value"));
                        if (e1(l)) {
                            if (!a.computed) {
                                if (o.type === "Identifier") {
                                    t(l, s, o.name);
                                } else {
                                    const e1 = n.types.stringLiteral(o.value + "");
                                    t(l, s, e1);
                                }
                            } else {
                                const e1 = handleComputedProperty(r, o, s);
                                t(l, s, e1);
                            }
                        }
                    }
                };
            }
            function isDecoratedAnonymousClassExpression(e1) {
                return e1.isClassExpression({
                    id: null
                }) && shouldTransformClass(e1.node);
            }
            function generateLetUidIdentifier(e1, t) {
                const r = e1.generateUidIdentifier(t);
                e1.push({
                    id: r,
                    kind: "let"
                });
                return n.types.cloneNode(r);
            }
            function _default(param, param1, i, a) {
                let { assertVersion: e1, assumption: t } = param, { loose: s } = param1;
                var o, l;
                {
                    if (i === "2023-11" || i === "2023-05" || i === "2023-01") {
                        e1("^7.21.0");
                    } else if (i === "2021-12") {
                        e1("^7.16.0");
                    } else {
                        e1("^7.19.0");
                    }
                }
                const c = new WeakSet;
                const p = (o = t("constantSuper")) != null ? o : s;
                const u = (l = t("ignoreFunctionLength")) != null ? l : s;
                const d = NamedEvaluationVisitoryFactory(isDecoratedAnonymousClassExpression, visitClass);
                function visitClass(e1, t, r) {
                    var n;
                    if (c.has(e1)) return;
                    const { node: s } = e1;
                    r != null ? r : r = (n = s.id) == null ? void 0 : n.name;
                    const a = transformClass(e1, t, p, u, r, d, i);
                    if (a) {
                        c.add(a);
                        return;
                    }
                    c.add(e1);
                }
                return {
                    name: "proposal-decorators",
                    inherits: a,
                    visitor: Object.assign({
                        ExportDefaultDeclaration (e1, t) {
                            const { declaration: s } = e1.node;
                            if ((s == null ? void 0 : s.type) === "ClassDeclaration" && isDecorated(s)) {
                                const a = !s.id;
                                {
                                    var i;
                                    (i = e1.splitExportDeclaration) != null ? i : e1.splitExportDeclaration = r(8026).NodePath.prototype.splitExportDeclaration;
                                }
                                const o = e1.splitExportDeclaration();
                                if (a) {
                                    visitClass(o, t, n.types.stringLiteral("default"));
                                }
                            }
                        },
                        ExportNamedDeclaration (e1) {
                            const { declaration: t } = e1.node;
                            if ((t == null ? void 0 : t.type) === "ClassDeclaration" && isDecorated(t)) {
                                {
                                    var n;
                                    (n = e1.splitExportDeclaration) != null ? n : e1.splitExportDeclaration = r(8026).NodePath.prototype.splitExportDeclaration;
                                }
                                e1.splitExportDeclaration();
                            }
                        },
                        Class (e1, t) {
                            visitClass(e1, t, undefined);
                        }
                    }, d)
                };
            }
        },
        1409: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.FEATURES = void 0;
            t.enableFeature = enableFeature;
            t.isLoose = isLoose;
            t.shouldTransform = shouldTransform;
            var n = r(7009);
            const s = t.FEATURES = Object.freeze({
                fields: 1 << 1,
                privateMethods: 1 << 2,
                decorators: 1 << 3,
                privateIn: 1 << 4,
                staticBlocks: 1 << 5
            });
            const i = new Map([
                [
                    s.fields,
                    "@babel/plugin-transform-class-properties"
                ],
                [
                    s.privateMethods,
                    "@babel/plugin-transform-private-methods"
                ],
                [
                    s.privateIn,
                    "@babel/plugin-transform-private-property-in-object"
                ]
            ]);
            const a = "@babel/plugin-class-features/featuresKey";
            const o = "@babel/plugin-class-features/looseKey";
            {
                var l = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
            }
            {
                var canIgnoreLoose = function(e1, t) {
                    return !!(e1.get(l) & t);
                };
            }
            function enableFeature(e1, t, r) {
                if (!hasFeature(e1, t) || canIgnoreLoose(e1, t)) {
                    e1.set(a, e1.get(a) | t);
                    if (r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
                        setLoose(e1, t, true);
                        e1.set(l, e1.get(l) | t);
                    } else if (r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
                        setLoose(e1, t, false);
                        e1.set(l, e1.get(l) | t);
                    } else {
                        setLoose(e1, t, r);
                    }
                }
                let n;
                for (const [t, r] of i){
                    if (!hasFeature(e1, t)) continue;
                    {
                        if (canIgnoreLoose(e1, t)) continue;
                    }
                    const i = isLoose(e1, t);
                    if (n === !i) {
                        throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, " + "@babel/plugin-transform-private-methods and " + "@babel/plugin-transform-private-property-in-object (when they are enabled)." + "\n\n" + getBabelShowConfigForHint(e1));
                    } else {
                        n = i;
                        {
                            var s = r;
                        }
                    }
                }
                if (n !== undefined) {
                    for (const [t, r] of i){
                        if (hasFeature(e1, t) && isLoose(e1, t) !== n) {
                            setLoose(e1, t, n);
                            console.warn('Though the "loose" option was set to "'.concat(!n, '" in your @babel/preset-env ') + "config, it will not be used for ".concat(r, ' since the "loose" mode option was set to ') + '"'.concat(n, '" for ').concat(s, '.\nThe "loose" option must be the ') + "same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods " + "and @babel/plugin-transform-private-property-in-object (when they are enabled): you can " + "silence this warning by explicitly adding\n" + '	["'.concat(r, '", { "loose": ').concat(n, " }]\n") + 'to the "plugins" section of your Babel config.' + "\n\n" + getBabelShowConfigForHint(e1));
                        }
                    }
                }
            }
            function getBabelShowConfigForHint(e1) {
                let { filename: t } = e1.opts;
                if (!t || t === "unknown") {
                    t = "[name of the input file]";
                }
                return "If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.\nYou can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:\n	npx cross-env BABEL_SHOW_CONFIG_FOR=".concat(t, " <your build command>\nSee https://babeljs.io/docs/configuration#print-effective-configs for more info.");
            }
            function hasFeature(e1, t) {
                return !!(e1.get(a) & t);
            }
            function isLoose(e1, t) {
                return !!(e1.get(o) & t);
            }
            function setLoose(e1, t, r) {
                if (r) e1.set(o, e1.get(o) | t);
                else e1.set(o, e1.get(o) & ~t);
                {
                    e1.set(l, e1.get(l) & ~t);
                }
            }
            function shouldTransform(e1, t) {
                let r = null;
                let i = null;
                let a = null;
                let o = null;
                let l = null;
                if ((0, n.hasOwnDecorators)(e1.node)) {
                    r = e1.get("decorators.0");
                }
                for (const t of e1.get("body.body")){
                    if (!r && (0, n.hasOwnDecorators)(t.node)) {
                        r = t.get("decorators.0");
                    }
                    if (!i && t.isClassProperty()) {
                        i = t;
                    }
                    if (!a && t.isClassPrivateProperty()) {
                        a = t;
                    }
                    if (!o && t.isClassPrivateMethod != null && t.isClassPrivateMethod()) {
                        o = t;
                    }
                    if (!l && t.isStaticBlock != null && t.isStaticBlock()) {
                        l = t;
                    }
                }
                if (r && a) {
                    throw a.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
                }
                if (r && o) {
                    throw o.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
                }
                if (r && !hasFeature(t, s.decorators)) {
                    throw e1.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "version": "legacy" }], ' + 'make sure it comes *before* "@babel/plugin-transform-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n' + '\t["@babel/plugin-transform-class-properties", { "loose": true }]');
                }
                if (o && !hasFeature(t, s.privateMethods)) {
                    throw o.buildCodeFrameError("Class private methods are not enabled. " + "Please add `@babel/plugin-transform-private-methods` to your configuration.");
                }
                if ((i || a) && !hasFeature(t, s.fields) && !hasFeature(t, s.privateMethods)) {
                    throw e1.buildCodeFrameError("Class fields are not enabled. " + "Please add `@babel/plugin-transform-class-properties` to your configuration.");
                }
                if (l && !hasFeature(t, s.staticBlocks)) {
                    throw e1.buildCodeFrameError("Static class blocks are not enabled. " + "Please add `@babel/plugin-transform-class-static-block` to your configuration.");
                }
                if (r || o || l) {
                    return true;
                }
                if ((i || a) && hasFeature(t, s.fields)) {
                    return true;
                }
                return false;
            }
        },
        4697: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildCheckInRHS = buildCheckInRHS;
            t.buildFieldsInitNodes = buildFieldsInitNodes;
            t.buildPrivateNamesMap = buildPrivateNamesMap;
            t.buildPrivateNamesNodes = buildPrivateNamesNodes;
            t.privateNameVisitorFactory = privateNameVisitorFactory;
            t.transformPrivateNamesUsage = transformPrivateNamesUsage;
            var n = r(2358);
            var s = r(8026);
            var i = r(6721);
            var a = r(3034);
            var o = r(582);
            var l = r(344);
            var c = r(9102);
            var p = r(1238);
            {
                var newHelpers = (e1)=>{
                    return e1.availableHelper("classPrivateFieldGet2");
                };
            }
            function buildPrivateNamesMap(e1, t, r, s) {
                const i = new Map;
                let a;
                for (const o of r){
                    if (o.isPrivate()) {
                        const { name: r } = o.node.key.id;
                        let l = i.get(r);
                        if (!l) {
                            const n = !o.isProperty();
                            const c = o.node.static;
                            let p = false;
                            let u;
                            if (!t && newHelpers(s) && n && !c) {
                                p = !!a;
                                a != null ? a : a = o.scope.generateUidIdentifier("".concat(e1, "_brand"));
                                u = a;
                            } else {
                                u = o.scope.generateUidIdentifier(r);
                            }
                            l = {
                                id: u,
                                static: c,
                                method: n,
                                initAdded: p
                            };
                            i.set(r, l);
                        }
                        if (o.isClassPrivateMethod()) {
                            if (o.node.kind === "get") {
                                const { body: e1 } = o.node.body;
                                let t;
                                if (e1.length === 1 && n.types.isReturnStatement(t = e1[0]) && n.types.isCallExpression(t = t.argument) && t.arguments.length === 1 && n.types.isThisExpression(t.arguments[0]) && n.types.isIdentifier(t = t.callee)) {
                                    l.getId = n.types.cloneNode(t);
                                    l.getterDeclared = true;
                                } else {
                                    l.getId = o.scope.generateUidIdentifier("get_".concat(r));
                                }
                            } else if (o.node.kind === "set") {
                                const { params: e1 } = o.node;
                                const { body: t } = o.node.body;
                                let s;
                                if (t.length === 1 && n.types.isExpressionStatement(s = t[0]) && n.types.isCallExpression(s = s.expression) && s.arguments.length === 2 && n.types.isThisExpression(s.arguments[0]) && n.types.isIdentifier(s.arguments[1], {
                                    name: e1[0].name
                                }) && n.types.isIdentifier(s = s.callee)) {
                                    l.setId = n.types.cloneNode(s);
                                    l.setterDeclared = true;
                                } else {
                                    l.setId = o.scope.generateUidIdentifier("set_".concat(r));
                                }
                            } else if (o.node.kind === "method") {
                                l.methodId = o.scope.generateUidIdentifier(r);
                            }
                        }
                        i.set(r, l);
                    }
                }
                return i;
            }
            function buildPrivateNamesNodes(e1, t, r, s) {
                const i = [];
                const a = new Set;
                for (const [o, c] of e1){
                    const { static: e1, method: p, getId: u, setId: d } = c;
                    const f = u || d;
                    const h = n.types.cloneNode(c.id);
                    let m;
                    if (t) {
                        m = n.types.callExpression(s.addHelper("classPrivateFieldLooseKey"), [
                            n.types.stringLiteral(o)
                        ]);
                    } else if (r) {
                        m = n.types.callExpression(n.types.identifier("Symbol"), [
                            n.types.stringLiteral(o)
                        ]);
                    } else if (!e1) {
                        if (a.has(h.name)) continue;
                        a.add(h.name);
                        m = n.types.newExpression(n.types.identifier(p && (!f || newHelpers(s)) ? "WeakSet" : "WeakMap"), []);
                    }
                    if (m) {
                        if (!r) {
                            (0, l.default)(m);
                        }
                        i.push(n.template.statement.ast(_templateObject10(), h, m));
                    }
                }
                return i;
            }
            function privateNameVisitorFactory(e1) {
                const t = s.visitors.environmentVisitor(Object.assign({}, e1));
                const r = Object.assign({}, e1, {
                    Class (e1) {
                        const { privateNamesMap: n } = this;
                        const s = e1.get("body.body");
                        const i = new Map(n);
                        const a = [];
                        for (const e1 of s){
                            if (!e1.isPrivate()) continue;
                            const { name: t } = e1.node.key.id;
                            i.delete(t);
                            a.push(t);
                        }
                        if (!a.length) {
                            return;
                        }
                        e1.get("body").traverse(t, Object.assign({}, this, {
                            redeclared: a
                        }));
                        e1.traverse(r, Object.assign({}, this, {
                            privateNamesMap: i
                        }));
                        e1.skipKey("body");
                    }
                });
                return r;
            }
            const u = privateNameVisitorFactory({
                PrivateName (e1, param) {
                    let { noDocumentAll: t } = param;
                    const { privateNamesMap: r, redeclared: n } = this;
                    const { node: s, parentPath: i } = e1;
                    if (!i.isMemberExpression({
                        property: s
                    }) && !i.isOptionalMemberExpression({
                        property: s
                    })) {
                        return;
                    }
                    const { name: a } = s.id;
                    if (!r.has(a)) return;
                    if (n != null && n.includes(a)) return;
                    this.handle(i, t);
                }
            });
            function unshadow(e1, t, r) {
                while((n = t) != null && n.hasBinding(e1) && !t.bindingIdentifierEquals(e1, r)){
                    var n;
                    t.rename(e1);
                    t = t.parent;
                }
            }
            function buildCheckInRHS(e1, t, r) {
                if (r || !(t.availableHelper != null && t.availableHelper("checkInRHS"))) return e1;
                return n.types.callExpression(t.addHelper("checkInRHS"), [
                    e1
                ]);
            }
            const d = privateNameVisitorFactory({
                BinaryExpression (e1, param) {
                    let { file: t } = param;
                    const { operator: r, left: s, right: i } = e1.node;
                    if (r !== "in") return;
                    if (!n.types.isPrivateName(s)) return;
                    const { privateFieldsAsProperties: a, privateNamesMap: o, redeclared: l } = this;
                    const { name: c } = s.id;
                    if (!o.has(c)) return;
                    if (l != null && l.includes(c)) return;
                    unshadow(this.classRef.name, e1.scope, this.innerBinding);
                    if (a) {
                        const { id: r } = o.get(c);
                        e1.replaceWith(n.template.expression.ast(_templateObject11(), buildCheckInRHS(i, t), n.types.cloneNode(r)));
                        return;
                    }
                    const { id: p, static: u } = o.get(c);
                    if (u) {
                        e1.replaceWith(n.template.expression.ast(_templateObject12(), buildCheckInRHS(i, t), n.types.cloneNode(this.classRef)));
                        return;
                    }
                    e1.replaceWith(n.template.expression.ast(_templateObject13(), n.types.cloneNode(p), buildCheckInRHS(i, t)));
                }
            });
            function readOnlyError(e1, t) {
                return n.types.callExpression(e1.addHelper("readOnlyError"), [
                    n.types.stringLiteral("#".concat(t))
                ]);
            }
            function writeOnlyError(e1, t) {
                if (!e1.availableHelper("writeOnlyError")) {
                    console.warn("@babel/helpers is outdated, update it to silence this warning.");
                    return n.types.buildUndefinedNode();
                }
                return n.types.callExpression(e1.addHelper("writeOnlyError"), [
                    n.types.stringLiteral("#".concat(t))
                ]);
            }
            function buildStaticPrivateFieldAccess(e1, t) {
                if (t) return e1;
                return n.types.memberExpression(e1, n.types.identifier("_"));
            }
            function autoInherits(e1) {
                return function(t) {
                    return n.types.inherits(e1.apply(this, arguments), t.node);
                };
            }
            const f = {
                memoise (e1, t) {
                    const { scope: r } = e1;
                    const { object: n } = e1.node;
                    const s = r.maybeGenerateMemoised(n);
                    if (!s) {
                        return;
                    }
                    this.memoiser.set(n, s, t);
                },
                receiver (e1) {
                    const { object: t } = e1.node;
                    if (this.memoiser.has(t)) {
                        return n.types.cloneNode(this.memoiser.get(t));
                    }
                    return n.types.cloneNode(t);
                },
                get: autoInherits(function(e1) {
                    const { classRef: t, privateNamesMap: r, file: s, innerBinding: i, noUninitializedPrivateFieldAccess: a } = this;
                    const o = e1.node.property;
                    const { name: l } = o.id;
                    const { id: c, static: p, method: u, methodId: d, getId: f, setId: h } = r.get(l);
                    const m = f || h;
                    const cloneId = (e1)=>n.types.inherits(n.types.cloneNode(e1), o);
                    if (p) {
                        unshadow(t.name, e1.scope, i);
                        if (!newHelpers(s)) {
                            const r = u && !m ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
                            return n.types.callExpression(s.addHelper(r), [
                                this.receiver(e1),
                                n.types.cloneNode(t),
                                cloneId(c)
                            ]);
                        }
                        const r = this.receiver(e1);
                        const o = n.types.isIdentifier(r) && r.name === t.name;
                        if (!u) {
                            if (o) {
                                return buildStaticPrivateFieldAccess(cloneId(c), a);
                            }
                            return buildStaticPrivateFieldAccess(n.types.callExpression(s.addHelper("assertClassBrand"), [
                                n.types.cloneNode(t),
                                r,
                                cloneId(c)
                            ]), a);
                        }
                        if (f) {
                            if (o) {
                                return n.types.callExpression(cloneId(f), [
                                    r
                                ]);
                            }
                            return n.types.callExpression(s.addHelper("classPrivateGetter"), [
                                n.types.cloneNode(t),
                                r,
                                cloneId(f)
                            ]);
                        }
                        if (h) {
                            const e1 = n.types.buildUndefinedNode();
                            if (o) return e1;
                            return n.types.sequenceExpression([
                                n.types.callExpression(s.addHelper("assertClassBrand"), [
                                    n.types.cloneNode(t),
                                    r
                                ]),
                                e1
                            ]);
                        }
                        if (o) return cloneId(c);
                        return n.types.callExpression(s.addHelper("assertClassBrand"), [
                            n.types.cloneNode(t),
                            r,
                            cloneId(c)
                        ]);
                    }
                    if (u) {
                        if (m) {
                            if (!f) {
                                return n.types.sequenceExpression([
                                    this.receiver(e1),
                                    writeOnlyError(s, l)
                                ]);
                            }
                            if (!newHelpers(s)) {
                                return n.types.callExpression(s.addHelper("classPrivateFieldGet"), [
                                    this.receiver(e1),
                                    cloneId(c)
                                ]);
                            }
                            return n.types.callExpression(s.addHelper("classPrivateGetter"), [
                                n.types.cloneNode(c),
                                this.receiver(e1),
                                cloneId(f)
                            ]);
                        }
                        if (!newHelpers(s)) {
                            return n.types.callExpression(s.addHelper("classPrivateMethodGet"), [
                                this.receiver(e1),
                                n.types.cloneNode(c),
                                cloneId(d)
                            ]);
                        }
                        return n.types.callExpression(s.addHelper("assertClassBrand"), [
                            n.types.cloneNode(c),
                            this.receiver(e1),
                            cloneId(d)
                        ]);
                    }
                    if (newHelpers(s)) {
                        return n.types.callExpression(s.addHelper("classPrivateFieldGet2"), [
                            cloneId(c),
                            this.receiver(e1)
                        ]);
                    }
                    return n.types.callExpression(s.addHelper("classPrivateFieldGet"), [
                        this.receiver(e1),
                        cloneId(c)
                    ]);
                }),
                boundGet (e1) {
                    this.memoise(e1, 1);
                    return n.types.callExpression(n.types.memberExpression(this.get(e1), n.types.identifier("bind")), [
                        this.receiver(e1)
                    ]);
                },
                set: autoInherits(function(e1, t) {
                    const { classRef: r, privateNamesMap: s, file: i, noUninitializedPrivateFieldAccess: a } = this;
                    const o = e1.node.property;
                    const { name: l } = o.id;
                    const { id: c, static: p, method: u, setId: d, getId: f } = s.get(l);
                    const h = f || d;
                    const cloneId = (e1)=>n.types.inherits(n.types.cloneNode(e1), o);
                    if (p) {
                        if (!newHelpers(i)) {
                            const s = u && !h ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
                            return n.types.callExpression(i.addHelper(s), [
                                this.receiver(e1),
                                n.types.cloneNode(r),
                                cloneId(c),
                                t
                            ]);
                        }
                        const s = this.receiver(e1);
                        const o = n.types.isIdentifier(s) && s.name === r.name;
                        if (u && !d) {
                            const e1 = readOnlyError(i, l);
                            if (o) return n.types.sequenceExpression([
                                t,
                                e1
                            ]);
                            return n.types.sequenceExpression([
                                t,
                                n.types.callExpression(i.addHelper("assertClassBrand"), [
                                    n.types.cloneNode(r),
                                    s
                                ]),
                                readOnlyError(i, l)
                            ]);
                        }
                        if (d) {
                            if (o) {
                                return n.types.callExpression(n.types.cloneNode(d), [
                                    s,
                                    t
                                ]);
                            }
                            return n.types.callExpression(i.addHelper("classPrivateSetter"), [
                                n.types.cloneNode(r),
                                cloneId(d),
                                s,
                                t
                            ]);
                        }
                        return n.types.assignmentExpression("=", buildStaticPrivateFieldAccess(cloneId(c), a), o ? t : n.types.callExpression(i.addHelper("assertClassBrand"), [
                            n.types.cloneNode(r),
                            s,
                            t
                        ]));
                    }
                    if (u) {
                        if (d) {
                            if (!newHelpers(i)) {
                                return n.types.callExpression(i.addHelper("classPrivateFieldSet"), [
                                    this.receiver(e1),
                                    cloneId(c),
                                    t
                                ]);
                            }
                            return n.types.callExpression(i.addHelper("classPrivateSetter"), [
                                n.types.cloneNode(c),
                                cloneId(d),
                                this.receiver(e1),
                                t
                            ]);
                        }
                        return n.types.sequenceExpression([
                            this.receiver(e1),
                            t,
                            readOnlyError(i, l)
                        ]);
                    }
                    if (newHelpers(i)) {
                        return n.types.callExpression(i.addHelper("classPrivateFieldSet2"), [
                            cloneId(c),
                            this.receiver(e1),
                            t
                        ]);
                    }
                    return n.types.callExpression(i.addHelper("classPrivateFieldSet"), [
                        this.receiver(e1),
                        cloneId(c),
                        t
                    ]);
                }),
                destructureSet (e1) {
                    const { classRef: t, privateNamesMap: r, file: s, noUninitializedPrivateFieldAccess: i } = this;
                    const a = e1.node.property;
                    const { name: o } = a.id;
                    const { id: l, static: c, method: p, setId: u } = r.get(o);
                    const cloneId = (e1)=>n.types.inherits(n.types.cloneNode(e1), a);
                    if (!newHelpers(s)) {
                        if (c) {
                            try {
                                var d = s.addHelper("classStaticPrivateFieldDestructureSet");
                            } catch (e1) {
                                throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n" + "please update @babel/helpers to the latest version.");
                            }
                            return n.types.memberExpression(n.types.callExpression(d, [
                                this.receiver(e1),
                                n.types.cloneNode(t),
                                cloneId(l)
                            ]), n.types.identifier("value"));
                        }
                        return n.types.memberExpression(n.types.callExpression(s.addHelper("classPrivateFieldDestructureSet"), [
                            this.receiver(e1),
                            cloneId(l)
                        ]), n.types.identifier("value"));
                    }
                    if (p && !u) {
                        return n.types.memberExpression(n.types.sequenceExpression([
                            e1.node.object,
                            readOnlyError(s, o)
                        ]), n.types.identifier("_"));
                    }
                    if (c && !p) {
                        const t = this.get(e1);
                        if (!i || !n.types.isCallExpression(t)) {
                            return t;
                        }
                        const r = t.arguments.pop();
                        t.arguments.push(n.template.expression.ast(_templateObject14(), r));
                        return n.types.memberExpression(n.types.callExpression(s.addHelper("toSetter"), [
                            t
                        ]), n.types.identifier("_"));
                    }
                    const f = this.set(e1, n.types.identifier("_"));
                    if (!n.types.isCallExpression(f) || !n.types.isIdentifier(f.arguments[f.arguments.length - 1], {
                        name: "_"
                    })) {
                        throw e1.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. " + "Please report it at https://github.com/babel/babel/issues.");
                    }
                    let h;
                    if (n.types.isMemberExpression(f.callee, {
                        computed: false
                    }) && n.types.isIdentifier(f.callee.property) && f.callee.property.name === "call") {
                        h = [
                            f.callee.object,
                            n.types.arrayExpression(f.arguments.slice(1, -1)),
                            f.arguments[0]
                        ];
                    } else {
                        h = [
                            f.callee,
                            n.types.arrayExpression(f.arguments.slice(0, -1))
                        ];
                    }
                    return n.types.memberExpression(n.types.callExpression(s.addHelper("toSetter"), h), n.types.identifier("_"));
                },
                call (e1, t) {
                    this.memoise(e1, 1);
                    return (0, o.default)(this.get(e1), this.receiver(e1), t, false);
                },
                optionalCall (e1, t) {
                    this.memoise(e1, 1);
                    return (0, o.default)(this.get(e1), this.receiver(e1), t, true);
                },
                delete () {
                    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
                }
            };
            const h = {
                get (e1) {
                    const { privateNamesMap: t, file: r } = this;
                    const { object: s } = e1.node;
                    const { name: i } = e1.node.property.id;
                    return n.template.expression(_templateObject15())({
                        BASE: r.addHelper("classPrivateFieldLooseBase"),
                        REF: n.types.cloneNode(s),
                        PROP: n.types.cloneNode(t.get(i).id)
                    });
                },
                set () {
                    throw new Error("private name handler with loose = true don't need set()");
                },
                boundGet (e1) {
                    return n.types.callExpression(n.types.memberExpression(this.get(e1), n.types.identifier("bind")), [
                        n.types.cloneNode(e1.node.object)
                    ]);
                },
                simpleSet (e1) {
                    return this.get(e1);
                },
                destructureSet (e1) {
                    return this.get(e1);
                },
                call (e1, t) {
                    return n.types.callExpression(this.get(e1), t);
                },
                optionalCall (e1, t) {
                    return n.types.optionalCallExpression(this.get(e1), t, true);
                },
                delete () {
                    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
                }
            };
            function transformPrivateNamesUsage(e1, t, r, param, l) {
                let { privateFieldsAsProperties: n, noUninitializedPrivateFieldAccess: s, noDocumentAll: i, innerBinding: o } = param;
                if (!r.size) return;
                const c = t.get("body");
                const p = n ? h : f;
                (0, a.default)(c, u, Object.assign({
                    privateNamesMap: r,
                    classRef: e1,
                    file: l
                }, p, {
                    noDocumentAll: i,
                    noUninitializedPrivateFieldAccess: s,
                    innerBinding: o
                }));
                c.traverse(d, {
                    privateNamesMap: r,
                    classRef: e1,
                    file: l,
                    privateFieldsAsProperties: n,
                    innerBinding: o
                });
            }
            function buildPrivateFieldInitLoose(e1, t, r) {
                const { id: s } = r.get(t.node.key.id.name);
                const i = t.node.value || t.scope.buildUndefinedNode();
                return inheritPropComments(n.template.statement.ast(_templateObject16(), e1, n.types.cloneNode(s), i), t);
            }
            function buildPrivateInstanceFieldInitSpec(e1, t, r, s) {
                const { id: i } = r.get(t.node.key.id.name);
                const a = t.node.value || t.scope.buildUndefinedNode();
                {
                    if (!s.availableHelper("classPrivateFieldInitSpec")) {
                        return inheritPropComments(n.template.statement.ast(_templateObject17(), n.types.cloneNode(i), e1, a), t);
                    }
                }
                const o = s.addHelper("classPrivateFieldInitSpec");
                return inheritLoc(inheritPropComments(n.types.expressionStatement(n.types.callExpression(o, [
                    n.types.thisExpression(),
                    inheritLoc(n.types.cloneNode(i), t.node.key),
                    newHelpers(s) ? a : n.template.expression.ast(_templateObject18(), a)
                ])), t), t.node);
            }
            function buildPrivateStaticFieldInitSpec(e1, t, r) {
                const s = t.get(e1.node.key.id.name);
                const i = r ? e1.node.value : n.template.expression.ast(_templateObject19(), e1.node.value || n.types.buildUndefinedNode());
                return inheritPropComments(n.types.variableDeclaration("var", [
                    n.types.variableDeclarator(n.types.cloneNode(s.id), i)
                ]), e1);
            }
            {
                var buildPrivateStaticFieldInitSpecOld = function(e1, t) {
                    const r = t.get(e1.node.key.id.name);
                    const { id: s, getId: i, setId: a, initAdded: o } = r;
                    const l = i || a;
                    if (!e1.isProperty() && (o || !l)) return;
                    if (l) {
                        t.set(e1.node.key.id.name, Object.assign({}, r, {
                            initAdded: true
                        }));
                        return inheritPropComments(n.template.statement.ast(_templateObject20(), n.types.cloneNode(s), i ? i.name : e1.scope.buildUndefinedNode(), a ? a.name : e1.scope.buildUndefinedNode()), e1);
                    }
                    const c = e1.node.value || e1.scope.buildUndefinedNode();
                    return inheritPropComments(n.template.statement.ast(_templateObject21(), n.types.cloneNode(s), c), e1);
                };
            }
            function buildPrivateMethodInitLoose(e1, t, r) {
                const s = r.get(t.node.key.id.name);
                const { methodId: i, id: a, getId: o, setId: l, initAdded: c } = s;
                if (c) return;
                if (i) {
                    return inheritPropComments(n.template.statement.ast(_templateObject22(), e1, a, i.name), t);
                }
                const p = o || l;
                if (p) {
                    r.set(t.node.key.id.name, Object.assign({}, s, {
                        initAdded: true
                    }));
                    return inheritPropComments(n.template.statement.ast(_templateObject23(), e1, a, o ? o.name : t.scope.buildUndefinedNode(), l ? l.name : t.scope.buildUndefinedNode()), t);
                }
            }
            function buildPrivateInstanceMethodInitSpec(e1, t, r, n) {
                const s = r.get(t.node.key.id.name);
                if (s.initAdded) return;
                if (!newHelpers(n)) {
                    const i = s.getId || s.setId;
                    if (i) {
                        return buildPrivateAccessorInitialization(e1, t, r, n);
                    }
                }
                return buildPrivateInstanceMethodInitialization(e1, t, r, n);
            }
            function buildPrivateAccessorInitialization(e1, t, r, s) {
                const i = r.get(t.node.key.id.name);
                const { id: a, getId: o, setId: l } = i;
                r.set(t.node.key.id.name, Object.assign({}, i, {
                    initAdded: true
                }));
                {
                    if (!s.availableHelper("classPrivateFieldInitSpec")) {
                        return inheritPropComments(n.template.statement.ast(_templateObject24(), a, e1, o ? o.name : t.scope.buildUndefinedNode(), l ? l.name : t.scope.buildUndefinedNode()), t);
                    }
                }
                const c = s.addHelper("classPrivateFieldInitSpec");
                return inheritLoc(inheritPropComments(n.template.statement.ast(_templateObject25(), c, n.types.thisExpression(), n.types.cloneNode(a), o ? o.name : t.scope.buildUndefinedNode(), l ? l.name : t.scope.buildUndefinedNode()), t), t.node);
            }
            function buildPrivateInstanceMethodInitialization(e1, t, r, s) {
                const i = r.get(t.node.key.id.name);
                const { id: a } = i;
                {
                    if (!s.availableHelper("classPrivateMethodInitSpec")) {
                        return inheritPropComments(n.template.statement.ast(_templateObject26(), a, e1), t);
                    }
                }
                const o = s.addHelper("classPrivateMethodInitSpec");
                return inheritPropComments(n.template.statement.ast(_templateObject27(), o, n.types.thisExpression(), n.types.cloneNode(a)), t);
            }
            function buildPublicFieldInitLoose(e1, t) {
                const { key: r, computed: s } = t.node;
                const i = t.node.value || t.scope.buildUndefinedNode();
                return inheritPropComments(n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(e1, r, s || n.types.isLiteral(r)), i)), t);
            }
            function buildPublicFieldInitSpec(e1, t, r) {
                const { key: s, computed: i } = t.node;
                const a = t.node.value || t.scope.buildUndefinedNode();
                return inheritPropComments(n.types.expressionStatement(n.types.callExpression(r.addHelper("defineProperty"), [
                    e1,
                    i || n.types.isLiteral(s) ? s : n.types.stringLiteral(s.name),
                    a
                ])), t);
            }
            function buildPrivateStaticMethodInitLoose(e1, t, r, s) {
                const i = s.get(t.node.key.id.name);
                const { id: a, methodId: o, getId: l, setId: c, initAdded: p } = i;
                if (p) return;
                const u = l || c;
                if (u) {
                    s.set(t.node.key.id.name, Object.assign({}, i, {
                        initAdded: true
                    }));
                    return inheritPropComments(n.template.statement.ast(_templateObject28(), e1, a, l ? l.name : t.scope.buildUndefinedNode(), c ? c.name : t.scope.buildUndefinedNode()), t);
                }
                return inheritPropComments(n.template.statement.ast(_templateObject29(), e1, a, o.name), t);
            }
            function buildPrivateMethodDeclaration(e1, t, r) {
                let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                const i = r.get(t.node.key.id.name);
                const { id: a, methodId: o, getId: l, setId: c, getterDeclared: p, setterDeclared: u, static: d } = i;
                const { params: f, body: h, generator: y, async: g } = t.node;
                const b = l && f.length === 0;
                const T = c && f.length > 0;
                if (b && p || T && u) {
                    r.set(t.node.key.id.name, Object.assign({}, i, {
                        initAdded: true
                    }));
                    return null;
                }
                if (newHelpers(e1) && (b || T) && !s) {
                    const e1 = t.get("body").scope;
                    const r = e1.generateUidIdentifier("this");
                    const s = {
                        thisRef: r,
                        argumentsPath: []
                    };
                    t.traverse(m, s);
                    if (s.argumentsPath.length) {
                        const t = e1.generateUidIdentifier("arguments");
                        e1.push({
                            id: t,
                            init: n.template.expression.ast(_templateObject30())
                        });
                        for (const e1 of s.argumentsPath){
                            e1.replaceWith(n.types.cloneNode(t));
                        }
                    }
                    f.unshift(n.types.cloneNode(r));
                }
                let S = o;
                if (b) {
                    r.set(t.node.key.id.name, Object.assign({}, i, {
                        getterDeclared: true,
                        initAdded: true
                    }));
                    S = l;
                } else if (T) {
                    r.set(t.node.key.id.name, Object.assign({}, i, {
                        setterDeclared: true,
                        initAdded: true
                    }));
                    S = c;
                } else if (d && !s) {
                    S = a;
                }
                return inheritPropComments(n.types.functionDeclaration(n.types.cloneNode(S), f, h, y, g), t);
            }
            const m = s.visitors.environmentVisitor({
                Identifier (e1, t) {
                    if (t.argumentsPath && e1.node.name === "arguments") {
                        t.argumentsPath.push(e1);
                    }
                },
                UnaryExpression (e1) {
                    const { node: t } = e1;
                    if (t.operator === "delete") {
                        const r = (0, c.skipTransparentExprWrapperNodes)(t.argument);
                        if (n.types.isThisExpression(r)) {
                            e1.replaceWith(n.types.booleanLiteral(true));
                        }
                    }
                },
                ThisExpression (e1, t) {
                    t.needsClassRef = true;
                    e1.replaceWith(n.types.cloneNode(t.thisRef));
                },
                MetaProperty (e1) {
                    const { node: t, scope: r } = e1;
                    if (t.meta.name === "new" && t.property.name === "target") {
                        e1.replaceWith(r.buildUndefinedNode());
                    }
                }
            });
            const y = {
                ReferencedIdentifier (e1, t) {
                    if (e1.scope.bindingIdentifierEquals(e1.node.name, t.innerBinding)) {
                        t.needsClassRef = true;
                        e1.node.name = t.thisRef.name;
                    }
                }
            };
            function replaceThisContext(e1, t, r) {
                var n;
                const s = {
                    thisRef: t,
                    needsClassRef: false,
                    innerBinding: r
                };
                if (!e1.isMethod()) {
                    e1.traverse(m, s);
                }
                if (r != null && (n = s.thisRef) != null && n.name && s.thisRef.name !== r.name) {
                    e1.traverse(y, s);
                }
                return s.needsClassRef;
            }
            function isNameOrLength(param) {
                let { key: e1, computed: t } = param;
                if (e1.type === "Identifier") {
                    return !t && (e1.name === "name" || e1.name === "length");
                }
                if (e1.type === "StringLiteral") {
                    return e1.value === "name" || e1.value === "length";
                }
                return false;
            }
            function inheritPropComments(e1, t) {
                n.types.inheritLeadingComments(e1, t.node);
                n.types.inheritInnerComments(e1, t.node);
                return e1;
            }
            function inheritLoc(e1, t) {
                e1.start = t.start;
                e1.end = t.end;
                e1.loc = t.loc;
                return e1;
            }
            function buildFieldsInitNodes(e1, t, r, s, a, o, l, c, u, d) {
                let f = 0;
                let h;
                const m = [];
                const y = [];
                let g = false;
                const b = [];
                let T = null;
                const S = n.types.isIdentifier(t) ? ()=>t : ()=>{
                    h != null ? h : h = r[0].scope.generateUidIdentifierBasedOnNode(t);
                    return h;
                };
                const x = e1 != null ? e1 : r[0].scope.generateUidIdentifier((d == null ? void 0 : d.name) || "Class");
                e1 != null ? e1 : e1 = n.types.cloneNode(d);
                for (const t of r){
                    if (t.isClassProperty()) {
                        p.assertFieldTransformed(t);
                    }
                    const r = !(n.types.isStaticBlock != null && n.types.isStaticBlock(t.node)) && t.node.static;
                    const h = !r;
                    const T = t.isPrivate();
                    const E = !T;
                    const P = t.isProperty();
                    const v = !P;
                    const A = t.isStaticBlock == null ? void 0 : t.isStaticBlock();
                    if (r) f |= 1;
                    if (r || v && T || A) {
                        new i.default({
                            methodPath: t,
                            constantSuper: u,
                            file: a,
                            refToPreserve: d,
                            getSuperRef: S,
                            getObjectRef () {
                                f |= 2;
                                if (r || A) {
                                    return x;
                                } else {
                                    return n.types.memberExpression(x, n.types.identifier("prototype"));
                                }
                            }
                        }).replace();
                        const e1 = replaceThisContext(t, x, d);
                        if (e1) {
                            f |= 2;
                        }
                    }
                    g = false;
                    switch(true){
                        case A:
                            {
                                const e1 = t.node.body;
                                if (e1.length === 1 && n.types.isExpressionStatement(e1[0])) {
                                    m.push(inheritPropComments(e1[0], t));
                                } else {
                                    m.push(n.types.inheritsComments(n.template.statement.ast(_templateObject31(), e1), t.node));
                                }
                                break;
                            }
                        case r && T && P && l:
                            m.push(buildPrivateFieldInitLoose(n.types.cloneNode(e1), t, s));
                            break;
                        case r && T && P && !l:
                            if (!newHelpers(a)) {
                                m.push(buildPrivateStaticFieldInitSpecOld(t, s));
                            } else {
                                m.push(buildPrivateStaticFieldInitSpec(t, s, c));
                            }
                            break;
                        case r && E && P && o:
                            if (!isNameOrLength(t.node)) {
                                m.push(buildPublicFieldInitLoose(n.types.cloneNode(e1), t));
                                break;
                            }
                        case r && E && P && !o:
                            m.push(buildPublicFieldInitSpec(n.types.cloneNode(e1), t, a));
                            break;
                        case h && T && P && l:
                            y.push(buildPrivateFieldInitLoose(n.types.thisExpression(), t, s));
                            break;
                        case h && T && P && !l:
                            y.push(buildPrivateInstanceFieldInitSpec(n.types.thisExpression(), t, s, a));
                            break;
                        case h && T && v && l:
                            y.unshift(buildPrivateMethodInitLoose(n.types.thisExpression(), t, s));
                            b.push(buildPrivateMethodDeclaration(a, t, s, l));
                            break;
                        case h && T && v && !l:
                            y.unshift(buildPrivateInstanceMethodInitSpec(n.types.thisExpression(), t, s, a));
                            b.push(buildPrivateMethodDeclaration(a, t, s, l));
                            break;
                        case r && T && v && !l:
                            if (!newHelpers(a)) {
                                m.unshift(buildPrivateStaticFieldInitSpecOld(t, s));
                            }
                            b.push(buildPrivateMethodDeclaration(a, t, s, l));
                            break;
                        case r && T && v && l:
                            m.unshift(buildPrivateStaticMethodInitLoose(n.types.cloneNode(e1), t, a, s));
                            b.push(buildPrivateMethodDeclaration(a, t, s, l));
                            break;
                        case h && E && P && o:
                            y.push(buildPublicFieldInitLoose(n.types.thisExpression(), t));
                            break;
                        case h && E && P && !o:
                            g = true;
                            y.push(buildPublicFieldInitSpec(n.types.thisExpression(), t, a));
                            break;
                        default:
                            throw new Error("Unreachable.");
                    }
                }
                if (f & 2 && d != null) {
                    T = n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(x), n.types.cloneNode(d)));
                }
                return {
                    staticNodes: m.filter(Boolean),
                    instanceNodes: y.filter(Boolean),
                    lastInstanceNodeReturnsThis: g,
                    pureStaticNodes: b.filter(Boolean),
                    classBindingNode: T,
                    wrapClass (t) {
                        for (const e1 of r){
                            e1.node.leadingComments = null;
                            e1.remove();
                        }
                        if (h) {
                            t.scope.push({
                                id: n.types.cloneNode(h)
                            });
                            t.set("superClass", n.types.assignmentExpression("=", h, t.node.superClass));
                        }
                        if (f !== 0) {
                            if (t.isClassExpression()) {
                                t.scope.push({
                                    id: e1
                                });
                                t.replaceWith(n.types.assignmentExpression("=", n.types.cloneNode(e1), t.node));
                            } else {
                                if (d == null) {
                                    t.node.id = e1;
                                }
                                if (T != null) {
                                    t.scope.push({
                                        id: x
                                    });
                                }
                            }
                        }
                        return t;
                    }
                };
            }
        },
        3713: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "FEATURES", {
                enumerable: true,
                get: function() {
                    return c.FEATURES;
                }
            });
            Object.defineProperty(t, "buildCheckInRHS", {
                enumerable: true,
                get: function() {
                    return i.buildCheckInRHS;
                }
            });
            t.createClassFeaturePlugin = createClassFeaturePlugin;
            Object.defineProperty(t, "enableFeature", {
                enumerable: true,
                get: function() {
                    return c.enableFeature;
                }
            });
            Object.defineProperty(t, "injectInitialization", {
                enumerable: true,
                get: function() {
                    return l.injectInitialization;
                }
            });
            var n = r(2358);
            var s = r(7849);
            var i = r(4697);
            var a = r(7009);
            var o = r(4073);
            var l = r(5040);
            var c = r(1409);
            var p = r(1238);
            const u = "@babel/plugin-class-features/version";
            function createClassFeaturePlugin(param) {
                let { name: e1, feature: t, loose: d, manipulateOptions: f, api: h, inherits: m, decoratorVersion: y } = param;
                var g;
                if (t & c.FEATURES.decorators) {
                    {
                        if (y === "2023-11" || y === "2023-05" || y === "2023-01" || y === "2022-03" || y === "2021-12") {
                            return (0, a.default)(h, {
                                loose: d
                            }, y, m);
                        }
                    }
                }
                {
                    h != null ? h : h = {
                        assumption: ()=>void 0
                    };
                }
                const b = h.assumption("setPublicClassFields");
                const T = h.assumption("privateFieldsAsSymbols");
                const S = h.assumption("privateFieldsAsProperties");
                const x = (g = h.assumption("noUninitializedPrivateFieldAccess")) != null ? g : false;
                const E = h.assumption("constantSuper");
                const P = h.assumption("noDocumentAll");
                if (S && T) {
                    throw new Error('Cannot enable both the "privateFieldsAsProperties" and ' + '"privateFieldsAsSymbols" assumptions as the same time.');
                }
                const v = S || T;
                if (d === true) {
                    const t = [];
                    if (b !== undefined) {
                        t.push('"setPublicClassFields"');
                    }
                    if (S !== undefined) {
                        t.push('"privateFieldsAsProperties"');
                    }
                    if (T !== undefined) {
                        t.push('"privateFieldsAsSymbols"');
                    }
                    if (t.length !== 0) {
                        console.warn("[".concat(e1, ']: You are using the "loose: true" option and you are') + " explicitly setting a value for the ".concat(t.join(" and ")) + " assumption".concat(t.length > 1 ? "s" : "", '. The "loose" option') + " can cause incompatibilities with the other class features" + " plugins, so it's recommended that you replace it with the" + " following top-level option:\n" + '	"assumptions": {\n' + '		"setPublicClassFields": true,\n' + '		"privateFieldsAsSymbols": true\n' + "	}");
                    }
                }
                return {
                    name: e1,
                    manipulateOptions: f,
                    inherits: m,
                    pre (e1) {
                        (0, c.enableFeature)(e1, t, d);
                        {
                            if (typeof e1.get(u) === "number") {
                                e1.set(u, "7.27.0");
                                return;
                            }
                        }
                        if (!e1.get(u) || s.lt(e1.get(u), "7.27.0")) {
                            e1.set(u, "7.27.0");
                        }
                    },
                    visitor: {
                        Class (e1, param) {
                            let { file: s } = param;
                            if (s.get(u) !== "7.27.0") return;
                            if (!(0, c.shouldTransform)(e1, s)) return;
                            const d = e1.isClassDeclaration();
                            if (d) (0, p.assertFieldTransformed)(e1);
                            const f = (0, c.isLoose)(s, t);
                            let h;
                            const m = (0, a.hasDecorators)(e1.node);
                            const y = [];
                            const g = [];
                            const A = [];
                            const w = new Set;
                            const I = e1.get("body");
                            for (const e1 of I.get("body")){
                                if ((e1.isClassProperty() || e1.isClassMethod()) && e1.node.computed) {
                                    A.push(e1);
                                }
                                if (e1.isPrivate()) {
                                    const { name: t } = e1.node.key.id;
                                    const r = "get ".concat(t);
                                    const n = "set ".concat(t);
                                    if (e1.isClassPrivateMethod()) {
                                        if (e1.node.kind === "get") {
                                            if (w.has(r) || w.has(t) && !w.has(n)) {
                                                throw e1.buildCodeFrameError("Duplicate private field");
                                            }
                                            w.add(r).add(t);
                                        } else if (e1.node.kind === "set") {
                                            if (w.has(n) || w.has(t) && !w.has(r)) {
                                                throw e1.buildCodeFrameError("Duplicate private field");
                                            }
                                            w.add(n).add(t);
                                        }
                                    } else {
                                        if (w.has(t) && !w.has(r) && !w.has(n) || w.has(t) && (w.has(r) || w.has(n))) {
                                            throw e1.buildCodeFrameError("Duplicate private field");
                                        }
                                        w.add(t);
                                    }
                                }
                                if (e1.isClassMethod({
                                    kind: "constructor"
                                })) {
                                    h = e1;
                                } else {
                                    g.push(e1);
                                    if (e1.isProperty() || e1.isPrivate() || e1.isStaticBlock != null && e1.isStaticBlock()) {
                                        y.push(e1);
                                    }
                                }
                            }
                            {
                                if (!y.length && !m) return;
                            }
                            const C = e1.node.id;
                            let O;
                            if (!C || !d) {
                                {
                                    var N;
                                    (N = e1.ensureFunctionName) != null ? N : e1.ensureFunctionName = r(8026).NodePath.prototype.ensureFunctionName;
                                }
                                e1.ensureFunctionName(false);
                                O = e1.scope.generateUidIdentifier((C == null ? void 0 : C.name) || "Class");
                            }
                            const k = O != null ? O : n.types.cloneNode(C);
                            const _ = (0, i.buildPrivateNamesMap)(k.name, v != null ? v : f, y, s);
                            const D = (0, i.buildPrivateNamesNodes)(_, S != null ? S : f, T != null ? T : false, s);
                            (0, i.transformPrivateNamesUsage)(k, e1, _, {
                                privateFieldsAsProperties: v != null ? v : f,
                                noUninitializedPrivateFieldAccess: x,
                                noDocumentAll: P,
                                innerBinding: C
                            }, s);
                            let M, L, j, F, B, R, U;
                            {
                                if (m) {
                                    L = B = M = [];
                                    ({ instanceNodes: j, wrapClass: U } = (0, o.buildDecoratedClass)(k, e1, g, s));
                                } else {
                                    M = (0, l.extractComputedKeys)(e1, A, s);
                                    ({ staticNodes: L, pureStaticNodes: B, instanceNodes: j, lastInstanceNodeReturnsThis: F, classBindingNode: R, wrapClass: U } = (0, i.buildFieldsInitNodes)(O, e1.node.superClass, y, _, s, b != null ? b : f, v != null ? v : f, x, E != null ? E : f, C));
                                }
                            }
                            if (j.length > 0) {
                                (0, l.injectInitialization)(e1, h, j, (e1, t)=>{
                                    {
                                        if (m) return;
                                    }
                                    for (const r of y){
                                        if (n.types.isStaticBlock != null && n.types.isStaticBlock(r.node) || r.node.static) continue;
                                        r.traverse(e1, t);
                                    }
                                }, F);
                            }
                            const K = U(e1);
                            K.insertBefore([
                                ...D,
                                ...M
                            ]);
                            if (L.length > 0) {
                                K.insertAfter(L);
                            }
                            if (B.length > 0) {
                                K.find((e1)=>e1.isStatement() || e1.isDeclaration()).insertAfter(B);
                            }
                            if (R != null && d) {
                                K.insertAfter(R);
                            }
                        },
                        ExportDefaultDeclaration (e1, param) {
                            let { file: t } = param;
                            {
                                if (t.get(u) !== "7.27.0") return;
                                const s = e1.get("declaration");
                                if (s.isClassDeclaration() && (0, a.hasDecorators)(s.node)) {
                                    if (s.node.id) {
                                        {
                                            var n;
                                            (n = e1.splitExportDeclaration) != null ? n : e1.splitExportDeclaration = r(8026).NodePath.prototype.splitExportDeclaration;
                                        }
                                        e1.splitExportDeclaration();
                                    } else {
                                        s.node.type = "ClassExpression";
                                    }
                                }
                            }
                        }
                    }
                };
            }
        },
        5040: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.extractComputedKeys = extractComputedKeys;
            t.injectInitialization = injectInitialization;
            t.memoiseComputedKey = memoiseComputedKey;
            var n = r(2358);
            var s = r(8026);
            const i = s.visitors.environmentVisitor({
                Super (e1) {
                    const { node: t, parentPath: r } = e1;
                    if (r.isCallExpression({
                        callee: t
                    })) {
                        this.push(r);
                    }
                }
            });
            const a = {
                "TSTypeAnnotation|TypeAnnotation" (e1) {
                    e1.skip();
                },
                ReferencedIdentifier (e1, param) {
                    let { scope: t } = param;
                    if (t.hasOwnBinding(e1.node.name)) {
                        t.rename(e1.node.name);
                        e1.skip();
                    }
                }
            };
            function handleClassTDZ(e1, t) {
                if (t.classBinding && t.classBinding === e1.scope.getBinding(e1.node.name)) {
                    const r = t.file.addHelper("classNameTDZError");
                    const s = n.types.callExpression(r, [
                        n.types.stringLiteral(e1.node.name)
                    ]);
                    e1.replaceWith(n.types.sequenceExpression([
                        s,
                        e1.node
                    ]));
                    e1.skip();
                }
            }
            const o = {
                ReferencedIdentifier: handleClassTDZ,
                "TSTypeAnnotation|TypeAnnotation" (e1) {
                    e1.skip();
                }
            };
            function injectInitialization(e1, t, r, s, o) {
                if (!r.length) return;
                const l = !!e1.node.superClass;
                if (!t) {
                    const r = n.types.classMethod("constructor", n.types.identifier("constructor"), [], n.types.blockStatement([]));
                    if (l) {
                        r.params = [
                            n.types.restElement(n.types.identifier("args"))
                        ];
                        r.body.body.push(n.template.statement.ast(_templateObject32()));
                    }
                    [t] = e1.get("body").unshiftContainer("body", r);
                }
                if (s) {
                    s(a, {
                        scope: t.scope
                    });
                }
                if (l) {
                    const e1 = [];
                    t.traverse(i, e1);
                    let s = true;
                    for (const t of e1){
                        if (s) {
                            s = false;
                        } else {
                            r = r.map((e1)=>n.types.cloneNode(e1));
                        }
                        if (!t.parentPath.isExpressionStatement()) {
                            const e1 = [
                                t.node,
                                ...r.map((e1)=>n.types.toExpression(e1))
                            ];
                            if (!o) e1.push(n.types.thisExpression());
                            t.replaceWith(n.types.sequenceExpression(e1));
                        } else {
                            t.insertAfter(r);
                        }
                    }
                } else {
                    t.get("body").unshiftContainer("body", r);
                }
            }
            function memoiseComputedKey(e1, t, r) {
                const s = n.types.isIdentifier(e1) && t.hasUid(e1.name);
                if (s) {
                    return;
                }
                const i = n.types.isAssignmentExpression(e1, {
                    operator: "="
                }) && n.types.isIdentifier(e1.left) && t.hasUid(e1.left.name);
                if (i) {
                    return n.types.cloneNode(e1);
                } else {
                    const s = n.types.identifier(r);
                    t.push({
                        id: s,
                        kind: "let"
                    });
                    return n.types.assignmentExpression("=", n.types.cloneNode(s), e1);
                }
            }
            function extractComputedKeys(e1, t, r) {
                const { scope: s } = e1;
                const i = [];
                const a = {
                    classBinding: e1.node.id && s.getBinding(e1.node.id.name),
                    file: r
                };
                for (const e1 of t){
                    const t = e1.get("key");
                    if (t.isReferencedIdentifier()) {
                        handleClassTDZ(t, a);
                    } else {
                        t.traverse(o, a);
                    }
                    const r = e1.node;
                    if (!t.isConstantExpression()) {
                        const e1 = memoiseComputedKey(t.node, s, s.generateUidBasedOnNode(t.node));
                        if (e1) {
                            i.push(n.types.expressionStatement(e1));
                            r.key = n.types.cloneNode(e1.left);
                        }
                    }
                }
                return i;
            }
        },
        1238: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assertFieldTransformed = assertFieldTransformed;
            function assertFieldTransformed(e1) {
                if (e1.node.declare || false) {
                    throw e1.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by " + "@babel/plugin-transform-typescript.\n" + "If you have already enabled that plugin (or '@babel/preset-typescript'), make sure " + "that it runs before any plugin related to additional class features:\n" + " - @babel/plugin-transform-class-properties\n" + " - @babel/plugin-transform-private-methods\n" + " - @babel/plugin-proposal-decorators");
                }
            }
        },
        3034: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(3061);
            function _interopNamespace(e1) {
                if (e1 && e1.__esModule) return e1;
                var t = Object.create(null);
                if (e1) {
                    Object.keys(e1).forEach(function(r) {
                        if (r !== "default") {
                            var n = Object.getOwnPropertyDescriptor(e1, r);
                            Object.defineProperty(t, r, n.get ? n : {
                                enumerable: true,
                                get: function() {
                                    return e1[r];
                                }
                            });
                        }
                    });
                }
                t.default = e1;
                return Object.freeze(t);
            }
            var s = _interopNamespace(n);
            function willPathCastToBoolean(e1) {
                const t = e1;
                const { node: r, parentPath: n } = t;
                if (n.isLogicalExpression()) {
                    const { operator: e1, right: t } = n.node;
                    if (e1 === "&&" || e1 === "||" || e1 === "??" && r === t) {
                        return willPathCastToBoolean(n);
                    }
                }
                if (n.isSequenceExpression()) {
                    const { expressions: e1 } = n.node;
                    if (e1[e1.length - 1] === r) {
                        return willPathCastToBoolean(n);
                    } else {
                        return true;
                    }
                }
                return n.isConditional({
                    test: r
                }) || n.isUnaryExpression({
                    operator: "!"
                }) || n.isLoop({
                    test: r
                });
            }
            const { LOGICAL_OPERATORS: i, arrowFunctionExpression: a, assignmentExpression: o, binaryExpression: l, booleanLiteral: c, callExpression: p, cloneNode: u, conditionalExpression: d, identifier: f, isMemberExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: y, isUpdateExpression: g, logicalExpression: b, memberExpression: T, nullLiteral: S, optionalCallExpression: x, optionalMemberExpression: E, sequenceExpression: P, updateExpression: v } = s;
            class AssignmentMemoiser {
                has(e1) {
                    return this._map.has(e1);
                }
                get(e1) {
                    if (!this.has(e1)) return;
                    const t = this._map.get(e1);
                    const { value: r } = t;
                    t.count--;
                    if (t.count === 0) {
                        return o("=", r, e1);
                    }
                    return r;
                }
                set(e1, t, r) {
                    return this._map.set(e1, {
                        count: r,
                        value: t
                    });
                }
                constructor(){
                    this._map = void 0;
                    this._map = new WeakMap;
                }
            }
            function toNonOptional(e1, t) {
                const { node: r } = e1;
                if (y(r)) {
                    return T(t, r.property, r.computed);
                }
                if (e1.isOptionalCallExpression()) {
                    const r = e1.get("callee");
                    if (e1.node.optional && r.isOptionalMemberExpression()) {
                        const n = r.node.object;
                        const s = e1.scope.maybeGenerateMemoised(n);
                        r.get("object").replaceWith(o("=", s, n));
                        return p(T(t, f("call")), [
                            s,
                            ...e1.node.arguments
                        ]);
                    }
                    return p(t, e1.node.arguments);
                }
                return e1.node;
            }
            function isInDetachedTree(e1) {
                while(e1){
                    if (e1.isProgram()) break;
                    const { parentPath: t, container: r, listKey: n } = e1;
                    const s = t.node;
                    if (n) {
                        if (r !== s[n]) {
                            return true;
                        }
                    } else {
                        if (r !== s) return true;
                    }
                    e1 = t;
                }
                return false;
            }
            const A = {
                memoise () {},
                handle (e1, t) {
                    const { node: r, parent: n, parentPath: s, scope: i } = e1;
                    if (e1.isOptionalMemberExpression()) {
                        if (isInDetachedTree(e1)) return;
                        const g = e1.find((param)=>{
                            let { node: t, parent: r } = param;
                            if (y(r)) {
                                return r.optional || r.object !== t;
                            }
                            if (m(r)) {
                                return t !== e1.node && r.optional || r.callee !== t;
                            }
                            return true;
                        });
                        if (i.path.isPattern()) {
                            g.replaceWith(p(a([], g.node), []));
                            return;
                        }
                        const T = willPathCastToBoolean(g);
                        const P = g.parentPath;
                        if (P.isUpdateExpression({
                            argument: r
                        })) {
                            throw e1.buildCodeFrameError("can't handle update expression");
                        }
                        const v = P.isAssignmentExpression({
                            left: g.node
                        });
                        const A = P.isUnaryExpression({
                            operator: "delete"
                        });
                        if (A && g.isOptionalMemberExpression() && g.get("property").isPrivateName()) {
                            throw e1.buildCodeFrameError("can't delete a private class element");
                        }
                        let w = e1;
                        for(;;){
                            if (w.isOptionalMemberExpression()) {
                                if (w.node.optional) break;
                                w = w.get("object");
                                continue;
                            } else if (w.isOptionalCallExpression()) {
                                if (w.node.optional) break;
                                w = w.get("callee");
                                continue;
                            }
                            throw new Error("Internal error: unexpected ".concat(w.node.type));
                        }
                        const I = w.isOptionalMemberExpression() ? w.node.object : w.node.callee;
                        const C = i.maybeGenerateMemoised(I);
                        const O = C != null ? C : I;
                        const N = s.isOptionalCallExpression({
                            callee: r
                        });
                        const isOptionalCall = (e1)=>N;
                        const k = s.isCallExpression({
                            callee: r
                        });
                        w.replaceWith(toNonOptional(w, O));
                        if (isOptionalCall()) {
                            if (n.optional) {
                                s.replaceWith(this.optionalCall(e1, n.arguments));
                            } else {
                                s.replaceWith(this.call(e1, n.arguments));
                            }
                        } else if (k) {
                            e1.replaceWith(this.boundGet(e1));
                        } else if (this.delete && s.isUnaryExpression({
                            operator: "delete"
                        })) {
                            s.replaceWith(this.delete(e1));
                        } else if (s.isAssignmentExpression()) {
                            handleAssignment(this, e1, s);
                        } else {
                            e1.replaceWith(this.get(e1));
                        }
                        let _ = e1.node;
                        for(let t = e1; t !== g;){
                            const e1 = t.parentPath;
                            if (e1 === g && isOptionalCall() && n.optional) {
                                _ = e1.node;
                                break;
                            }
                            _ = toNonOptional(e1, _);
                            t = e1;
                        }
                        let D;
                        const M = g.parentPath;
                        if (h(_) && M.isOptionalCallExpression({
                            callee: g.node,
                            optional: true
                        })) {
                            const { object: t } = _;
                            D = e1.scope.maybeGenerateMemoised(t);
                            if (D) {
                                _.object = o("=", D, t);
                            }
                        }
                        let L = g;
                        if (A || v) {
                            L = M;
                            _ = M.node;
                        }
                        const j = C ? o("=", u(O), u(I)) : u(O);
                        if (T) {
                            let e1;
                            if (t) {
                                e1 = l("!=", j, S());
                            } else {
                                e1 = b("&&", l("!==", j, S()), l("!==", u(O), i.buildUndefinedNode()));
                            }
                            L.replaceWith(b("&&", e1, _));
                        } else {
                            let e1;
                            if (t) {
                                e1 = l("==", j, S());
                            } else {
                                e1 = b("||", l("===", j, S()), l("===", u(O), i.buildUndefinedNode()));
                            }
                            L.replaceWith(d(e1, A ? c(true) : i.buildUndefinedNode(), _));
                        }
                        if (D) {
                            const e1 = M.node;
                            M.replaceWith(x(E(e1.callee, f("call"), false, true), [
                                u(D),
                                ...e1.arguments
                            ], false));
                        }
                        return;
                    }
                    if (g(n, {
                        argument: r
                    })) {
                        if (this.simpleSet) {
                            e1.replaceWith(this.simpleSet(e1));
                            return;
                        }
                        const { operator: t, prefix: a } = n;
                        this.memoise(e1, 2);
                        const l = i.generateUidIdentifierBasedOnNode(r);
                        i.push({
                            id: l
                        });
                        const c = [
                            o("=", u(l), this.get(e1))
                        ];
                        if (a) {
                            c.push(v(t, u(l), a));
                            const r = P(c);
                            s.replaceWith(this.set(e1, r));
                            return;
                        } else {
                            const n = i.generateUidIdentifierBasedOnNode(r);
                            i.push({
                                id: n
                            });
                            c.push(o("=", u(n), v(t, u(l), a)), u(l));
                            const p = P(c);
                            s.replaceWith(P([
                                this.set(e1, p),
                                u(n)
                            ]));
                            return;
                        }
                    }
                    if (s.isAssignmentExpression({
                        left: r
                    })) {
                        handleAssignment(this, e1, s);
                        return;
                    }
                    if (s.isCallExpression({
                        callee: r
                    })) {
                        s.replaceWith(this.call(e1, s.node.arguments));
                        return;
                    }
                    if (s.isOptionalCallExpression({
                        callee: r
                    })) {
                        if (i.path.isPattern()) {
                            s.replaceWith(p(a([], s.node), []));
                            return;
                        }
                        s.replaceWith(this.optionalCall(e1, s.node.arguments));
                        return;
                    }
                    if (this.delete && s.isUnaryExpression({
                        operator: "delete"
                    })) {
                        s.replaceWith(this.delete(e1));
                        return;
                    }
                    if (s.isForXStatement({
                        left: r
                    }) || s.isObjectProperty({
                        value: r
                    }) && s.parentPath.isObjectPattern() || s.isAssignmentPattern({
                        left: r
                    }) && s.parentPath.isObjectProperty({
                        value: n
                    }) && s.parentPath.parentPath.isObjectPattern() || s.isArrayPattern() || s.isAssignmentPattern({
                        left: r
                    }) && s.parentPath.isArrayPattern() || s.isRestElement()) {
                        e1.replaceWith(this.destructureSet(e1));
                        return;
                    }
                    if (s.isTaggedTemplateExpression()) {
                        e1.replaceWith(this.boundGet(e1));
                    } else {
                        e1.replaceWith(this.get(e1));
                    }
                }
            };
            function handleAssignment(e1, t, r) {
                if (e1.simpleSet) {
                    t.replaceWith(e1.simpleSet(t));
                    return;
                }
                const { operator: n, right: s } = r.node;
                if (n === "=") {
                    r.replaceWith(e1.set(t, s));
                } else {
                    const a = n.slice(0, -1);
                    if (i.includes(a)) {
                        e1.memoise(t, 1);
                        r.replaceWith(b(a, e1.get(t), e1.set(t, s)));
                    } else {
                        e1.memoise(t, 2);
                        r.replaceWith(e1.set(t, l(a, e1.get(t), s)));
                    }
                }
            }
            function memberExpressionToFunctions(e1, t, r) {
                e1.traverse(t, Object.assign({}, A, r, {
                    memoiser: new AssignmentMemoiser
                }));
            }
            t["default"] = memberExpressionToFunctions;
        },
        8e3: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9491);
            var s = r(3061);
            const { callExpression: i, cloneNode: a, expressionStatement: o, identifier: l, importDeclaration: c, importDefaultSpecifier: p, importNamespaceSpecifier: u, importSpecifier: d, memberExpression: f, stringLiteral: h, variableDeclaration: m, variableDeclarator: y } = s;
            class ImportBuilder {
                done() {
                    return {
                        statements: this._statements,
                        resultName: this._resultName
                    };
                }
                import() {
                    this._statements.push(c([], h(this._importedSource)));
                    return this;
                }
                require() {
                    this._statements.push(o(i(l("require"), [
                        h(this._importedSource)
                    ])));
                    return this;
                }
                namespace() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "namespace";
                    const t = this._scope.generateUidIdentifier(e1);
                    const r = this._statements[this._statements.length - 1];
                    n(r.type === "ImportDeclaration");
                    n(r.specifiers.length === 0);
                    r.specifiers = [
                        u(t)
                    ];
                    this._resultName = a(t);
                    return this;
                }
                default(e1) {
                    const t = this._scope.generateUidIdentifier(e1);
                    const r = this._statements[this._statements.length - 1];
                    n(r.type === "ImportDeclaration");
                    n(r.specifiers.length === 0);
                    r.specifiers = [
                        p(t)
                    ];
                    this._resultName = a(t);
                    return this;
                }
                named(e1, t) {
                    if (t === "default") return this.default(e1);
                    const r = this._scope.generateUidIdentifier(e1);
                    const s = this._statements[this._statements.length - 1];
                    n(s.type === "ImportDeclaration");
                    n(s.specifiers.length === 0);
                    s.specifiers = [
                        d(r, l(t))
                    ];
                    this._resultName = a(r);
                    return this;
                }
                var(e1) {
                    const t = this._scope.generateUidIdentifier(e1);
                    let r = this._statements[this._statements.length - 1];
                    if (r.type !== "ExpressionStatement") {
                        n(this._resultName);
                        r = o(this._resultName);
                        this._statements.push(r);
                    }
                    this._statements[this._statements.length - 1] = m("var", [
                        y(t, r.expression)
                    ]);
                    this._resultName = a(t);
                    return this;
                }
                defaultInterop() {
                    return this._interop(this._hub.addHelper("interopRequireDefault"));
                }
                wildcardInterop() {
                    return this._interop(this._hub.addHelper("interopRequireWildcard"));
                }
                _interop(e1) {
                    const t = this._statements[this._statements.length - 1];
                    if (t.type === "ExpressionStatement") {
                        t.expression = i(e1, [
                            t.expression
                        ]);
                    } else if (t.type === "VariableDeclaration") {
                        n(t.declarations.length === 1);
                        t.declarations[0].init = i(e1, [
                            t.declarations[0].init
                        ]);
                    } else {
                        n.fail("Unexpected type.");
                    }
                    return this;
                }
                prop(e1) {
                    const t = this._statements[this._statements.length - 1];
                    if (t.type === "ExpressionStatement") {
                        t.expression = f(t.expression, l(e1));
                    } else if (t.type === "VariableDeclaration") {
                        n(t.declarations.length === 1);
                        t.declarations[0].init = f(t.declarations[0].init, l(e1));
                    } else {
                        n.fail("Unexpected type:" + t.type);
                    }
                    return this;
                }
                read(e1) {
                    this._resultName = f(this._resultName, l(e1));
                }
                constructor(e1, t, r){
                    this._statements = [];
                    this._resultName = null;
                    this._importedSource = void 0;
                    this._scope = t;
                    this._hub = r;
                    this._importedSource = e1;
                }
            }
            t["default"] = ImportBuilder;
        },
        4955: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9491);
            var s = r(3061);
            var i = r(8e3);
            var a = r(2488);
            const { identifier: o, importSpecifier: l, numericLiteral: c, sequenceExpression: p, isImportDeclaration: u } = s;
            class ImportInjector {
                addDefault(e1, t) {
                    return this.addNamed("default", e1, t);
                }
                addNamed(e1, t, r) {
                    n(typeof e1 === "string");
                    return this._generateImport(this._applyDefaults(t, r), e1);
                }
                addNamespace(e1, t) {
                    return this._generateImport(this._applyDefaults(e1, t), null);
                }
                addSideEffect(e1, t) {
                    return this._generateImport(this._applyDefaults(e1, t), void 0);
                }
                _applyDefaults(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    let s;
                    if (typeof e1 === "string") {
                        s = Object.assign({}, this._defaultOpts, {
                            importedSource: e1
                        }, t);
                    } else {
                        n(!t, "Unexpected secondary arguments.");
                        s = Object.assign({}, this._defaultOpts, e1);
                    }
                    if (!r && t) {
                        if (t.nameHint !== undefined) s.nameHint = t.nameHint;
                        if (t.blockHoist !== undefined) s.blockHoist = t.blockHoist;
                    }
                    return s;
                }
                _generateImport(e1, t) {
                    const r = t === "default";
                    const n = !!t && !r;
                    const s = t === null;
                    const { importedSource: o, importedType: l, importedInterop: u, importingInterop: d, ensureLiveReference: f, ensureNoContext: h, nameHint: m, importPosition: y, blockHoist: g } = e1;
                    let b = m || t;
                    const T = (0, a.default)(this._programPath);
                    const S = T && d === "node";
                    const x = T && d === "babel";
                    if (y === "after" && !T) {
                        throw new Error('"importPosition": "after" is only supported in modules');
                    }
                    const E = new i.default(o, this._programScope, this._hub);
                    if (l === "es6") {
                        if (!S && !x) {
                            throw new Error("Cannot import an ES6 module from CommonJS");
                        }
                        E.import();
                        if (s) {
                            E.namespace(m || o);
                        } else if (r || n) {
                            E.named(b, t);
                        }
                    } else if (l !== "commonjs") {
                        throw new Error('Unexpected interopType "'.concat(l, '"'));
                    } else if (u === "babel") {
                        if (S) {
                            b = b !== "default" ? b : o;
                            const e1 = "".concat(o, "$es6Default");
                            E.import();
                            if (s) {
                                E.default(e1).var(b || o).wildcardInterop();
                            } else if (r) {
                                if (f) {
                                    E.default(e1).var(b || o).defaultInterop().read("default");
                                } else {
                                    E.default(e1).var(b).defaultInterop().prop(t);
                                }
                            } else if (n) {
                                E.default(e1).read(t);
                            }
                        } else if (x) {
                            E.import();
                            if (s) {
                                E.namespace(b || o);
                            } else if (r || n) {
                                E.named(b, t);
                            }
                        } else {
                            E.require();
                            if (s) {
                                E.var(b || o).wildcardInterop();
                            } else if ((r || n) && f) {
                                if (r) {
                                    b = b !== "default" ? b : o;
                                    E.var(b).read(t);
                                    E.defaultInterop();
                                } else {
                                    E.var(o).read(t);
                                }
                            } else if (r) {
                                E.var(b).defaultInterop().prop(t);
                            } else if (n) {
                                E.var(b).prop(t);
                            }
                        }
                    } else if (u === "compiled") {
                        if (S) {
                            E.import();
                            if (s) {
                                E.default(b || o);
                            } else if (r || n) {
                                E.default(o).read(b);
                            }
                        } else if (x) {
                            E.import();
                            if (s) {
                                E.namespace(b || o);
                            } else if (r || n) {
                                E.named(b, t);
                            }
                        } else {
                            E.require();
                            if (s) {
                                E.var(b || o);
                            } else if (r || n) {
                                if (f) {
                                    E.var(o).read(b);
                                } else {
                                    E.prop(t).var(b);
                                }
                            }
                        }
                    } else if (u === "uncompiled") {
                        if (r && f) {
                            throw new Error("No live reference for commonjs default");
                        }
                        if (S) {
                            E.import();
                            if (s) {
                                E.default(b || o);
                            } else if (r) {
                                E.default(b);
                            } else if (n) {
                                E.default(o).read(b);
                            }
                        } else if (x) {
                            E.import();
                            if (s) {
                                E.default(b || o);
                            } else if (r) {
                                E.default(b);
                            } else if (n) {
                                E.named(b, t);
                            }
                        } else {
                            E.require();
                            if (s) {
                                E.var(b || o);
                            } else if (r) {
                                E.var(b);
                            } else if (n) {
                                if (f) {
                                    E.var(o).read(b);
                                } else {
                                    E.var(b).prop(t);
                                }
                            }
                        }
                    } else {
                        throw new Error('Unknown importedInterop "'.concat(u, '".'));
                    }
                    const { statements: P, resultName: v } = E.done();
                    this._insertStatements(P, y, g);
                    if ((r || n) && h && v.type !== "Identifier") {
                        return p([
                            c(0),
                            v
                        ]);
                    }
                    return v;
                }
                _insertStatements(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "before", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
                    if (t === "after") {
                        if (this._insertStatementsAfter(e1)) return;
                    } else {
                        if (this._insertStatementsBefore(e1, r)) return;
                    }
                    this._programPath.unshiftContainer("body", e1);
                }
                _insertStatementsBefore(e1, t) {
                    if (e1.length === 1 && u(e1[0]) && isValueImport(e1[0])) {
                        const t = this._programPath.get("body").find((e1)=>e1.isImportDeclaration() && isValueImport(e1.node));
                        if ((t == null ? void 0 : t.node.source.value) === e1[0].source.value && maybeAppendImportSpecifiers(t.node, e1[0])) {
                            return true;
                        }
                    }
                    e1.forEach((e1)=>{
                        e1._blockHoist = t;
                    });
                    const r = this._programPath.get("body").find((e1)=>{
                        const t = e1.node._blockHoist;
                        return Number.isFinite(t) && t < 4;
                    });
                    if (r) {
                        r.insertBefore(e1);
                        return true;
                    }
                    return false;
                }
                _insertStatementsAfter(e1) {
                    const t = new Set(e1);
                    const r = new Map;
                    for (const t of e1){
                        if (u(t) && isValueImport(t)) {
                            const e1 = t.source.value;
                            if (!r.has(e1)) r.set(e1, []);
                            r.get(e1).push(t);
                        }
                    }
                    let n = null;
                    for (const e1 of this._programPath.get("body")){
                        if (e1.isImportDeclaration() && isValueImport(e1.node)) {
                            n = e1;
                            const s = e1.node.source.value;
                            const i = r.get(s);
                            if (!i) continue;
                            for (const r of i){
                                if (!t.has(r)) continue;
                                if (maybeAppendImportSpecifiers(e1.node, r)) {
                                    t.delete(r);
                                }
                            }
                        }
                    }
                    if (t.size === 0) return true;
                    if (n) n.insertAfter(Array.from(t));
                    return !!n;
                }
                constructor(e1, t, r){
                    this._defaultOpts = {
                        importedSource: null,
                        importedType: "commonjs",
                        importedInterop: "babel",
                        importingInterop: "babel",
                        ensureLiveReference: false,
                        ensureNoContext: false,
                        importPosition: "before"
                    };
                    const n = e1.find((e1)=>e1.isProgram());
                    this._programPath = n;
                    this._programScope = n.scope;
                    this._hub = n.hub;
                    this._defaultOpts = this._applyDefaults(t, r, true);
                }
            }
            t["default"] = ImportInjector;
            function isValueImport(e1) {
                return e1.importKind !== "type" && e1.importKind !== "typeof";
            }
            function hasNamespaceImport(e1) {
                return e1.specifiers.length === 1 && e1.specifiers[0].type === "ImportNamespaceSpecifier" || e1.specifiers.length === 2 && e1.specifiers[1].type === "ImportNamespaceSpecifier";
            }
            function hasDefaultImport(e1) {
                return e1.specifiers.length > 0 && e1.specifiers[0].type === "ImportDefaultSpecifier";
            }
            function maybeAppendImportSpecifiers(e1, t) {
                if (!e1.specifiers.length) {
                    e1.specifiers = t.specifiers;
                    return true;
                }
                if (!t.specifiers.length) return true;
                if (hasNamespaceImport(e1) || hasNamespaceImport(t)) return false;
                if (hasDefaultImport(t)) {
                    if (hasDefaultImport(e1)) {
                        t.specifiers[0] = l(t.specifiers[0].local, o("default"));
                    } else {
                        e1.specifiers.unshift(t.specifiers.shift());
                    }
                }
                e1.specifiers.push(...t.specifiers);
                return true;
            }
        },
        6912: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "ImportInjector", {
                enumerable: true,
                get: function() {
                    return n.default;
                }
            });
            t.addDefault = addDefault;
            t.addNamed = addNamed;
            t.addNamespace = addNamespace;
            t.addSideEffect = addSideEffect;
            Object.defineProperty(t, "isModule", {
                enumerable: true,
                get: function() {
                    return s.default;
                }
            });
            var n = r(4955);
            var s = r(2488);
            function addDefault(e1, t, r) {
                return new n.default(e1).addDefault(t, r);
            }
            function addNamed(e1, t, r, s) {
                return new n.default(e1).addNamed(t, r, s);
            }
            function addNamespace(e1, t, r) {
                return new n.default(e1).addNamespace(t, r);
            }
            function addSideEffect(e1, t, r) {
                return new n.default(e1).addSideEffect(t, r);
            }
        },
        2488: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isModule;
            function isModule(e1) {
                return e1.node.sourceType === "module";
            }
        },
        3747: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildDynamicImport = buildDynamicImport;
            var n = r(2358);
            {
                t.getDynamicImportSource = function getDynamicImportSource(e1) {
                    const [t] = e1.arguments;
                    return n.types.isStringLiteral(t) || n.types.isTemplateLiteral(t) ? t : n.template.expression.ast(_templateObject33(), t);
                };
            }
            function buildDynamicImport(e1, t, r, s) {
                const i = n.types.isCallExpression(e1) ? e1.arguments[0] : e1.source;
                if (n.types.isStringLiteral(i) || n.types.isTemplateLiteral(i) && i.quasis.length === 0) {
                    if (t) {
                        return n.template.expression.ast(_templateObject34(), s(i));
                    } else return s(i);
                }
                const a = n.types.isTemplateLiteral(i) ? n.types.identifier("specifier") : n.types.templateLiteral([
                    n.types.templateElement({
                        raw: ""
                    }),
                    n.types.templateElement({
                        raw: ""
                    })
                ], [
                    n.types.identifier("specifier")
                ]);
                if (t) {
                    return n.template.expression.ast(_templateObject35(), a, s(n.types.identifier("s")), i);
                } else if (r) {
                    return n.template.expression.ast(_templateObject36(), s(a), i);
                } else {
                    return n.template.expression.ast(_templateObject37(), s(a), i);
                }
            }
        },
        7857: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = getModuleName;
            {
                const e1 = getModuleName;
                t["default"] = getModuleName = function getModuleName(t, r) {
                    var n, s, i, a;
                    return e1(t, {
                        moduleId: (n = r.moduleId) != null ? n : t.moduleId,
                        moduleIds: (s = r.moduleIds) != null ? s : t.moduleIds,
                        getModuleId: (i = r.getModuleId) != null ? i : t.getModuleId,
                        moduleRoot: (a = r.moduleRoot) != null ? a : t.moduleRoot
                    });
                };
            }
            function getModuleName(e1, t) {
                const { filename: r, filenameRelative: n = r, sourceRoot: s = t.moduleRoot } = e1;
                const { moduleId: i, moduleIds: a = !!i, getModuleId: o, moduleRoot: l = s } = t;
                if (!a) return null;
                if (i != null && !o) {
                    return i;
                }
                let c = l != null ? l + "/" : "";
                if (n) {
                    const e1 = s != null ? new RegExp("^" + s + "/?") : "";
                    c += n.replace(e1, "").replace(/\.\w*$/, "");
                }
                c = c.replace(/\\/g, "/");
                if (o) {
                    return o(c) || c;
                } else {
                    return c;
                }
            }
        },
        9460: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "buildDynamicImport", {
                enumerable: true,
                get: function() {
                    return p.buildDynamicImport;
                }
            });
            t.buildNamespaceInitStatements = buildNamespaceInitStatements;
            t.ensureStatementsHoisted = ensureStatementsHoisted;
            Object.defineProperty(t, "getModuleName", {
                enumerable: true,
                get: function() {
                    return u.default;
                }
            });
            Object.defineProperty(t, "hasExports", {
                enumerable: true,
                get: function() {
                    return l.hasExports;
                }
            });
            Object.defineProperty(t, "isModule", {
                enumerable: true,
                get: function() {
                    return i.isModule;
                }
            });
            Object.defineProperty(t, "isSideEffectImport", {
                enumerable: true,
                get: function() {
                    return l.isSideEffectImport;
                }
            });
            t.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
            Object.defineProperty(t, "rewriteThis", {
                enumerable: true,
                get: function() {
                    return a.default;
                }
            });
            t.wrapInterop = wrapInterop;
            var n = r(9491);
            var s = r(2358);
            var i = r(6912);
            var a = r(5002);
            var o = r(2984);
            var l = r(8800);
            var c = r(1219);
            var p = r(3747);
            var u = r(7857);
            {
                t.getDynamicImportSource = r(3747).getDynamicImportSource;
            }
            function rewriteModuleStatementsAndPrepareHeader(e1, param) {
                let { exportName: t, strict: r, allowTopLevelThis: p, strictMode: u, noInterop: d, importInterop: f = d ? "none" : "babel", lazy: h, getWrapperPayload: m = c.toGetWrapperPayload(h != null ? h : false), wrapReference: y = c.wrapReference, esNamespaceOnly: g, filename: b, constantReexports: T = arguments[1].loose, enumerableModuleMeta: S = arguments[1].loose, noIncompleteNsImportDetection: x } = param;
                (0, l.validateImportInteropOption)(f);
                n((0, i.isModule)(e1), "Cannot process module statements in a script");
                e1.node.sourceType = "script";
                const E = (0, l.default)(e1, t, {
                    importInterop: f,
                    initializeReexports: T,
                    getWrapperPayload: m,
                    esNamespaceOnly: g,
                    filename: b
                });
                if (!p) {
                    (0, a.default)(e1);
                }
                (0, o.default)(e1, E, y);
                if (u !== false) {
                    const t = e1.node.directives.some((e1)=>e1.value.value === "use strict");
                    if (!t) {
                        e1.unshiftContainer("directives", s.types.directive(s.types.directiveLiteral("use strict")));
                    }
                }
                const P = [];
                if ((0, l.hasExports)(E) && !r) {
                    P.push(buildESModuleHeader(E, S));
                }
                const v = buildExportNameListDeclaration(e1, E);
                if (v) {
                    E.exportNameListName = v.name;
                    P.push(v.statement);
                }
                P.push(...buildExportInitializationStatements(e1, E, y, T, x));
                return {
                    meta: E,
                    headers: P
                };
            }
            function ensureStatementsHoisted(e1) {
                e1.forEach((e1)=>{
                    e1._blockHoist = 3;
                });
            }
            function wrapInterop(e1, t, r) {
                if (r === "none") {
                    return null;
                }
                if (r === "node-namespace") {
                    return s.types.callExpression(e1.hub.addHelper("interopRequireWildcard"), [
                        t,
                        s.types.booleanLiteral(true)
                    ]);
                } else if (r === "node-default") {
                    return null;
                }
                let n;
                if (r === "default") {
                    n = "interopRequireDefault";
                } else if (r === "namespace") {
                    n = "interopRequireWildcard";
                } else {
                    throw new Error("Unknown interop: ".concat(r));
                }
                return s.types.callExpression(e1.hub.addHelper(n), [
                    t
                ]);
            }
            function buildNamespaceInitStatements(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : c.wrapReference;
                var i;
                const a = [];
                const o = s.types.identifier(t.name);
                for (const e1 of t.importsNamespace){
                    if (e1 === t.name) continue;
                    a.push(s.template.statement(_templateObject38())({
                        NAME: e1,
                        SOURCE: s.types.cloneNode(o)
                    }));
                }
                const l = (i = n(o, t.wrap)) != null ? i : o;
                if (r) {
                    a.push(...buildReexportsFromMeta(e1, t, true, n));
                }
                for (const r of t.reexportNamespace){
                    a.push((!s.types.isIdentifier(l) ? s.template.statement(_templateObject39()) : s.template.statement(_templateObject40()))({
                        EXPORTS: e1.exportName,
                        NAME: r,
                        NAMESPACE: s.types.cloneNode(l)
                    }));
                }
                if (t.reexportAll) {
                    const n = buildNamespaceReexport(e1, s.types.cloneNode(l), r);
                    n.loc = t.reexportAll.loc;
                    a.push(n);
                }
                return a;
            }
            const d = {
                constant: (param)=>{
                    let { exports: e1, exportName: t, namespaceImport: r } = param;
                    return s.template.statement.ast(_templateObject41(), e1, t, r);
                },
                constantComputed: (param)=>{
                    let { exports: e1, exportName: t, namespaceImport: r } = param;
                    return s.template.statement.ast(_templateObject42(), e1, t, r);
                },
                spec: (param)=>{
                    let { exports: e1, exportName: t, namespaceImport: r } = param;
                    return s.template.statement.ast(_templateObject43(), e1, t, r);
                }
            };
            function buildReexportsFromMeta(e1, t, r, n) {
                var i;
                let a = s.types.identifier(t.name);
                a = (i = n(a, t.wrap)) != null ? i : a;
                const { stringSpecifiers: o } = e1;
                return Array.from(t.reexports, (param)=>{
                    let [n, i] = param;
                    let l = s.types.cloneNode(a);
                    if (i === "default" && t.interop === "node-default") {} else if (o.has(i)) {
                        l = s.types.memberExpression(l, s.types.stringLiteral(i), true);
                    } else {
                        l = s.types.memberExpression(l, s.types.identifier(i));
                    }
                    const c = {
                        exports: e1.exportName,
                        exportName: n,
                        namespaceImport: l
                    };
                    if (r || s.types.isIdentifier(l)) {
                        if (o.has(n)) {
                            return d.constantComputed(c);
                        } else {
                            return d.constant(c);
                        }
                    } else {
                        return d.spec(c);
                    }
                });
            }
            function buildESModuleHeader(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                return (t ? s.template.statement(_templateObject44()) : s.template.statement(_templateObject45()))({
                    EXPORTS: e1.exportName
                });
            }
            function buildNamespaceReexport(e1, t, r) {
                return (r ? s.template.statement(_templateObject46()) : s.template.statement(_templateObject47()))({
                    NAMESPACE: t,
                    EXPORTS: e1.exportName,
                    VERIFY_NAME_LIST: e1.exportNameListName ? (0, s.template)(_templateObject48())({
                        EXPORTS_LIST: e1.exportNameListName
                    }) : null
                });
            }
            function buildExportNameListDeclaration(e1, t) {
                const r = Object.create(null);
                for (const e1 of t.local.values()){
                    for (const t of e1.names){
                        r[t] = true;
                    }
                }
                let n = false;
                for (const e1 of t.source.values()){
                    for (const t of e1.reexports.keys()){
                        r[t] = true;
                    }
                    for (const t of e1.reexportNamespace){
                        r[t] = true;
                    }
                    n = n || !!e1.reexportAll;
                }
                if (!n || Object.keys(r).length === 0) return null;
                const i = e1.scope.generateUidIdentifier("exportNames");
                delete r.default;
                return {
                    name: i.name,
                    statement: s.types.variableDeclaration("var", [
                        s.types.variableDeclarator(i, s.types.valueToNode(r))
                    ])
                };
            }
            function buildExportInitializationStatements(e1, t, r) {
                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                const a = [];
                for (const [e1, r] of t.local){
                    if (r.kind === "import") {} else if (r.kind === "hoisted") {
                        a.push([
                            r.names[0],
                            buildInitStatement(t, r.names, s.types.identifier(e1))
                        ]);
                    } else if (!i) {
                        for (const e1 of r.names){
                            a.push([
                                e1,
                                null
                            ]);
                        }
                    }
                }
                for (const e1 of t.source.values()){
                    if (!n) {
                        const n = buildReexportsFromMeta(t, e1, false, r);
                        const s = [
                            ...e1.reexports.keys()
                        ];
                        for(let e1 = 0; e1 < n.length; e1++){
                            a.push([
                                s[e1],
                                n[e1]
                            ]);
                        }
                    }
                    if (!i) {
                        for (const t of e1.reexportNamespace){
                            a.push([
                                t,
                                null
                            ]);
                        }
                    }
                }
                a.sort((param, param1)=>{
                    let [e1] = param, [t] = param1;
                    if (e1 < t) return -1;
                    if (t < e1) return 1;
                    return 0;
                });
                const o = [];
                if (i) {
                    for (const [, e1] of a){
                        o.push(e1);
                    }
                } else {
                    const r = 100;
                    for(let n = 0; n < a.length; n += r){
                        let s = [];
                        for(let i = 0; i < r && n + i < a.length; i++){
                            const [r, l] = a[n + i];
                            if (l !== null) {
                                if (s.length > 0) {
                                    o.push(buildInitStatement(t, s, e1.scope.buildUndefinedNode()));
                                    s = [];
                                }
                                o.push(l);
                            } else {
                                s.push(r);
                            }
                        }
                        if (s.length > 0) {
                            o.push(buildInitStatement(t, s, e1.scope.buildUndefinedNode()));
                        }
                    }
                }
                return o;
            }
            const f = {
                computed: (param)=>{
                    let { exports: e1, name: t, value: r } = param;
                    return s.template.expression.ast(_templateObject49(), e1, t, r);
                },
                default: (param)=>{
                    let { exports: e1, name: t, value: r } = param;
                    return s.template.expression.ast(_templateObject50(), e1, t, r);
                },
                define: (param)=>{
                    let { exports: e1, name: t, value: r } = param;
                    return s.template.expression.ast(_templateObject51(), e1, t, t, r);
                }
            };
            function buildInitStatement(e1, t, r) {
                const { stringSpecifiers: n, exportName: i } = e1;
                return s.types.expressionStatement(t.reduce((e1, t)=>{
                    const r = {
                        exports: i,
                        name: t,
                        value: e1
                    };
                    if (t === "__proto__") {
                        return f.define(r);
                    }
                    if (n.has(t)) {
                        return f.computed(r);
                    }
                    return f.default(r);
                }, r));
            }
        },
        1219: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.toGetWrapperPayload = toGetWrapperPayload;
            t.wrapReference = wrapReference;
            var n = r(2358);
            var s = r(8800);
            function toGetWrapperPayload(e1) {
                return (t, r)=>{
                    if (e1 === false) return null;
                    if ((0, s.isSideEffectImport)(r) || r.reexportAll) return null;
                    if (e1 === true) {
                        return t.includes(".") ? null : "lazy";
                    }
                    if (Array.isArray(e1)) {
                        return !e1.includes(t) ? null : "lazy";
                    }
                    if (typeof e1 === "function") {
                        return e1(t) ? "lazy" : null;
                    }
                    throw new Error(".lazy must be a boolean, string array, or function");
                };
            }
            function wrapReference(e1, t) {
                if (t === "lazy") return n.types.callExpression(e1, []);
                return null;
            }
        },
        8800: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = normalizeModuleAndLoadMetadata;
            t.hasExports = hasExports;
            t.isSideEffectImport = isSideEffectImport;
            t.validateImportInteropOption = validateImportInteropOption;
            var n = r(1017);
            var s = r(974);
            function hasExports(e1) {
                return e1.hasExports;
            }
            function isSideEffectImport(e1) {
                return e1.imports.size === 0 && e1.importsNamespace.size === 0 && e1.reexports.size === 0 && e1.reexportNamespace.size === 0 && !e1.reexportAll;
            }
            function validateImportInteropOption(e1) {
                if (typeof e1 !== "function" && e1 !== "none" && e1 !== "babel" && e1 !== "node") {
                    throw new Error('.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received '.concat(e1, ")."));
                }
                return e1;
            }
            function resolveImportInterop(e1, t, r) {
                if (typeof e1 === "function") {
                    return validateImportInteropOption(e1(t, r));
                }
                return e1;
            }
            function normalizeModuleAndLoadMetadata(e1, t, param) {
                let { importInterop: r, initializeReexports: n = false, getWrapperPayload: s, esNamespaceOnly: i = false, filename: a } = param;
                if (!t) {
                    t = e1.scope.generateUidIdentifier("exports").name;
                }
                const o = new Set;
                nameAnonymousExports(e1);
                const { local: l, sources: c, hasExports: p } = getModuleMetadata(e1, {
                    initializeReexports: n,
                    getWrapperPayload: s
                }, o);
                removeImportExportDeclarations(e1);
                for (const [e1, t] of c){
                    const { importsNamespace: n, imports: s } = t;
                    if (n.size > 0 && s.size === 0) {
                        const [e1] = n;
                        t.name = e1;
                    }
                    const o = resolveImportInterop(r, e1, a);
                    if (o === "none") {
                        t.interop = "none";
                    } else if (o === "node" && t.interop === "namespace") {
                        t.interop = "node-namespace";
                    } else if (o === "node" && t.interop === "default") {
                        t.interop = "node-default";
                    } else if (i && t.interop === "namespace") {
                        t.interop = "default";
                    }
                }
                return {
                    exportName: t,
                    exportNameListName: null,
                    hasExports: p,
                    local: l,
                    source: c,
                    stringSpecifiers: o
                };
            }
            function getExportSpecifierName(e1, t) {
                if (e1.isIdentifier()) {
                    return e1.node.name;
                } else if (e1.isStringLiteral()) {
                    const r = e1.node.value;
                    if (!(0, s.isIdentifierName)(r)) {
                        t.add(r);
                    }
                    return r;
                } else {
                    throw new Error("Expected export specifier to be either Identifier or StringLiteral, got ".concat(e1.node.type));
                }
            }
            function assertExportSpecifier(e1) {
                if (e1.isExportSpecifier()) {
                    return;
                } else if (e1.isExportNamespaceSpecifier()) {
                    throw e1.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
                } else {
                    throw e1.buildCodeFrameError("Unexpected export specifier type");
                }
            }
            function getModuleMetadata(e1, param, s) {
                let { getWrapperPayload: t, initializeReexports: r } = param;
                const i = getLocalExportMetadata(e1, r, s);
                const a = new Map;
                const o = new Map;
                const getData = (t, r)=>{
                    const s = t.value;
                    let i = o.get(s);
                    if (!i) {
                        i = {
                            name: e1.scope.generateUidIdentifier((0, n.basename)(s, (0, n.extname)(s))).name,
                            interop: "none",
                            loc: null,
                            imports: new Map,
                            importsNamespace: new Set,
                            reexports: new Map,
                            reexportNamespace: new Set,
                            reexportAll: null,
                            wrap: null,
                            get lazy () {
                                return this.wrap === "lazy";
                            },
                            referenced: false
                        };
                        o.set(s, i);
                        a.set(s, [
                            r
                        ]);
                    } else {
                        a.get(s).push(r);
                    }
                    return i;
                };
                let l = false;
                e1.get("body").forEach((e1)=>{
                    if (e1.isImportDeclaration()) {
                        const t = getData(e1.node.source, e1.node);
                        if (!t.loc) t.loc = e1.node.loc;
                        e1.get("specifiers").forEach((e1)=>{
                            if (e1.isImportDefaultSpecifier()) {
                                const r = e1.get("local").node.name;
                                t.imports.set(r, "default");
                                const n = i.get(r);
                                if (n) {
                                    i.delete(r);
                                    n.names.forEach((e1)=>{
                                        t.reexports.set(e1, "default");
                                    });
                                    t.referenced = true;
                                }
                            } else if (e1.isImportNamespaceSpecifier()) {
                                const r = e1.get("local").node.name;
                                t.importsNamespace.add(r);
                                const n = i.get(r);
                                if (n) {
                                    i.delete(r);
                                    n.names.forEach((e1)=>{
                                        t.reexportNamespace.add(e1);
                                    });
                                    t.referenced = true;
                                }
                            } else if (e1.isImportSpecifier()) {
                                const r = getExportSpecifierName(e1.get("imported"), s);
                                const n = e1.get("local").node.name;
                                t.imports.set(n, r);
                                const a = i.get(n);
                                if (a) {
                                    i.delete(n);
                                    a.names.forEach((e1)=>{
                                        t.reexports.set(e1, r);
                                    });
                                    t.referenced = true;
                                }
                            }
                        });
                    } else if (e1.isExportAllDeclaration()) {
                        l = true;
                        const t = getData(e1.node.source, e1.node);
                        if (!t.loc) t.loc = e1.node.loc;
                        t.reexportAll = {
                            loc: e1.node.loc
                        };
                        t.referenced = true;
                    } else if (e1.isExportNamedDeclaration() && e1.node.source) {
                        l = true;
                        const t = getData(e1.node.source, e1.node);
                        if (!t.loc) t.loc = e1.node.loc;
                        e1.get("specifiers").forEach((e1)=>{
                            assertExportSpecifier(e1);
                            const r = getExportSpecifierName(e1.get("local"), s);
                            const n = getExportSpecifierName(e1.get("exported"), s);
                            t.reexports.set(n, r);
                            t.referenced = true;
                            if (n === "__esModule") {
                                throw e1.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                            }
                        });
                    } else if (e1.isExportNamedDeclaration() || e1.isExportDefaultDeclaration()) {
                        l = true;
                    }
                });
                for (const e1 of o.values()){
                    let t = false;
                    let r = false;
                    if (e1.importsNamespace.size > 0) {
                        t = true;
                        r = true;
                    }
                    if (e1.reexportAll) {
                        r = true;
                    }
                    for (const n of e1.imports.values()){
                        if (n === "default") t = true;
                        else r = true;
                    }
                    for (const n of e1.reexports.values()){
                        if (n === "default") t = true;
                        else r = true;
                    }
                    if (t && r) {
                        e1.interop = "namespace";
                    } else if (t) {
                        e1.interop = "default";
                    }
                }
                if (t) {
                    for (const [e1, r] of o){
                        r.wrap = t(e1, r, a.get(e1));
                    }
                }
                return {
                    hasExports: l,
                    local: i,
                    sources: o
                };
            }
            function getLocalExportMetadata(e1, t, r) {
                const n = new Map;
                e1.get("body").forEach((e1)=>{
                    let r;
                    if (e1.isImportDeclaration()) {
                        r = "import";
                    } else {
                        if (e1.isExportDefaultDeclaration()) {
                            e1 = e1.get("declaration");
                        }
                        if (e1.isExportNamedDeclaration()) {
                            if (e1.node.declaration) {
                                e1 = e1.get("declaration");
                            } else if (t && e1.node.source && e1.get("source").isStringLiteral()) {
                                e1.get("specifiers").forEach((e1)=>{
                                    assertExportSpecifier(e1);
                                    n.set(e1.get("local").node.name, "block");
                                });
                                return;
                            }
                        }
                        if (e1.isFunctionDeclaration()) {
                            r = "hoisted";
                        } else if (e1.isClassDeclaration()) {
                            r = "block";
                        } else if (e1.isVariableDeclaration({
                            kind: "var"
                        })) {
                            r = "var";
                        } else if (e1.isVariableDeclaration()) {
                            r = "block";
                        } else {
                            return;
                        }
                    }
                    Object.keys(e1.getOuterBindingIdentifiers()).forEach((e1)=>{
                        n.set(e1, r);
                    });
                });
                const s = new Map;
                const getLocalMetadata = (e1)=>{
                    const t = e1.node.name;
                    let r = s.get(t);
                    if (!r) {
                        const i = n.get(t);
                        if (i === undefined) {
                            throw e1.buildCodeFrameError('Exporting local "'.concat(t, '", which is not declared.'));
                        }
                        r = {
                            names: [],
                            kind: i
                        };
                        s.set(t, r);
                    }
                    return r;
                };
                e1.get("body").forEach((e1)=>{
                    if (e1.isExportNamedDeclaration() && (t || !e1.node.source)) {
                        if (e1.node.declaration) {
                            const t = e1.get("declaration");
                            const r = t.getOuterBindingIdentifierPaths();
                            Object.keys(r).forEach((e1)=>{
                                if (e1 === "__esModule") {
                                    throw t.buildCodeFrameError('Illegal export "__esModule".');
                                }
                                getLocalMetadata(r[e1]).names.push(e1);
                            });
                        } else {
                            e1.get("specifiers").forEach((e1)=>{
                                const t = e1.get("local");
                                const n = e1.get("exported");
                                const s = getLocalMetadata(t);
                                const i = getExportSpecifierName(n, r);
                                if (i === "__esModule") {
                                    throw n.buildCodeFrameError('Illegal export "__esModule".');
                                }
                                s.names.push(i);
                            });
                        }
                    } else if (e1.isExportDefaultDeclaration()) {
                        const t = e1.get("declaration");
                        if (t.isFunctionDeclaration() || t.isClassDeclaration()) {
                            getLocalMetadata(t.get("id")).names.push("default");
                        } else {
                            throw t.buildCodeFrameError("Unexpected default expression export.");
                        }
                    }
                });
                return s;
            }
            function nameAnonymousExports(e1) {
                e1.get("body").forEach((e1)=>{
                    if (!e1.isExportDefaultDeclaration()) return;
                    {
                        var t;
                        (t = e1.splitExportDeclaration) != null ? t : e1.splitExportDeclaration = r(8026).NodePath.prototype.splitExportDeclaration;
                    }
                    e1.splitExportDeclaration();
                });
            }
            function removeImportExportDeclarations(e1) {
                e1.get("body").forEach((e1)=>{
                    if (e1.isImportDeclaration()) {
                        e1.remove();
                    } else if (e1.isExportNamedDeclaration()) {
                        if (e1.node.declaration) {
                            e1.node.declaration._blockHoist = e1.node._blockHoist;
                            e1.replaceWith(e1.node.declaration);
                        } else {
                            e1.remove();
                        }
                    } else if (e1.isExportDefaultDeclaration()) {
                        const t = e1.get("declaration");
                        if (t.isFunctionDeclaration() || t.isClassDeclaration()) {
                            t._blockHoist = e1.node._blockHoist;
                            e1.replaceWith(t);
                        } else {
                            throw t.buildCodeFrameError("Unexpected default expression export.");
                        }
                    } else if (e1.isExportAllDeclaration()) {
                        e1.remove();
                    }
                });
            }
        },
        2984: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = rewriteLiveReferences;
            var n = r(2358);
            function isInType(e1) {
                do {
                    switch(e1.parent.type){
                        case "TSTypeAnnotation":
                        case "TSTypeAliasDeclaration":
                        case "TSTypeReference":
                        case "TypeAnnotation":
                        case "TypeAlias":
                            return true;
                        case "ExportSpecifier":
                            return e1.parentPath.parent.exportKind === "type";
                        default:
                            if (e1.parentPath.isStatement() || e1.parentPath.isExpression()) {
                                return false;
                            }
                    }
                }while (e1 = e1.parentPath)
            }
            function rewriteLiveReferences(e1, t, r) {
                const a = new Map;
                const o = new Map;
                const requeueInParent = (t)=>{
                    e1.requeue(t);
                };
                for (const [e1, r] of t.source){
                    for (const [t, n] of r.imports){
                        a.set(t, [
                            e1,
                            n,
                            null
                        ]);
                    }
                    for (const t of r.importsNamespace){
                        a.set(t, [
                            e1,
                            null,
                            t
                        ]);
                    }
                }
                for (const [e1, r] of t.local){
                    let t = o.get(e1);
                    if (!t) {
                        t = [];
                        o.set(e1, t);
                    }
                    t.push(...r.names);
                }
                const l = {
                    metadata: t,
                    requeueInParent: requeueInParent,
                    scope: e1.scope,
                    exported: o
                };
                e1.traverse(s, l);
                const c = {
                    seen: new WeakSet,
                    metadata: t,
                    requeueInParent: requeueInParent,
                    scope: e1.scope,
                    imported: a,
                    exported: o,
                    buildImportReference (param, a) {
                        let [e1, s, i] = param;
                        const o = t.source.get(e1);
                        o.referenced = true;
                        if (i) {
                            if (o.wrap) {
                                var l;
                                a = (l = r(a, o.wrap)) != null ? l : a;
                            }
                            return a;
                        }
                        let c = n.types.identifier(o.name);
                        if (o.wrap) {
                            var p;
                            c = (p = r(c, o.wrap)) != null ? p : c;
                        }
                        if (s === "default" && o.interop === "node-default") {
                            return c;
                        }
                        const u = t.stringSpecifiers.has(s);
                        return n.types.memberExpression(c, u ? n.types.stringLiteral(s) : n.types.identifier(s), u);
                    }
                };
                e1.traverse(i, c);
            }
            const s = {
                Scope (e1) {
                    e1.skip();
                },
                ClassDeclaration (e1) {
                    const { requeueInParent: t, exported: r, metadata: s } = this;
                    const { id: i } = e1.node;
                    if (!i) throw new Error("Expected class to have a name");
                    const a = i.name;
                    const o = r.get(a) || [];
                    if (o.length > 0) {
                        const r = n.types.expressionStatement(buildBindingExportAssignmentExpression(s, o, n.types.identifier(a), e1.scope));
                        r._blockHoist = e1.node._blockHoist;
                        t(e1.insertAfter(r)[0]);
                    }
                },
                VariableDeclaration (e1) {
                    const { requeueInParent: t, exported: r, metadata: s } = this;
                    const i = e1.node.kind === "var";
                    for (const a of e1.get("declarations")){
                        const { id: o } = a.node;
                        let { init: l } = a.node;
                        if (n.types.isIdentifier(o) && r.has(o.name) && !n.types.isArrowFunctionExpression(l) && (!n.types.isFunctionExpression(l) || l.id) && (!n.types.isClassExpression(l) || l.id)) {
                            if (!l) {
                                if (i) {
                                    continue;
                                } else {
                                    l = e1.scope.buildUndefinedNode();
                                }
                            }
                            a.node.init = buildBindingExportAssignmentExpression(s, r.get(o.name), l, e1.scope);
                            t(a.get("init"));
                        } else {
                            for (const i of Object.keys(a.getOuterBindingIdentifiers())){
                                if (r.has(i)) {
                                    const a = n.types.expressionStatement(buildBindingExportAssignmentExpression(s, r.get(i), n.types.identifier(i), e1.scope));
                                    a._blockHoist = e1.node._blockHoist;
                                    t(e1.insertAfter(a)[0]);
                                }
                            }
                        }
                    }
                }
            };
            const buildBindingExportAssignmentExpression = (e1, t, r, s)=>{
                const i = e1.exportName;
                for(let e1 = s; e1 != null; e1 = e1.parent){
                    if (e1.hasOwnBinding(i)) {
                        e1.rename(i);
                    }
                }
                return (t || []).reduce((t, r)=>{
                    const { stringSpecifiers: s } = e1;
                    const a = s.has(r);
                    return n.types.assignmentExpression("=", n.types.memberExpression(n.types.identifier(i), a ? n.types.stringLiteral(r) : n.types.identifier(r), a), t);
                }, r);
            };
            const buildImportThrow = (e1)=>n.template.expression.ast(_templateObject52(), e1);
            const i = {
                ReferencedIdentifier (e1) {
                    const { seen: t, buildImportReference: r, scope: s, imported: i, requeueInParent: a } = this;
                    if (t.has(e1.node)) return;
                    t.add(e1.node);
                    const o = e1.node.name;
                    const l = i.get(o);
                    if (l) {
                        if (isInType(e1)) {
                            throw e1.buildCodeFrameError('Cannot transform the imported binding "'.concat(o, "\" since it's also used in a type annotation. ") + "Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.");
                        }
                        const t = e1.scope.getBinding(o);
                        const i = s.getBinding(o);
                        if (i !== t) return;
                        const c = r(l, e1.node);
                        c.loc = e1.node.loc;
                        if ((e1.parentPath.isCallExpression({
                            callee: e1.node
                        }) || e1.parentPath.isOptionalCallExpression({
                            callee: e1.node
                        }) || e1.parentPath.isTaggedTemplateExpression({
                            tag: e1.node
                        })) && n.types.isMemberExpression(c)) {
                            e1.replaceWith(n.types.sequenceExpression([
                                n.types.numericLiteral(0),
                                c
                            ]));
                        } else if (e1.isJSXIdentifier() && n.types.isMemberExpression(c)) {
                            const { object: t, property: r } = c;
                            e1.replaceWith(n.types.jsxMemberExpression(n.types.jsxIdentifier(t.name), n.types.jsxIdentifier(r.name)));
                        } else {
                            e1.replaceWith(c);
                        }
                        a(e1);
                        e1.skip();
                    }
                },
                UpdateExpression (e1) {
                    const { scope: t, seen: r, imported: s, exported: i, requeueInParent: a, buildImportReference: o } = this;
                    if (r.has(e1.node)) return;
                    r.add(e1.node);
                    const l = e1.get("argument");
                    if (l.isMemberExpression()) return;
                    const c = e1.node;
                    if (l.isIdentifier()) {
                        const r = l.node.name;
                        if (t.getBinding(r) !== e1.scope.getBinding(r)) {
                            return;
                        }
                        const a = i.get(r);
                        const p = s.get(r);
                        if ((a == null ? void 0 : a.length) > 0 || p) {
                            if (p) {
                                e1.replaceWith(n.types.assignmentExpression(c.operator[0] + "=", o(p, l.node), buildImportThrow(r)));
                            } else if (c.prefix) {
                                e1.replaceWith(buildBindingExportAssignmentExpression(this.metadata, a, n.types.cloneNode(c), e1.scope));
                            } else {
                                const s = t.generateDeclaredUidIdentifier(r);
                                e1.replaceWith(n.types.sequenceExpression([
                                    n.types.assignmentExpression("=", n.types.cloneNode(s), n.types.cloneNode(c)),
                                    buildBindingExportAssignmentExpression(this.metadata, a, n.types.identifier(r), e1.scope),
                                    n.types.cloneNode(s)
                                ]));
                            }
                        }
                    }
                    a(e1);
                    e1.skip();
                },
                AssignmentExpression: {
                    exit (e1) {
                        const { scope: t, seen: r, imported: s, exported: i, requeueInParent: a, buildImportReference: o } = this;
                        if (r.has(e1.node)) return;
                        r.add(e1.node);
                        const l = e1.get("left");
                        if (l.isMemberExpression()) return;
                        if (l.isIdentifier()) {
                            const r = l.node.name;
                            if (t.getBinding(r) !== e1.scope.getBinding(r)) {
                                return;
                            }
                            const c = i.get(r);
                            const p = s.get(r);
                            if ((c == null ? void 0 : c.length) > 0 || p) {
                                const t = e1.node;
                                if (p) {
                                    t.left = o(p, l.node);
                                    t.right = n.types.sequenceExpression([
                                        t.right,
                                        buildImportThrow(r)
                                    ]);
                                }
                                const { operator: s } = t;
                                let i;
                                if (s === "=") {
                                    i = t;
                                } else if (s === "&&=" || s === "||=" || s === "??=") {
                                    i = n.types.assignmentExpression("=", t.left, n.types.logicalExpression(s.slice(0, -1), n.types.cloneNode(t.left), t.right));
                                } else {
                                    i = n.types.assignmentExpression("=", t.left, n.types.binaryExpression(s.slice(0, -1), n.types.cloneNode(t.left), t.right));
                                }
                                e1.replaceWith(buildBindingExportAssignmentExpression(this.metadata, c, i, e1.scope));
                                a(e1);
                                e1.skip();
                            }
                        } else {
                            const r = l.getOuterBindingIdentifiers();
                            const o = Object.keys(r).filter((r)=>t.getBinding(r) === e1.scope.getBinding(r));
                            const c = o.find((e1)=>s.has(e1));
                            if (c) {
                                e1.node.right = n.types.sequenceExpression([
                                    e1.node.right,
                                    buildImportThrow(c)
                                ]);
                            }
                            const p = [];
                            o.forEach((t)=>{
                                const r = i.get(t) || [];
                                if (r.length > 0) {
                                    p.push(buildBindingExportAssignmentExpression(this.metadata, r, n.types.identifier(t), e1.scope));
                                }
                            });
                            if (p.length > 0) {
                                let t = n.types.sequenceExpression(p);
                                if (e1.parentPath.isExpressionStatement()) {
                                    t = n.types.expressionStatement(t);
                                    t._blockHoist = e1.parentPath.node._blockHoist;
                                }
                                const r = e1.insertAfter(t)[0];
                                a(r);
                            }
                        }
                    }
                },
                ForXStatement (e1) {
                    const { scope: t, node: r } = e1;
                    const { left: s } = r;
                    const { exported: i, imported: a, scope: o } = this;
                    if (!n.types.isVariableDeclaration(s)) {
                        let r = false, l;
                        const c = e1.get("body").scope;
                        for (const e1 of Object.keys(n.types.getOuterBindingIdentifiers(s))){
                            if (o.getBinding(e1) === t.getBinding(e1)) {
                                if (i.has(e1)) {
                                    r = true;
                                    if (c.hasOwnBinding(e1)) {
                                        c.rename(e1);
                                    }
                                }
                                if (a.has(e1) && !l) {
                                    l = e1;
                                }
                            }
                        }
                        if (!r && !l) {
                            return;
                        }
                        e1.ensureBlock();
                        const p = e1.get("body");
                        const u = t.generateUidIdentifierBasedOnNode(s);
                        e1.get("left").replaceWith(n.types.variableDeclaration("let", [
                            n.types.variableDeclarator(n.types.cloneNode(u))
                        ]));
                        t.registerDeclaration(e1.get("left"));
                        if (r) {
                            p.unshiftContainer("body", n.types.expressionStatement(n.types.assignmentExpression("=", s, u)));
                        }
                        if (l) {
                            p.unshiftContainer("body", n.types.expressionStatement(buildImportThrow(l)));
                        }
                    }
                }
            };
        },
        5002: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = rewriteThis;
            var n = r(2358);
            var s = r(8026);
            let i;
            function rewriteThis(e1) {
                if (!i) {
                    i = s.visitors.environmentVisitor({
                        ThisExpression (e1) {
                            e1.replaceWith(n.types.unaryExpression("void", n.types.numericLiteral(0), true));
                        }
                    });
                    i.noScope = true;
                }
                (0, s.default)(e1.node, i);
            }
        },
        582: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = optimiseCallExpression;
            var n = r(3061);
            const { callExpression: s, identifier: i, isIdentifier: a, isSpreadElement: o, memberExpression: l, optionalCallExpression: c, optionalMemberExpression: p } = n;
            function optimiseCallExpression(e1, t, r, n) {
                if (r.length === 1 && o(r[0]) && a(r[0].argument, {
                    name: "arguments"
                })) {
                    if (n) {
                        return c(p(e1, i("apply"), false, true), [
                            t,
                            r[0].argument
                        ], false);
                    }
                    return s(l(e1, i("apply")), [
                        t,
                        r[0].argument
                    ]);
                } else {
                    if (n) {
                        return c(p(e1, i("call"), false, true), [
                            t,
                            ...r
                        ], false);
                    }
                    return s(l(e1, i("call")), [
                        t,
                        ...r
                    ]);
                }
            }
        },
        9045: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.declare = declare;
            t.declarePreset = void 0;
            const r = {
                assertVersion: (e1)=>(t)=>{
                        throwVersionError(t, e1.version);
                    }
            };
            {
                Object.assign(r, {
                    targets: ()=>()=>({}),
                    assumption: ()=>()=>undefined,
                    addExternalDependency: ()=>()=>{}
                });
            }
            function declare(e1) {
                return (t, n, s)=>{
                    var i;
                    let a;
                    for (const e1 of Object.keys(r)){
                        var o;
                        if (t[e1]) continue;
                        (o = a) != null ? o : a = copyApiObject(t);
                        a[e1] = r[e1](a);
                    }
                    return e1((i = a) != null ? i : t, n || {}, s);
                };
            }
            const n = t.declarePreset = declare;
            function copyApiObject(e1) {
                let t = null;
                if (typeof e1.version === "string" && /^7\./.test(e1.version)) {
                    t = Object.getPrototypeOf(e1);
                    if (t && (!hasOwnProperty.call(t, "version") || !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types"))) {
                        t = null;
                    }
                }
                return Object.assign({}, t, e1);
            }
            function throwVersionError(e1, t) {
                if (typeof e1 === "number") {
                    if (!Number.isInteger(e1)) {
                        throw new Error("Expected string or integer value.");
                    }
                    e1 = "^".concat(e1, ".0.0-0");
                }
                if (typeof e1 !== "string") {
                    throw new Error("Expected string or integer value.");
                }
                const r = Error.stackTraceLimit;
                if (typeof r === "number" && r < 25) {
                    Error.stackTraceLimit = 25;
                }
                let n;
                if (t.slice(0, 2) === "7.") {
                    n = new Error('Requires Babel "^7.0.0-beta.41", but was loaded with "'.concat(t, '". ') + "You'll need to update your @babel/core version.");
                } else {
                    n = new Error('Requires Babel "'.concat(e1, '", but was loaded with "').concat(t, '". ') + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + 'the first entry that doesn\'t mention "@babel/core" or "babel-core" ' + "to see what is calling Babel.");
                }
                if (typeof r === "number") {
                    Error.stackTraceLimit = r;
                }
                throw Object.assign(n, {
                    code: "BABEL_VERSION_UNSUPPORTED",
                    version: t,
                    range: e1
                });
            }
        },
        6721: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(3034);
            var s = r(582);
            var i = r(2358);
            var a = r(8026);
            const { assignmentExpression: o, callExpression: l, cloneNode: c, identifier: p, memberExpression: u, sequenceExpression: d, stringLiteral: f, thisExpression: h } = i.types;
            {
                t.environmentVisitor = a.visitors.environmentVisitor({});
                t.skipAllButComputedKey = function skipAllButComputedKey(e1) {
                    e1.skip();
                    if (e1.node.computed) {
                        e1.context.maybeQueue(e1.get("key"));
                    }
                };
            }
            const m = a.visitors.environmentVisitor({
                Super (e1, t) {
                    const { node: r, parentPath: n } = e1;
                    if (!n.isMemberExpression({
                        object: r
                    })) return;
                    t.handle(n);
                }
            });
            const y = a.visitors.environmentVisitor({
                Scopable (e1, param) {
                    let { refName: t } = param;
                    const r = e1.scope.getOwnBinding(t);
                    if (r && r.identifier.name === t) {
                        e1.scope.rename(t);
                    }
                }
            });
            const g = {
                memoise (e1, t) {
                    const { scope: r, node: n } = e1;
                    const { computed: s, property: i } = n;
                    if (!s) {
                        return;
                    }
                    const a = r.maybeGenerateMemoised(i);
                    if (!a) {
                        return;
                    }
                    this.memoiser.set(i, a, t);
                },
                prop (e1) {
                    const { computed: t, property: r } = e1.node;
                    if (this.memoiser.has(r)) {
                        return c(this.memoiser.get(r));
                    }
                    if (t) {
                        return c(r);
                    }
                    return f(r.name);
                },
                _getPrototypeOfExpression () {
                    const e1 = c(this.getObjectRef());
                    const t = this.isStatic || this.isPrivateMethod ? e1 : u(e1, p("prototype"));
                    return l(this.file.addHelper("getPrototypeOf"), [
                        t
                    ]);
                },
                get (e1) {
                    const t = c(this.getObjectRef());
                    return l(this.file.addHelper("superPropGet"), [
                        this.isDerivedConstructor ? d([
                            h(),
                            t
                        ]) : t,
                        this.prop(e1),
                        h(),
                        ...this.isStatic || this.isPrivateMethod ? [] : [
                            i.types.numericLiteral(1)
                        ]
                    ]);
                },
                _call (e1, t, r) {
                    const n = c(this.getObjectRef());
                    let s;
                    if (t.length === 1 && i.types.isSpreadElement(t[0]) && (i.types.isIdentifier(t[0].argument) || i.types.isArrayExpression(t[0].argument))) {
                        s = t[0].argument;
                    } else {
                        s = i.types.arrayExpression(t);
                    }
                    const a = i.types.callExpression(this.file.addHelper("superPropGet"), [
                        this.isDerivedConstructor ? d([
                            h(),
                            n
                        ]) : n,
                        this.prop(e1),
                        h(),
                        i.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))
                    ]);
                    if (r) {
                        return i.types.optionalCallExpression(a, [
                            s
                        ], true);
                    }
                    return l(a, [
                        s
                    ]);
                },
                set (e1, t) {
                    const r = c(this.getObjectRef());
                    return l(this.file.addHelper("superPropSet"), [
                        this.isDerivedConstructor ? d([
                            h(),
                            r
                        ]) : r,
                        this.prop(e1),
                        t,
                        h(),
                        i.types.numericLiteral(e1.isInStrictMode() ? 1 : 0),
                        ...this.isStatic || this.isPrivateMethod ? [] : [
                            i.types.numericLiteral(1)
                        ]
                    ]);
                },
                destructureSet (e1) {
                    throw e1.buildCodeFrameError("Destructuring to a super field is not supported yet.");
                },
                call (e1, t) {
                    return this._call(e1, t, false);
                },
                optionalCall (e1, t) {
                    return this._call(e1, t, true);
                },
                delete (e1) {
                    if (e1.node.computed) {
                        return d([
                            l(this.file.addHelper("toPropertyKey"), [
                                c(e1.node.property)
                            ]),
                            i.template.expression.ast(_templateObject53())
                        ]);
                    } else {
                        return i.template.expression.ast(_templateObject54());
                    }
                }
            };
            const b = {
                memoise (e1, t) {
                    const { scope: r, node: n } = e1;
                    const { computed: s, property: i } = n;
                    if (!s) {
                        return;
                    }
                    const a = r.maybeGenerateMemoised(i);
                    if (!a) {
                        return;
                    }
                    this.memoiser.set(i, a, t);
                },
                prop (e1) {
                    const { computed: t, property: r } = e1.node;
                    if (this.memoiser.has(r)) {
                        return c(this.memoiser.get(r));
                    }
                    if (t) {
                        return c(r);
                    }
                    return f(r.name);
                },
                _getPrototypeOfExpression () {
                    const e1 = c(this.getObjectRef());
                    const t = this.isStatic || this.isPrivateMethod ? e1 : u(e1, p("prototype"));
                    return l(this.file.addHelper("getPrototypeOf"), [
                        t
                    ]);
                },
                get (e1) {
                    return this._get(e1);
                },
                _get (e1) {
                    const t = this._getPrototypeOfExpression();
                    return l(this.file.addHelper("get"), [
                        this.isDerivedConstructor ? d([
                            h(),
                            t
                        ]) : t,
                        this.prop(e1),
                        h()
                    ]);
                },
                set (e1, t) {
                    const r = this._getPrototypeOfExpression();
                    return l(this.file.addHelper("set"), [
                        this.isDerivedConstructor ? d([
                            h(),
                            r
                        ]) : r,
                        this.prop(e1),
                        t,
                        h(),
                        i.types.booleanLiteral(e1.isInStrictMode())
                    ]);
                },
                destructureSet (e1) {
                    throw e1.buildCodeFrameError("Destructuring to a super field is not supported yet.");
                },
                call (e1, t) {
                    return (0, s.default)(this._get(e1), h(), t, false);
                },
                optionalCall (e1, t) {
                    return (0, s.default)(this._get(e1), c(h()), t, true);
                },
                delete (e1) {
                    if (e1.node.computed) {
                        return d([
                            l(this.file.addHelper("toPropertyKey"), [
                                c(e1.node.property)
                            ]),
                            i.template.expression.ast(_templateObject55())
                        ]);
                    } else {
                        return i.template.expression.ast(_templateObject56());
                    }
                }
            };
            const T = Object.assign({}, g, {
                prop (e1) {
                    const { property: t } = e1.node;
                    if (this.memoiser.has(t)) {
                        return c(this.memoiser.get(t));
                    }
                    return c(t);
                },
                get (e1) {
                    const { isStatic: t, getSuperRef: r } = this;
                    const { computed: n } = e1.node;
                    const s = this.prop(e1);
                    let i;
                    if (t) {
                        var a;
                        i = (a = r()) != null ? a : u(p("Function"), p("prototype"));
                    } else {
                        var o;
                        i = u((o = r()) != null ? o : p("Object"), p("prototype"));
                    }
                    return u(i, s, n);
                },
                set (e1, t) {
                    const { computed: r } = e1.node;
                    const n = this.prop(e1);
                    return o("=", u(h(), n, r), t);
                },
                destructureSet (e1) {
                    const { computed: t } = e1.node;
                    const r = this.prop(e1);
                    return u(h(), r, t);
                },
                call (e1, t) {
                    return (0, s.default)(this.get(e1), h(), t, false);
                },
                optionalCall (e1, t) {
                    return (0, s.default)(this.get(e1), h(), t, true);
                }
            });
            class ReplaceSupers {
                getObjectRef() {
                    return c(this.opts.objectRef || this.opts.getObjectRef());
                }
                getSuperRef() {
                    if (this.opts.superRef) return c(this.opts.superRef);
                    if (this.opts.getSuperRef) {
                        return c(this.opts.getSuperRef());
                    }
                }
                replace() {
                    const { methodPath: e1 } = this;
                    if (this.opts.refToPreserve) {
                        e1.traverse(y, {
                            refName: this.opts.refToPreserve.name
                        });
                    }
                    const t = this.constantSuper ? T : this.file.availableHelper("superPropSet") ? g : b;
                    m.shouldSkip = (t)=>{
                        if (t.parentPath === e1) {
                            if (t.parentKey === "decorators" || t.parentKey === "key") {
                                return true;
                            }
                        }
                    };
                    (0, n.default)(e1, m, Object.assign({
                        file: this.file,
                        scope: this.methodPath.scope,
                        isDerivedConstructor: this.isDerivedConstructor,
                        isStatic: this.isStatic,
                        isPrivateMethod: this.isPrivateMethod,
                        getObjectRef: this.getObjectRef.bind(this),
                        getSuperRef: this.getSuperRef.bind(this),
                        boundGet: t.get
                    }, t));
                }
                constructor(e1){
                    var t;
                    const r = e1.methodPath;
                    this.methodPath = r;
                    this.isDerivedConstructor = r.isClassMethod({
                        kind: "constructor"
                    }) && !!e1.superRef;
                    this.isStatic = r.isObjectMethod() || r.node.static || (r.isStaticBlock == null ? void 0 : r.isStaticBlock());
                    this.isPrivateMethod = r.isPrivate() && r.isMethod();
                    this.file = e1.file;
                    this.constantSuper = (t = e1.constantSuper) != null ? t : e1.isLoose;
                    this.opts = e1;
                }
            }
            t["default"] = ReplaceSupers;
        },
        9102: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isTransparentExprWrapper = isTransparentExprWrapper;
            t.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;
            t.skipTransparentExprWrappers = skipTransparentExprWrappers;
            var n = r(3061);
            const { isParenthesizedExpression: s, isTSAsExpression: i, isTSNonNullExpression: a, isTSSatisfiesExpression: o, isTSTypeAssertion: l, isTypeCastExpression: c } = n;
            function isTransparentExprWrapper(e1) {
                return i(e1) || o(e1) || l(e1) || a(e1) || c(e1) || s(e1);
            }
            function skipTransparentExprWrappers(e1) {
                while(isTransparentExprWrapper(e1.node)){
                    e1 = e1.get("expression");
                }
                return e1;
            }
            function skipTransparentExprWrapperNodes(e1) {
                while(isTransparentExprWrapper(e1)){
                    e1 = e1.expression;
                }
                return e1;
            }
        },
        5241: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.readCodePoint = readCodePoint;
            t.readInt = readInt;
            t.readStringContents = readStringContents;
            var r = function isDigit(e1) {
                return e1 >= 48 && e1 <= 57;
            };
            const n = {
                decBinOct: new Set([
                    46,
                    66,
                    69,
                    79,
                    95,
                    98,
                    101,
                    111
                ]),
                hex: new Set([
                    46,
                    88,
                    95,
                    120
                ])
            };
            const s = {
                bin: (e1)=>e1 === 48 || e1 === 49,
                oct: (e1)=>e1 >= 48 && e1 <= 55,
                dec: (e1)=>e1 >= 48 && e1 <= 57,
                hex: (e1)=>e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102
            };
            function readStringContents(e1, t, r, n, s, i) {
                const a = r;
                const o = n;
                const l = s;
                let c = "";
                let p = null;
                let u = r;
                const { length: d } = t;
                for(;;){
                    if (r >= d) {
                        i.unterminated(a, o, l);
                        c += t.slice(u, r);
                        break;
                    }
                    const f = t.charCodeAt(r);
                    if (isStringEnd(e1, f, t, r)) {
                        c += t.slice(u, r);
                        break;
                    }
                    if (f === 92) {
                        c += t.slice(u, r);
                        const a = readEscapedChar(t, r, n, s, e1 === "template", i);
                        if (a.ch === null && !p) {
                            p = {
                                pos: r,
                                lineStart: n,
                                curLine: s
                            };
                        } else {
                            c += a.ch;
                        }
                        ({ pos: r, lineStart: n, curLine: s } = a);
                        u = r;
                    } else if (f === 8232 || f === 8233) {
                        ++r;
                        ++s;
                        n = r;
                    } else if (f === 10 || f === 13) {
                        if (e1 === "template") {
                            c += t.slice(u, r) + "\n";
                            ++r;
                            if (f === 13 && t.charCodeAt(r) === 10) {
                                ++r;
                            }
                            ++s;
                            u = n = r;
                        } else {
                            i.unterminated(a, o, l);
                        }
                    } else {
                        ++r;
                    }
                }
                return {
                    pos: r,
                    str: c,
                    firstInvalidLoc: p,
                    lineStart: n,
                    curLine: s,
                    containsInvalid: !!p
                };
            }
            function isStringEnd(e1, t, r, n) {
                if (e1 === "template") {
                    return t === 96 || t === 36 && r.charCodeAt(n + 1) === 123;
                }
                return t === (e1 === "double" ? 34 : 39);
            }
            function readEscapedChar(e1, t, r, n, s, i) {
                const a = !s;
                t++;
                const res = (e1)=>({
                        pos: t,
                        ch: e1,
                        lineStart: r,
                        curLine: n
                    });
                const o = e1.charCodeAt(t++);
                switch(o){
                    case 110:
                        return res("\n");
                    case 114:
                        return res("\r");
                    case 120:
                        {
                            let s;
                            ({ code: s, pos: t } = readHexChar(e1, t, r, n, 2, false, a, i));
                            return res(s === null ? null : String.fromCharCode(s));
                        }
                    case 117:
                        {
                            let s;
                            ({ code: s, pos: t } = readCodePoint(e1, t, r, n, a, i));
                            return res(s === null ? null : String.fromCodePoint(s));
                        }
                    case 116:
                        return res("\t");
                    case 98:
                        return res("\b");
                    case 118:
                        return res("\v");
                    case 102:
                        return res("\f");
                    case 13:
                        if (e1.charCodeAt(t) === 10) {
                            ++t;
                        }
                    case 10:
                        r = t;
                        ++n;
                    case 8232:
                    case 8233:
                        return res("");
                    case 56:
                    case 57:
                        if (s) {
                            return res(null);
                        } else {
                            i.strictNumericEscape(t - 1, r, n);
                        }
                    default:
                        if (o >= 48 && o <= 55) {
                            const a = t - 1;
                            const o = /^[0-7]+/.exec(e1.slice(a, t + 2));
                            let l = o[0];
                            let c = parseInt(l, 8);
                            if (c > 255) {
                                l = l.slice(0, -1);
                                c = parseInt(l, 8);
                            }
                            t += l.length - 1;
                            const p = e1.charCodeAt(t);
                            if (l !== "0" || p === 56 || p === 57) {
                                if (s) {
                                    return res(null);
                                } else {
                                    i.strictNumericEscape(a, r, n);
                                }
                            }
                            return res(String.fromCharCode(c));
                        }
                        return res(String.fromCharCode(o));
                }
            }
            function readHexChar(e1, t, r, n, s, i, a, o) {
                const l = t;
                let c;
                ({ n: c, pos: t } = readInt(e1, t, r, n, 16, s, i, false, o, !a));
                if (c === null) {
                    if (a) {
                        o.invalidEscapeSequence(l, r, n);
                    } else {
                        t = l - 1;
                    }
                }
                return {
                    code: c,
                    pos: t
                };
            }
            function readInt(e1, t, i, a, o, l, c, p, u, d) {
                const f = t;
                const h = o === 16 ? n.hex : n.decBinOct;
                const m = o === 16 ? s.hex : o === 10 ? s.dec : o === 8 ? s.oct : s.bin;
                let y = false;
                let g = 0;
                for(let n = 0, s = l == null ? Infinity : l; n < s; ++n){
                    const n = e1.charCodeAt(t);
                    let s;
                    if (n === 95 && p !== "bail") {
                        const r = e1.charCodeAt(t - 1);
                        const n = e1.charCodeAt(t + 1);
                        if (!p) {
                            if (d) return {
                                n: null,
                                pos: t
                            };
                            u.numericSeparatorInEscapeSequence(t, i, a);
                        } else if (Number.isNaN(n) || !m(n) || h.has(r) || h.has(n)) {
                            if (d) return {
                                n: null,
                                pos: t
                            };
                            u.unexpectedNumericSeparator(t, i, a);
                        }
                        ++t;
                        continue;
                    }
                    if (n >= 97) {
                        s = n - 97 + 10;
                    } else if (n >= 65) {
                        s = n - 65 + 10;
                    } else if (r(n)) {
                        s = n - 48;
                    } else {
                        s = Infinity;
                    }
                    if (s >= o) {
                        if (s <= 9 && d) {
                            return {
                                n: null,
                                pos: t
                            };
                        } else if (s <= 9 && u.invalidDigit(t, i, a, o)) {
                            s = 0;
                        } else if (c) {
                            s = 0;
                            y = true;
                        } else {
                            break;
                        }
                    }
                    ++t;
                    g = g * o + s;
                }
                if (t === f || l != null && t - f !== l || y) {
                    return {
                        n: null,
                        pos: t
                    };
                }
                return {
                    n: g,
                    pos: t
                };
            }
            function readCodePoint(e1, t, r, n, s, i) {
                const a = e1.charCodeAt(t);
                let o;
                if (a === 123) {
                    ++t;
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, e1.indexOf("}", t) - t, true, s, i));
                    ++t;
                    if (o !== null && o > 1114111) {
                        if (s) {
                            i.invalidCodePoint(t, r, n);
                        } else {
                            return {
                                code: null,
                                pos: t
                            };
                        }
                    }
                } else {
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, 4, false, s, i));
                }
                return {
                    code: o,
                    pos: t
                };
            }
        },
        7008: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isIdentifierChar = isIdentifierChar;
            t.isIdentifierName = isIdentifierName;
            t.isIdentifierStart = isIdentifierStart;
            let r = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
            let n = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
            const s = new RegExp("[" + r + "]");
            const i = new RegExp("[" + r + n + "]");
            r = n = null;
            const a = [
                0,
                11,
                2,
                25,
                2,
                18,
                2,
                1,
                2,
                14,
                3,
                13,
                35,
                122,
                70,
                52,
                268,
                28,
                4,
                48,
                48,
                31,
                14,
                29,
                6,
                37,
                11,
                29,
                3,
                35,
                5,
                7,
                2,
                4,
                43,
                157,
                19,
                35,
                5,
                35,
                5,
                39,
                9,
                51,
                13,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                2,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                4,
                51,
                13,
                310,
                10,
                21,
                11,
                7,
                25,
                5,
                2,
                41,
                2,
                8,
                70,
                5,
                3,
                0,
                2,
                43,
                2,
                1,
                4,
                0,
                3,
                22,
                11,
                22,
                10,
                30,
                66,
                18,
                2,
                1,
                11,
                21,
                11,
                25,
                71,
                55,
                7,
                1,
                65,
                0,
                16,
                3,
                2,
                2,
                2,
                28,
                43,
                28,
                4,
                28,
                36,
                7,
                2,
                27,
                28,
                53,
                11,
                21,
                11,
                18,
                14,
                17,
                111,
                72,
                56,
                50,
                14,
                50,
                14,
                35,
                39,
                27,
                10,
                22,
                251,
                41,
                7,
                1,
                17,
                2,
                60,
                28,
                11,
                0,
                9,
                21,
                43,
                17,
                47,
                20,
                28,
                22,
                13,
                52,
                58,
                1,
                3,
                0,
                14,
                44,
                33,
                24,
                27,
                35,
                30,
                0,
                3,
                0,
                9,
                34,
                4,
                0,
                13,
                47,
                15,
                3,
                22,
                0,
                2,
                0,
                36,
                17,
                2,
                24,
                20,
                1,
                64,
                6,
                2,
                0,
                2,
                3,
                2,
                14,
                2,
                9,
                8,
                46,
                39,
                7,
                3,
                1,
                3,
                21,
                2,
                6,
                2,
                1,
                2,
                4,
                4,
                0,
                19,
                0,
                13,
                4,
                31,
                9,
                2,
                0,
                3,
                0,
                2,
                37,
                2,
                0,
                26,
                0,
                2,
                0,
                45,
                52,
                19,
                3,
                21,
                2,
                31,
                47,
                21,
                1,
                2,
                0,
                185,
                46,
                42,
                3,
                37,
                47,
                21,
                0,
                60,
                42,
                14,
                0,
                72,
                26,
                38,
                6,
                186,
                43,
                117,
                63,
                32,
                7,
                3,
                0,
                3,
                7,
                2,
                1,
                2,
                23,
                16,
                0,
                2,
                0,
                95,
                7,
                3,
                38,
                17,
                0,
                2,
                0,
                29,
                0,
                11,
                39,
                8,
                0,
                22,
                0,
                12,
                45,
                20,
                0,
                19,
                72,
                200,
                32,
                32,
                8,
                2,
                36,
                18,
                0,
                50,
                29,
                113,
                6,
                2,
                1,
                2,
                37,
                22,
                0,
                26,
                5,
                2,
                1,
                2,
                31,
                15,
                0,
                328,
                18,
                16,
                0,
                2,
                12,
                2,
                33,
                125,
                0,
                80,
                921,
                103,
                110,
                18,
                195,
                2637,
                96,
                16,
                1071,
                18,
                5,
                26,
                3994,
                6,
                582,
                6842,
                29,
                1763,
                568,
                8,
                30,
                18,
                78,
                18,
                29,
                19,
                47,
                17,
                3,
                32,
                20,
                6,
                18,
                433,
                44,
                212,
                63,
                129,
                74,
                6,
                0,
                67,
                12,
                65,
                1,
                2,
                0,
                29,
                6135,
                9,
                1237,
                42,
                9,
                8936,
                3,
                2,
                6,
                2,
                1,
                2,
                290,
                16,
                0,
                30,
                2,
                3,
                0,
                15,
                3,
                9,
                395,
                2309,
                106,
                6,
                12,
                4,
                8,
                8,
                9,
                5991,
                84,
                2,
                70,
                2,
                1,
                3,
                0,
                3,
                1,
                3,
                3,
                2,
                11,
                2,
                0,
                2,
                6,
                2,
                64,
                2,
                3,
                3,
                7,
                2,
                6,
                2,
                27,
                2,
                3,
                2,
                4,
                2,
                0,
                4,
                6,
                2,
                339,
                3,
                24,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                7,
                1845,
                30,
                7,
                5,
                262,
                61,
                147,
                44,
                11,
                6,
                17,
                0,
                322,
                29,
                19,
                43,
                485,
                27,
                229,
                29,
                3,
                0,
                496,
                6,
                2,
                3,
                2,
                1,
                2,
                14,
                2,
                196,
                60,
                67,
                8,
                0,
                1205,
                3,
                2,
                26,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                9,
                2,
                3,
                2,
                0,
                2,
                0,
                7,
                0,
                5,
                0,
                2,
                0,
                2,
                0,
                2,
                2,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                1,
                2,
                0,
                3,
                3,
                2,
                6,
                2,
                3,
                2,
                3,
                2,
                0,
                2,
                9,
                2,
                16,
                6,
                2,
                2,
                4,
                2,
                16,
                4421,
                42719,
                33,
                4153,
                7,
                221,
                3,
                5761,
                15,
                7472,
                16,
                621,
                2467,
                541,
                1507,
                4938,
                6,
                4191
            ];
            const o = [
                509,
                0,
                227,
                0,
                150,
                4,
                294,
                9,
                1368,
                2,
                2,
                1,
                6,
                3,
                41,
                2,
                5,
                0,
                166,
                1,
                574,
                3,
                9,
                9,
                7,
                9,
                32,
                4,
                318,
                1,
                80,
                3,
                71,
                10,
                50,
                3,
                123,
                2,
                54,
                14,
                32,
                10,
                3,
                1,
                11,
                3,
                46,
                10,
                8,
                0,
                46,
                9,
                7,
                2,
                37,
                13,
                2,
                9,
                6,
                1,
                45,
                0,
                13,
                2,
                49,
                13,
                9,
                3,
                2,
                11,
                83,
                11,
                7,
                0,
                3,
                0,
                158,
                11,
                6,
                9,
                7,
                3,
                56,
                1,
                2,
                6,
                3,
                1,
                3,
                2,
                10,
                0,
                11,
                1,
                3,
                6,
                4,
                4,
                68,
                8,
                2,
                0,
                3,
                0,
                2,
                3,
                2,
                4,
                2,
                0,
                15,
                1,
                83,
                17,
                10,
                9,
                5,
                0,
                82,
                19,
                13,
                9,
                214,
                6,
                3,
                8,
                28,
                1,
                83,
                16,
                16,
                9,
                82,
                12,
                9,
                9,
                7,
                19,
                58,
                14,
                5,
                9,
                243,
                14,
                166,
                9,
                71,
                5,
                2,
                1,
                3,
                3,
                2,
                0,
                2,
                1,
                13,
                9,
                120,
                6,
                3,
                6,
                4,
                0,
                29,
                9,
                41,
                6,
                2,
                3,
                9,
                0,
                10,
                10,
                47,
                15,
                343,
                9,
                54,
                7,
                2,
                7,
                17,
                9,
                57,
                21,
                2,
                13,
                123,
                5,
                4,
                0,
                2,
                1,
                2,
                6,
                2,
                0,
                9,
                9,
                49,
                4,
                2,
                1,
                2,
                4,
                9,
                9,
                330,
                3,
                10,
                1,
                2,
                0,
                49,
                6,
                4,
                4,
                14,
                10,
                5350,
                0,
                7,
                14,
                11465,
                27,
                2343,
                9,
                87,
                9,
                39,
                4,
                60,
                6,
                26,
                9,
                535,
                9,
                470,
                0,
                2,
                54,
                8,
                3,
                82,
                0,
                12,
                1,
                19628,
                1,
                4178,
                9,
                519,
                45,
                3,
                22,
                543,
                4,
                4,
                5,
                9,
                7,
                3,
                6,
                31,
                3,
                149,
                2,
                1418,
                49,
                513,
                54,
                5,
                49,
                9,
                0,
                15,
                0,
                23,
                4,
                2,
                14,
                1361,
                6,
                2,
                16,
                3,
                6,
                2,
                1,
                2,
                4,
                101,
                0,
                161,
                6,
                10,
                9,
                357,
                0,
                62,
                13,
                499,
                13,
                245,
                1,
                2,
                9,
                726,
                6,
                110,
                6,
                6,
                9,
                4759,
                9,
                787719,
                239
            ];
            function isInAstralSet(e1, t) {
                let r = 65536;
                for(let n = 0, s = t.length; n < s; n += 2){
                    r += t[n];
                    if (r > e1) return false;
                    r += t[n + 1];
                    if (r >= e1) return true;
                }
                return false;
            }
            function isIdentifierStart(e1) {
                if (e1 < 65) return e1 === 36;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && s.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, a);
            }
            function isIdentifierChar(e1) {
                if (e1 < 48) return e1 === 36;
                if (e1 < 58) return true;
                if (e1 < 65) return false;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && i.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, a) || isInAstralSet(e1, o);
            }
            function isIdentifierName(e1) {
                let t = true;
                for(let r = 0; r < e1.length; r++){
                    let n = e1.charCodeAt(r);
                    if ((n & 64512) === 55296 && r + 1 < e1.length) {
                        const t = e1.charCodeAt(++r);
                        if ((t & 64512) === 56320) {
                            n = 65536 + ((n & 1023) << 10) + (t & 1023);
                        }
                    }
                    if (t) {
                        t = false;
                        if (!isIdentifierStart(n)) {
                            return false;
                        }
                    } else if (!isIdentifierChar(n)) {
                        return false;
                    }
                }
                return !t;
            }
        },
        974: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "isIdentifierChar", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierChar;
                }
            });
            Object.defineProperty(t, "isIdentifierName", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierName;
                }
            });
            Object.defineProperty(t, "isIdentifierStart", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierStart;
                }
            });
            Object.defineProperty(t, "isKeyword", {
                enumerable: true,
                get: function() {
                    return s.isKeyword;
                }
            });
            Object.defineProperty(t, "isReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictBindOnlyReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictBindOnlyReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictBindReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictBindReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictReservedWord;
                }
            });
            var n = r(7008);
            var s = r(1444);
        },
        1444: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isKeyword = isKeyword;
            t.isReservedWord = isReservedWord;
            t.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
            t.isStrictBindReservedWord = isStrictBindReservedWord;
            t.isStrictReservedWord = isStrictReservedWord;
            const r = {
                keyword: [
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ],
                strict: [
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ],
                strictBind: [
                    "eval",
                    "arguments"
                ]
            };
            const n = new Set(r.keyword);
            const s = new Set(r.strict);
            const i = new Set(r.strictBind);
            function isReservedWord(e1, t) {
                return t && e1 === "await" || e1 === "enum";
            }
            function isStrictReservedWord(e1, t) {
                return isReservedWord(e1, t) || s.has(e1);
            }
            function isStrictBindOnlyReservedWord(e1) {
                return i.has(e1);
            }
            function isStrictBindReservedWord(e1, t) {
                return isStrictReservedWord(e1, t) || isStrictBindOnlyReservedWord(e1);
            }
            function isKeyword(e1) {
                return n.has(e1);
            }
        },
        3648: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.findSuggestion = findSuggestion;
            const { min: r } = Math;
            function levenshtein(e1, t) {
                let n = [], s = [], i, a;
                const o = e1.length, l = t.length;
                if (!o) {
                    return l;
                }
                if (!l) {
                    return o;
                }
                for(a = 0; a <= l; a++){
                    n[a] = a;
                }
                for(i = 1; i <= o; i++){
                    for(s = [
                        i
                    ], a = 1; a <= l; a++){
                        s[a] = e1[i - 1] === t[a - 1] ? n[a - 1] : r(n[a - 1], n[a], s[a - 1]) + 1;
                    }
                    n = s;
                }
                return s[l];
            }
            function findSuggestion(e1, t) {
                const n = t.map((t)=>levenshtein(t, e1));
                return t[n.indexOf(r(...n))];
            }
        },
        3146: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "OptionValidator", {
                enumerable: true,
                get: function() {
                    return n.OptionValidator;
                }
            });
            Object.defineProperty(t, "findSuggestion", {
                enumerable: true,
                get: function() {
                    return s.findSuggestion;
                }
            });
            var n = r(2020);
            var s = r(3648);
        },
        2020: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.OptionValidator = void 0;
            var n = r(3648);
            class OptionValidator {
                validateTopLevelOptions(e1, t) {
                    const r = Object.keys(t);
                    for (const t of Object.keys(e1)){
                        if (!r.includes(t)) {
                            throw new Error(this.formatMessage("'".concat(t, "' is not a valid top-level option.\n- Did you mean '").concat((0, n.findSuggestion)(t, r), "'?")));
                        }
                    }
                }
                validateBooleanOption(e1, t, r) {
                    if (t === undefined) {
                        return r;
                    } else {
                        this.invariant(typeof t === "boolean", "'".concat(e1, "' option must be a boolean."));
                    }
                    return t;
                }
                validateStringOption(e1, t, r) {
                    if (t === undefined) {
                        return r;
                    } else {
                        this.invariant(typeof t === "string", "'".concat(e1, "' option must be a string."));
                    }
                    return t;
                }
                invariant(e1, t) {
                    if (!e1) {
                        throw new Error(this.formatMessage(t));
                    }
                }
                formatMessage(e1) {
                    return "".concat(this.descriptor, ": ").concat(e1);
                }
                constructor(e1){
                    this.descriptor = e1;
                }
            }
            t.OptionValidator = OptionValidator;
        },
        3017: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(5326);
            function helper(e1, t, r) {
                return Object.freeze({
                    minVersion: e1,
                    ast: ()=>n.default.program.ast(t, {
                            preserveComments: true
                        }),
                    metadata: r
                });
            }
            const s = t["default"] = {
                __proto__: null,
                OverloadYield: helper("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
                    globals: [],
                    locals: {
                        _OverloadYield: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_OverloadYield",
                    dependencies: {}
                }),
                applyDecoratedDescriptor: helper("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _applyDecoratedDescriptor: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_applyDecoratedDescriptor",
                    dependencies: {}
                }),
                applyDecs2311: helper("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
                    globals: [
                        "Symbol",
                        "Object",
                        "TypeError",
                        "Error"
                    ],
                    locals: {
                        applyDecs2311: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "applyDecs2311",
                    dependencies: {
                        checkInRHS: [
                            "body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"
                        ],
                        setFunctionName: [
                            "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee",
                            "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"
                        ],
                        toPropertyKey: [
                            "body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"
                        ]
                    }
                }),
                arrayLikeToArray: helper("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", {
                    globals: [
                        "Array"
                    ],
                    locals: {
                        _arrayLikeToArray: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_arrayLikeToArray",
                    dependencies: {}
                }),
                arrayWithHoles: helper("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
                    globals: [
                        "Array"
                    ],
                    locals: {
                        _arrayWithHoles: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_arrayWithHoles",
                    dependencies: {}
                }),
                arrayWithoutHoles: helper("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
                    globals: [
                        "Array"
                    ],
                    locals: {
                        _arrayWithoutHoles: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_arrayWithoutHoles",
                    dependencies: {
                        arrayLikeToArray: [
                            "body.0.body.body.0.consequent.argument.callee"
                        ]
                    }
                }),
                assertClassBrand: helper("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _assertClassBrand: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_assertClassBrand",
                    dependencies: {}
                }),
                assertThisInitialized: helper("7.0.0-beta.0", "function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}", {
                    globals: [
                        "ReferenceError"
                    ],
                    locals: {
                        _assertThisInitialized: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_assertThisInitialized",
                    dependencies: {}
                }),
                asyncGeneratorDelegate: helper("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
                    globals: [
                        "Promise",
                        "Symbol"
                    ],
                    locals: {
                        _asyncGeneratorDelegate: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_asyncGeneratorDelegate",
                    dependencies: {
                        OverloadYield: [
                            "body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"
                        ]
                    }
                }),
                asyncIterator: helper("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
                    globals: [
                        "Symbol",
                        "TypeError",
                        "Object",
                        "Promise"
                    ],
                    locals: {
                        _asyncIterator: [
                            "body.0.id"
                        ],
                        AsyncFromSyncIterator: [
                            "body.1.id",
                            "body.0.body.body.1.body.body.1.consequent.argument.callee",
                            "body.1.body.body.1.argument.expressions.1.left.object",
                            "body.1.body.body.1.argument.expressions.2.callee",
                            "body.1.body.body.1.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_asyncIterator",
                    dependencies: {}
                }),
                asyncToGenerator: helper("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}', {
                    globals: [
                        "Promise"
                    ],
                    locals: {
                        asyncGeneratorStep: [
                            "body.0.id",
                            "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee",
                            "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"
                        ],
                        _asyncToGenerator: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_asyncToGenerator",
                    dependencies: {}
                }),
                awaitAsyncGenerator: helper("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
                    globals: [],
                    locals: {
                        _awaitAsyncGenerator: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_awaitAsyncGenerator",
                    dependencies: {
                        OverloadYield: [
                            "body.0.body.body.0.argument.callee"
                        ]
                    }
                }),
                callSuper: helper("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
                    globals: [
                        "Reflect"
                    ],
                    locals: {
                        _callSuper: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_callSuper",
                    dependencies: {
                        getPrototypeOf: [
                            "body.0.body.body.0.argument.expressions.0.right.callee",
                            "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"
                        ],
                        isNativeReflectConstruct: [
                            "body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"
                        ],
                        possibleConstructorReturn: [
                            "body.0.body.body.0.argument.expressions.1.callee"
                        ]
                    }
                }),
                checkInRHS: helper("7.20.5", 'function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}', {
                    globals: [
                        "Object",
                        "TypeError"
                    ],
                    locals: {
                        _checkInRHS: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_checkInRHS",
                    dependencies: {}
                }),
                checkPrivateRedeclaration: helper("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _checkPrivateRedeclaration: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_checkPrivateRedeclaration",
                    dependencies: {}
                }),
                classCallCheck: helper("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _classCallCheck: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classCallCheck",
                    dependencies: {}
                }),
                classNameTDZError: helper("7.0.0-beta.0", "function _classNameTDZError(e){throw new ReferenceError('Class \"'+e+'\" cannot be referenced in computed property keys.')}", {
                    globals: [
                        "ReferenceError"
                    ],
                    locals: {
                        _classNameTDZError: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classNameTDZError",
                    dependencies: {}
                }),
                classPrivateFieldGet2: helper("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
                    globals: [],
                    locals: {
                        _classPrivateFieldGet2: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateFieldGet2",
                    dependencies: {
                        assertClassBrand: [
                            "body.0.body.body.0.argument.arguments.0.callee"
                        ]
                    }
                }),
                classPrivateFieldInitSpec: helper("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
                    globals: [],
                    locals: {
                        _classPrivateFieldInitSpec: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateFieldInitSpec",
                    dependencies: {
                        checkPrivateRedeclaration: [
                            "body.0.body.body.0.expression.expressions.0.callee"
                        ]
                    }
                }),
                classPrivateFieldLooseBase: helper("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _classPrivateFieldBase: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateFieldBase",
                    dependencies: {}
                }),
                classPrivateFieldLooseKey: helper("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
                    globals: [],
                    locals: {
                        id: [
                            "body.0.declarations.0.id",
                            "body.1.body.body.0.argument.left.left.right.argument",
                            "body.1.body.body.0.argument.left.left.right.argument"
                        ],
                        _classPrivateFieldKey: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateFieldKey",
                    dependencies: {}
                }),
                classPrivateFieldSet2: helper("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
                    globals: [],
                    locals: {
                        _classPrivateFieldSet2: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateFieldSet2",
                    dependencies: {
                        assertClassBrand: [
                            "body.0.body.body.0.argument.expressions.0.arguments.0.callee"
                        ]
                    }
                }),
                classPrivateGetter: helper("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
                    globals: [],
                    locals: {
                        _classPrivateGetter: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateGetter",
                    dependencies: {
                        assertClassBrand: [
                            "body.0.body.body.0.argument.arguments.0.callee"
                        ]
                    }
                }),
                classPrivateMethodInitSpec: helper("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
                    globals: [],
                    locals: {
                        _classPrivateMethodInitSpec: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateMethodInitSpec",
                    dependencies: {
                        checkPrivateRedeclaration: [
                            "body.0.body.body.0.expression.expressions.0.callee"
                        ]
                    }
                }),
                classPrivateSetter: helper("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
                    globals: [],
                    locals: {
                        _classPrivateSetter: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classPrivateSetter",
                    dependencies: {
                        assertClassBrand: [
                            "body.0.body.body.0.argument.expressions.0.arguments.0.callee"
                        ]
                    }
                }),
                classStaticPrivateMethodGet: helper("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
                    globals: [],
                    locals: {
                        _classStaticPrivateMethodGet: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_classStaticPrivateMethodGet",
                    dependencies: {
                        assertClassBrand: [
                            "body.0.body.body.0.argument.expressions.0.callee"
                        ]
                    }
                }),
                construct: helper("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
                    globals: [
                        "Reflect"
                    ],
                    locals: {
                        _construct: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_construct",
                    dependencies: {
                        isNativeReflectConstruct: [
                            "body.0.body.body.0.test.callee"
                        ],
                        setPrototypeOf: [
                            "body.0.body.body.4.argument.expressions.0.right.callee"
                        ]
                    }
                }),
                createClass: helper("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _defineProperties: [
                            "body.0.id",
                            "body.1.body.body.0.argument.expressions.0.right.callee",
                            "body.1.body.body.0.argument.expressions.1.right.callee"
                        ],
                        _createClass: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_createClass",
                    dependencies: {
                        toPropertyKey: [
                            "body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"
                        ]
                    }
                }),
                createForOfIteratorHelper: helper("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', {
                    globals: [
                        "Symbol",
                        "Array",
                        "TypeError"
                    ],
                    locals: {
                        _createForOfIteratorHelper: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_createForOfIteratorHelper",
                    dependencies: {
                        unsupportedIterableToArray: [
                            "body.0.body.body.1.consequent.body.0.test.left.right.right.callee"
                        ]
                    }
                }),
                createForOfIteratorHelperLoose: helper("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
                    globals: [
                        "Symbol",
                        "Array",
                        "TypeError"
                    ],
                    locals: {
                        _createForOfIteratorHelperLoose: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_createForOfIteratorHelperLoose",
                    dependencies: {
                        unsupportedIterableToArray: [
                            "body.0.body.body.2.test.left.right.right.callee"
                        ]
                    }
                }),
                createSuper: helper("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", {
                    globals: [
                        "Reflect"
                    ],
                    locals: {
                        _createSuper: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_createSuper",
                    dependencies: {
                        getPrototypeOf: [
                            "body.0.body.body.1.argument.body.body.0.declarations.1.init.callee",
                            "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"
                        ],
                        isNativeReflectConstruct: [
                            "body.0.body.body.0.declarations.0.init.callee"
                        ],
                        possibleConstructorReturn: [
                            "body.0.body.body.1.argument.body.body.2.argument.callee"
                        ]
                    }
                }),
                decorate: helper("7.1.5", 'function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError(\'An element descriptor\\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "\'+r+\'"\');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError(\'An element descriptor\\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "\'+i+\'"\');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError(\'A class descriptor\\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "\'+r+\'"\');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can\'t have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can\'t be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can\'t be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected \'"+r+"\' to be a function");return t}', {
                    globals: [
                        "Object",
                        "TypeError",
                        "Symbol",
                        "ReferenceError"
                    ],
                    locals: {
                        _decorate: [
                            "body.0.id"
                        ],
                        _getDecoratorsApi: [
                            "body.1.id",
                            "body.0.body.body.0.declarations.0.init.callee",
                            "body.1.body.body.0.expression.left"
                        ],
                        _createElementDescriptor: [
                            "body.2.id",
                            "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"
                        ],
                        _coalesceGetterSetter: [
                            "body.3.id",
                            "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"
                        ],
                        _coalesceClassElements: [
                            "body.4.id",
                            "body.0.body.body.2.declarations.1.init.arguments.0.callee"
                        ],
                        _hasDecorators: [
                            "body.5.id",
                            "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee",
                            "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee",
                            "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee",
                            "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee",
                            "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"
                        ],
                        _isDataDescriptor: [
                            "body.6.id",
                            "body.4.body.body.0.body.body.1.consequent.test.left.callee",
                            "body.4.body.body.0.body.body.1.consequent.test.right.callee"
                        ],
                        _optionalCallableProperty: [
                            "body.7.id",
                            "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee",
                            "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_decorate",
                    dependencies: {
                        toArray: [
                            "body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"
                        ],
                        toPropertyKey: [
                            "body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee",
                            "body.2.body.body.0.declarations.1.init.callee"
                        ]
                    }
                }),
                defaults: helper("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _defaults: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_defaults",
                    dependencies: {}
                }),
                defineAccessor: helper("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _defineAccessor: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_defineAccessor",
                    dependencies: {}
                }),
                defineProperty: helper("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _defineProperty: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_defineProperty",
                    dependencies: {
                        toPropertyKey: [
                            "body.0.body.body.0.argument.expressions.0.test.left.right.callee"
                        ]
                    }
                }),
                extends: helper("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _extends: [
                            "body.0.id",
                            "body.0.body.body.0.argument.expressions.1.callee.object",
                            "body.0.body.body.0.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.argument.expressions.0"
                    ],
                    exportName: "_extends",
                    dependencies: {}
                }),
                get: helper("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', {
                    globals: [
                        "Reflect",
                        "Object"
                    ],
                    locals: {
                        _get: [
                            "body.0.id",
                            "body.0.body.body.0.argument.expressions.1.callee.object",
                            "body.0.body.body.0.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.argument.expressions.0"
                    ],
                    exportName: "_get",
                    dependencies: {
                        superPropBase: [
                            "body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"
                        ]
                    }
                }),
                getPrototypeOf: helper("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _getPrototypeOf: [
                            "body.0.id",
                            "body.0.body.body.0.argument.expressions.1.callee",
                            "body.0.body.body.0.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.argument.expressions.0"
                    ],
                    exportName: "_getPrototypeOf",
                    dependencies: {}
                }),
                identity: helper("7.17.0", "function _identity(t){return t}", {
                    globals: [],
                    locals: {
                        _identity: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_identity",
                    dependencies: {}
                }),
                importDeferProxy: helper("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", {
                    globals: [
                        "Proxy",
                        "Reflect"
                    ],
                    locals: {
                        _importDeferProxy: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_importDeferProxy",
                    dependencies: {}
                }),
                inherits: helper("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
                    globals: [
                        "TypeError",
                        "Object"
                    ],
                    locals: {
                        _inherits: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_inherits",
                    dependencies: {
                        setPrototypeOf: [
                            "body.0.body.body.1.expression.expressions.2.right.callee"
                        ]
                    }
                }),
                inheritsLoose: helper("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _inheritsLoose: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_inheritsLoose",
                    dependencies: {
                        setPrototypeOf: [
                            "body.0.body.body.0.expression.expressions.2.callee"
                        ]
                    }
                }),
                initializerDefineProperty: helper("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _initializerDefineProperty: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_initializerDefineProperty",
                    dependencies: {}
                }),
                initializerWarningHelper: helper("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
                    globals: [
                        "Error"
                    ],
                    locals: {
                        _initializerWarningHelper: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_initializerWarningHelper",
                    dependencies: {}
                }),
                instanceof: helper("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', {
                    globals: [
                        "Symbol"
                    ],
                    locals: {
                        _instanceof: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_instanceof",
                    dependencies: {}
                }),
                interopRequireDefault: helper("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
                    globals: [],
                    locals: {
                        _interopRequireDefault: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_interopRequireDefault",
                    dependencies: {}
                }),
                interopRequireWildcard: helper("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}', {
                    globals: [
                        "WeakMap",
                        "Object"
                    ],
                    locals: {
                        _getRequireWildcardCache: [
                            "body.0.id",
                            "body.1.body.body.2.declarations.0.init.callee",
                            "body.0.body.body.2.argument.callee.left"
                        ],
                        _interopRequireWildcard: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_interopRequireWildcard",
                    dependencies: {}
                }),
                isNativeFunction: helper("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', {
                    globals: [
                        "Function"
                    ],
                    locals: {
                        _isNativeFunction: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_isNativeFunction",
                    dependencies: {}
                }),
                isNativeReflectConstruct: helper("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
                    globals: [
                        "Boolean",
                        "Reflect"
                    ],
                    locals: {
                        _isNativeReflectConstruct: [
                            "body.0.id",
                            "body.0.body.body.1.argument.callee.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.1.argument.callee"
                    ],
                    exportName: "_isNativeReflectConstruct",
                    dependencies: {}
                }),
                iterableToArray: helper("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', {
                    globals: [
                        "Symbol",
                        "Array"
                    ],
                    locals: {
                        _iterableToArray: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_iterableToArray",
                    dependencies: {}
                }),
                iterableToArrayLimit: helper("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', {
                    globals: [
                        "Symbol",
                        "Object"
                    ],
                    locals: {
                        _iterableToArrayLimit: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_iterableToArrayLimit",
                    dependencies: {}
                }),
                jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
                    globals: [
                        "Symbol",
                        "Array"
                    ],
                    locals: {
                        REACT_ELEMENT_TYPE: [
                            "body.0.declarations.0.id",
                            "body.1.body.body.0.expression.left",
                            "body.1.body.body.4.argument.properties.0.value",
                            "body.1.body.body.0.expression.right.left"
                        ],
                        _createRawReactElement: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_createRawReactElement",
                    dependencies: {}
                }),
                maybeArrayLike: helper("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
                    globals: [
                        "Array"
                    ],
                    locals: {
                        _maybeArrayLike: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_maybeArrayLike",
                    dependencies: {
                        arrayLikeToArray: [
                            "body.0.body.body.0.consequent.body.1.argument.callee"
                        ]
                    }
                }),
                newArrowCheck: helper("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _newArrowCheck: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_newArrowCheck",
                    dependencies: {}
                }),
                nonIterableRest: helper("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _nonIterableRest: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_nonIterableRest",
                    dependencies: {}
                }),
                nonIterableSpread: helper("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _nonIterableSpread: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_nonIterableSpread",
                    dependencies: {}
                }),
                nullishReceiverError: helper("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _nullishReceiverError: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_nullishReceiverError",
                    dependencies: {}
                }),
                objectDestructuringEmpty: helper("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _objectDestructuringEmpty: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_objectDestructuringEmpty",
                    dependencies: {}
                }),
                objectSpread2: helper("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        ownKeys: [
                            "body.0.id",
                            "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee",
                            "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"
                        ],
                        _objectSpread2: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_objectSpread2",
                    dependencies: {
                        defineProperty: [
                            "body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"
                        ]
                    }
                }),
                objectWithoutProperties: helper("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _objectWithoutProperties: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_objectWithoutProperties",
                    dependencies: {
                        objectWithoutPropertiesLoose: [
                            "body.0.body.body.1.declarations.2.init.callee"
                        ]
                    }
                }),
                objectWithoutPropertiesLoose: helper("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", {
                    globals: [],
                    locals: {
                        _objectWithoutPropertiesLoose: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_objectWithoutPropertiesLoose",
                    dependencies: {}
                }),
                possibleConstructorReturn: helper("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _possibleConstructorReturn: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_possibleConstructorReturn",
                    dependencies: {
                        assertThisInitialized: [
                            "body.0.body.body.2.argument.callee"
                        ]
                    }
                }),
                readOnlyError: helper("7.0.0-beta.0", "function _readOnlyError(r){throw new TypeError('\"'+r+'\" is read-only')}", {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _readOnlyError: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_readOnlyError",
                    dependencies: {}
                }),
                regeneratorRuntime: helper("7.18.0", 'function _regeneratorRuntime(){"use strict";\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a \'"+n+"\' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}', {
                    globals: [
                        "Object",
                        "Symbol",
                        "Error",
                        "TypeError",
                        "isNaN",
                        "Promise"
                    ],
                    locals: {
                        _regeneratorRuntime: [
                            "body.0.id",
                            "body.0.body.body.0.expression.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.expression"
                    ],
                    exportName: "_regeneratorRuntime",
                    dependencies: {}
                }),
                set: helper("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
                    globals: [
                        "Reflect",
                        "Object",
                        "TypeError"
                    ],
                    locals: {
                        set: [
                            "body.0.id",
                            "body.0.body.body.0.argument.expressions.1.callee",
                            "body.1.body.body.0.test.left.argument.callee",
                            "body.0.body.body.0.argument.expressions.0.left"
                        ],
                        _set: [
                            "body.1.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_set",
                    dependencies: {
                        superPropBase: [
                            "body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"
                        ],
                        defineProperty: [
                            "body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"
                        ]
                    }
                }),
                setFunctionName: helper("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        setFunctionName: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "setFunctionName",
                    dependencies: {}
                }),
                setPrototypeOf: helper("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _setPrototypeOf: [
                            "body.0.id",
                            "body.0.body.body.0.argument.expressions.1.callee",
                            "body.0.body.body.0.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.argument.expressions.0"
                    ],
                    exportName: "_setPrototypeOf",
                    dependencies: {}
                }),
                skipFirstGeneratorNext: helper("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", {
                    globals: [],
                    locals: {
                        _skipFirstGeneratorNext: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_skipFirstGeneratorNext",
                    dependencies: {}
                }),
                slicedToArray: helper("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", {
                    globals: [],
                    locals: {
                        _slicedToArray: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_slicedToArray",
                    dependencies: {
                        arrayWithHoles: [
                            "body.0.body.body.0.argument.left.left.left.callee"
                        ],
                        iterableToArrayLimit: [
                            "body.0.body.body.0.argument.left.left.right.callee"
                        ],
                        unsupportedIterableToArray: [
                            "body.0.body.body.0.argument.left.right.callee"
                        ],
                        nonIterableRest: [
                            "body.0.body.body.0.argument.right.callee"
                        ]
                    }
                }),
                superPropBase: helper("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", {
                    globals: [],
                    locals: {
                        _superPropBase: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_superPropBase",
                    dependencies: {
                        getPrototypeOf: [
                            "body.0.body.body.0.test.right.right.right.callee"
                        ]
                    }
                }),
                superPropGet: helper("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}', {
                    globals: [],
                    locals: {
                        _superPropGet: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_superPropGet",
                    dependencies: {
                        get: [
                            "body.0.body.body.0.declarations.0.init.callee"
                        ],
                        getPrototypeOf: [
                            "body.0.body.body.0.declarations.0.init.arguments.0.callee"
                        ]
                    }
                }),
                superPropSet: helper("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
                    globals: [],
                    locals: {
                        _superPropSet: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_superPropSet",
                    dependencies: {
                        set: [
                            "body.0.body.body.0.argument.callee"
                        ],
                        getPrototypeOf: [
                            "body.0.body.body.0.argument.arguments.0.callee"
                        ]
                    }
                }),
                taggedTemplateLiteral: helper("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _taggedTemplateLiteral: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_taggedTemplateLiteral",
                    dependencies: {}
                }),
                taggedTemplateLiteralLoose: helper("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
                    globals: [],
                    locals: {
                        _taggedTemplateLiteralLoose: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_taggedTemplateLiteralLoose",
                    dependencies: {}
                }),
                tdz: helper("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
                    globals: [
                        "ReferenceError"
                    ],
                    locals: {
                        _tdzError: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_tdzError",
                    dependencies: {}
                }),
                temporalRef: helper("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
                    globals: [],
                    locals: {
                        _temporalRef: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_temporalRef",
                    dependencies: {
                        temporalUndefined: [
                            "body.0.body.body.0.argument.test.right"
                        ],
                        tdz: [
                            "body.0.body.body.0.argument.consequent.callee"
                        ]
                    }
                }),
                temporalUndefined: helper("7.0.0-beta.0", "function _temporalUndefined(){}", {
                    globals: [],
                    locals: {
                        _temporalUndefined: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_temporalUndefined",
                    dependencies: {}
                }),
                toArray: helper("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", {
                    globals: [],
                    locals: {
                        _toArray: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_toArray",
                    dependencies: {
                        arrayWithHoles: [
                            "body.0.body.body.0.argument.left.left.left.callee"
                        ],
                        iterableToArray: [
                            "body.0.body.body.0.argument.left.left.right.callee"
                        ],
                        unsupportedIterableToArray: [
                            "body.0.body.body.0.argument.left.right.callee"
                        ],
                        nonIterableRest: [
                            "body.0.body.body.0.argument.right.callee"
                        ]
                    }
                }),
                toConsumableArray: helper("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", {
                    globals: [],
                    locals: {
                        _toConsumableArray: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_toConsumableArray",
                    dependencies: {
                        arrayWithoutHoles: [
                            "body.0.body.body.0.argument.left.left.left.callee"
                        ],
                        iterableToArray: [
                            "body.0.body.body.0.argument.left.left.right.callee"
                        ],
                        unsupportedIterableToArray: [
                            "body.0.body.body.0.argument.left.right.callee"
                        ],
                        nonIterableSpread: [
                            "body.0.body.body.0.argument.right.callee"
                        ]
                    }
                }),
                toPrimitive: helper("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', {
                    globals: [
                        "Symbol",
                        "TypeError",
                        "String",
                        "Number"
                    ],
                    locals: {
                        toPrimitive: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "toPrimitive",
                    dependencies: {}
                }),
                toPropertyKey: helper("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
                    globals: [],
                    locals: {
                        toPropertyKey: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "toPropertyKey",
                    dependencies: {
                        toPrimitive: [
                            "body.0.body.body.0.declarations.0.init.callee"
                        ]
                    }
                }),
                toSetter: helper("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', {
                    globals: [
                        "Object"
                    ],
                    locals: {
                        _toSetter: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_toSetter",
                    dependencies: {}
                }),
                tsRewriteRelativeImportExtensions: helper("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.test(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,(function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase()+"js":t})):t}', {
                    globals: [],
                    locals: {
                        tsRewriteRelativeImportExtensions: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "tsRewriteRelativeImportExtensions",
                    dependencies: {}
                }),
                typeof: helper("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', {
                    globals: [
                        "Symbol"
                    ],
                    locals: {
                        _typeof: [
                            "body.0.id",
                            "body.0.body.body.0.argument.expressions.1.callee",
                            "body.0.body.body.0.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.argument.expressions.0"
                    ],
                    exportName: "_typeof",
                    dependencies: {}
                }),
                unsupportedIterableToArray: helper("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
                    globals: [
                        "Array"
                    ],
                    locals: {
                        _unsupportedIterableToArray: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_unsupportedIterableToArray",
                    dependencies: {
                        arrayLikeToArray: [
                            "body.0.body.body.0.consequent.body.0.consequent.argument.callee",
                            "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"
                        ]
                    }
                }),
                usingCtx: helper("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}', {
                    globals: [
                        "SuppressedError",
                        "Error",
                        "Object",
                        "TypeError",
                        "Symbol",
                        "Promise"
                    ],
                    locals: {
                        _usingCtx: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_usingCtx",
                    dependencies: {}
                }),
                wrapAsyncGenerator: helper("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
                    globals: [
                        "Promise",
                        "Symbol"
                    ],
                    locals: {
                        _wrapAsyncGenerator: [
                            "body.0.id"
                        ],
                        AsyncGenerator: [
                            "body.1.id",
                            "body.0.body.body.0.argument.body.body.0.argument.callee",
                            "body.2.expression.expressions.0.left.object.object",
                            "body.2.expression.expressions.1.left.object.object",
                            "body.2.expression.expressions.2.left.object.object",
                            "body.2.expression.expressions.3.left.object.object"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_wrapAsyncGenerator",
                    dependencies: {
                        OverloadYield: [
                            "body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"
                        ]
                    }
                }),
                wrapNativeSuper: helper("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
                    globals: [
                        "Map",
                        "TypeError",
                        "Object"
                    ],
                    locals: {
                        _wrapNativeSuper: [
                            "body.0.id",
                            "body.0.body.body.1.argument.expressions.1.callee",
                            "body.0.body.body.1.argument.expressions.0.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.1.argument.expressions.0"
                    ],
                    exportName: "_wrapNativeSuper",
                    dependencies: {
                        getPrototypeOf: [
                            "body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"
                        ],
                        setPrototypeOf: [
                            "body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"
                        ],
                        isNativeFunction: [
                            "body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"
                        ],
                        construct: [
                            "body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"
                        ]
                    }
                }),
                wrapRegExp: helper("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$)/g,(function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
                    globals: [
                        "RegExp",
                        "WeakMap",
                        "Object",
                        "Symbol",
                        "Array"
                    ],
                    locals: {
                        _wrapRegExp: [
                            "body.0.id",
                            "body.0.body.body.4.argument.expressions.3.callee.object",
                            "body.0.body.body.0.expression.left"
                        ]
                    },
                    exportBindingAssignments: [
                        "body.0.body.body.0.expression"
                    ],
                    exportName: "_wrapRegExp",
                    dependencies: {
                        setPrototypeOf: [
                            "body.0.body.body.2.body.body.1.argument.expressions.1.callee"
                        ],
                        inherits: [
                            "body.0.body.body.4.argument.expressions.0.callee"
                        ]
                    }
                }),
                writeOnlyError: helper("7.12.13", "function _writeOnlyError(r){throw new TypeError('\"'+r+'\" is write-only')}", {
                    globals: [
                        "TypeError"
                    ],
                    locals: {
                        _writeOnlyError: [
                            "body.0.id"
                        ]
                    },
                    exportBindingAssignments: [],
                    exportName: "_writeOnlyError",
                    dependencies: {}
                })
            };
            {
                Object.assign(s, {
                    AwaitValue: helper("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
                        globals: [],
                        locals: {
                            _AwaitValue: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_AwaitValue",
                        dependencies: {}
                    }),
                    applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
                        globals: [
                            "Object",
                            "Map",
                            "Symbol",
                            "Array",
                            "Error",
                            "TypeError",
                            "console"
                        ],
                        locals: {
                            old_createMetadataMethodsForProperty: [
                                "body.0.id",
                                "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee",
                                "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"
                            ],
                            old_convertMetadataMapToFinal: [
                                "body.1.id",
                                "body.13.body.body.1.argument.expressions.1.callee",
                                "body.13.body.body.1.argument.expressions.3.callee"
                            ],
                            old_createAddInitializerMethod: [
                                "body.2.id",
                                "body.3.body.body.3.test.expressions.0.right.right.callee",
                                "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"
                            ],
                            old_memberDec: [
                                "body.3.id",
                                "body.9.body.body.1.consequent.expression.left.right.right.callee",
                                "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"
                            ],
                            old_assertNotFinished: [
                                "body.4.id",
                                "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee",
                                "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee",
                                "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"
                            ],
                            old_assertMetadataKey: [
                                "body.5.id",
                                "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee",
                                "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"
                            ],
                            old_assertCallable: [
                                "body.6.id",
                                "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee",
                                "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee",
                                "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee",
                                "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee",
                                "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"
                            ],
                            old_assertValidReturnValue: [
                                "body.7.id",
                                "body.9.body.body.1.consequent.expression.right.expressions.0.callee",
                                "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee",
                                "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"
                            ],
                            old_getInit: [
                                "body.8.id",
                                "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee",
                                "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"
                            ],
                            old_applyMemberDec: [
                                "body.9.id",
                                "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"
                            ],
                            old_applyMemberDecs: [
                                "body.10.id",
                                "body.13.body.body.1.argument.expressions.0.callee"
                            ],
                            old_pushInitializers: [
                                "body.11.id",
                                "body.10.body.body.1.expression.expressions.0.callee",
                                "body.10.body.body.1.expression.expressions.1.callee"
                            ],
                            old_applyClassDecs: [
                                "body.12.id",
                                "body.13.body.body.1.argument.expressions.2.callee"
                            ],
                            applyDecs: [
                                "body.13.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "applyDecs",
                        dependencies: {
                            setFunctionName: [
                                "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee",
                                "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"
                            ],
                            toPropertyKey: [
                                "body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"
                            ]
                        }
                    }),
                    applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
                        globals: [
                            "Error",
                            "TypeError",
                            "Object",
                            "Map",
                            "Array"
                        ],
                        locals: {
                            applyDecs2203Factory: [
                                "body.0.id",
                                "body.2.body.body.0.argument.callee.right.right.callee"
                            ],
                            applyDecs2203Impl: [
                                "body.1.declarations.0.id",
                                "body.2.body.body.0.argument.callee.right.left",
                                "body.2.body.body.0.argument.callee.left"
                            ],
                            applyDecs2203: [
                                "body.2.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "applyDecs2203",
                        dependencies: {}
                    }),
                    applyDecs2203R: helper("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
                        globals: [
                            "Error",
                            "TypeError",
                            "Object",
                            "Map",
                            "Array"
                        ],
                        locals: {
                            applyDecs2203RFactory: [
                                "body.0.id",
                                "body.1.body.body.0.argument.callee.right.callee"
                            ],
                            applyDecs2203R: [
                                "body.1.id",
                                "body.1.body.body.0.argument.callee.left"
                            ]
                        },
                        exportBindingAssignments: [
                            "body.1.body.body.0.argument.callee"
                        ],
                        exportName: "applyDecs2203R",
                        dependencies: {
                            setFunctionName: [
                                "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee",
                                "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"
                            ],
                            toPropertyKey: [
                                "body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"
                            ]
                        }
                    }),
                    applyDecs2301: helper("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
                        globals: [
                            "Error",
                            "TypeError",
                            "Object",
                            "Map",
                            "Array"
                        ],
                        locals: {
                            applyDecs2301Factory: [
                                "body.0.id",
                                "body.1.body.body.0.argument.callee.right.callee"
                            ],
                            applyDecs2301: [
                                "body.1.id",
                                "body.1.body.body.0.argument.callee.left"
                            ]
                        },
                        exportBindingAssignments: [
                            "body.1.body.body.0.argument.callee"
                        ],
                        exportName: "applyDecs2301",
                        dependencies: {
                            checkInRHS: [
                                "body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"
                            ],
                            setFunctionName: [
                                "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee",
                                "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"
                            ],
                            toPropertyKey: [
                                "body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"
                            ]
                        }
                    }),
                    applyDecs2305: helper("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
                        globals: [
                            "TypeError",
                            "Array",
                            "Object",
                            "Error",
                            "Symbol",
                            "Map"
                        ],
                        locals: {
                            applyDecs2305: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "applyDecs2305",
                        dependencies: {
                            checkInRHS: [
                                "body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"
                            ],
                            setFunctionName: [
                                "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee",
                                "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"
                            ],
                            toPropertyKey: [
                                "body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"
                            ]
                        }
                    }),
                    classApplyDescriptorDestructureSet: helper("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', {
                        globals: [
                            "TypeError"
                        ],
                        locals: {
                            _classApplyDescriptorDestructureSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classApplyDescriptorDestructureSet",
                        dependencies: {}
                    }),
                    classApplyDescriptorGet: helper("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
                        globals: [],
                        locals: {
                            _classApplyDescriptorGet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classApplyDescriptorGet",
                        dependencies: {}
                    }),
                    classApplyDescriptorSet: helper("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', {
                        globals: [
                            "TypeError"
                        ],
                        locals: {
                            _classApplyDescriptorSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classApplyDescriptorSet",
                        dependencies: {}
                    }),
                    classCheckPrivateStaticAccess: helper("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
                        globals: [],
                        locals: {
                            _classCheckPrivateStaticAccess: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classCheckPrivateStaticAccess",
                        dependencies: {
                            assertClassBrand: [
                                "body.0.body.body.0.argument.callee"
                            ]
                        }
                    }),
                    classCheckPrivateStaticFieldDescriptor: helper("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', {
                        globals: [
                            "TypeError"
                        ],
                        locals: {
                            _classCheckPrivateStaticFieldDescriptor: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classCheckPrivateStaticFieldDescriptor",
                        dependencies: {}
                    }),
                    classExtractFieldDescriptor: helper("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
                        globals: [],
                        locals: {
                            _classExtractFieldDescriptor: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classExtractFieldDescriptor",
                        dependencies: {
                            classPrivateFieldGet2: [
                                "body.0.body.body.0.argument.callee"
                            ]
                        }
                    }),
                    classPrivateFieldDestructureSet: helper("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", {
                        globals: [],
                        locals: {
                            _classPrivateFieldDestructureSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classPrivateFieldDestructureSet",
                        dependencies: {
                            classApplyDescriptorDestructureSet: [
                                "body.0.body.body.1.argument.callee"
                            ],
                            classPrivateFieldGet2: [
                                "body.0.body.body.0.declarations.0.init.callee"
                            ]
                        }
                    }),
                    classPrivateFieldGet: helper("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", {
                        globals: [],
                        locals: {
                            _classPrivateFieldGet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classPrivateFieldGet",
                        dependencies: {
                            classApplyDescriptorGet: [
                                "body.0.body.body.1.argument.callee"
                            ],
                            classPrivateFieldGet2: [
                                "body.0.body.body.0.declarations.0.init.callee"
                            ]
                        }
                    }),
                    classPrivateFieldSet: helper("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", {
                        globals: [],
                        locals: {
                            _classPrivateFieldSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classPrivateFieldSet",
                        dependencies: {
                            classApplyDescriptorSet: [
                                "body.0.body.body.1.argument.expressions.0.callee"
                            ],
                            classPrivateFieldGet2: [
                                "body.0.body.body.0.declarations.0.init.callee"
                            ]
                        }
                    }),
                    classPrivateMethodGet: helper("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
                        globals: [],
                        locals: {
                            _classPrivateMethodGet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classPrivateMethodGet",
                        dependencies: {
                            assertClassBrand: [
                                "body.0.body.body.0.argument.expressions.0.callee"
                            ]
                        }
                    }),
                    classPrivateMethodSet: helper("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
                        globals: [
                            "TypeError"
                        ],
                        locals: {
                            _classPrivateMethodSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classPrivateMethodSet",
                        dependencies: {}
                    }),
                    classStaticPrivateFieldDestructureSet: helper("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
                        globals: [],
                        locals: {
                            _classStaticPrivateFieldDestructureSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classStaticPrivateFieldDestructureSet",
                        dependencies: {
                            classApplyDescriptorDestructureSet: [
                                "body.0.body.body.0.argument.expressions.2.callee"
                            ],
                            assertClassBrand: [
                                "body.0.body.body.0.argument.expressions.0.callee"
                            ],
                            classCheckPrivateStaticFieldDescriptor: [
                                "body.0.body.body.0.argument.expressions.1.callee"
                            ]
                        }
                    }),
                    classStaticPrivateFieldSpecGet: helper("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
                        globals: [],
                        locals: {
                            _classStaticPrivateFieldSpecGet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classStaticPrivateFieldSpecGet",
                        dependencies: {
                            classApplyDescriptorGet: [
                                "body.0.body.body.0.argument.expressions.2.callee"
                            ],
                            assertClassBrand: [
                                "body.0.body.body.0.argument.expressions.0.callee"
                            ],
                            classCheckPrivateStaticFieldDescriptor: [
                                "body.0.body.body.0.argument.expressions.1.callee"
                            ]
                        }
                    }),
                    classStaticPrivateFieldSpecSet: helper("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
                        globals: [],
                        locals: {
                            _classStaticPrivateFieldSpecSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classStaticPrivateFieldSpecSet",
                        dependencies: {
                            classApplyDescriptorSet: [
                                "body.0.body.body.0.argument.expressions.2.callee"
                            ],
                            assertClassBrand: [
                                "body.0.body.body.0.argument.expressions.0.callee"
                            ],
                            classCheckPrivateStaticFieldDescriptor: [
                                "body.0.body.body.0.argument.expressions.1.callee"
                            ]
                        }
                    }),
                    classStaticPrivateMethodSet: helper("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', {
                        globals: [
                            "TypeError"
                        ],
                        locals: {
                            _classStaticPrivateMethodSet: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_classStaticPrivateMethodSet",
                        dependencies: {}
                    }),
                    defineEnumerableProperties: helper("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', {
                        globals: [
                            "Object"
                        ],
                        locals: {
                            _defineEnumerableProperties: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_defineEnumerableProperties",
                        dependencies: {}
                    }),
                    dispose: helper("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
                        globals: [
                            "SuppressedError",
                            "Error",
                            "Object",
                            "Promise"
                        ],
                        locals: {
                            dispose_SuppressedError: [
                                "body.0.id",
                                "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object",
                                "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value",
                                "body.0.body.body.0.argument.expressions.1.callee",
                                "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee",
                                "body.0.body.body.0.argument.expressions.0.consequent.left",
                                "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"
                            ],
                            _dispose: [
                                "body.1.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_dispose",
                        dependencies: {}
                    }),
                    objectSpread: helper("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', {
                        globals: [
                            "Object"
                        ],
                        locals: {
                            _objectSpread: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_objectSpread",
                        dependencies: {
                            defineProperty: [
                                "body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"
                            ]
                        }
                    }),
                    using: helper("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', {
                        globals: [
                            "Object",
                            "TypeError",
                            "Symbol"
                        ],
                        locals: {
                            _using: [
                                "body.0.id"
                            ]
                        },
                        exportBindingAssignments: [],
                        exportName: "_using",
                        dependencies: {}
                    })
                });
            }
        },
        8796: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            t.get = get;
            t.getDependencies = getDependencies;
            t.list = void 0;
            t.minVersion = minVersion;
            var n = r(3061);
            var s = r(3017);
            const { cloneNode: i, identifier: a } = n;
            function deep(e1, t, r) {
                try {
                    const n = t.split(".");
                    let s = n.shift();
                    while(n.length > 0){
                        e1 = e1[s];
                        s = n.shift();
                    }
                    if (arguments.length > 2) {
                        e1[s] = r;
                    } else {
                        return e1[s];
                    }
                } catch (e1) {
                    e1.message += " (when accessing ".concat(t, ")");
                    throw e1;
                }
            }
            function permuteHelperAST(e1, t, r, n, s, o) {
                const { locals: l, dependencies: c, exportBindingAssignments: p, exportName: u } = t;
                const d = new Set(n || []);
                if (r) d.add(r);
                for (const [t, n] of (Object.entries || ((e1)=>Object.keys(e1).map((t)=>[
                            t,
                            e1[t]
                        ])))(l)){
                    let s = t;
                    if (r && t === u) {
                        s = r;
                    } else {
                        while(d.has(s))s = "_" + s;
                    }
                    if (s !== t) {
                        for (const t of n){
                            deep(e1, t, a(s));
                        }
                    }
                }
                for (const [t, r] of (Object.entries || ((e1)=>Object.keys(e1).map((t)=>[
                            t,
                            e1[t]
                        ])))(c)){
                    const n = typeof s === "function" && s(t) || a(t);
                    for (const t of r){
                        deep(e1, t, i(n));
                    }
                }
                o == null || o(e1, u, (t)=>{
                    p.forEach((r)=>deep(e1, r, t(deep(e1, r))));
                });
            }
            const o = Object.create(null);
            function loadHelper(e1) {
                if (!o[e1]) {
                    const t = s.default[e1];
                    if (!t) {
                        throw Object.assign(new ReferenceError("Unknown helper ".concat(e1)), {
                            code: "BABEL_HELPER_UNKNOWN",
                            helper: e1
                        });
                    }
                    o[e1] = {
                        minVersion: t.minVersion,
                        build (e1, r, n, s) {
                            const i = t.ast();
                            permuteHelperAST(i, t.metadata, r, n, e1, s);
                            return {
                                nodes: i.body,
                                globals: t.metadata.globals
                            };
                        },
                        getDependencies () {
                            return Object.keys(t.metadata.dependencies);
                        }
                    };
                }
                return o[e1];
            }
            function get(e1, t, r, n, s) {
                {
                    if (typeof r === "object") {
                        const e1 = r;
                        if ((e1 == null ? void 0 : e1.type) === "Identifier") {
                            r = e1.name;
                        } else {
                            r = undefined;
                        }
                    }
                }
                return loadHelper(e1).build(t, r, n, s);
            }
            function minVersion(e1) {
                return loadHelper(e1).minVersion;
            }
            function getDependencies(e1) {
                return loadHelper(e1).getDependencies();
            }
            {
                t.ensure = (e1)=>{
                    loadHelper(e1);
                };
            }
            const l = t.list = Object.keys(s.default).map((e1)=>e1.replace(/^_/, ""));
            var c = t["default"] = get;
        },
        9849: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            function _objectWithoutPropertiesLoose(e1, t) {
                if (null == e1) return {};
                var r = {};
                for(var n in e1)if (({}).hasOwnProperty.call(e1, n)) {
                    if (-1 !== t.indexOf(n)) continue;
                    r[n] = e1[n];
                }
                return r;
            }
            class Position {
                constructor(e1, t, r){
                    this.line = void 0;
                    this.column = void 0;
                    this.index = void 0;
                    this.line = e1;
                    this.column = t;
                    this.index = r;
                }
            }
            class SourceLocation {
                constructor(e1, t){
                    this.start = void 0;
                    this.end = void 0;
                    this.filename = void 0;
                    this.identifierName = void 0;
                    this.start = e1;
                    this.end = t;
                }
            }
            function createPositionWithColumnOffset(e1, t) {
                const { line: r, column: n, index: s } = e1;
                return new Position(r, n + t, s + t);
            }
            const r = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
            var n = {
                ImportMetaOutsideModule: {
                    message: "import.meta may appear only with 'sourceType: \"module\"'",
                    code: r
                },
                ImportOutsideModule: {
                    message: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
                    code: r
                }
            };
            const s = {
                ArrayPattern: "array destructuring pattern",
                AssignmentExpression: "assignment expression",
                AssignmentPattern: "assignment expression",
                ArrowFunctionExpression: "arrow function expression",
                ConditionalExpression: "conditional expression",
                CatchClause: "catch clause",
                ForOfStatement: "for-of statement",
                ForInStatement: "for-in statement",
                ForStatement: "for-loop",
                FormalParameters: "function parameter list",
                Identifier: "identifier",
                ImportSpecifier: "import specifier",
                ImportDefaultSpecifier: "import default specifier",
                ImportNamespaceSpecifier: "import namespace specifier",
                ObjectPattern: "object destructuring pattern",
                ParenthesizedExpression: "parenthesized expression",
                RestElement: "rest element",
                UpdateExpression: {
                    true: "prefix operation",
                    false: "postfix operation"
                },
                VariableDeclarator: "variable declaration",
                YieldExpression: "yield expression"
            };
            const toNodeDescription = (e1)=>e1.type === "UpdateExpression" ? s.UpdateExpression["".concat(e1.prefix)] : s[e1.type];
            var i = {
                AccessorIsGenerator: (param)=>{
                    let { kind: e1 } = param;
                    return "A ".concat(e1, "ter cannot be a generator.");
                },
                ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
                AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
                AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
                AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
                AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
                AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
                AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
                BadGetterArity: "A 'get' accessor must not have any formal parameters.",
                BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
                BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
                ConstructorClassField: "Classes may not have a field named 'constructor'.",
                ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
                ConstructorIsAccessor: "Class constructor may not be an accessor.",
                ConstructorIsAsync: "Constructor can't be an async function.",
                ConstructorIsGenerator: "Constructor can't be a generator.",
                DeclarationMissingInitializer: (param)=>{
                    let { kind: e1 } = param;
                    return "Missing initializer in ".concat(e1, " declaration.");
                },
                DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
                DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
                DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
                DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
                DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
                DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
                DecoratorStaticBlock: "Decorators can't be used with a static block.",
                DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
                DeletePrivateField: "Deleting a private field is not allowed.",
                DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
                DuplicateConstructor: "Duplicate constructor in the same class.",
                DuplicateDefaultExport: "Only one default export allowed per module.",
                DuplicateExport: (param)=>{
                    let { exportName: e1 } = param;
                    return "`".concat(e1, "` has already been exported. Exported identifiers must be unique.");
                },
                DuplicateProto: "Redefinition of __proto__ property.",
                DuplicateRegExpFlags: "Duplicate regular expression flag.",
                DynamicImportPhaseRequiresImportExpressions: (param)=>{
                    let { phase: e1 } = param;
                    return "'import.".concat(e1, "(...)' can only be parsed when using the 'createImportExpressions' option.");
                },
                ElementAfterRest: "Rest element must be last element.",
                EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
                ExportBindingIsString: (param)=>{
                    let { localName: e1, exportName: t } = param;
                    return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(e1, "' as '").concat(t, "' } from 'some-module'`?");
                },
                ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
                ForInOfLoopInitializer: (param)=>{
                    let { type: e1 } = param;
                    return "'".concat(e1 === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
                },
                ForInUsing: "For-in loop may not start with 'using' declaration.",
                ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
                ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
                GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
                IllegalBreakContinue: (param)=>{
                    let { type: e1 } = param;
                    return "Unsyntactic ".concat(e1 === "BreakStatement" ? "break" : "continue", ".");
                },
                IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
                IllegalReturn: "'return' outside of function.",
                ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
                ImportBindingIsString: (param)=>{
                    let { importName: e1 } = param;
                    return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(e1, '" as foo }`?');
                },
                ImportCallArity: "`import()` requires exactly one or two arguments.",
                ImportCallNotNewExpression: "Cannot use new with import(...).",
                ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
                ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
                ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
                ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
                IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
                InvalidBigIntLiteral: "Invalid BigIntLiteral.",
                InvalidCodePoint: "Code point out of bounds.",
                InvalidCoverInitializedName: "Invalid shorthand property initializer.",
                InvalidDecimal: "Invalid decimal.",
                InvalidDigit: (param)=>{
                    let { radix: e1 } = param;
                    return "Expected number in radix ".concat(e1, ".");
                },
                InvalidEscapeSequence: "Bad character escape sequence.",
                InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
                InvalidEscapedReservedWord: (param)=>{
                    let { reservedWord: e1 } = param;
                    return "Escape sequence in keyword ".concat(e1, ".");
                },
                InvalidIdentifier: (param)=>{
                    let { identifierName: e1 } = param;
                    return "Invalid identifier ".concat(e1, ".");
                },
                InvalidLhs: (param)=>{
                    let { ancestor: e1 } = param;
                    return "Invalid left-hand side in ".concat(toNodeDescription(e1), ".");
                },
                InvalidLhsBinding: (param)=>{
                    let { ancestor: e1 } = param;
                    return "Binding invalid left-hand side in ".concat(toNodeDescription(e1), ".");
                },
                InvalidLhsOptionalChaining: (param)=>{
                    let { ancestor: e1 } = param;
                    return "Invalid optional chaining in the left-hand side of ".concat(toNodeDescription(e1), ".");
                },
                InvalidNumber: "Invalid number.",
                InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
                InvalidOrUnexpectedToken: (param)=>{
                    let { unexpected: e1 } = param;
                    return "Unexpected character '".concat(e1, "'.");
                },
                InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
                InvalidPrivateFieldResolution: (param)=>{
                    let { identifierName: e1 } = param;
                    return "Private name #".concat(e1, " is not defined.");
                },
                InvalidPropertyBindingPattern: "Binding member expression.",
                InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
                InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
                LabelRedeclaration: (param)=>{
                    let { labelName: e1 } = param;
                    return "Label '".concat(e1, "' is already declared.");
                },
                LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
                LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
                MalformedRegExpFlags: "Invalid regular expression flag.",
                MissingClassName: "A class name is required.",
                MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
                MissingSemicolon: "Missing semicolon.",
                MissingPlugin: (param)=>{
                    let { missingPlugin: e1 } = param;
                    return "This experimental syntax requires enabling the parser plugin: ".concat(e1.map((e1)=>JSON.stringify(e1)).join(", "), ".");
                },
                MissingOneOfPlugins: (param)=>{
                    let { missingPlugin: e1 } = param;
                    return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(e1.map((e1)=>JSON.stringify(e1)).join(", "), ".");
                },
                MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
                MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
                ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
                ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
                ModuleAttributesWithDuplicateKeys: (param)=>{
                    let { key: e1 } = param;
                    return 'Duplicate key "'.concat(e1, '" is not allowed in module attributes.');
                },
                ModuleExportNameHasLoneSurrogate: (param)=>{
                    let { surrogateCharCode: e1 } = param;
                    return "An export name cannot include a lone surrogate, found '\\u".concat(e1.toString(16), "'.");
                },
                ModuleExportUndefined: (param)=>{
                    let { localName: e1 } = param;
                    return "Export '".concat(e1, "' is not defined.");
                },
                MultipleDefaultsInSwitch: "Multiple default clauses.",
                NewlineAfterThrow: "Illegal newline after throw.",
                NoCatchOrFinally: "Missing catch or finally clause.",
                NumberIdentifier: "Identifier directly after number.",
                NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
                ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
                OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
                OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
                OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
                ParamDupe: "Argument name clash.",
                PatternHasAccessor: "Object pattern can't contain getter or setter.",
                PatternHasMethod: "Object pattern can't contain methods.",
                PrivateInExpectedIn: (param)=>{
                    let { identifierName: e1 } = param;
                    return "Private names are only allowed in property accesses (`obj.#".concat(e1, "`) or in `in` expressions (`#").concat(e1, " in obj`).");
                },
                PrivateNameRedeclaration: (param)=>{
                    let { identifierName: e1 } = param;
                    return "Duplicate private name #".concat(e1, ".");
                },
                RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                RecordNoProto: "'__proto__' is not allowed in Record expressions.",
                RestTrailingComma: "Unexpected trailing comma after rest element.",
                SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
                SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
                SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
                StaticPrototype: "Classes may not have static property named prototype.",
                SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
                SuperPrivateField: "Private fields can't be accessed on super.",
                TrailingDecorator: "Decorators must be attached to a class element.",
                TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
                UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
                UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
                UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
                UnexpectedKeyword: (param)=>{
                    let { keyword: e1 } = param;
                    return "Unexpected keyword '".concat(e1, "'.");
                },
                UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
                UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
                UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
                UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
                UnexpectedPrivateField: "Unexpected private name.",
                UnexpectedReservedWord: (param)=>{
                    let { reservedWord: e1 } = param;
                    return "Unexpected reserved word '".concat(e1, "'.");
                },
                UnexpectedSuper: "'super' is only allowed in object methods and classes.",
                UnexpectedToken: (param)=>{
                    let { expected: e1, unexpected: t } = param;
                    return "Unexpected token".concat(t ? " '".concat(t, "'.") : "").concat(e1 ? ', expected "'.concat(e1, '"') : "");
                },
                UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
                UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
                UnsupportedBind: "Binding should be performed on object property.",
                UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
                UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
                UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
                UnsupportedMetaProperty: (param)=>{
                    let { target: e1, onlyValidPropertyName: t } = param;
                    return "The only valid meta property for ".concat(e1, " is ").concat(e1, ".").concat(t, ".");
                },
                UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
                UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
                UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
                UnterminatedComment: "Unterminated comment.",
                UnterminatedRegExp: "Unterminated regular expression.",
                UnterminatedString: "Unterminated string constant.",
                UnterminatedTemplate: "Unterminated template.",
                UsingDeclarationExport: "Using declaration cannot be exported.",
                UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
                VarRedeclaration: (param)=>{
                    let { identifierName: e1 } = param;
                    return "Identifier '".concat(e1, "' has already been declared.");
                },
                YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
                YieldInParameter: "Yield expression is not allowed in formal parameters.",
                YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
                ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
            };
            var a = {
                StrictDelete: "Deleting local variable in strict mode.",
                StrictEvalArguments: (param)=>{
                    let { referenceName: e1 } = param;
                    return "Assigning to '".concat(e1, "' in strict mode.");
                },
                StrictEvalArgumentsBinding: (param)=>{
                    let { bindingName: e1 } = param;
                    return "Binding '".concat(e1, "' in strict mode.");
                },
                StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
                StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
                StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
                StrictWith: "'with' in strict mode."
            };
            const o = new Set([
                "ArrowFunctionExpression",
                "AssignmentExpression",
                "ConditionalExpression",
                "YieldExpression"
            ]);
            var l = Object.assign({
                PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
                PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
                PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
                PipeTopicUnconfiguredToken: (param)=>{
                    let { token: e1 } = param;
                    return "Invalid topic token ".concat(e1, ". In order to use ").concat(e1, ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "').concat(e1, '" }.');
                },
                PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
                PipeUnparenthesizedBody: (param)=>{
                    let { type: e1 } = param;
                    return "Hack-style pipe body cannot be an unparenthesized ".concat(toNodeDescription({
                        type: e1
                    }), "; please wrap it in parentheses.");
                }
            }, {
                PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
                PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
                PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
                PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
                PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
                PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
            });
            const c = [
                "message"
            ];
            function defineHidden(e1, t, r) {
                Object.defineProperty(e1, t, {
                    enumerable: false,
                    configurable: true,
                    value: r
                });
            }
            function toParseErrorConstructor(param) {
                let { toMessage: e1, code: t, reasonCode: r, syntaxPlugin: n } = param;
                const s = r === "MissingPlugin" || r === "MissingOneOfPlugins";
                {
                    const e1 = {
                        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
                        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
                        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
                        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
                        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
                        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
                    };
                    if (e1[r]) {
                        r = e1[r];
                    }
                }
                return function constructor(i, a) {
                    const o = new SyntaxError;
                    o.code = t;
                    o.reasonCode = r;
                    o.loc = i;
                    o.pos = i.index;
                    o.syntaxPlugin = n;
                    if (s) {
                        o.missingPlugin = a.missingPlugin;
                    }
                    defineHidden(o, "clone", function clone() {
                        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var t;
                        const { line: r, column: n, index: s } = (t = e1.loc) != null ? t : i;
                        return constructor(new Position(r, n, s), Object.assign({}, a, e1.details));
                    });
                    defineHidden(o, "details", a);
                    Object.defineProperty(o, "message", {
                        configurable: true,
                        get () {
                            const t = "".concat(e1(a), " (").concat(i.line, ":").concat(i.column, ")");
                            this.message = t;
                            return t;
                        },
                        set (e1) {
                            Object.defineProperty(this, "message", {
                                value: e1,
                                writable: true
                            });
                        }
                    });
                    return o;
                };
            }
            function ParseErrorEnum(e1, t) {
                if (Array.isArray(e1)) {
                    return (t)=>ParseErrorEnum(t, e1[0]);
                }
                const r = {};
                for (const n of Object.keys(e1)){
                    const s = e1[n];
                    const i = typeof s === "string" ? {
                        message: ()=>s
                    } : typeof s === "function" ? {
                        message: s
                    } : s, { message: a } = i, o = _objectWithoutPropertiesLoose(i, c);
                    const l = typeof a === "string" ? ()=>a : a;
                    r[n] = toParseErrorConstructor(Object.assign({
                        code: "BABEL_PARSER_SYNTAX_ERROR",
                        reasonCode: n,
                        toMessage: l
                    }, t ? {
                        syntaxPlugin: t
                    } : {}, o));
                }
                return r;
            }
            const p = Object.assign({}, ParseErrorEnum(n), ParseErrorEnum(i), ParseErrorEnum(a), ParseErrorEnum(_templateObject57())(l));
            function createDefaultOptions() {
                return {
                    sourceType: "script",
                    sourceFilename: undefined,
                    startIndex: 0,
                    startColumn: 0,
                    startLine: 1,
                    allowAwaitOutsideFunction: false,
                    allowReturnOutsideFunction: false,
                    allowNewTargetOutsideFunction: false,
                    allowImportExportEverywhere: false,
                    allowSuperOutsideMethod: false,
                    allowUndeclaredExports: false,
                    allowYieldOutsideFunction: false,
                    plugins: [],
                    strictMode: null,
                    ranges: false,
                    tokens: false,
                    createImportExpressions: false,
                    createParenthesizedExpressions: false,
                    errorRecovery: false,
                    attachComment: true,
                    annexB: true
                };
            }
            function getOptions(e1) {
                const t = createDefaultOptions();
                if (e1 == null) {
                    return t;
                }
                if (e1.annexB != null && e1.annexB !== false) {
                    throw new Error("The `annexB` option can only be set to `false`.");
                }
                for (const r of Object.keys(t)){
                    if (e1[r] != null) t[r] = e1[r];
                }
                if (t.startLine === 1) {
                    if (e1.startIndex == null && t.startColumn > 0) {
                        t.startIndex = t.startColumn;
                    } else if (e1.startColumn == null && t.startIndex > 0) {
                        t.startColumn = t.startIndex;
                    }
                } else if (e1.startColumn == null || e1.startIndex == null) {
                    if (e1.startIndex != null) {
                        throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
                    }
                }
                return t;
            }
            const { defineProperty: u } = Object;
            const toUnenumerable = (e1, t)=>{
                if (e1) {
                    u(e1, t, {
                        enumerable: false,
                        value: e1[t]
                    });
                }
            };
            function toESTreeLocation(e1) {
                toUnenumerable(e1.loc.start, "index");
                toUnenumerable(e1.loc.end, "index");
                return e1;
            }
            var estree = (e1)=>{
                class ESTreeParserMixin extends e1 {
                    parse() {
                        const e1 = toESTreeLocation(super.parse());
                        if (this.optionFlags & 256) {
                            e1.tokens = e1.tokens.map(toESTreeLocation);
                        }
                        return e1;
                    }
                    parseRegExpLiteral(param) {
                        let { pattern: e1, flags: t } = param;
                        let r = null;
                        try {
                            r = new RegExp(e1, t);
                        } catch (e1) {}
                        const n = this.estreeParseLiteral(r);
                        n.regex = {
                            pattern: e1,
                            flags: t
                        };
                        return n;
                    }
                    parseBigIntLiteral(e1) {
                        let t;
                        try {
                            t = BigInt(e1);
                        } catch (e1) {
                            t = null;
                        }
                        const r = this.estreeParseLiteral(t);
                        r.bigint = String(r.value || e1);
                        return r;
                    }
                    parseDecimalLiteral(e1) {
                        const t = null;
                        const r = this.estreeParseLiteral(t);
                        r.decimal = String(r.value || e1);
                        return r;
                    }
                    estreeParseLiteral(e1) {
                        return this.parseLiteral(e1, "Literal");
                    }
                    parseStringLiteral(e1) {
                        return this.estreeParseLiteral(e1);
                    }
                    parseNumericLiteral(e1) {
                        return this.estreeParseLiteral(e1);
                    }
                    parseNullLiteral() {
                        return this.estreeParseLiteral(null);
                    }
                    parseBooleanLiteral(e1) {
                        return this.estreeParseLiteral(e1);
                    }
                    directiveToStmt(e1) {
                        const t = e1.value;
                        delete e1.value;
                        t.type = "Literal";
                        t.raw = t.extra.raw;
                        t.value = t.extra.expressionValue;
                        const r = e1;
                        r.type = "ExpressionStatement";
                        r.expression = t;
                        r.directive = t.extra.rawValue;
                        delete t.extra;
                        return r;
                    }
                    initFunction(e1, t) {
                        super.initFunction(e1, t);
                        e1.expression = false;
                    }
                    checkDeclaration(e1) {
                        if (e1 != null && this.isObjectProperty(e1)) {
                            this.checkDeclaration(e1.value);
                        } else {
                            super.checkDeclaration(e1);
                        }
                    }
                    getObjectOrClassMethodParams(e1) {
                        return e1.value.params;
                    }
                    isValidDirective(e1) {
                        var t;
                        return e1.type === "ExpressionStatement" && e1.expression.type === "Literal" && typeof e1.expression.value === "string" && !((t = e1.expression.extra) != null && t.parenthesized);
                    }
                    parseBlockBody(e1, t, r, n, s) {
                        super.parseBlockBody(e1, t, r, n, s);
                        const i = e1.directives.map((e1)=>this.directiveToStmt(e1));
                        e1.body = i.concat(e1.body);
                        delete e1.directives;
                    }
                    parsePrivateName() {
                        const e1 = super.parsePrivateName();
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return e1;
                            }
                        }
                        return this.convertPrivateNameToPrivateIdentifier(e1);
                    }
                    convertPrivateNameToPrivateIdentifier(e1) {
                        const t = super.getPrivateNameSV(e1);
                        e1 = e1;
                        delete e1.id;
                        e1.name = t;
                        e1.type = "PrivateIdentifier";
                        return e1;
                    }
                    isPrivateName(e1) {
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return super.isPrivateName(e1);
                            }
                        }
                        return e1.type === "PrivateIdentifier";
                    }
                    getPrivateNameSV(e1) {
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return super.getPrivateNameSV(e1);
                            }
                        }
                        return e1.name;
                    }
                    parseLiteral(e1, t) {
                        const r = super.parseLiteral(e1, t);
                        r.raw = r.extra.raw;
                        delete r.extra;
                        return r;
                    }
                    parseFunctionBody(e1, t) {
                        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        super.parseFunctionBody(e1, t, r);
                        e1.expression = e1.body.type !== "BlockStatement";
                    }
                    parseMethod(e1, t, r, n, s, i) {
                        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                        let o = this.startNode();
                        o.kind = e1.kind;
                        o = super.parseMethod(o, t, r, n, s, i, a);
                        o.type = "FunctionExpression";
                        delete o.kind;
                        e1.value = o;
                        const { typeParameters: l } = e1;
                        if (l) {
                            delete e1.typeParameters;
                            o.typeParameters = l;
                            this.resetStartLocationFromNode(o, l);
                        }
                        if (i === "ClassPrivateMethod") {
                            e1.computed = false;
                        }
                        return this.finishNode(e1, "MethodDefinition");
                    }
                    nameIsConstructor(e1) {
                        if (e1.type === "Literal") return e1.value === "constructor";
                        return super.nameIsConstructor(e1);
                    }
                    parseClassProperty() {
                        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                            e1[_key] = arguments[_key];
                        }
                        const t = super.parseClassProperty(...e1);
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return t;
                            }
                        }
                        {
                            t.type = "PropertyDefinition";
                        }
                        return t;
                    }
                    parseClassPrivateProperty() {
                        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                            e1[_key] = arguments[_key];
                        }
                        const t = super.parseClassPrivateProperty(...e1);
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return t;
                            }
                        }
                        {
                            t.type = "PropertyDefinition";
                        }
                        t.computed = false;
                        return t;
                    }
                    parseClassAccessorProperty(e1) {
                        const t = super.parseClassAccessorProperty(e1);
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return t;
                            }
                        }
                        t.type = "AccessorProperty";
                        return t;
                    }
                    parseObjectMethod(e1, t, r, n, s) {
                        const i = super.parseObjectMethod(e1, t, r, n, s);
                        if (i) {
                            i.type = "Property";
                            if (i.kind === "method") {
                                i.kind = "init";
                            }
                            i.shorthand = false;
                        }
                        return i;
                    }
                    parseObjectProperty(e1, t, r, n) {
                        const s = super.parseObjectProperty(e1, t, r, n);
                        if (s) {
                            s.kind = "init";
                            s.type = "Property";
                        }
                        return s;
                    }
                    isValidLVal(e1, t, r) {
                        return e1 === "Property" ? "value" : super.isValidLVal(e1, t, r);
                    }
                    isAssignable(e1, t) {
                        if (e1 != null && this.isObjectProperty(e1)) {
                            return this.isAssignable(e1.value, t);
                        }
                        return super.isAssignable(e1, t);
                    }
                    toAssignable(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        if (e1 != null && this.isObjectProperty(e1)) {
                            const { key: r, value: n } = e1;
                            if (this.isPrivateName(r)) {
                                this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start);
                            }
                            this.toAssignable(n, t);
                        } else {
                            super.toAssignable(e1, t);
                        }
                    }
                    toAssignableObjectExpressionProp(e1, t, r) {
                        if (e1.type === "Property" && (e1.kind === "get" || e1.kind === "set")) {
                            this.raise(p.PatternHasAccessor, e1.key);
                        } else if (e1.type === "Property" && e1.method) {
                            this.raise(p.PatternHasMethod, e1.key);
                        } else {
                            super.toAssignableObjectExpressionProp(e1, t, r);
                        }
                    }
                    finishCallExpression(e1, t) {
                        const r = super.finishCallExpression(e1, t);
                        if (r.callee.type === "Import") {
                            var n, s;
                            r.type = "ImportExpression";
                            r.source = r.arguments[0];
                            r.options = (n = r.arguments[1]) != null ? n : null;
                            r.attributes = (s = r.arguments[1]) != null ? s : null;
                            delete r.arguments;
                            delete r.callee;
                        }
                        return r;
                    }
                    toReferencedArguments(e1) {
                        if (e1.type === "ImportExpression") {
                            return;
                        }
                        super.toReferencedArguments(e1);
                    }
                    parseExport(e1, t) {
                        const r = this.state.lastTokStartLoc;
                        const n = super.parseExport(e1, t);
                        switch(n.type){
                            case "ExportAllDeclaration":
                                n.exported = null;
                                break;
                            case "ExportNamedDeclaration":
                                if (n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier") {
                                    n.type = "ExportAllDeclaration";
                                    n.exported = n.specifiers[0].exported;
                                    delete n.specifiers;
                                }
                            case "ExportDefaultDeclaration":
                                {
                                    var s;
                                    const { declaration: e1 } = n;
                                    if ((e1 == null ? void 0 : e1.type) === "ClassDeclaration" && ((s = e1.decorators) == null ? void 0 : s.length) > 0 && e1.start === n.start) {
                                        this.resetStartLocation(n, r);
                                    }
                                }
                                break;
                        }
                        return n;
                    }
                    parseSubscript(e1, t, r, n) {
                        const s = super.parseSubscript(e1, t, r, n);
                        if (n.optionalChainMember) {
                            if (s.type === "OptionalMemberExpression" || s.type === "OptionalCallExpression") {
                                s.type = s.type.substring(8);
                            }
                            if (n.stop) {
                                const e1 = this.startNodeAtNode(s);
                                e1.expression = s;
                                return this.finishNode(e1, "ChainExpression");
                            }
                        } else if (s.type === "MemberExpression" || s.type === "CallExpression") {
                            s.optional = false;
                        }
                        return s;
                    }
                    isOptionalMemberExpression(e1) {
                        if (e1.type === "ChainExpression") {
                            return e1.expression.type === "MemberExpression";
                        }
                        return super.isOptionalMemberExpression(e1);
                    }
                    hasPropertyAsPrivateName(e1) {
                        if (e1.type === "ChainExpression") {
                            e1 = e1.expression;
                        }
                        return super.hasPropertyAsPrivateName(e1);
                    }
                    isObjectProperty(e1) {
                        return e1.type === "Property" && e1.kind === "init" && !e1.method;
                    }
                    isObjectMethod(e1) {
                        return e1.type === "Property" && (e1.method || e1.kind === "get" || e1.kind === "set");
                    }
                    finishNodeAt(e1, t, r) {
                        return toESTreeLocation(super.finishNodeAt(e1, t, r));
                    }
                    resetStartLocation(e1, t) {
                        super.resetStartLocation(e1, t);
                        toESTreeLocation(e1);
                    }
                    resetEndLocation(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                        super.resetEndLocation(e1, t);
                        toESTreeLocation(e1);
                    }
                }
                return ESTreeParserMixin;
            };
            class TokContext {
                constructor(e1, t){
                    this.token = void 0;
                    this.preserveSpace = void 0;
                    this.token = e1;
                    this.preserveSpace = !!t;
                }
            }
            const d = {
                brace: new TokContext("{"),
                j_oTag: new TokContext("<tag"),
                j_cTag: new TokContext("</tag"),
                j_expr: new TokContext("<tag>...</tag>", true)
            };
            {
                d.template = new TokContext("`", true);
            }
            const f = true;
            const h = true;
            const m = true;
            const y = true;
            const g = true;
            const b = true;
            class ExportedTokenType {
                constructor(e1, t = {}){
                    this.label = void 0;
                    this.keyword = void 0;
                    this.beforeExpr = void 0;
                    this.startsExpr = void 0;
                    this.rightAssociative = void 0;
                    this.isLoop = void 0;
                    this.isAssign = void 0;
                    this.prefix = void 0;
                    this.postfix = void 0;
                    this.binop = void 0;
                    this.label = e1;
                    this.keyword = t.keyword;
                    this.beforeExpr = !!t.beforeExpr;
                    this.startsExpr = !!t.startsExpr;
                    this.rightAssociative = !!t.rightAssociative;
                    this.isLoop = !!t.isLoop;
                    this.isAssign = !!t.isAssign;
                    this.prefix = !!t.prefix;
                    this.postfix = !!t.postfix;
                    this.binop = t.binop != null ? t.binop : null;
                    {
                        this.updateContext = null;
                    }
                }
            }
            const T = new Map;
            function createKeyword(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                t.keyword = e1;
                const r = createToken(e1, t);
                T.set(e1, r);
                return r;
            }
            function createBinop(e1, t) {
                return createToken(e1, {
                    beforeExpr: f,
                    binop: t
                });
            }
            let S = -1;
            const x = [];
            const E = [];
            const P = [];
            const v = [];
            const A = [];
            const w = [];
            function createToken(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var r, n, s, i;
                ++S;
                E.push(e1);
                P.push((r = t.binop) != null ? r : -1);
                v.push((n = t.beforeExpr) != null ? n : false);
                A.push((s = t.startsExpr) != null ? s : false);
                w.push((i = t.prefix) != null ? i : false);
                x.push(new ExportedTokenType(e1, t));
                return S;
            }
            function createKeywordLike(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var r, n, s, i;
                ++S;
                T.set(e1, S);
                E.push(e1);
                P.push((r = t.binop) != null ? r : -1);
                v.push((n = t.beforeExpr) != null ? n : false);
                A.push((s = t.startsExpr) != null ? s : false);
                w.push((i = t.prefix) != null ? i : false);
                x.push(new ExportedTokenType("name", t));
                return S;
            }
            const I = {
                bracketL: createToken("[", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                bracketHashL: createToken("#[", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                bracketBarL: createToken("[|", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                bracketR: createToken("]"),
                bracketBarR: createToken("|]"),
                braceL: createToken("{", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                braceBarL: createToken("{|", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                braceHashL: createToken("#{", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                braceR: createToken("}"),
                braceBarR: createToken("|}"),
                parenL: createToken("(", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                parenR: createToken(")"),
                comma: createToken(",", {
                    beforeExpr: f
                }),
                semi: createToken(";", {
                    beforeExpr: f
                }),
                colon: createToken(":", {
                    beforeExpr: f
                }),
                doubleColon: createToken("::", {
                    beforeExpr: f
                }),
                dot: createToken("."),
                question: createToken("?", {
                    beforeExpr: f
                }),
                questionDot: createToken("?."),
                arrow: createToken("=>", {
                    beforeExpr: f
                }),
                template: createToken("template"),
                ellipsis: createToken("...", {
                    beforeExpr: f
                }),
                backQuote: createToken("`", {
                    startsExpr: h
                }),
                dollarBraceL: createToken("${", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                templateTail: createToken("...`", {
                    startsExpr: h
                }),
                templateNonTail: createToken("...${", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                at: createToken("@"),
                hash: createToken("#", {
                    startsExpr: h
                }),
                interpreterDirective: createToken("#!..."),
                eq: createToken("=", {
                    beforeExpr: f,
                    isAssign: y
                }),
                assign: createToken("_=", {
                    beforeExpr: f,
                    isAssign: y
                }),
                slashAssign: createToken("_=", {
                    beforeExpr: f,
                    isAssign: y
                }),
                xorAssign: createToken("_=", {
                    beforeExpr: f,
                    isAssign: y
                }),
                moduloAssign: createToken("_=", {
                    beforeExpr: f,
                    isAssign: y
                }),
                incDec: createToken("++/--", {
                    prefix: g,
                    postfix: b,
                    startsExpr: h
                }),
                bang: createToken("!", {
                    beforeExpr: f,
                    prefix: g,
                    startsExpr: h
                }),
                tilde: createToken("~", {
                    beforeExpr: f,
                    prefix: g,
                    startsExpr: h
                }),
                doubleCaret: createToken("^^", {
                    startsExpr: h
                }),
                doubleAt: createToken("@@", {
                    startsExpr: h
                }),
                pipeline: createBinop("|>", 0),
                nullishCoalescing: createBinop("??", 1),
                logicalOR: createBinop("||", 1),
                logicalAND: createBinop("&&", 2),
                bitwiseOR: createBinop("|", 3),
                bitwiseXOR: createBinop("^", 4),
                bitwiseAND: createBinop("&", 5),
                equality: createBinop("==/!=/===/!==", 6),
                lt: createBinop("</>/<=/>=", 7),
                gt: createBinop("</>/<=/>=", 7),
                relational: createBinop("</>/<=/>=", 7),
                bitShift: createBinop("<</>>/>>>", 8),
                bitShiftL: createBinop("<</>>/>>>", 8),
                bitShiftR: createBinop("<</>>/>>>", 8),
                plusMin: createToken("+/-", {
                    beforeExpr: f,
                    binop: 9,
                    prefix: g,
                    startsExpr: h
                }),
                modulo: createToken("%", {
                    binop: 10,
                    startsExpr: h
                }),
                star: createToken("*", {
                    binop: 10
                }),
                slash: createBinop("/", 10),
                exponent: createToken("**", {
                    beforeExpr: f,
                    binop: 11,
                    rightAssociative: true
                }),
                _in: createKeyword("in", {
                    beforeExpr: f,
                    binop: 7
                }),
                _instanceof: createKeyword("instanceof", {
                    beforeExpr: f,
                    binop: 7
                }),
                _break: createKeyword("break"),
                _case: createKeyword("case", {
                    beforeExpr: f
                }),
                _catch: createKeyword("catch"),
                _continue: createKeyword("continue"),
                _debugger: createKeyword("debugger"),
                _default: createKeyword("default", {
                    beforeExpr: f
                }),
                _else: createKeyword("else", {
                    beforeExpr: f
                }),
                _finally: createKeyword("finally"),
                _function: createKeyword("function", {
                    startsExpr: h
                }),
                _if: createKeyword("if"),
                _return: createKeyword("return", {
                    beforeExpr: f
                }),
                _switch: createKeyword("switch"),
                _throw: createKeyword("throw", {
                    beforeExpr: f,
                    prefix: g,
                    startsExpr: h
                }),
                _try: createKeyword("try"),
                _var: createKeyword("var"),
                _const: createKeyword("const"),
                _with: createKeyword("with"),
                _new: createKeyword("new", {
                    beforeExpr: f,
                    startsExpr: h
                }),
                _this: createKeyword("this", {
                    startsExpr: h
                }),
                _super: createKeyword("super", {
                    startsExpr: h
                }),
                _class: createKeyword("class", {
                    startsExpr: h
                }),
                _extends: createKeyword("extends", {
                    beforeExpr: f
                }),
                _export: createKeyword("export"),
                _import: createKeyword("import", {
                    startsExpr: h
                }),
                _null: createKeyword("null", {
                    startsExpr: h
                }),
                _true: createKeyword("true", {
                    startsExpr: h
                }),
                _false: createKeyword("false", {
                    startsExpr: h
                }),
                _typeof: createKeyword("typeof", {
                    beforeExpr: f,
                    prefix: g,
                    startsExpr: h
                }),
                _void: createKeyword("void", {
                    beforeExpr: f,
                    prefix: g,
                    startsExpr: h
                }),
                _delete: createKeyword("delete", {
                    beforeExpr: f,
                    prefix: g,
                    startsExpr: h
                }),
                _do: createKeyword("do", {
                    isLoop: m,
                    beforeExpr: f
                }),
                _for: createKeyword("for", {
                    isLoop: m
                }),
                _while: createKeyword("while", {
                    isLoop: m
                }),
                _as: createKeywordLike("as", {
                    startsExpr: h
                }),
                _assert: createKeywordLike("assert", {
                    startsExpr: h
                }),
                _async: createKeywordLike("async", {
                    startsExpr: h
                }),
                _await: createKeywordLike("await", {
                    startsExpr: h
                }),
                _defer: createKeywordLike("defer", {
                    startsExpr: h
                }),
                _from: createKeywordLike("from", {
                    startsExpr: h
                }),
                _get: createKeywordLike("get", {
                    startsExpr: h
                }),
                _let: createKeywordLike("let", {
                    startsExpr: h
                }),
                _meta: createKeywordLike("meta", {
                    startsExpr: h
                }),
                _of: createKeywordLike("of", {
                    startsExpr: h
                }),
                _sent: createKeywordLike("sent", {
                    startsExpr: h
                }),
                _set: createKeywordLike("set", {
                    startsExpr: h
                }),
                _source: createKeywordLike("source", {
                    startsExpr: h
                }),
                _static: createKeywordLike("static", {
                    startsExpr: h
                }),
                _using: createKeywordLike("using", {
                    startsExpr: h
                }),
                _yield: createKeywordLike("yield", {
                    startsExpr: h
                }),
                _asserts: createKeywordLike("asserts", {
                    startsExpr: h
                }),
                _checks: createKeywordLike("checks", {
                    startsExpr: h
                }),
                _exports: createKeywordLike("exports", {
                    startsExpr: h
                }),
                _global: createKeywordLike("global", {
                    startsExpr: h
                }),
                _implements: createKeywordLike("implements", {
                    startsExpr: h
                }),
                _intrinsic: createKeywordLike("intrinsic", {
                    startsExpr: h
                }),
                _infer: createKeywordLike("infer", {
                    startsExpr: h
                }),
                _is: createKeywordLike("is", {
                    startsExpr: h
                }),
                _mixins: createKeywordLike("mixins", {
                    startsExpr: h
                }),
                _proto: createKeywordLike("proto", {
                    startsExpr: h
                }),
                _require: createKeywordLike("require", {
                    startsExpr: h
                }),
                _satisfies: createKeywordLike("satisfies", {
                    startsExpr: h
                }),
                _keyof: createKeywordLike("keyof", {
                    startsExpr: h
                }),
                _readonly: createKeywordLike("readonly", {
                    startsExpr: h
                }),
                _unique: createKeywordLike("unique", {
                    startsExpr: h
                }),
                _abstract: createKeywordLike("abstract", {
                    startsExpr: h
                }),
                _declare: createKeywordLike("declare", {
                    startsExpr: h
                }),
                _enum: createKeywordLike("enum", {
                    startsExpr: h
                }),
                _module: createKeywordLike("module", {
                    startsExpr: h
                }),
                _namespace: createKeywordLike("namespace", {
                    startsExpr: h
                }),
                _interface: createKeywordLike("interface", {
                    startsExpr: h
                }),
                _type: createKeywordLike("type", {
                    startsExpr: h
                }),
                _opaque: createKeywordLike("opaque", {
                    startsExpr: h
                }),
                name: createToken("name", {
                    startsExpr: h
                }),
                placeholder: createToken("%%", {
                    startsExpr: true
                }),
                string: createToken("string", {
                    startsExpr: h
                }),
                num: createToken("num", {
                    startsExpr: h
                }),
                bigint: createToken("bigint", {
                    startsExpr: h
                }),
                decimal: createToken("decimal", {
                    startsExpr: h
                }),
                regexp: createToken("regexp", {
                    startsExpr: h
                }),
                privateName: createToken("#name", {
                    startsExpr: h
                }),
                eof: createToken("eof"),
                jsxName: createToken("jsxName"),
                jsxText: createToken("jsxText", {
                    beforeExpr: true
                }),
                jsxTagStart: createToken("jsxTagStart", {
                    startsExpr: true
                }),
                jsxTagEnd: createToken("jsxTagEnd")
            };
            function tokenIsIdentifier(e1) {
                return e1 >= 93 && e1 <= 133;
            }
            function tokenKeywordOrIdentifierIsKeyword(e1) {
                return e1 <= 92;
            }
            function tokenIsKeywordOrIdentifier(e1) {
                return e1 >= 58 && e1 <= 133;
            }
            function tokenIsLiteralPropertyName(e1) {
                return e1 >= 58 && e1 <= 137;
            }
            function tokenComesBeforeExpression(e1) {
                return v[e1];
            }
            function tokenCanStartExpression(e1) {
                return A[e1];
            }
            function tokenIsAssignment(e1) {
                return e1 >= 29 && e1 <= 33;
            }
            function tokenIsFlowInterfaceOrTypeOrOpaque(e1) {
                return e1 >= 129 && e1 <= 131;
            }
            function tokenIsLoop(e1) {
                return e1 >= 90 && e1 <= 92;
            }
            function tokenIsKeyword(e1) {
                return e1 >= 58 && e1 <= 92;
            }
            function tokenIsOperator(e1) {
                return e1 >= 39 && e1 <= 59;
            }
            function tokenIsPostfix(e1) {
                return e1 === 34;
            }
            function tokenIsPrefix(e1) {
                return w[e1];
            }
            function tokenIsTSTypeOperator(e1) {
                return e1 >= 121 && e1 <= 123;
            }
            function tokenIsTSDeclarationStart(e1) {
                return e1 >= 124 && e1 <= 130;
            }
            function tokenLabelName(e1) {
                return E[e1];
            }
            function tokenOperatorPrecedence(e1) {
                return P[e1];
            }
            function tokenIsRightAssociative(e1) {
                return e1 === 57;
            }
            function tokenIsTemplate(e1) {
                return e1 >= 24 && e1 <= 25;
            }
            function getExportedToken(e1) {
                return x[e1];
            }
            {
                x[8].updateContext = (e1)=>{
                    e1.pop();
                };
                x[5].updateContext = x[7].updateContext = x[23].updateContext = (e1)=>{
                    e1.push(d.brace);
                };
                x[22].updateContext = (e1)=>{
                    if (e1[e1.length - 1] === d.template) {
                        e1.pop();
                    } else {
                        e1.push(d.template);
                    }
                };
                x[143].updateContext = (e1)=>{
                    e1.push(d.j_expr, d.j_oTag);
                };
            }
            let C = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
            let O = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
            const N = new RegExp("[" + C + "]");
            const k = new RegExp("[" + C + O + "]");
            C = O = null;
            const _ = [
                0,
                11,
                2,
                25,
                2,
                18,
                2,
                1,
                2,
                14,
                3,
                13,
                35,
                122,
                70,
                52,
                268,
                28,
                4,
                48,
                48,
                31,
                14,
                29,
                6,
                37,
                11,
                29,
                3,
                35,
                5,
                7,
                2,
                4,
                43,
                157,
                19,
                35,
                5,
                35,
                5,
                39,
                9,
                51,
                13,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                2,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                4,
                51,
                13,
                310,
                10,
                21,
                11,
                7,
                25,
                5,
                2,
                41,
                2,
                8,
                70,
                5,
                3,
                0,
                2,
                43,
                2,
                1,
                4,
                0,
                3,
                22,
                11,
                22,
                10,
                30,
                66,
                18,
                2,
                1,
                11,
                21,
                11,
                25,
                71,
                55,
                7,
                1,
                65,
                0,
                16,
                3,
                2,
                2,
                2,
                28,
                43,
                28,
                4,
                28,
                36,
                7,
                2,
                27,
                28,
                53,
                11,
                21,
                11,
                18,
                14,
                17,
                111,
                72,
                56,
                50,
                14,
                50,
                14,
                35,
                39,
                27,
                10,
                22,
                251,
                41,
                7,
                1,
                17,
                2,
                60,
                28,
                11,
                0,
                9,
                21,
                43,
                17,
                47,
                20,
                28,
                22,
                13,
                52,
                58,
                1,
                3,
                0,
                14,
                44,
                33,
                24,
                27,
                35,
                30,
                0,
                3,
                0,
                9,
                34,
                4,
                0,
                13,
                47,
                15,
                3,
                22,
                0,
                2,
                0,
                36,
                17,
                2,
                24,
                20,
                1,
                64,
                6,
                2,
                0,
                2,
                3,
                2,
                14,
                2,
                9,
                8,
                46,
                39,
                7,
                3,
                1,
                3,
                21,
                2,
                6,
                2,
                1,
                2,
                4,
                4,
                0,
                19,
                0,
                13,
                4,
                31,
                9,
                2,
                0,
                3,
                0,
                2,
                37,
                2,
                0,
                26,
                0,
                2,
                0,
                45,
                52,
                19,
                3,
                21,
                2,
                31,
                47,
                21,
                1,
                2,
                0,
                185,
                46,
                42,
                3,
                37,
                47,
                21,
                0,
                60,
                42,
                14,
                0,
                72,
                26,
                38,
                6,
                186,
                43,
                117,
                63,
                32,
                7,
                3,
                0,
                3,
                7,
                2,
                1,
                2,
                23,
                16,
                0,
                2,
                0,
                95,
                7,
                3,
                38,
                17,
                0,
                2,
                0,
                29,
                0,
                11,
                39,
                8,
                0,
                22,
                0,
                12,
                45,
                20,
                0,
                19,
                72,
                200,
                32,
                32,
                8,
                2,
                36,
                18,
                0,
                50,
                29,
                113,
                6,
                2,
                1,
                2,
                37,
                22,
                0,
                26,
                5,
                2,
                1,
                2,
                31,
                15,
                0,
                328,
                18,
                16,
                0,
                2,
                12,
                2,
                33,
                125,
                0,
                80,
                921,
                103,
                110,
                18,
                195,
                2637,
                96,
                16,
                1071,
                18,
                5,
                26,
                3994,
                6,
                582,
                6842,
                29,
                1763,
                568,
                8,
                30,
                18,
                78,
                18,
                29,
                19,
                47,
                17,
                3,
                32,
                20,
                6,
                18,
                433,
                44,
                212,
                63,
                129,
                74,
                6,
                0,
                67,
                12,
                65,
                1,
                2,
                0,
                29,
                6135,
                9,
                1237,
                42,
                9,
                8936,
                3,
                2,
                6,
                2,
                1,
                2,
                290,
                16,
                0,
                30,
                2,
                3,
                0,
                15,
                3,
                9,
                395,
                2309,
                106,
                6,
                12,
                4,
                8,
                8,
                9,
                5991,
                84,
                2,
                70,
                2,
                1,
                3,
                0,
                3,
                1,
                3,
                3,
                2,
                11,
                2,
                0,
                2,
                6,
                2,
                64,
                2,
                3,
                3,
                7,
                2,
                6,
                2,
                27,
                2,
                3,
                2,
                4,
                2,
                0,
                4,
                6,
                2,
                339,
                3,
                24,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                7,
                1845,
                30,
                7,
                5,
                262,
                61,
                147,
                44,
                11,
                6,
                17,
                0,
                322,
                29,
                19,
                43,
                485,
                27,
                229,
                29,
                3,
                0,
                496,
                6,
                2,
                3,
                2,
                1,
                2,
                14,
                2,
                196,
                60,
                67,
                8,
                0,
                1205,
                3,
                2,
                26,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                9,
                2,
                3,
                2,
                0,
                2,
                0,
                7,
                0,
                5,
                0,
                2,
                0,
                2,
                0,
                2,
                2,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                1,
                2,
                0,
                3,
                3,
                2,
                6,
                2,
                3,
                2,
                3,
                2,
                0,
                2,
                9,
                2,
                16,
                6,
                2,
                2,
                4,
                2,
                16,
                4421,
                42719,
                33,
                4153,
                7,
                221,
                3,
                5761,
                15,
                7472,
                16,
                621,
                2467,
                541,
                1507,
                4938,
                6,
                4191
            ];
            const D = [
                509,
                0,
                227,
                0,
                150,
                4,
                294,
                9,
                1368,
                2,
                2,
                1,
                6,
                3,
                41,
                2,
                5,
                0,
                166,
                1,
                574,
                3,
                9,
                9,
                7,
                9,
                32,
                4,
                318,
                1,
                80,
                3,
                71,
                10,
                50,
                3,
                123,
                2,
                54,
                14,
                32,
                10,
                3,
                1,
                11,
                3,
                46,
                10,
                8,
                0,
                46,
                9,
                7,
                2,
                37,
                13,
                2,
                9,
                6,
                1,
                45,
                0,
                13,
                2,
                49,
                13,
                9,
                3,
                2,
                11,
                83,
                11,
                7,
                0,
                3,
                0,
                158,
                11,
                6,
                9,
                7,
                3,
                56,
                1,
                2,
                6,
                3,
                1,
                3,
                2,
                10,
                0,
                11,
                1,
                3,
                6,
                4,
                4,
                68,
                8,
                2,
                0,
                3,
                0,
                2,
                3,
                2,
                4,
                2,
                0,
                15,
                1,
                83,
                17,
                10,
                9,
                5,
                0,
                82,
                19,
                13,
                9,
                214,
                6,
                3,
                8,
                28,
                1,
                83,
                16,
                16,
                9,
                82,
                12,
                9,
                9,
                7,
                19,
                58,
                14,
                5,
                9,
                243,
                14,
                166,
                9,
                71,
                5,
                2,
                1,
                3,
                3,
                2,
                0,
                2,
                1,
                13,
                9,
                120,
                6,
                3,
                6,
                4,
                0,
                29,
                9,
                41,
                6,
                2,
                3,
                9,
                0,
                10,
                10,
                47,
                15,
                343,
                9,
                54,
                7,
                2,
                7,
                17,
                9,
                57,
                21,
                2,
                13,
                123,
                5,
                4,
                0,
                2,
                1,
                2,
                6,
                2,
                0,
                9,
                9,
                49,
                4,
                2,
                1,
                2,
                4,
                9,
                9,
                330,
                3,
                10,
                1,
                2,
                0,
                49,
                6,
                4,
                4,
                14,
                10,
                5350,
                0,
                7,
                14,
                11465,
                27,
                2343,
                9,
                87,
                9,
                39,
                4,
                60,
                6,
                26,
                9,
                535,
                9,
                470,
                0,
                2,
                54,
                8,
                3,
                82,
                0,
                12,
                1,
                19628,
                1,
                4178,
                9,
                519,
                45,
                3,
                22,
                543,
                4,
                4,
                5,
                9,
                7,
                3,
                6,
                31,
                3,
                149,
                2,
                1418,
                49,
                513,
                54,
                5,
                49,
                9,
                0,
                15,
                0,
                23,
                4,
                2,
                14,
                1361,
                6,
                2,
                16,
                3,
                6,
                2,
                1,
                2,
                4,
                101,
                0,
                161,
                6,
                10,
                9,
                357,
                0,
                62,
                13,
                499,
                13,
                245,
                1,
                2,
                9,
                726,
                6,
                110,
                6,
                6,
                9,
                4759,
                9,
                787719,
                239
            ];
            function isInAstralSet(e1, t) {
                let r = 65536;
                for(let n = 0, s = t.length; n < s; n += 2){
                    r += t[n];
                    if (r > e1) return false;
                    r += t[n + 1];
                    if (r >= e1) return true;
                }
                return false;
            }
            function isIdentifierStart(e1) {
                if (e1 < 65) return e1 === 36;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && N.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, _);
            }
            function isIdentifierChar(e1) {
                if (e1 < 48) return e1 === 36;
                if (e1 < 58) return true;
                if (e1 < 65) return false;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && k.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, _) || isInAstralSet(e1, D);
            }
            const M = {
                keyword: [
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ],
                strict: [
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ],
                strictBind: [
                    "eval",
                    "arguments"
                ]
            };
            const L = new Set(M.keyword);
            const j = new Set(M.strict);
            const F = new Set(M.strictBind);
            function isReservedWord(e1, t) {
                return t && e1 === "await" || e1 === "enum";
            }
            function isStrictReservedWord(e1, t) {
                return isReservedWord(e1, t) || j.has(e1);
            }
            function isStrictBindOnlyReservedWord(e1) {
                return F.has(e1);
            }
            function isStrictBindReservedWord(e1, t) {
                return isStrictReservedWord(e1, t) || isStrictBindOnlyReservedWord(e1);
            }
            function isKeyword(e1) {
                return L.has(e1);
            }
            function isIteratorStart(e1, t, r) {
                return e1 === 64 && t === 64 && isIdentifierStart(r);
            }
            const B = new Set([
                "break",
                "case",
                "catch",
                "continue",
                "debugger",
                "default",
                "do",
                "else",
                "finally",
                "for",
                "function",
                "if",
                "return",
                "switch",
                "throw",
                "try",
                "var",
                "const",
                "while",
                "with",
                "new",
                "this",
                "super",
                "class",
                "extends",
                "export",
                "import",
                "null",
                "true",
                "false",
                "in",
                "instanceof",
                "typeof",
                "void",
                "delete",
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield",
                "eval",
                "arguments",
                "enum",
                "await"
            ]);
            function canBeReservedWord(e1) {
                return B.has(e1);
            }
            class Scope {
                constructor(e1){
                    this.flags = 0;
                    this.names = new Map;
                    this.firstLexicalName = "";
                    this.flags = e1;
                }
            }
            class ScopeHandler {
                get inTopLevel() {
                    return (this.currentScope().flags & 1) > 0;
                }
                get inFunction() {
                    return (this.currentVarScopeFlags() & 2) > 0;
                }
                get allowSuper() {
                    return (this.currentThisScopeFlags() & 16) > 0;
                }
                get allowDirectSuper() {
                    return (this.currentThisScopeFlags() & 32) > 0;
                }
                get inClass() {
                    return (this.currentThisScopeFlags() & 64) > 0;
                }
                get inClassAndNotInNonArrowFunction() {
                    const e1 = this.currentThisScopeFlags();
                    return (e1 & 64) > 0 && (e1 & 2) === 0;
                }
                get inStaticBlock() {
                    for(let e1 = this.scopeStack.length - 1;; e1--){
                        const { flags: t } = this.scopeStack[e1];
                        if (t & 128) {
                            return true;
                        }
                        if (t & (387 | 64)) {
                            return false;
                        }
                    }
                }
                get inNonArrowFunction() {
                    return (this.currentThisScopeFlags() & 2) > 0;
                }
                get treatFunctionsAsVar() {
                    return this.treatFunctionsAsVarInScope(this.currentScope());
                }
                createScope(e1) {
                    return new Scope(e1);
                }
                enter(e1) {
                    this.scopeStack.push(this.createScope(e1));
                }
                exit() {
                    const e1 = this.scopeStack.pop();
                    return e1.flags;
                }
                treatFunctionsAsVarInScope(e1) {
                    return !!(e1.flags & (2 | 128) || !this.parser.inModule && e1.flags & 1);
                }
                declareName(e1, t, r) {
                    let n = this.currentScope();
                    if (t & 8 || t & 16) {
                        this.checkRedeclarationInScope(n, e1, t, r);
                        let s = n.names.get(e1) || 0;
                        if (t & 16) {
                            s = s | 4;
                        } else {
                            if (!n.firstLexicalName) {
                                n.firstLexicalName = e1;
                            }
                            s = s | 2;
                        }
                        n.names.set(e1, s);
                        if (t & 8) {
                            this.maybeExportDefined(n, e1);
                        }
                    } else if (t & 4) {
                        for(let s = this.scopeStack.length - 1; s >= 0; --s){
                            n = this.scopeStack[s];
                            this.checkRedeclarationInScope(n, e1, t, r);
                            n.names.set(e1, (n.names.get(e1) || 0) | 1);
                            this.maybeExportDefined(n, e1);
                            if (n.flags & 387) break;
                        }
                    }
                    if (this.parser.inModule && n.flags & 1) {
                        this.undefinedExports.delete(e1);
                    }
                }
                maybeExportDefined(e1, t) {
                    if (this.parser.inModule && e1.flags & 1) {
                        this.undefinedExports.delete(t);
                    }
                }
                checkRedeclarationInScope(e1, t, r, n) {
                    if (this.isRedeclaredInScope(e1, t, r)) {
                        this.parser.raise(p.VarRedeclaration, n, {
                            identifierName: t
                        });
                    }
                }
                isRedeclaredInScope(e1, t, r) {
                    if (!(r & 1)) return false;
                    if (r & 8) {
                        return e1.names.has(t);
                    }
                    const n = e1.names.get(t);
                    if (r & 16) {
                        return (n & 2) > 0 || !this.treatFunctionsAsVarInScope(e1) && (n & 1) > 0;
                    }
                    return (n & 2) > 0 && !(e1.flags & 8 && e1.firstLexicalName === t) || !this.treatFunctionsAsVarInScope(e1) && (n & 4) > 0;
                }
                checkLocalExport(e1) {
                    const { name: t } = e1;
                    const r = this.scopeStack[0];
                    if (!r.names.has(t)) {
                        this.undefinedExports.set(t, e1.loc.start);
                    }
                }
                currentScope() {
                    return this.scopeStack[this.scopeStack.length - 1];
                }
                currentVarScopeFlags() {
                    for(let e1 = this.scopeStack.length - 1;; e1--){
                        const { flags: t } = this.scopeStack[e1];
                        if (t & 387) {
                            return t;
                        }
                    }
                }
                currentThisScopeFlags() {
                    for(let e1 = this.scopeStack.length - 1;; e1--){
                        const { flags: t } = this.scopeStack[e1];
                        if (t & (387 | 64) && !(t & 4)) {
                            return t;
                        }
                    }
                }
                constructor(e1, t){
                    this.parser = void 0;
                    this.scopeStack = [];
                    this.inModule = void 0;
                    this.undefinedExports = new Map;
                    this.parser = e1;
                    this.inModule = t;
                }
            }
            class FlowScope extends Scope {
                constructor(...e1){
                    super(...e1);
                    this.declareFunctions = new Set;
                }
            }
            class FlowScopeHandler extends ScopeHandler {
                createScope(e1) {
                    return new FlowScope(e1);
                }
                declareName(e1, t, r) {
                    const n = this.currentScope();
                    if (t & 2048) {
                        this.checkRedeclarationInScope(n, e1, t, r);
                        this.maybeExportDefined(n, e1);
                        n.declareFunctions.add(e1);
                        return;
                    }
                    super.declareName(e1, t, r);
                }
                isRedeclaredInScope(e1, t, r) {
                    if (super.isRedeclaredInScope(e1, t, r)) return true;
                    if (r & 2048 && !e1.declareFunctions.has(t)) {
                        const r = e1.names.get(t);
                        return (r & 4) > 0 || (r & 2) > 0;
                    }
                    return false;
                }
                checkLocalExport(e1) {
                    if (!this.scopeStack[0].declareFunctions.has(e1.name)) {
                        super.checkLocalExport(e1);
                    }
                }
            }
            class BaseParser {
                sourceToOffsetPos(e1) {
                    return e1 + this.startIndex;
                }
                offsetToSourcePos(e1) {
                    return e1 - this.startIndex;
                }
                hasPlugin(e1) {
                    if (typeof e1 === "string") {
                        return this.plugins.has(e1);
                    } else {
                        const [t, r] = e1;
                        if (!this.hasPlugin(t)) {
                            return false;
                        }
                        const n = this.plugins.get(t);
                        for (const e1 of Object.keys(r)){
                            if ((n == null ? void 0 : n[e1]) !== r[e1]) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                getPluginOption(e1, t) {
                    var r;
                    return (r = this.plugins.get(e1)) == null ? void 0 : r[t];
                }
                constructor(){
                    this.sawUnambiguousESM = false;
                    this.ambiguousScriptDifferentAst = false;
                }
            }
            function setTrailingComments(e1, t) {
                if (e1.trailingComments === undefined) {
                    e1.trailingComments = t;
                } else {
                    e1.trailingComments.unshift(...t);
                }
            }
            function setLeadingComments(e1, t) {
                if (e1.leadingComments === undefined) {
                    e1.leadingComments = t;
                } else {
                    e1.leadingComments.unshift(...t);
                }
            }
            function setInnerComments(e1, t) {
                if (e1.innerComments === undefined) {
                    e1.innerComments = t;
                } else {
                    e1.innerComments.unshift(...t);
                }
            }
            function adjustInnerComments(e1, t, r) {
                let n = null;
                let s = t.length;
                while(n === null && s > 0){
                    n = t[--s];
                }
                if (n === null || n.start > r.start) {
                    setInnerComments(e1, r.comments);
                } else {
                    setTrailingComments(n, r.comments);
                }
            }
            class CommentsParser extends BaseParser {
                addComment(e1) {
                    if (this.filename) e1.loc.filename = this.filename;
                    const { commentsLen: t } = this.state;
                    if (this.comments.length !== t) {
                        this.comments.length = t;
                    }
                    this.comments.push(e1);
                    this.state.commentsLen++;
                }
                processComment(e1) {
                    const { commentStack: t } = this.state;
                    const r = t.length;
                    if (r === 0) return;
                    let n = r - 1;
                    const s = t[n];
                    if (s.start === e1.end) {
                        s.leadingNode = e1;
                        n--;
                    }
                    const { start: i } = e1;
                    for(; n >= 0; n--){
                        const r = t[n];
                        const s = r.end;
                        if (s > i) {
                            r.containingNode = e1;
                            this.finalizeComment(r);
                            t.splice(n, 1);
                        } else {
                            if (s === i) {
                                r.trailingNode = e1;
                            }
                            break;
                        }
                    }
                }
                finalizeComment(e1) {
                    const { comments: t } = e1;
                    if (e1.leadingNode !== null || e1.trailingNode !== null) {
                        if (e1.leadingNode !== null) {
                            setTrailingComments(e1.leadingNode, t);
                        }
                        if (e1.trailingNode !== null) {
                            setLeadingComments(e1.trailingNode, t);
                        }
                    } else {
                        const { containingNode: r, start: n } = e1;
                        if (this.input.charCodeAt(this.offsetToSourcePos(n) - 1) === 44) {
                            switch(r.type){
                                case "ObjectExpression":
                                case "ObjectPattern":
                                case "RecordExpression":
                                    adjustInnerComments(r, r.properties, e1);
                                    break;
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    adjustInnerComments(r, r.arguments, e1);
                                    break;
                                case "FunctionDeclaration":
                                case "FunctionExpression":
                                case "ArrowFunctionExpression":
                                case "ObjectMethod":
                                case "ClassMethod":
                                case "ClassPrivateMethod":
                                    adjustInnerComments(r, r.params, e1);
                                    break;
                                case "ArrayExpression":
                                case "ArrayPattern":
                                case "TupleExpression":
                                    adjustInnerComments(r, r.elements, e1);
                                    break;
                                case "ExportNamedDeclaration":
                                case "ImportDeclaration":
                                    adjustInnerComments(r, r.specifiers, e1);
                                    break;
                                case "TSEnumDeclaration":
                                    {
                                        adjustInnerComments(r, r.members, e1);
                                    }
                                    break;
                                case "TSEnumBody":
                                    adjustInnerComments(r, r.members, e1);
                                    break;
                                default:
                                    {
                                        setInnerComments(r, t);
                                    }
                            }
                        } else {
                            setInnerComments(r, t);
                        }
                    }
                }
                finalizeRemainingComments() {
                    const { commentStack: e1 } = this.state;
                    for(let t = e1.length - 1; t >= 0; t--){
                        this.finalizeComment(e1[t]);
                    }
                    this.state.commentStack = [];
                }
                resetPreviousNodeTrailingComments(e1) {
                    const { commentStack: t } = this.state;
                    const { length: r } = t;
                    if (r === 0) return;
                    const n = t[r - 1];
                    if (n.leadingNode === e1) {
                        n.leadingNode = null;
                    }
                }
                resetPreviousIdentifierLeadingComments(e1) {
                    const { commentStack: t } = this.state;
                    const { length: r } = t;
                    if (r === 0) return;
                    if (t[r - 1].trailingNode === e1) {
                        t[r - 1].trailingNode = null;
                    } else if (r >= 2 && t[r - 2].trailingNode === e1) {
                        t[r - 2].trailingNode = null;
                    }
                }
                takeSurroundingComments(e1, t, r) {
                    const { commentStack: n } = this.state;
                    const s = n.length;
                    if (s === 0) return;
                    let i = s - 1;
                    for(; i >= 0; i--){
                        const s = n[i];
                        const a = s.end;
                        const o = s.start;
                        if (o === r) {
                            s.leadingNode = e1;
                        } else if (a === t) {
                            s.trailingNode = e1;
                        } else if (a < t) {
                            break;
                        }
                    }
                }
            }
            const R = /\r\n|[\r\n\u2028\u2029]/;
            const U = new RegExp(R.source, "g");
            function isNewLine(e1) {
                switch(e1){
                    case 10:
                    case 13:
                    case 8232:
                    case 8233:
                        return true;
                    default:
                        return false;
                }
            }
            function hasNewLine(e1, t, r) {
                for(let n = t; n < r; n++){
                    if (isNewLine(e1.charCodeAt(n))) {
                        return true;
                    }
                }
                return false;
            }
            const K = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
            const V = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
            function isWhitespace(e1) {
                switch(e1){
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                    case 160:
                    case 5760:
                    case 8192:
                    case 8193:
                    case 8194:
                    case 8195:
                    case 8196:
                    case 8197:
                    case 8198:
                    case 8199:
                    case 8200:
                    case 8201:
                    case 8202:
                    case 8239:
                    case 8287:
                    case 12288:
                    case 65279:
                        return true;
                    default:
                        return false;
                }
            }
            class State {
                get strict() {
                    return (this.flags & 1) > 0;
                }
                set strict(e1) {
                    if (e1) this.flags |= 1;
                    else this.flags &= -2;
                }
                init(param) {
                    let { strictMode: e1, sourceType: t, startIndex: r, startLine: n, startColumn: s } = param;
                    this.strict = e1 === false ? false : e1 === true ? true : t === "module";
                    this.startIndex = r;
                    this.curLine = n;
                    this.lineStart = -s;
                    this.startLoc = this.endLoc = new Position(n, s, r);
                }
                get maybeInArrowParameters() {
                    return (this.flags & 2) > 0;
                }
                set maybeInArrowParameters(e1) {
                    if (e1) this.flags |= 2;
                    else this.flags &= -3;
                }
                get inType() {
                    return (this.flags & 4) > 0;
                }
                set inType(e1) {
                    if (e1) this.flags |= 4;
                    else this.flags &= -5;
                }
                get noAnonFunctionType() {
                    return (this.flags & 8) > 0;
                }
                set noAnonFunctionType(e1) {
                    if (e1) this.flags |= 8;
                    else this.flags &= -9;
                }
                get hasFlowComment() {
                    return (this.flags & 16) > 0;
                }
                set hasFlowComment(e1) {
                    if (e1) this.flags |= 16;
                    else this.flags &= -17;
                }
                get isAmbientContext() {
                    return (this.flags & 32) > 0;
                }
                set isAmbientContext(e1) {
                    if (e1) this.flags |= 32;
                    else this.flags &= -33;
                }
                get inAbstractClass() {
                    return (this.flags & 64) > 0;
                }
                set inAbstractClass(e1) {
                    if (e1) this.flags |= 64;
                    else this.flags &= -65;
                }
                get inDisallowConditionalTypesContext() {
                    return (this.flags & 128) > 0;
                }
                set inDisallowConditionalTypesContext(e1) {
                    if (e1) this.flags |= 128;
                    else this.flags &= -129;
                }
                get soloAwait() {
                    return (this.flags & 256) > 0;
                }
                set soloAwait(e1) {
                    if (e1) this.flags |= 256;
                    else this.flags &= -257;
                }
                get inFSharpPipelineDirectBody() {
                    return (this.flags & 512) > 0;
                }
                set inFSharpPipelineDirectBody(e1) {
                    if (e1) this.flags |= 512;
                    else this.flags &= -513;
                }
                get canStartJSXElement() {
                    return (this.flags & 1024) > 0;
                }
                set canStartJSXElement(e1) {
                    if (e1) this.flags |= 1024;
                    else this.flags &= -1025;
                }
                get containsEsc() {
                    return (this.flags & 2048) > 0;
                }
                set containsEsc(e1) {
                    if (e1) this.flags |= 2048;
                    else this.flags &= -2049;
                }
                get hasTopLevelAwait() {
                    return (this.flags & 4096) > 0;
                }
                set hasTopLevelAwait(e1) {
                    if (e1) this.flags |= 4096;
                    else this.flags &= -4097;
                }
                curPosition() {
                    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
                }
                clone() {
                    const e1 = new State;
                    e1.flags = this.flags;
                    e1.startIndex = this.startIndex;
                    e1.curLine = this.curLine;
                    e1.lineStart = this.lineStart;
                    e1.startLoc = this.startLoc;
                    e1.endLoc = this.endLoc;
                    e1.errors = this.errors.slice();
                    e1.potentialArrowAt = this.potentialArrowAt;
                    e1.noArrowAt = this.noArrowAt.slice();
                    e1.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
                    e1.topicContext = this.topicContext;
                    e1.labels = this.labels.slice();
                    e1.commentsLen = this.commentsLen;
                    e1.commentStack = this.commentStack.slice();
                    e1.pos = this.pos;
                    e1.type = this.type;
                    e1.value = this.value;
                    e1.start = this.start;
                    e1.end = this.end;
                    e1.lastTokEndLoc = this.lastTokEndLoc;
                    e1.lastTokStartLoc = this.lastTokStartLoc;
                    e1.context = this.context.slice();
                    e1.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
                    e1.strictErrors = this.strictErrors;
                    e1.tokensLength = this.tokensLength;
                    return e1;
                }
                constructor(){
                    this.flags = 1024;
                    this.startIndex = void 0;
                    this.curLine = void 0;
                    this.lineStart = void 0;
                    this.startLoc = void 0;
                    this.endLoc = void 0;
                    this.errors = [];
                    this.potentialArrowAt = -1;
                    this.noArrowAt = [];
                    this.noArrowParamsConversionAt = [];
                    this.topicContext = {
                        maxNumOfResolvableTopics: 0,
                        maxTopicIndex: null
                    };
                    this.labels = [];
                    this.commentsLen = 0;
                    this.commentStack = [];
                    this.pos = 0;
                    this.type = 140;
                    this.value = null;
                    this.start = 0;
                    this.end = 0;
                    this.lastTokEndLoc = null;
                    this.lastTokStartLoc = null;
                    this.context = [
                        d.brace
                    ];
                    this.firstInvalidTemplateEscapePos = null;
                    this.strictErrors = new Map;
                    this.tokensLength = 0;
                }
            }
            var W = function isDigit(e1) {
                return e1 >= 48 && e1 <= 57;
            };
            const $ = {
                decBinOct: new Set([
                    46,
                    66,
                    69,
                    79,
                    95,
                    98,
                    101,
                    111
                ]),
                hex: new Set([
                    46,
                    88,
                    95,
                    120
                ])
            };
            const q = {
                bin: (e1)=>e1 === 48 || e1 === 49,
                oct: (e1)=>e1 >= 48 && e1 <= 55,
                dec: (e1)=>e1 >= 48 && e1 <= 57,
                hex: (e1)=>e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102
            };
            function readStringContents(e1, t, r, n, s, i) {
                const a = r;
                const o = n;
                const l = s;
                let c = "";
                let p = null;
                let u = r;
                const { length: d } = t;
                for(;;){
                    if (r >= d) {
                        i.unterminated(a, o, l);
                        c += t.slice(u, r);
                        break;
                    }
                    const f = t.charCodeAt(r);
                    if (isStringEnd(e1, f, t, r)) {
                        c += t.slice(u, r);
                        break;
                    }
                    if (f === 92) {
                        c += t.slice(u, r);
                        const a = readEscapedChar(t, r, n, s, e1 === "template", i);
                        if (a.ch === null && !p) {
                            p = {
                                pos: r,
                                lineStart: n,
                                curLine: s
                            };
                        } else {
                            c += a.ch;
                        }
                        ({ pos: r, lineStart: n, curLine: s } = a);
                        u = r;
                    } else if (f === 8232 || f === 8233) {
                        ++r;
                        ++s;
                        n = r;
                    } else if (f === 10 || f === 13) {
                        if (e1 === "template") {
                            c += t.slice(u, r) + "\n";
                            ++r;
                            if (f === 13 && t.charCodeAt(r) === 10) {
                                ++r;
                            }
                            ++s;
                            u = n = r;
                        } else {
                            i.unterminated(a, o, l);
                        }
                    } else {
                        ++r;
                    }
                }
                return {
                    pos: r,
                    str: c,
                    firstInvalidLoc: p,
                    lineStart: n,
                    curLine: s,
                    containsInvalid: !!p
                };
            }
            function isStringEnd(e1, t, r, n) {
                if (e1 === "template") {
                    return t === 96 || t === 36 && r.charCodeAt(n + 1) === 123;
                }
                return t === (e1 === "double" ? 34 : 39);
            }
            function readEscapedChar(e1, t, r, n, s, i) {
                const a = !s;
                t++;
                const res = (e1)=>({
                        pos: t,
                        ch: e1,
                        lineStart: r,
                        curLine: n
                    });
                const o = e1.charCodeAt(t++);
                switch(o){
                    case 110:
                        return res("\n");
                    case 114:
                        return res("\r");
                    case 120:
                        {
                            let s;
                            ({ code: s, pos: t } = readHexChar(e1, t, r, n, 2, false, a, i));
                            return res(s === null ? null : String.fromCharCode(s));
                        }
                    case 117:
                        {
                            let s;
                            ({ code: s, pos: t } = readCodePoint(e1, t, r, n, a, i));
                            return res(s === null ? null : String.fromCodePoint(s));
                        }
                    case 116:
                        return res("\t");
                    case 98:
                        return res("\b");
                    case 118:
                        return res("\v");
                    case 102:
                        return res("\f");
                    case 13:
                        if (e1.charCodeAt(t) === 10) {
                            ++t;
                        }
                    case 10:
                        r = t;
                        ++n;
                    case 8232:
                    case 8233:
                        return res("");
                    case 56:
                    case 57:
                        if (s) {
                            return res(null);
                        } else {
                            i.strictNumericEscape(t - 1, r, n);
                        }
                    default:
                        if (o >= 48 && o <= 55) {
                            const a = t - 1;
                            const o = /^[0-7]+/.exec(e1.slice(a, t + 2));
                            let l = o[0];
                            let c = parseInt(l, 8);
                            if (c > 255) {
                                l = l.slice(0, -1);
                                c = parseInt(l, 8);
                            }
                            t += l.length - 1;
                            const p = e1.charCodeAt(t);
                            if (l !== "0" || p === 56 || p === 57) {
                                if (s) {
                                    return res(null);
                                } else {
                                    i.strictNumericEscape(a, r, n);
                                }
                            }
                            return res(String.fromCharCode(c));
                        }
                        return res(String.fromCharCode(o));
                }
            }
            function readHexChar(e1, t, r, n, s, i, a, o) {
                const l = t;
                let c;
                ({ n: c, pos: t } = readInt(e1, t, r, n, 16, s, i, false, o, !a));
                if (c === null) {
                    if (a) {
                        o.invalidEscapeSequence(l, r, n);
                    } else {
                        t = l - 1;
                    }
                }
                return {
                    code: c,
                    pos: t
                };
            }
            function readInt(e1, t, r, n, s, i, a, o, l, c) {
                const p = t;
                const u = s === 16 ? $.hex : $.decBinOct;
                const d = s === 16 ? q.hex : s === 10 ? q.dec : s === 8 ? q.oct : q.bin;
                let f = false;
                let h = 0;
                for(let p = 0, m = i == null ? Infinity : i; p < m; ++p){
                    const i = e1.charCodeAt(t);
                    let p;
                    if (i === 95 && o !== "bail") {
                        const s = e1.charCodeAt(t - 1);
                        const i = e1.charCodeAt(t + 1);
                        if (!o) {
                            if (c) return {
                                n: null,
                                pos: t
                            };
                            l.numericSeparatorInEscapeSequence(t, r, n);
                        } else if (Number.isNaN(i) || !d(i) || u.has(s) || u.has(i)) {
                            if (c) return {
                                n: null,
                                pos: t
                            };
                            l.unexpectedNumericSeparator(t, r, n);
                        }
                        ++t;
                        continue;
                    }
                    if (i >= 97) {
                        p = i - 97 + 10;
                    } else if (i >= 65) {
                        p = i - 65 + 10;
                    } else if (W(i)) {
                        p = i - 48;
                    } else {
                        p = Infinity;
                    }
                    if (p >= s) {
                        if (p <= 9 && c) {
                            return {
                                n: null,
                                pos: t
                            };
                        } else if (p <= 9 && l.invalidDigit(t, r, n, s)) {
                            p = 0;
                        } else if (a) {
                            p = 0;
                            f = true;
                        } else {
                            break;
                        }
                    }
                    ++t;
                    h = h * s + p;
                }
                if (t === p || i != null && t - p !== i || f) {
                    return {
                        n: null,
                        pos: t
                    };
                }
                return {
                    n: h,
                    pos: t
                };
            }
            function readCodePoint(e1, t, r, n, s, i) {
                const a = e1.charCodeAt(t);
                let o;
                if (a === 123) {
                    ++t;
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, e1.indexOf("}", t) - t, true, s, i));
                    ++t;
                    if (o !== null && o > 1114111) {
                        if (s) {
                            i.invalidCodePoint(t, r, n);
                        } else {
                            return {
                                code: null,
                                pos: t
                            };
                        }
                    }
                } else {
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, 4, false, s, i));
                }
                return {
                    code: o,
                    pos: t
                };
            }
            function buildPosition(e1, t, r) {
                return new Position(r, e1 - t, e1);
            }
            const H = new Set([
                103,
                109,
                115,
                105,
                121,
                117,
                100,
                118
            ]);
            class Token {
                constructor(e1){
                    const t = e1.startIndex || 0;
                    this.type = e1.type;
                    this.value = e1.value;
                    this.start = t + e1.start;
                    this.end = t + e1.end;
                    this.loc = new SourceLocation(e1.startLoc, e1.endLoc);
                }
            }
            class Tokenizer extends CommentsParser {
                pushToken(e1) {
                    this.tokens.length = this.state.tokensLength;
                    this.tokens.push(e1);
                    ++this.state.tokensLength;
                }
                next() {
                    this.checkKeywordEscapes();
                    if (this.optionFlags & 256) {
                        this.pushToken(new Token(this.state));
                    }
                    this.state.lastTokEndLoc = this.state.endLoc;
                    this.state.lastTokStartLoc = this.state.startLoc;
                    this.nextToken();
                }
                eat(e1) {
                    if (this.match(e1)) {
                        this.next();
                        return true;
                    } else {
                        return false;
                    }
                }
                match(e1) {
                    return this.state.type === e1;
                }
                createLookaheadState(e1) {
                    return {
                        pos: e1.pos,
                        value: null,
                        type: e1.type,
                        start: e1.start,
                        end: e1.end,
                        context: [
                            this.curContext()
                        ],
                        inType: e1.inType,
                        startLoc: e1.startLoc,
                        lastTokEndLoc: e1.lastTokEndLoc,
                        curLine: e1.curLine,
                        lineStart: e1.lineStart,
                        curPosition: e1.curPosition
                    };
                }
                lookahead() {
                    const e1 = this.state;
                    this.state = this.createLookaheadState(e1);
                    this.isLookahead = true;
                    this.nextToken();
                    this.isLookahead = false;
                    const t = this.state;
                    this.state = e1;
                    return t;
                }
                nextTokenStart() {
                    return this.nextTokenStartSince(this.state.pos);
                }
                nextTokenStartSince(e1) {
                    K.lastIndex = e1;
                    return K.test(this.input) ? K.lastIndex : e1;
                }
                lookaheadCharCode() {
                    return this.input.charCodeAt(this.nextTokenStart());
                }
                nextTokenInLineStart() {
                    return this.nextTokenInLineStartSince(this.state.pos);
                }
                nextTokenInLineStartSince(e1) {
                    V.lastIndex = e1;
                    return V.test(this.input) ? V.lastIndex : e1;
                }
                lookaheadInLineCharCode() {
                    return this.input.charCodeAt(this.nextTokenInLineStart());
                }
                codePointAtPos(e1) {
                    let t = this.input.charCodeAt(e1);
                    if ((t & 64512) === 55296 && ++e1 < this.input.length) {
                        const r = this.input.charCodeAt(e1);
                        if ((r & 64512) === 56320) {
                            t = 65536 + ((t & 1023) << 10) + (r & 1023);
                        }
                    }
                    return t;
                }
                setStrict(e1) {
                    this.state.strict = e1;
                    if (e1) {
                        this.state.strictErrors.forEach((param)=>{
                            let [e1, t] = param;
                            return this.raise(e1, t);
                        });
                        this.state.strictErrors.clear();
                    }
                }
                curContext() {
                    return this.state.context[this.state.context.length - 1];
                }
                nextToken() {
                    this.skipSpace();
                    this.state.start = this.state.pos;
                    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
                    if (this.state.pos >= this.length) {
                        this.finishToken(140);
                        return;
                    }
                    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
                }
                skipBlockComment(e1) {
                    let t;
                    if (!this.isLookahead) t = this.state.curPosition();
                    const r = this.state.pos;
                    const n = this.input.indexOf(e1, r + 2);
                    if (n === -1) {
                        throw this.raise(p.UnterminatedComment, this.state.curPosition());
                    }
                    this.state.pos = n + e1.length;
                    U.lastIndex = r + 2;
                    while(U.test(this.input) && U.lastIndex <= n){
                        ++this.state.curLine;
                        this.state.lineStart = U.lastIndex;
                    }
                    if (this.isLookahead) return;
                    const s = {
                        type: "CommentBlock",
                        value: this.input.slice(r + 2, n),
                        start: this.sourceToOffsetPos(r),
                        end: this.sourceToOffsetPos(n + e1.length),
                        loc: new SourceLocation(t, this.state.curPosition())
                    };
                    if (this.optionFlags & 256) this.pushToken(s);
                    return s;
                }
                skipLineComment(e1) {
                    const t = this.state.pos;
                    let r;
                    if (!this.isLookahead) r = this.state.curPosition();
                    let n = this.input.charCodeAt(this.state.pos += e1);
                    if (this.state.pos < this.length) {
                        while(!isNewLine(n) && ++this.state.pos < this.length){
                            n = this.input.charCodeAt(this.state.pos);
                        }
                    }
                    if (this.isLookahead) return;
                    const s = this.state.pos;
                    const i = this.input.slice(t + e1, s);
                    const a = {
                        type: "CommentLine",
                        value: i,
                        start: this.sourceToOffsetPos(t),
                        end: this.sourceToOffsetPos(s),
                        loc: new SourceLocation(r, this.state.curPosition())
                    };
                    if (this.optionFlags & 256) this.pushToken(a);
                    return a;
                }
                skipSpace() {
                    const e1 = this.state.pos;
                    const t = this.optionFlags & 4096 ? [] : null;
                    e1: while(this.state.pos < this.length){
                        const r = this.input.charCodeAt(this.state.pos);
                        switch(r){
                            case 32:
                            case 160:
                            case 9:
                                ++this.state.pos;
                                break;
                            case 13:
                                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                                    ++this.state.pos;
                                }
                            case 10:
                            case 8232:
                            case 8233:
                                ++this.state.pos;
                                ++this.state.curLine;
                                this.state.lineStart = this.state.pos;
                                break;
                            case 47:
                                switch(this.input.charCodeAt(this.state.pos + 1)){
                                    case 42:
                                        {
                                            const e1 = this.skipBlockComment("*/");
                                            if (e1 !== undefined) {
                                                this.addComment(e1);
                                                t == null || t.push(e1);
                                            }
                                            break;
                                        }
                                    case 47:
                                        {
                                            const e1 = this.skipLineComment(2);
                                            if (e1 !== undefined) {
                                                this.addComment(e1);
                                                t == null || t.push(e1);
                                            }
                                            break;
                                        }
                                    default:
                                        break e1;
                                }
                                break;
                            default:
                                if (isWhitespace(r)) {
                                    ++this.state.pos;
                                } else if (r === 45 && !this.inModule && this.optionFlags & 8192) {
                                    const r = this.state.pos;
                                    if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (e1 === 0 || this.state.lineStart > e1)) {
                                        const e1 = this.skipLineComment(3);
                                        if (e1 !== undefined) {
                                            this.addComment(e1);
                                            t == null || t.push(e1);
                                        }
                                    } else {
                                        break e1;
                                    }
                                } else if (r === 60 && !this.inModule && this.optionFlags & 8192) {
                                    const e1 = this.state.pos;
                                    if (this.input.charCodeAt(e1 + 1) === 33 && this.input.charCodeAt(e1 + 2) === 45 && this.input.charCodeAt(e1 + 3) === 45) {
                                        const e1 = this.skipLineComment(4);
                                        if (e1 !== undefined) {
                                            this.addComment(e1);
                                            t == null || t.push(e1);
                                        }
                                    } else {
                                        break e1;
                                    }
                                } else {
                                    break e1;
                                }
                        }
                    }
                    if ((t == null ? void 0 : t.length) > 0) {
                        const r = this.state.pos;
                        const n = {
                            start: this.sourceToOffsetPos(e1),
                            end: this.sourceToOffsetPos(r),
                            comments: t,
                            leadingNode: null,
                            trailingNode: null,
                            containingNode: null
                        };
                        this.state.commentStack.push(n);
                    }
                }
                finishToken(e1, t) {
                    this.state.end = this.state.pos;
                    this.state.endLoc = this.state.curPosition();
                    const r = this.state.type;
                    this.state.type = e1;
                    this.state.value = t;
                    if (!this.isLookahead) {
                        this.updateContext(r);
                    }
                }
                replaceToken(e1) {
                    this.state.type = e1;
                    this.updateContext();
                }
                readToken_numberSign() {
                    if (this.state.pos === 0 && this.readToken_interpreter()) {
                        return;
                    }
                    const e1 = this.state.pos + 1;
                    const t = this.codePointAtPos(e1);
                    if (t >= 48 && t <= 57) {
                        throw this.raise(p.UnexpectedDigitAfterHash, this.state.curPosition());
                    }
                    if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
                        this.expectPlugin("recordAndTuple");
                        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
                            throw this.raise(t === 123 ? p.RecordExpressionHashIncorrectStartSyntaxType : p.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
                        }
                        this.state.pos += 2;
                        if (t === 123) {
                            this.finishToken(7);
                        } else {
                            this.finishToken(1);
                        }
                    } else if (isIdentifierStart(t)) {
                        ++this.state.pos;
                        this.finishToken(139, this.readWord1(t));
                    } else if (t === 92) {
                        ++this.state.pos;
                        this.finishToken(139, this.readWord1());
                    } else {
                        this.finishOp(27, 1);
                    }
                }
                readToken_dot() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 >= 48 && e1 <= 57) {
                        this.readNumber(true);
                        return;
                    }
                    if (e1 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
                        this.state.pos += 3;
                        this.finishToken(21);
                    } else {
                        ++this.state.pos;
                        this.finishToken(16);
                    }
                }
                readToken_slash() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 61) {
                        this.finishOp(31, 2);
                    } else {
                        this.finishOp(56, 1);
                    }
                }
                readToken_interpreter() {
                    if (this.state.pos !== 0 || this.length < 2) return false;
                    let e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 !== 33) return false;
                    const t = this.state.pos;
                    this.state.pos += 1;
                    while(!isNewLine(e1) && ++this.state.pos < this.length){
                        e1 = this.input.charCodeAt(this.state.pos);
                    }
                    const r = this.input.slice(t + 2, this.state.pos);
                    this.finishToken(28, r);
                    return true;
                }
                readToken_mult_modulo(e1) {
                    let t = e1 === 42 ? 55 : 54;
                    let r = 1;
                    let n = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 42 && n === 42) {
                        r++;
                        n = this.input.charCodeAt(this.state.pos + 2);
                        t = 57;
                    }
                    if (n === 61 && !this.state.inType) {
                        r++;
                        t = e1 === 37 ? 33 : 30;
                    }
                    this.finishOp(t, r);
                }
                readToken_pipe_amp(e1) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === e1) {
                        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                            this.finishOp(30, 3);
                        } else {
                            this.finishOp(e1 === 124 ? 41 : 42, 2);
                        }
                        return;
                    }
                    if (e1 === 124) {
                        if (t === 62) {
                            this.finishOp(39, 2);
                            return;
                        }
                        if (this.hasPlugin("recordAndTuple") && t === 125) {
                            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                throw this.raise(p.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                            }
                            this.state.pos += 2;
                            this.finishToken(9);
                            return;
                        }
                        if (this.hasPlugin("recordAndTuple") && t === 93) {
                            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                throw this.raise(p.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                            }
                            this.state.pos += 2;
                            this.finishToken(4);
                            return;
                        }
                    }
                    if (t === 61) {
                        this.finishOp(30, 2);
                        return;
                    }
                    this.finishOp(e1 === 124 ? 43 : 45, 1);
                }
                readToken_caret() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 61 && !this.state.inType) {
                        this.finishOp(32, 2);
                    } else if (e1 === 94 && this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "hack",
                            topicToken: "^^"
                        }
                    ])) {
                        this.finishOp(37, 2);
                        const e1 = this.input.codePointAt(this.state.pos);
                        if (e1 === 94) {
                            this.unexpected();
                        }
                    } else {
                        this.finishOp(44, 1);
                    }
                }
                readToken_atSign() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 64 && this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "hack",
                            topicToken: "@@"
                        }
                    ])) {
                        this.finishOp(38, 2);
                    } else {
                        this.finishOp(26, 1);
                    }
                }
                readToken_plus_min(e1) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === e1) {
                        this.finishOp(34, 2);
                        return;
                    }
                    if (t === 61) {
                        this.finishOp(30, 2);
                    } else {
                        this.finishOp(53, 1);
                    }
                }
                readToken_lt() {
                    const { pos: e1 } = this.state;
                    const t = this.input.charCodeAt(e1 + 1);
                    if (t === 60) {
                        if (this.input.charCodeAt(e1 + 2) === 61) {
                            this.finishOp(30, 3);
                            return;
                        }
                        this.finishOp(51, 2);
                        return;
                    }
                    if (t === 61) {
                        this.finishOp(49, 2);
                        return;
                    }
                    this.finishOp(47, 1);
                }
                readToken_gt() {
                    const { pos: e1 } = this.state;
                    const t = this.input.charCodeAt(e1 + 1);
                    if (t === 62) {
                        const t = this.input.charCodeAt(e1 + 2) === 62 ? 3 : 2;
                        if (this.input.charCodeAt(e1 + t) === 61) {
                            this.finishOp(30, t + 1);
                            return;
                        }
                        this.finishOp(52, t);
                        return;
                    }
                    if (t === 61) {
                        this.finishOp(49, 2);
                        return;
                    }
                    this.finishOp(48, 1);
                }
                readToken_eq_excl(e1) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === 61) {
                        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                        return;
                    }
                    if (e1 === 61 && t === 62) {
                        this.state.pos += 2;
                        this.finishToken(19);
                        return;
                    }
                    this.finishOp(e1 === 61 ? 29 : 35, 1);
                }
                readToken_question() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    const t = this.input.charCodeAt(this.state.pos + 2);
                    if (e1 === 63) {
                        if (t === 61) {
                            this.finishOp(30, 3);
                        } else {
                            this.finishOp(40, 2);
                        }
                    } else if (e1 === 46 && !(t >= 48 && t <= 57)) {
                        this.state.pos += 2;
                        this.finishToken(18);
                    } else {
                        ++this.state.pos;
                        this.finishToken(17);
                    }
                }
                getTokenFromCode(e1) {
                    switch(e1){
                        case 46:
                            this.readToken_dot();
                            return;
                        case 40:
                            ++this.state.pos;
                            this.finishToken(10);
                            return;
                        case 41:
                            ++this.state.pos;
                            this.finishToken(11);
                            return;
                        case 59:
                            ++this.state.pos;
                            this.finishToken(13);
                            return;
                        case 44:
                            ++this.state.pos;
                            this.finishToken(12);
                            return;
                        case 91:
                            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                    throw this.raise(p.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                                }
                                this.state.pos += 2;
                                this.finishToken(2);
                            } else {
                                ++this.state.pos;
                                this.finishToken(0);
                            }
                            return;
                        case 93:
                            ++this.state.pos;
                            this.finishToken(3);
                            return;
                        case 123:
                            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                    throw this.raise(p.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                                }
                                this.state.pos += 2;
                                this.finishToken(6);
                            } else {
                                ++this.state.pos;
                                this.finishToken(5);
                            }
                            return;
                        case 125:
                            ++this.state.pos;
                            this.finishToken(8);
                            return;
                        case 58:
                            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                                this.finishOp(15, 2);
                            } else {
                                ++this.state.pos;
                                this.finishToken(14);
                            }
                            return;
                        case 63:
                            this.readToken_question();
                            return;
                        case 96:
                            this.readTemplateToken();
                            return;
                        case 48:
                            {
                                const e1 = this.input.charCodeAt(this.state.pos + 1);
                                if (e1 === 120 || e1 === 88) {
                                    this.readRadixNumber(16);
                                    return;
                                }
                                if (e1 === 111 || e1 === 79) {
                                    this.readRadixNumber(8);
                                    return;
                                }
                                if (e1 === 98 || e1 === 66) {
                                    this.readRadixNumber(2);
                                    return;
                                }
                            }
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                        case 56:
                        case 57:
                            this.readNumber(false);
                            return;
                        case 34:
                        case 39:
                            this.readString(e1);
                            return;
                        case 47:
                            this.readToken_slash();
                            return;
                        case 37:
                        case 42:
                            this.readToken_mult_modulo(e1);
                            return;
                        case 124:
                        case 38:
                            this.readToken_pipe_amp(e1);
                            return;
                        case 94:
                            this.readToken_caret();
                            return;
                        case 43:
                        case 45:
                            this.readToken_plus_min(e1);
                            return;
                        case 60:
                            this.readToken_lt();
                            return;
                        case 62:
                            this.readToken_gt();
                            return;
                        case 61:
                        case 33:
                            this.readToken_eq_excl(e1);
                            return;
                        case 126:
                            this.finishOp(36, 1);
                            return;
                        case 64:
                            this.readToken_atSign();
                            return;
                        case 35:
                            this.readToken_numberSign();
                            return;
                        case 92:
                            this.readWord();
                            return;
                        default:
                            if (isIdentifierStart(e1)) {
                                this.readWord(e1);
                                return;
                            }
                    }
                    throw this.raise(p.InvalidOrUnexpectedToken, this.state.curPosition(), {
                        unexpected: String.fromCodePoint(e1)
                    });
                }
                finishOp(e1, t) {
                    const r = this.input.slice(this.state.pos, this.state.pos + t);
                    this.state.pos += t;
                    this.finishToken(e1, r);
                }
                readRegexp() {
                    const e1 = this.state.startLoc;
                    const t = this.state.start + 1;
                    let r, n;
                    let { pos: s } = this.state;
                    for(;; ++s){
                        if (s >= this.length) {
                            throw this.raise(p.UnterminatedRegExp, createPositionWithColumnOffset(e1, 1));
                        }
                        const t = this.input.charCodeAt(s);
                        if (isNewLine(t)) {
                            throw this.raise(p.UnterminatedRegExp, createPositionWithColumnOffset(e1, 1));
                        }
                        if (r) {
                            r = false;
                        } else {
                            if (t === 91) {
                                n = true;
                            } else if (t === 93 && n) {
                                n = false;
                            } else if (t === 47 && !n) {
                                break;
                            }
                            r = t === 92;
                        }
                    }
                    const i = this.input.slice(t, s);
                    ++s;
                    let a = "";
                    const nextPos = ()=>createPositionWithColumnOffset(e1, s + 2 - t);
                    while(s < this.length){
                        const e1 = this.codePointAtPos(s);
                        const t = String.fromCharCode(e1);
                        if (H.has(e1)) {
                            if (e1 === 118) {
                                if (a.includes("u")) {
                                    this.raise(p.IncompatibleRegExpUVFlags, nextPos());
                                }
                            } else if (e1 === 117) {
                                if (a.includes("v")) {
                                    this.raise(p.IncompatibleRegExpUVFlags, nextPos());
                                }
                            }
                            if (a.includes(t)) {
                                this.raise(p.DuplicateRegExpFlags, nextPos());
                            }
                        } else if (isIdentifierChar(e1) || e1 === 92) {
                            this.raise(p.MalformedRegExpFlags, nextPos());
                        } else {
                            break;
                        }
                        ++s;
                        a += t;
                    }
                    this.state.pos = s;
                    this.finishToken(138, {
                        pattern: i,
                        flags: a
                    });
                }
                readInt(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                    const { n: s, pos: i } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e1, t, r, n, this.errorHandlers_readInt, false);
                    this.state.pos = i;
                    return s;
                }
                readRadixNumber(e1) {
                    const t = this.state.pos;
                    const r = this.state.curPosition();
                    let n = false;
                    this.state.pos += 2;
                    const s = this.readInt(e1);
                    if (s == null) {
                        this.raise(p.InvalidDigit, createPositionWithColumnOffset(r, 2), {
                            radix: e1
                        });
                    }
                    const i = this.input.charCodeAt(this.state.pos);
                    if (i === 110) {
                        ++this.state.pos;
                        n = true;
                    } else if (i === 109) {
                        throw this.raise(p.InvalidDecimal, r);
                    }
                    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                        throw this.raise(p.NumberIdentifier, this.state.curPosition());
                    }
                    if (n) {
                        const e1 = this.input.slice(t, this.state.pos).replace(/[_n]/g, "");
                        this.finishToken(136, e1);
                        return;
                    }
                    this.finishToken(135, s);
                }
                readNumber(e1) {
                    const t = this.state.pos;
                    const r = this.state.curPosition();
                    let n = false;
                    let s = false;
                    let i = false;
                    let a = false;
                    if (!e1 && this.readInt(10) === null) {
                        this.raise(p.InvalidNumber, this.state.curPosition());
                    }
                    const o = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
                    if (o) {
                        const e1 = this.input.slice(t, this.state.pos);
                        this.recordStrictModeErrors(p.StrictOctalLiteral, r);
                        if (!this.state.strict) {
                            const t = e1.indexOf("_");
                            if (t > 0) {
                                this.raise(p.ZeroDigitNumericSeparator, createPositionWithColumnOffset(r, t));
                            }
                        }
                        a = o && !/[89]/.test(e1);
                    }
                    let l = this.input.charCodeAt(this.state.pos);
                    if (l === 46 && !a) {
                        ++this.state.pos;
                        this.readInt(10);
                        n = true;
                        l = this.input.charCodeAt(this.state.pos);
                    }
                    if ((l === 69 || l === 101) && !a) {
                        l = this.input.charCodeAt(++this.state.pos);
                        if (l === 43 || l === 45) {
                            ++this.state.pos;
                        }
                        if (this.readInt(10) === null) {
                            this.raise(p.InvalidOrMissingExponent, r);
                        }
                        n = true;
                        i = true;
                        l = this.input.charCodeAt(this.state.pos);
                    }
                    if (l === 110) {
                        if (n || o) {
                            this.raise(p.InvalidBigIntLiteral, r);
                        }
                        ++this.state.pos;
                        s = true;
                    }
                    if (l === 109) {
                        this.expectPlugin("decimal", this.state.curPosition());
                        if (i || o) {
                            this.raise(p.InvalidDecimal, r);
                        }
                        ++this.state.pos;
                        var c = true;
                    }
                    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                        throw this.raise(p.NumberIdentifier, this.state.curPosition());
                    }
                    const u = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
                    if (s) {
                        this.finishToken(136, u);
                        return;
                    }
                    if (c) {
                        this.finishToken(137, u);
                        return;
                    }
                    const d = a ? parseInt(u, 8) : parseFloat(u);
                    this.finishToken(135, d);
                }
                readCodePoint(e1) {
                    const { code: t, pos: r } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e1, this.errorHandlers_readCodePoint);
                    this.state.pos = r;
                    return t;
                }
                readString(e1) {
                    const { str: t, pos: r, curLine: n, lineStart: s } = readStringContents(e1 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
                    this.state.pos = r + 1;
                    this.state.lineStart = s;
                    this.state.curLine = n;
                    this.finishToken(134, t);
                }
                readTemplateContinuation() {
                    if (!this.match(8)) {
                        this.unexpected(null, 8);
                    }
                    this.state.pos--;
                    this.readTemplateToken();
                }
                readTemplateToken() {
                    const e1 = this.input[this.state.pos];
                    const { str: t, firstInvalidLoc: r, pos: n, curLine: s, lineStart: i } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
                    this.state.pos = n + 1;
                    this.state.lineStart = i;
                    this.state.curLine = s;
                    if (r) {
                        this.state.firstInvalidTemplateEscapePos = new Position(r.curLine, r.pos - r.lineStart, this.sourceToOffsetPos(r.pos));
                    }
                    if (this.input.codePointAt(n) === 96) {
                        this.finishToken(24, r ? null : e1 + t + "`");
                    } else {
                        this.state.pos++;
                        this.finishToken(25, r ? null : e1 + t + "${");
                    }
                }
                recordStrictModeErrors(e1, t) {
                    const r = t.index;
                    if (this.state.strict && !this.state.strictErrors.has(r)) {
                        this.raise(e1, t);
                    } else {
                        this.state.strictErrors.set(r, [
                            e1,
                            t
                        ]);
                    }
                }
                readWord1(e1) {
                    this.state.containsEsc = false;
                    let t = "";
                    const r = this.state.pos;
                    let n = this.state.pos;
                    if (e1 !== undefined) {
                        this.state.pos += e1 <= 65535 ? 1 : 2;
                    }
                    while(this.state.pos < this.length){
                        const e1 = this.codePointAtPos(this.state.pos);
                        if (isIdentifierChar(e1)) {
                            this.state.pos += e1 <= 65535 ? 1 : 2;
                        } else if (e1 === 92) {
                            this.state.containsEsc = true;
                            t += this.input.slice(n, this.state.pos);
                            const e1 = this.state.curPosition();
                            const s = this.state.pos === r ? isIdentifierStart : isIdentifierChar;
                            if (this.input.charCodeAt(++this.state.pos) !== 117) {
                                this.raise(p.MissingUnicodeEscape, this.state.curPosition());
                                n = this.state.pos - 1;
                                continue;
                            }
                            ++this.state.pos;
                            const i = this.readCodePoint(true);
                            if (i !== null) {
                                if (!s(i)) {
                                    this.raise(p.EscapedCharNotAnIdentifier, e1);
                                }
                                t += String.fromCodePoint(i);
                            }
                            n = this.state.pos;
                        } else {
                            break;
                        }
                    }
                    return t + this.input.slice(n, this.state.pos);
                }
                readWord(e1) {
                    const t = this.readWord1(e1);
                    const r = T.get(t);
                    if (r !== undefined) {
                        this.finishToken(r, tokenLabelName(r));
                    } else {
                        this.finishToken(132, t);
                    }
                }
                checkKeywordEscapes() {
                    const { type: e1 } = this.state;
                    if (tokenIsKeyword(e1) && this.state.containsEsc) {
                        this.raise(p.InvalidEscapedReservedWord, this.state.startLoc, {
                            reservedWord: tokenLabelName(e1)
                        });
                    }
                }
                raise(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    const n = t instanceof Position ? t : t.loc.start;
                    const s = e1(n, r);
                    if (!(this.optionFlags & 2048)) throw s;
                    if (!this.isLookahead) this.state.errors.push(s);
                    return s;
                }
                raiseOverwrite(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    const n = t instanceof Position ? t : t.loc.start;
                    const s = n.index;
                    const i = this.state.errors;
                    for(let t = i.length - 1; t >= 0; t--){
                        const a = i[t];
                        if (a.loc.index === s) {
                            return i[t] = e1(n, r);
                        }
                        if (a.loc.index < s) break;
                    }
                    return this.raise(e1, t, r);
                }
                updateContext(e1) {}
                unexpected(e1, t) {
                    throw this.raise(p.UnexpectedToken, e1 != null ? e1 : this.state.startLoc, {
                        expected: t ? tokenLabelName(t) : null
                    });
                }
                expectPlugin(e1, t) {
                    if (this.hasPlugin(e1)) {
                        return true;
                    }
                    throw this.raise(p.MissingPlugin, t != null ? t : this.state.startLoc, {
                        missingPlugin: [
                            e1
                        ]
                    });
                }
                expectOnePlugin(e1) {
                    if (!e1.some((e1)=>this.hasPlugin(e1))) {
                        throw this.raise(p.MissingOneOfPlugins, this.state.startLoc, {
                            missingPlugin: e1
                        });
                    }
                }
                errorBuilder(e1) {
                    return (t, r, n)=>{
                        this.raise(e1, buildPosition(t, r, n));
                    };
                }
                constructor(e1, t){
                    super();
                    this.isLookahead = void 0;
                    this.tokens = [];
                    this.errorHandlers_readInt = {
                        invalidDigit: (e1, t, r, n)=>{
                            if (!(this.optionFlags & 2048)) return false;
                            this.raise(p.InvalidDigit, buildPosition(e1, t, r), {
                                radix: n
                            });
                            return true;
                        },
                        numericSeparatorInEscapeSequence: this.errorBuilder(p.NumericSeparatorInEscapeSequence),
                        unexpectedNumericSeparator: this.errorBuilder(p.UnexpectedNumericSeparator)
                    };
                    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
                        invalidEscapeSequence: this.errorBuilder(p.InvalidEscapeSequence),
                        invalidCodePoint: this.errorBuilder(p.InvalidCodePoint)
                    });
                    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
                        strictNumericEscape: (e1, t, r)=>{
                            this.recordStrictModeErrors(p.StrictNumericEscape, buildPosition(e1, t, r));
                        },
                        unterminated: (e1, t, r)=>{
                            throw this.raise(p.UnterminatedString, buildPosition(e1 - 1, t, r));
                        }
                    });
                    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
                        strictNumericEscape: this.errorBuilder(p.StrictNumericEscape),
                        unterminated: (e1, t, r)=>{
                            throw this.raise(p.UnterminatedTemplate, buildPosition(e1, t, r));
                        }
                    });
                    this.state = new State;
                    this.state.init(e1);
                    this.input = t;
                    this.length = t.length;
                    this.comments = [];
                    this.isLookahead = false;
                }
            }
            class ClassScope {
                constructor(){
                    this.privateNames = new Set;
                    this.loneAccessors = new Map;
                    this.undefinedPrivateNames = new Map;
                }
            }
            class ClassScopeHandler {
                current() {
                    return this.stack[this.stack.length - 1];
                }
                enter() {
                    this.stack.push(new ClassScope);
                }
                exit() {
                    const e1 = this.stack.pop();
                    const t = this.current();
                    for (const [r, n] of Array.from(e1.undefinedPrivateNames)){
                        if (t) {
                            if (!t.undefinedPrivateNames.has(r)) {
                                t.undefinedPrivateNames.set(r, n);
                            }
                        } else {
                            this.parser.raise(p.InvalidPrivateFieldResolution, n, {
                                identifierName: r
                            });
                        }
                    }
                }
                declarePrivateName(e1, t, r) {
                    const { privateNames: n, loneAccessors: s, undefinedPrivateNames: i } = this.current();
                    let a = n.has(e1);
                    if (t & 3) {
                        const r = a && s.get(e1);
                        if (r) {
                            const n = r & 4;
                            const i = t & 4;
                            const o = r & 3;
                            const l = t & 3;
                            a = o === l || n !== i;
                            if (!a) s.delete(e1);
                        } else if (!a) {
                            s.set(e1, t);
                        }
                    }
                    if (a) {
                        this.parser.raise(p.PrivateNameRedeclaration, r, {
                            identifierName: e1
                        });
                    }
                    n.add(e1);
                    i.delete(e1);
                }
                usePrivateName(e1, t) {
                    let r;
                    for (r of this.stack){
                        if (r.privateNames.has(e1)) return;
                    }
                    if (r) {
                        r.undefinedPrivateNames.set(e1, t);
                    } else {
                        this.parser.raise(p.InvalidPrivateFieldResolution, t, {
                            identifierName: e1
                        });
                    }
                }
                constructor(e1){
                    this.parser = void 0;
                    this.stack = [];
                    this.undefinedPrivateNames = new Map;
                    this.parser = e1;
                }
            }
            class ExpressionScope {
                canBeArrowParameterDeclaration() {
                    return this.type === 2 || this.type === 1;
                }
                isCertainlyParameterDeclaration() {
                    return this.type === 3;
                }
                constructor(e1 = 0){
                    this.type = e1;
                }
            }
            class ArrowHeadParsingScope extends ExpressionScope {
                recordDeclarationError(e1, t) {
                    const r = t.index;
                    this.declarationErrors.set(r, [
                        e1,
                        t
                    ]);
                }
                clearDeclarationError(e1) {
                    this.declarationErrors.delete(e1);
                }
                iterateErrors(e1) {
                    this.declarationErrors.forEach(e1);
                }
                constructor(e1){
                    super(e1);
                    this.declarationErrors = new Map;
                }
            }
            class ExpressionScopeHandler {
                enter(e1) {
                    this.stack.push(e1);
                }
                exit() {
                    this.stack.pop();
                }
                recordParameterInitializerError(e1, t) {
                    const r = t.loc.start;
                    const { stack: n } = this;
                    let s = n.length - 1;
                    let i = n[s];
                    while(!i.isCertainlyParameterDeclaration()){
                        if (i.canBeArrowParameterDeclaration()) {
                            i.recordDeclarationError(e1, r);
                        } else {
                            return;
                        }
                        i = n[--s];
                    }
                    this.parser.raise(e1, r);
                }
                recordArrowParameterBindingError(e1, t) {
                    const { stack: r } = this;
                    const n = r[r.length - 1];
                    const s = t.loc.start;
                    if (n.isCertainlyParameterDeclaration()) {
                        this.parser.raise(e1, s);
                    } else if (n.canBeArrowParameterDeclaration()) {
                        n.recordDeclarationError(e1, s);
                    } else {
                        return;
                    }
                }
                recordAsyncArrowParametersError(e1) {
                    const { stack: t } = this;
                    let r = t.length - 1;
                    let n = t[r];
                    while(n.canBeArrowParameterDeclaration()){
                        if (n.type === 2) {
                            n.recordDeclarationError(p.AwaitBindingIdentifier, e1);
                        }
                        n = t[--r];
                    }
                }
                validateAsPattern() {
                    const { stack: e1 } = this;
                    const t = e1[e1.length - 1];
                    if (!t.canBeArrowParameterDeclaration()) return;
                    t.iterateErrors((param)=>{
                        let [t, r] = param;
                        this.parser.raise(t, r);
                        let n = e1.length - 2;
                        let s = e1[n];
                        while(s.canBeArrowParameterDeclaration()){
                            s.clearDeclarationError(r.index);
                            s = e1[--n];
                        }
                    });
                }
                constructor(e1){
                    this.parser = void 0;
                    this.stack = [
                        new ExpressionScope
                    ];
                    this.parser = e1;
                }
            }
            function newParameterDeclarationScope() {
                return new ExpressionScope(3);
            }
            function newArrowHeadScope() {
                return new ArrowHeadParsingScope(1);
            }
            function newAsyncArrowScope() {
                return new ArrowHeadParsingScope(2);
            }
            function newExpressionScope() {
                return new ExpressionScope;
            }
            class ProductionParameterHandler {
                enter(e1) {
                    this.stacks.push(e1);
                }
                exit() {
                    this.stacks.pop();
                }
                currentFlags() {
                    return this.stacks[this.stacks.length - 1];
                }
                get hasAwait() {
                    return (this.currentFlags() & 2) > 0;
                }
                get hasYield() {
                    return (this.currentFlags() & 1) > 0;
                }
                get hasReturn() {
                    return (this.currentFlags() & 4) > 0;
                }
                get hasIn() {
                    return (this.currentFlags() & 8) > 0;
                }
                constructor(){
                    this.stacks = [];
                }
            }
            function functionFlags(e1, t) {
                return (e1 ? 2 : 0) | (t ? 1 : 0);
            }
            class UtilParser extends Tokenizer {
                addExtra(e1, t, r) {
                    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                    if (!e1) return;
                    let { extra: s } = e1;
                    if (s == null) {
                        s = {};
                        e1.extra = s;
                    }
                    if (n) {
                        s[t] = r;
                    } else {
                        Object.defineProperty(s, t, {
                            enumerable: n,
                            value: r
                        });
                    }
                }
                isContextual(e1) {
                    return this.state.type === e1 && !this.state.containsEsc;
                }
                isUnparsedContextual(e1, t) {
                    const r = e1 + t.length;
                    if (this.input.slice(e1, r) === t) {
                        const e1 = this.input.charCodeAt(r);
                        return !(isIdentifierChar(e1) || (e1 & 64512) === 55296);
                    }
                    return false;
                }
                isLookaheadContextual(e1) {
                    const t = this.nextTokenStart();
                    return this.isUnparsedContextual(t, e1);
                }
                eatContextual(e1) {
                    if (this.isContextual(e1)) {
                        this.next();
                        return true;
                    }
                    return false;
                }
                expectContextual(e1, t) {
                    if (!this.eatContextual(e1)) {
                        if (t != null) {
                            throw this.raise(t, this.state.startLoc);
                        }
                        this.unexpected(null, e1);
                    }
                }
                canInsertSemicolon() {
                    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
                }
                hasPrecedingLineBreak() {
                    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
                }
                hasFollowingLineBreak() {
                    return hasNewLine(this.input, this.state.end, this.nextTokenStart());
                }
                isLineTerminator() {
                    return this.eat(13) || this.canInsertSemicolon();
                }
                semicolon() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                    if (e1 ? this.isLineTerminator() : this.eat(13)) return;
                    this.raise(p.MissingSemicolon, this.state.lastTokEndLoc);
                }
                expect(e1, t) {
                    if (!this.eat(e1)) {
                        this.unexpected(t, e1);
                    }
                }
                tryParse(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone();
                    const r = {
                        node: null
                    };
                    try {
                        const n = e1(function() {
                            let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                            r.node = e1;
                            throw r;
                        });
                        if (this.state.errors.length > t.errors.length) {
                            const e1 = this.state;
                            this.state = t;
                            this.state.tokensLength = e1.tokensLength;
                            return {
                                node: n,
                                error: e1.errors[t.errors.length],
                                thrown: false,
                                aborted: false,
                                failState: e1
                            };
                        }
                        return {
                            node: n,
                            error: null,
                            thrown: false,
                            aborted: false,
                            failState: null
                        };
                    } catch (e1) {
                        const n = this.state;
                        this.state = t;
                        if (e1 instanceof SyntaxError) {
                            return {
                                node: null,
                                error: e1,
                                thrown: true,
                                aborted: false,
                                failState: n
                            };
                        }
                        if (e1 === r) {
                            return {
                                node: r.node,
                                error: null,
                                thrown: false,
                                aborted: true,
                                failState: n
                            };
                        }
                        throw e1;
                    }
                }
                checkExpressionErrors(e1, t) {
                    if (!e1) return false;
                    const { shorthandAssignLoc: r, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: i } = e1;
                    const a = !!r || !!n || !!i || !!s;
                    if (!t) {
                        return a;
                    }
                    if (r != null) {
                        this.raise(p.InvalidCoverInitializedName, r);
                    }
                    if (n != null) {
                        this.raise(p.DuplicateProto, n);
                    }
                    if (s != null) {
                        this.raise(p.UnexpectedPrivateField, s);
                    }
                    if (i != null) {
                        this.unexpected(i);
                    }
                }
                isLiteralPropertyName() {
                    return tokenIsLiteralPropertyName(this.state.type);
                }
                isPrivateName(e1) {
                    return e1.type === "PrivateName";
                }
                getPrivateNameSV(e1) {
                    return e1.id.name;
                }
                hasPropertyAsPrivateName(e1) {
                    return (e1.type === "MemberExpression" || e1.type === "OptionalMemberExpression") && this.isPrivateName(e1.property);
                }
                isObjectProperty(e1) {
                    return e1.type === "ObjectProperty";
                }
                isObjectMethod(e1) {
                    return e1.type === "ObjectMethod";
                }
                initializeScopes() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module";
                    const t = this.state.labels;
                    this.state.labels = [];
                    const r = this.exportedIdentifiers;
                    this.exportedIdentifiers = new Set;
                    const n = this.inModule;
                    this.inModule = e1;
                    const s = this.scope;
                    const i = this.getScopeHandler();
                    this.scope = new i(this, e1);
                    const a = this.prodParam;
                    this.prodParam = new ProductionParameterHandler;
                    const o = this.classScope;
                    this.classScope = new ClassScopeHandler(this);
                    const l = this.expressionScope;
                    this.expressionScope = new ExpressionScopeHandler(this);
                    return ()=>{
                        this.state.labels = t;
                        this.exportedIdentifiers = r;
                        this.inModule = n;
                        this.scope = s;
                        this.prodParam = a;
                        this.classScope = o;
                        this.expressionScope = l;
                    };
                }
                enterInitialScopes() {
                    let e1 = 0;
                    if (this.inModule) {
                        e1 |= 2;
                    }
                    if (this.optionFlags & 32) {
                        e1 |= 1;
                    }
                    this.scope.enter(1);
                    this.prodParam.enter(e1);
                }
                checkDestructuringPrivate(e1) {
                    const { privateKeyLoc: t } = e1;
                    if (t !== null) {
                        this.expectPlugin("destructuringPrivate", t);
                    }
                }
            }
            class ExpressionErrors {
                constructor(){
                    this.shorthandAssignLoc = null;
                    this.doubleProtoLoc = null;
                    this.privateKeyLoc = null;
                    this.optionalParametersLoc = null;
                }
            }
            class Node {
                constructor(e1, t, r){
                    this.type = "";
                    this.start = t;
                    this.end = 0;
                    this.loc = new SourceLocation(r);
                    if ((e1 == null ? void 0 : e1.optionFlags) & 128) this.range = [
                        t,
                        0
                    ];
                    if (e1 != null && e1.filename) this.loc.filename = e1.filename;
                }
            }
            const G = Node.prototype;
            {
                G.__clone = function() {
                    const e1 = new Node(undefined, this.start, this.loc.start);
                    const t = Object.keys(this);
                    for(let r = 0, n = t.length; r < n; r++){
                        const n = t[r];
                        if (n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments") {
                            e1[n] = this[n];
                        }
                    }
                    return e1;
                };
            }
            function clonePlaceholder(e1) {
                return cloneIdentifier(e1);
            }
            function cloneIdentifier(e1) {
                const { type: t, start: r, end: n, loc: s, range: i, extra: a, name: o } = e1;
                const l = Object.create(G);
                l.type = t;
                l.start = r;
                l.end = n;
                l.loc = s;
                l.range = i;
                l.extra = a;
                l.name = o;
                if (t === "Placeholder") {
                    l.expectedNode = e1.expectedNode;
                }
                return l;
            }
            function cloneStringLiteral(e1) {
                const { type: t, start: r, end: n, loc: s, range: i, extra: a } = e1;
                if (t === "Placeholder") {
                    return clonePlaceholder(e1);
                }
                const o = Object.create(G);
                o.type = t;
                o.start = r;
                o.end = n;
                o.loc = s;
                o.range = i;
                if (e1.raw !== undefined) {
                    o.raw = e1.raw;
                } else {
                    o.extra = a;
                }
                o.value = e1.value;
                return o;
            }
            class NodeUtils extends UtilParser {
                startNode() {
                    const e1 = this.state.startLoc;
                    return new Node(this, e1.index, e1);
                }
                startNodeAt(e1) {
                    return new Node(this, e1.index, e1);
                }
                startNodeAtNode(e1) {
                    return this.startNodeAt(e1.loc.start);
                }
                finishNode(e1, t) {
                    return this.finishNodeAt(e1, t, this.state.lastTokEndLoc);
                }
                finishNodeAt(e1, t, r) {
                    e1.type = t;
                    e1.end = r.index;
                    e1.loc.end = r;
                    if (this.optionFlags & 128) e1.range[1] = r.index;
                    if (this.optionFlags & 4096) {
                        this.processComment(e1);
                    }
                    return e1;
                }
                resetStartLocation(e1, t) {
                    e1.start = t.index;
                    e1.loc.start = t;
                    if (this.optionFlags & 128) e1.range[0] = t.index;
                }
                resetEndLocation(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                    e1.end = t.index;
                    e1.loc.end = t;
                    if (this.optionFlags & 128) e1.range[1] = t.index;
                }
                resetStartLocationFromNode(e1, t) {
                    this.resetStartLocation(e1, t.loc.start);
                }
            }
            const J = new Set([
                "_",
                "any",
                "bool",
                "boolean",
                "empty",
                "extends",
                "false",
                "interface",
                "mixed",
                "null",
                "number",
                "static",
                "string",
                "true",
                "typeof",
                "void"
            ]);
            const z = ParseErrorEnum(_templateObject58())({
                AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
                AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
                AssignReservedType: (param)=>{
                    let { reservedType: e1 } = param;
                    return "Cannot overwrite reserved type ".concat(e1, ".");
                },
                DeclareClassElement: "The `declare` modifier can only appear on class fields.",
                DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
                DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
                EnumBooleanMemberNotInitialized: (param)=>{
                    let { memberName: e1, enumName: t } = param;
                    return "Boolean enum members need to be initialized. Use either `".concat(e1, " = true,` or `").concat(e1, " = false,` in enum `").concat(t, "`.");
                },
                EnumDuplicateMemberName: (param)=>{
                    let { memberName: e1, enumName: t } = param;
                    return "Enum member names need to be unique, but the name `".concat(e1, "` has already been used before in enum `").concat(t, "`.");
                },
                EnumInconsistentMemberValues: (param)=>{
                    let { enumName: e1 } = param;
                    return "Enum `".concat(e1, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
                },
                EnumInvalidExplicitType: (param)=>{
                    let { invalidEnumType: e1, enumName: t } = param;
                    return "Enum type `".concat(e1, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(t, "`.");
                },
                EnumInvalidExplicitTypeUnknownSupplied: (param)=>{
                    let { enumName: e1 } = param;
                    return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(e1, "`.");
                },
                EnumInvalidMemberInitializerPrimaryType: (param)=>{
                    let { enumName: e1, memberName: t, explicitType: r } = param;
                    return "Enum `".concat(e1, "` has type `").concat(r, "`, so the initializer of `").concat(t, "` needs to be a ").concat(r, " literal.");
                },
                EnumInvalidMemberInitializerSymbolType: (param)=>{
                    let { enumName: e1, memberName: t } = param;
                    return "Symbol enum members cannot be initialized. Use `".concat(t, ",` in enum `").concat(e1, "`.");
                },
                EnumInvalidMemberInitializerUnknownType: (param)=>{
                    let { enumName: e1, memberName: t } = param;
                    return "The enum member initializer for `".concat(t, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(e1, "`.");
                },
                EnumInvalidMemberName: (param)=>{
                    let { enumName: e1, memberName: t, suggestion: r } = param;
                    return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(t, "`, consider using `").concat(r, "`, in enum `").concat(e1, "`.");
                },
                EnumNumberMemberNotInitialized: (param)=>{
                    let { enumName: e1, memberName: t } = param;
                    return "Number enum members need to be initialized, e.g. `".concat(t, " = 1` in enum `").concat(e1, "`.");
                },
                EnumStringMemberInconsistentlyInitialized: (param)=>{
                    let { enumName: e1 } = param;
                    return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(e1, "`.");
                },
                GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
                ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
                ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
                InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
                InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
                InexactVariance: "Explicit inexact syntax cannot have variance.",
                InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
                MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
                NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
                NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
                PatternIsOptional: Object.assign({
                    message: "A binding pattern parameter cannot be optional in an implementation signature."
                }, {
                    reasonCode: "OptionalBindingPattern"
                }),
                SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
                SpreadVariance: "Spread properties cannot have variance.",
                ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
                ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
                ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
                ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
                ThisParamNoDefault: "The `this` parameter may not have a default value.",
                TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
                UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
                UnexpectedReservedType: (param)=>{
                    let { reservedType: e1 } = param;
                    return "Unexpected reserved type ".concat(e1, ".");
                },
                UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
                UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
                UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
                UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
                UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
                UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
                UnsupportedDeclareExportKind: (param)=>{
                    let { unsupportedExportKind: e1, suggestion: t } = param;
                    return "`declare export ".concat(e1, "` is not supported. Use `").concat(t, "` instead.");
                },
                UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
                UnterminatedFlowComment: "Unterminated flow-comment."
            });
            function isEsModuleType(e1) {
                return e1.type === "DeclareExportAllDeclaration" || e1.type === "DeclareExportDeclaration" && (!e1.declaration || e1.declaration.type !== "TypeAlias" && e1.declaration.type !== "InterfaceDeclaration");
            }
            function hasTypeImportKind(e1) {
                return e1.importKind === "type" || e1.importKind === "typeof";
            }
            const X = {
                const: "declare export var",
                let: "declare export var",
                type: "export type",
                interface: "export interface"
            };
            function partition(e1, t) {
                const r = [];
                const n = [];
                for(let s = 0; s < e1.length; s++){
                    (t(e1[s], s, e1) ? r : n).push(e1[s]);
                }
                return [
                    r,
                    n
                ];
            }
            const Y = /\*?\s*@((?:no)?flow)\b/;
            var flow = (e1)=>{
                class FlowParserMixin extends e1 {
                    getScopeHandler() {
                        return FlowScopeHandler;
                    }
                    shouldParseTypes() {
                        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
                    }
                    finishToken(e1, t) {
                        if (e1 !== 134 && e1 !== 13 && e1 !== 28) {
                            if (this.flowPragma === undefined) {
                                this.flowPragma = null;
                            }
                        }
                        super.finishToken(e1, t);
                    }
                    addComment(e1) {
                        if (this.flowPragma === undefined) {
                            const t = Y.exec(e1.value);
                            if (!t) ;
                            else if (t[1] === "flow") {
                                this.flowPragma = "flow";
                            } else if (t[1] === "noflow") {
                                this.flowPragma = "noflow";
                            } else {
                                throw new Error("Unexpected flow pragma");
                            }
                        }
                        super.addComment(e1);
                    }
                    flowParseTypeInitialiser(e1) {
                        const t = this.state.inType;
                        this.state.inType = true;
                        this.expect(e1 || 14);
                        const r = this.flowParseType();
                        this.state.inType = t;
                        return r;
                    }
                    flowParsePredicate() {
                        const e1 = this.startNode();
                        const t = this.state.startLoc;
                        this.next();
                        this.expectContextual(110);
                        if (this.state.lastTokStartLoc.index > t.index + 1) {
                            this.raise(z.UnexpectedSpaceBetweenModuloChecks, t);
                        }
                        if (this.eat(10)) {
                            e1.value = super.parseExpression();
                            this.expect(11);
                            return this.finishNode(e1, "DeclaredPredicate");
                        } else {
                            return this.finishNode(e1, "InferredPredicate");
                        }
                    }
                    flowParseTypeAndPredicateInitialiser() {
                        const e1 = this.state.inType;
                        this.state.inType = true;
                        this.expect(14);
                        let t = null;
                        let r = null;
                        if (this.match(54)) {
                            this.state.inType = e1;
                            r = this.flowParsePredicate();
                        } else {
                            t = this.flowParseType();
                            this.state.inType = e1;
                            if (this.match(54)) {
                                r = this.flowParsePredicate();
                            }
                        }
                        return [
                            t,
                            r
                        ];
                    }
                    flowParseDeclareClass(e1) {
                        this.next();
                        this.flowParseInterfaceish(e1, true);
                        return this.finishNode(e1, "DeclareClass");
                    }
                    flowParseDeclareFunction(e1) {
                        this.next();
                        const t = e1.id = this.parseIdentifier();
                        const r = this.startNode();
                        const n = this.startNode();
                        if (this.match(47)) {
                            r.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            r.typeParameters = null;
                        }
                        this.expect(10);
                        const s = this.flowParseFunctionTypeParams();
                        r.params = s.params;
                        r.rest = s.rest;
                        r.this = s._this;
                        this.expect(11);
                        [r.returnType, e1.predicate] = this.flowParseTypeAndPredicateInitialiser();
                        n.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation");
                        t.typeAnnotation = this.finishNode(n, "TypeAnnotation");
                        this.resetEndLocation(t);
                        this.semicolon();
                        this.scope.declareName(e1.id.name, 2048, e1.id.loc.start);
                        return this.finishNode(e1, "DeclareFunction");
                    }
                    flowParseDeclare(e1, t) {
                        if (this.match(80)) {
                            return this.flowParseDeclareClass(e1);
                        } else if (this.match(68)) {
                            return this.flowParseDeclareFunction(e1);
                        } else if (this.match(74)) {
                            return this.flowParseDeclareVariable(e1);
                        } else if (this.eatContextual(127)) {
                            if (this.match(16)) {
                                return this.flowParseDeclareModuleExports(e1);
                            } else {
                                if (t) {
                                    this.raise(z.NestedDeclareModule, this.state.lastTokStartLoc);
                                }
                                return this.flowParseDeclareModule(e1);
                            }
                        } else if (this.isContextual(130)) {
                            return this.flowParseDeclareTypeAlias(e1);
                        } else if (this.isContextual(131)) {
                            return this.flowParseDeclareOpaqueType(e1);
                        } else if (this.isContextual(129)) {
                            return this.flowParseDeclareInterface(e1);
                        } else if (this.match(82)) {
                            return this.flowParseDeclareExportDeclaration(e1, t);
                        } else {
                            this.unexpected();
                        }
                    }
                    flowParseDeclareVariable(e1) {
                        this.next();
                        e1.id = this.flowParseTypeAnnotatableIdentifier(true);
                        this.scope.declareName(e1.id.name, 5, e1.id.loc.start);
                        this.semicolon();
                        return this.finishNode(e1, "DeclareVariable");
                    }
                    flowParseDeclareModule(e1) {
                        this.scope.enter(0);
                        if (this.match(134)) {
                            e1.id = super.parseExprAtom();
                        } else {
                            e1.id = this.parseIdentifier();
                        }
                        const t = e1.body = this.startNode();
                        const r = t.body = [];
                        this.expect(5);
                        while(!this.match(8)){
                            let e1 = this.startNode();
                            if (this.match(83)) {
                                this.next();
                                if (!this.isContextual(130) && !this.match(87)) {
                                    this.raise(z.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
                                }
                                super.parseImport(e1);
                            } else {
                                this.expectContextual(125, z.UnsupportedStatementInDeclareModule);
                                e1 = this.flowParseDeclare(e1, true);
                            }
                            r.push(e1);
                        }
                        this.scope.exit();
                        this.expect(8);
                        this.finishNode(t, "BlockStatement");
                        let n = null;
                        let s = false;
                        r.forEach((e1)=>{
                            if (isEsModuleType(e1)) {
                                if (n === "CommonJS") {
                                    this.raise(z.AmbiguousDeclareModuleKind, e1);
                                }
                                n = "ES";
                            } else if (e1.type === "DeclareModuleExports") {
                                if (s) {
                                    this.raise(z.DuplicateDeclareModuleExports, e1);
                                }
                                if (n === "ES") {
                                    this.raise(z.AmbiguousDeclareModuleKind, e1);
                                }
                                n = "CommonJS";
                                s = true;
                            }
                        });
                        e1.kind = n || "CommonJS";
                        return this.finishNode(e1, "DeclareModule");
                    }
                    flowParseDeclareExportDeclaration(e1, t) {
                        this.expect(82);
                        if (this.eat(65)) {
                            if (this.match(68) || this.match(80)) {
                                e1.declaration = this.flowParseDeclare(this.startNode());
                            } else {
                                e1.declaration = this.flowParseType();
                                this.semicolon();
                            }
                            e1.default = true;
                            return this.finishNode(e1, "DeclareExportDeclaration");
                        } else {
                            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !t) {
                                const e1 = this.state.value;
                                throw this.raise(z.UnsupportedDeclareExportKind, this.state.startLoc, {
                                    unsupportedExportKind: e1,
                                    suggestion: X[e1]
                                });
                            }
                            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
                                e1.declaration = this.flowParseDeclare(this.startNode());
                                e1.default = false;
                                return this.finishNode(e1, "DeclareExportDeclaration");
                            } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
                                e1 = this.parseExport(e1, null);
                                if (e1.type === "ExportNamedDeclaration") {
                                    e1.type = "ExportDeclaration";
                                    e1.default = false;
                                    delete e1.exportKind;
                                }
                                e1.type = "Declare" + e1.type;
                                return e1;
                            }
                        }
                        this.unexpected();
                    }
                    flowParseDeclareModuleExports(e1) {
                        this.next();
                        this.expectContextual(111);
                        e1.typeAnnotation = this.flowParseTypeAnnotation();
                        this.semicolon();
                        return this.finishNode(e1, "DeclareModuleExports");
                    }
                    flowParseDeclareTypeAlias(e1) {
                        this.next();
                        const t = this.flowParseTypeAlias(e1);
                        t.type = "DeclareTypeAlias";
                        return t;
                    }
                    flowParseDeclareOpaqueType(e1) {
                        this.next();
                        const t = this.flowParseOpaqueType(e1, true);
                        t.type = "DeclareOpaqueType";
                        return t;
                    }
                    flowParseDeclareInterface(e1) {
                        this.next();
                        this.flowParseInterfaceish(e1, false);
                        return this.finishNode(e1, "DeclareInterface");
                    }
                    flowParseInterfaceish(e1, t) {
                        e1.id = this.flowParseRestrictedIdentifier(!t, true);
                        this.scope.declareName(e1.id.name, t ? 17 : 8201, e1.id.loc.start);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            e1.typeParameters = null;
                        }
                        e1.extends = [];
                        if (this.eat(81)) {
                            do {
                                e1.extends.push(this.flowParseInterfaceExtends());
                            }while (!t && this.eat(12))
                        }
                        if (t) {
                            e1.implements = [];
                            e1.mixins = [];
                            if (this.eatContextual(117)) {
                                do {
                                    e1.mixins.push(this.flowParseInterfaceExtends());
                                }while (this.eat(12))
                            }
                            if (this.eatContextual(113)) {
                                do {
                                    e1.implements.push(this.flowParseInterfaceExtends());
                                }while (this.eat(12))
                            }
                        }
                        e1.body = this.flowParseObjectType({
                            allowStatic: t,
                            allowExact: false,
                            allowSpread: false,
                            allowProto: t,
                            allowInexact: false
                        });
                    }
                    flowParseInterfaceExtends() {
                        const e1 = this.startNode();
                        e1.id = this.flowParseQualifiedTypeIdentifier();
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterInstantiation();
                        } else {
                            e1.typeParameters = null;
                        }
                        return this.finishNode(e1, "InterfaceExtends");
                    }
                    flowParseInterface(e1) {
                        this.flowParseInterfaceish(e1, false);
                        return this.finishNode(e1, "InterfaceDeclaration");
                    }
                    checkNotUnderscore(e1) {
                        if (e1 === "_") {
                            this.raise(z.UnexpectedReservedUnderscore, this.state.startLoc);
                        }
                    }
                    checkReservedType(e1, t, r) {
                        if (!J.has(e1)) return;
                        this.raise(r ? z.AssignReservedType : z.UnexpectedReservedType, t, {
                            reservedType: e1
                        });
                    }
                    flowParseRestrictedIdentifier(e1, t) {
                        this.checkReservedType(this.state.value, this.state.startLoc, t);
                        return this.parseIdentifier(e1);
                    }
                    flowParseTypeAlias(e1) {
                        e1.id = this.flowParseRestrictedIdentifier(false, true);
                        this.scope.declareName(e1.id.name, 8201, e1.id.loc.start);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            e1.typeParameters = null;
                        }
                        e1.right = this.flowParseTypeInitialiser(29);
                        this.semicolon();
                        return this.finishNode(e1, "TypeAlias");
                    }
                    flowParseOpaqueType(e1, t) {
                        this.expectContextual(130);
                        e1.id = this.flowParseRestrictedIdentifier(true, true);
                        this.scope.declareName(e1.id.name, 8201, e1.id.loc.start);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            e1.typeParameters = null;
                        }
                        e1.supertype = null;
                        if (this.match(14)) {
                            e1.supertype = this.flowParseTypeInitialiser(14);
                        }
                        e1.impltype = null;
                        if (!t) {
                            e1.impltype = this.flowParseTypeInitialiser(29);
                        }
                        this.semicolon();
                        return this.finishNode(e1, "OpaqueType");
                    }
                    flowParseTypeParameter() {
                        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                        const t = this.state.startLoc;
                        const r = this.startNode();
                        const n = this.flowParseVariance();
                        const s = this.flowParseTypeAnnotatableIdentifier();
                        r.name = s.name;
                        r.variance = n;
                        r.bound = s.typeAnnotation;
                        if (this.match(29)) {
                            this.eat(29);
                            r.default = this.flowParseType();
                        } else {
                            if (e1) {
                                this.raise(z.MissingTypeParamDefault, t);
                            }
                        }
                        return this.finishNode(r, "TypeParameter");
                    }
                    flowParseTypeParameterDeclaration() {
                        const e1 = this.state.inType;
                        const t = this.startNode();
                        t.params = [];
                        this.state.inType = true;
                        if (this.match(47) || this.match(143)) {
                            this.next();
                        } else {
                            this.unexpected();
                        }
                        let r = false;
                        do {
                            const e1 = this.flowParseTypeParameter(r);
                            t.params.push(e1);
                            if (e1.default) {
                                r = true;
                            }
                            if (!this.match(48)) {
                                this.expect(12);
                            }
                        }while (!this.match(48))
                        this.expect(48);
                        this.state.inType = e1;
                        return this.finishNode(t, "TypeParameterDeclaration");
                    }
                    flowInTopLevelContext(e1) {
                        if (this.curContext() !== d.brace) {
                            const t = this.state.context;
                            this.state.context = [
                                t[0]
                            ];
                            try {
                                return e1();
                            } finally{
                                this.state.context = t;
                            }
                        } else {
                            return e1();
                        }
                    }
                    flowParseTypeParameterInstantiationInExpression() {
                        if (this.reScan_lt() !== 47) return;
                        return this.flowParseTypeParameterInstantiation();
                    }
                    flowParseTypeParameterInstantiation() {
                        const e1 = this.startNode();
                        const t = this.state.inType;
                        this.state.inType = true;
                        e1.params = [];
                        this.flowInTopLevelContext(()=>{
                            this.expect(47);
                            const t = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = false;
                            while(!this.match(48)){
                                e1.params.push(this.flowParseType());
                                if (!this.match(48)) {
                                    this.expect(12);
                                }
                            }
                            this.state.noAnonFunctionType = t;
                        });
                        this.state.inType = t;
                        if (!this.state.inType && this.curContext() === d.brace) {
                            this.reScan_lt_gt();
                        }
                        this.expect(48);
                        return this.finishNode(e1, "TypeParameterInstantiation");
                    }
                    flowParseTypeParameterInstantiationCallOrNew() {
                        if (this.reScan_lt() !== 47) return;
                        const e1 = this.startNode();
                        const t = this.state.inType;
                        e1.params = [];
                        this.state.inType = true;
                        this.expect(47);
                        while(!this.match(48)){
                            e1.params.push(this.flowParseTypeOrImplicitInstantiation());
                            if (!this.match(48)) {
                                this.expect(12);
                            }
                        }
                        this.expect(48);
                        this.state.inType = t;
                        return this.finishNode(e1, "TypeParameterInstantiation");
                    }
                    flowParseInterfaceType() {
                        const e1 = this.startNode();
                        this.expectContextual(129);
                        e1.extends = [];
                        if (this.eat(81)) {
                            do {
                                e1.extends.push(this.flowParseInterfaceExtends());
                            }while (this.eat(12))
                        }
                        e1.body = this.flowParseObjectType({
                            allowStatic: false,
                            allowExact: false,
                            allowSpread: false,
                            allowProto: false,
                            allowInexact: false
                        });
                        return this.finishNode(e1, "InterfaceTypeAnnotation");
                    }
                    flowParseObjectPropertyKey() {
                        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
                    }
                    flowParseObjectTypeIndexer(e1, t, r) {
                        e1.static = t;
                        if (this.lookahead().type === 14) {
                            e1.id = this.flowParseObjectPropertyKey();
                            e1.key = this.flowParseTypeInitialiser();
                        } else {
                            e1.id = null;
                            e1.key = this.flowParseType();
                        }
                        this.expect(3);
                        e1.value = this.flowParseTypeInitialiser();
                        e1.variance = r;
                        return this.finishNode(e1, "ObjectTypeIndexer");
                    }
                    flowParseObjectTypeInternalSlot(e1, t) {
                        e1.static = t;
                        e1.id = this.flowParseObjectPropertyKey();
                        this.expect(3);
                        this.expect(3);
                        if (this.match(47) || this.match(10)) {
                            e1.method = true;
                            e1.optional = false;
                            e1.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e1.loc.start));
                        } else {
                            e1.method = false;
                            if (this.eat(17)) {
                                e1.optional = true;
                            }
                            e1.value = this.flowParseTypeInitialiser();
                        }
                        return this.finishNode(e1, "ObjectTypeInternalSlot");
                    }
                    flowParseObjectTypeMethodish(e1) {
                        e1.params = [];
                        e1.rest = null;
                        e1.typeParameters = null;
                        e1.this = null;
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        this.expect(10);
                        if (this.match(78)) {
                            e1.this = this.flowParseFunctionTypeParam(true);
                            e1.this.name = null;
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        while(!this.match(11) && !this.match(21)){
                            e1.params.push(this.flowParseFunctionTypeParam(false));
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        if (this.eat(21)) {
                            e1.rest = this.flowParseFunctionTypeParam(false);
                        }
                        this.expect(11);
                        e1.returnType = this.flowParseTypeInitialiser();
                        return this.finishNode(e1, "FunctionTypeAnnotation");
                    }
                    flowParseObjectTypeCallProperty(e1, t) {
                        const r = this.startNode();
                        e1.static = t;
                        e1.value = this.flowParseObjectTypeMethodish(r);
                        return this.finishNode(e1, "ObjectTypeCallProperty");
                    }
                    flowParseObjectType(param) {
                        let { allowStatic: e1, allowExact: t, allowSpread: r, allowProto: n, allowInexact: s } = param;
                        const i = this.state.inType;
                        this.state.inType = true;
                        const a = this.startNode();
                        a.callProperties = [];
                        a.properties = [];
                        a.indexers = [];
                        a.internalSlots = [];
                        let o;
                        let l;
                        let c = false;
                        if (t && this.match(6)) {
                            this.expect(6);
                            o = 9;
                            l = true;
                        } else {
                            this.expect(5);
                            o = 8;
                            l = false;
                        }
                        a.exact = l;
                        while(!this.match(o)){
                            let t = false;
                            let i = null;
                            let o = null;
                            const p = this.startNode();
                            if (n && this.isContextual(118)) {
                                const t = this.lookahead();
                                if (t.type !== 14 && t.type !== 17) {
                                    this.next();
                                    i = this.state.startLoc;
                                    e1 = false;
                                }
                            }
                            if (e1 && this.isContextual(106)) {
                                const e1 = this.lookahead();
                                if (e1.type !== 14 && e1.type !== 17) {
                                    this.next();
                                    t = true;
                                }
                            }
                            const u = this.flowParseVariance();
                            if (this.eat(0)) {
                                if (i != null) {
                                    this.unexpected(i);
                                }
                                if (this.eat(0)) {
                                    if (u) {
                                        this.unexpected(u.loc.start);
                                    }
                                    a.internalSlots.push(this.flowParseObjectTypeInternalSlot(p, t));
                                } else {
                                    a.indexers.push(this.flowParseObjectTypeIndexer(p, t, u));
                                }
                            } else if (this.match(10) || this.match(47)) {
                                if (i != null) {
                                    this.unexpected(i);
                                }
                                if (u) {
                                    this.unexpected(u.loc.start);
                                }
                                a.callProperties.push(this.flowParseObjectTypeCallProperty(p, t));
                            } else {
                                let e1 = "init";
                                if (this.isContextual(99) || this.isContextual(104)) {
                                    const t = this.lookahead();
                                    if (tokenIsLiteralPropertyName(t.type)) {
                                        e1 = this.state.value;
                                        this.next();
                                    }
                                }
                                const n = this.flowParseObjectTypeProperty(p, t, i, u, e1, r, s != null ? s : !l);
                                if (n === null) {
                                    c = true;
                                    o = this.state.lastTokStartLoc;
                                } else {
                                    a.properties.push(n);
                                }
                            }
                            this.flowObjectTypeSemicolon();
                            if (o && !this.match(8) && !this.match(9)) {
                                this.raise(z.UnexpectedExplicitInexactInObject, o);
                            }
                        }
                        this.expect(o);
                        if (r) {
                            a.inexact = c;
                        }
                        const p = this.finishNode(a, "ObjectTypeAnnotation");
                        this.state.inType = i;
                        return p;
                    }
                    flowParseObjectTypeProperty(e1, t, r, n, s, i, a) {
                        if (this.eat(21)) {
                            const t = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                            if (t) {
                                if (!i) {
                                    this.raise(z.InexactInsideNonObject, this.state.lastTokStartLoc);
                                } else if (!a) {
                                    this.raise(z.InexactInsideExact, this.state.lastTokStartLoc);
                                }
                                if (n) {
                                    this.raise(z.InexactVariance, n);
                                }
                                return null;
                            }
                            if (!i) {
                                this.raise(z.UnexpectedSpreadType, this.state.lastTokStartLoc);
                            }
                            if (r != null) {
                                this.unexpected(r);
                            }
                            if (n) {
                                this.raise(z.SpreadVariance, n);
                            }
                            e1.argument = this.flowParseType();
                            return this.finishNode(e1, "ObjectTypeSpreadProperty");
                        } else {
                            e1.key = this.flowParseObjectPropertyKey();
                            e1.static = t;
                            e1.proto = r != null;
                            e1.kind = s;
                            let a = false;
                            if (this.match(47) || this.match(10)) {
                                e1.method = true;
                                if (r != null) {
                                    this.unexpected(r);
                                }
                                if (n) {
                                    this.unexpected(n.loc.start);
                                }
                                e1.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e1.loc.start));
                                if (s === "get" || s === "set") {
                                    this.flowCheckGetterSetterParams(e1);
                                }
                                if (!i && e1.key.name === "constructor" && e1.value.this) {
                                    this.raise(z.ThisParamBannedInConstructor, e1.value.this);
                                }
                            } else {
                                if (s !== "init") this.unexpected();
                                e1.method = false;
                                if (this.eat(17)) {
                                    a = true;
                                }
                                e1.value = this.flowParseTypeInitialiser();
                                e1.variance = n;
                            }
                            e1.optional = a;
                            return this.finishNode(e1, "ObjectTypeProperty");
                        }
                    }
                    flowCheckGetterSetterParams(e1) {
                        const t = e1.kind === "get" ? 0 : 1;
                        const r = e1.value.params.length + (e1.value.rest ? 1 : 0);
                        if (e1.value.this) {
                            this.raise(e1.kind === "get" ? z.GetterMayNotHaveThisParam : z.SetterMayNotHaveThisParam, e1.value.this);
                        }
                        if (r !== t) {
                            this.raise(e1.kind === "get" ? p.BadGetterArity : p.BadSetterArity, e1);
                        }
                        if (e1.kind === "set" && e1.value.rest) {
                            this.raise(p.BadSetterRestParameter, e1);
                        }
                    }
                    flowObjectTypeSemicolon() {
                        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
                            this.unexpected();
                        }
                    }
                    flowParseQualifiedTypeIdentifier(e1, t) {
                        e1 != null ? e1 : e1 = this.state.startLoc;
                        let r = t || this.flowParseRestrictedIdentifier(true);
                        while(this.eat(16)){
                            const t = this.startNodeAt(e1);
                            t.qualification = r;
                            t.id = this.flowParseRestrictedIdentifier(true);
                            r = this.finishNode(t, "QualifiedTypeIdentifier");
                        }
                        return r;
                    }
                    flowParseGenericType(e1, t) {
                        const r = this.startNodeAt(e1);
                        r.typeParameters = null;
                        r.id = this.flowParseQualifiedTypeIdentifier(e1, t);
                        if (this.match(47)) {
                            r.typeParameters = this.flowParseTypeParameterInstantiation();
                        }
                        return this.finishNode(r, "GenericTypeAnnotation");
                    }
                    flowParseTypeofType() {
                        const e1 = this.startNode();
                        this.expect(87);
                        e1.argument = this.flowParsePrimaryType();
                        return this.finishNode(e1, "TypeofTypeAnnotation");
                    }
                    flowParseTupleType() {
                        const e1 = this.startNode();
                        e1.types = [];
                        this.expect(0);
                        while(this.state.pos < this.length && !this.match(3)){
                            e1.types.push(this.flowParseType());
                            if (this.match(3)) break;
                            this.expect(12);
                        }
                        this.expect(3);
                        return this.finishNode(e1, "TupleTypeAnnotation");
                    }
                    flowParseFunctionTypeParam(e1) {
                        let t = null;
                        let r = false;
                        let n = null;
                        const s = this.startNode();
                        const i = this.lookahead();
                        const a = this.state.type === 78;
                        if (i.type === 14 || i.type === 17) {
                            if (a && !e1) {
                                this.raise(z.ThisParamMustBeFirst, s);
                            }
                            t = this.parseIdentifier(a);
                            if (this.eat(17)) {
                                r = true;
                                if (a) {
                                    this.raise(z.ThisParamMayNotBeOptional, s);
                                }
                            }
                            n = this.flowParseTypeInitialiser();
                        } else {
                            n = this.flowParseType();
                        }
                        s.name = t;
                        s.optional = r;
                        s.typeAnnotation = n;
                        return this.finishNode(s, "FunctionTypeParam");
                    }
                    reinterpretTypeAsFunctionTypeParam(e1) {
                        const t = this.startNodeAt(e1.loc.start);
                        t.name = null;
                        t.optional = false;
                        t.typeAnnotation = e1;
                        return this.finishNode(t, "FunctionTypeParam");
                    }
                    flowParseFunctionTypeParams() {
                        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                        let t = null;
                        let r = null;
                        if (this.match(78)) {
                            r = this.flowParseFunctionTypeParam(true);
                            r.name = null;
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        while(!this.match(11) && !this.match(21)){
                            e1.push(this.flowParseFunctionTypeParam(false));
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        if (this.eat(21)) {
                            t = this.flowParseFunctionTypeParam(false);
                        }
                        return {
                            params: e1,
                            rest: t,
                            _this: r
                        };
                    }
                    flowIdentToTypeAnnotation(e1, t, r) {
                        switch(r.name){
                            case "any":
                                return this.finishNode(t, "AnyTypeAnnotation");
                            case "bool":
                            case "boolean":
                                return this.finishNode(t, "BooleanTypeAnnotation");
                            case "mixed":
                                return this.finishNode(t, "MixedTypeAnnotation");
                            case "empty":
                                return this.finishNode(t, "EmptyTypeAnnotation");
                            case "number":
                                return this.finishNode(t, "NumberTypeAnnotation");
                            case "string":
                                return this.finishNode(t, "StringTypeAnnotation");
                            case "symbol":
                                return this.finishNode(t, "SymbolTypeAnnotation");
                            default:
                                this.checkNotUnderscore(r.name);
                                return this.flowParseGenericType(e1, r);
                        }
                    }
                    flowParsePrimaryType() {
                        const e1 = this.state.startLoc;
                        const t = this.startNode();
                        let r;
                        let n;
                        let s = false;
                        const i = this.state.noAnonFunctionType;
                        switch(this.state.type){
                            case 5:
                                return this.flowParseObjectType({
                                    allowStatic: false,
                                    allowExact: false,
                                    allowSpread: true,
                                    allowProto: false,
                                    allowInexact: true
                                });
                            case 6:
                                return this.flowParseObjectType({
                                    allowStatic: false,
                                    allowExact: true,
                                    allowSpread: true,
                                    allowProto: false,
                                    allowInexact: false
                                });
                            case 0:
                                this.state.noAnonFunctionType = false;
                                n = this.flowParseTupleType();
                                this.state.noAnonFunctionType = i;
                                return n;
                            case 47:
                                {
                                    const e1 = this.startNode();
                                    e1.typeParameters = this.flowParseTypeParameterDeclaration();
                                    this.expect(10);
                                    r = this.flowParseFunctionTypeParams();
                                    e1.params = r.params;
                                    e1.rest = r.rest;
                                    e1.this = r._this;
                                    this.expect(11);
                                    this.expect(19);
                                    e1.returnType = this.flowParseType();
                                    return this.finishNode(e1, "FunctionTypeAnnotation");
                                }
                            case 10:
                                {
                                    const e1 = this.startNode();
                                    this.next();
                                    if (!this.match(11) && !this.match(21)) {
                                        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                                            const e1 = this.lookahead().type;
                                            s = e1 !== 17 && e1 !== 14;
                                        } else {
                                            s = true;
                                        }
                                    }
                                    if (s) {
                                        this.state.noAnonFunctionType = false;
                                        n = this.flowParseType();
                                        this.state.noAnonFunctionType = i;
                                        if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                                            this.expect(11);
                                            return n;
                                        } else {
                                            this.eat(12);
                                        }
                                    }
                                    if (n) {
                                        r = this.flowParseFunctionTypeParams([
                                            this.reinterpretTypeAsFunctionTypeParam(n)
                                        ]);
                                    } else {
                                        r = this.flowParseFunctionTypeParams();
                                    }
                                    e1.params = r.params;
                                    e1.rest = r.rest;
                                    e1.this = r._this;
                                    this.expect(11);
                                    this.expect(19);
                                    e1.returnType = this.flowParseType();
                                    e1.typeParameters = null;
                                    return this.finishNode(e1, "FunctionTypeAnnotation");
                                }
                            case 134:
                                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                            case 85:
                            case 86:
                                t.value = this.match(85);
                                this.next();
                                return this.finishNode(t, "BooleanLiteralTypeAnnotation");
                            case 53:
                                if (this.state.value === "-") {
                                    this.next();
                                    if (this.match(135)) {
                                        return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t);
                                    }
                                    if (this.match(136)) {
                                        return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t);
                                    }
                                    throw this.raise(z.UnexpectedSubtractionOperand, this.state.startLoc);
                                }
                                this.unexpected();
                                return;
                            case 135:
                                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                            case 136:
                                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                            case 88:
                                this.next();
                                return this.finishNode(t, "VoidTypeAnnotation");
                            case 84:
                                this.next();
                                return this.finishNode(t, "NullLiteralTypeAnnotation");
                            case 78:
                                this.next();
                                return this.finishNode(t, "ThisTypeAnnotation");
                            case 55:
                                this.next();
                                return this.finishNode(t, "ExistsTypeAnnotation");
                            case 87:
                                return this.flowParseTypeofType();
                            default:
                                if (tokenIsKeyword(this.state.type)) {
                                    const e1 = tokenLabelName(this.state.type);
                                    this.next();
                                    return super.createIdentifier(t, e1);
                                } else if (tokenIsIdentifier(this.state.type)) {
                                    if (this.isContextual(129)) {
                                        return this.flowParseInterfaceType();
                                    }
                                    return this.flowIdentToTypeAnnotation(e1, t, this.parseIdentifier());
                                }
                        }
                        this.unexpected();
                    }
                    flowParsePostfixType() {
                        const e1 = this.state.startLoc;
                        let t = this.flowParsePrimaryType();
                        let r = false;
                        while((this.match(0) || this.match(18)) && !this.canInsertSemicolon()){
                            const n = this.startNodeAt(e1);
                            const s = this.eat(18);
                            r = r || s;
                            this.expect(0);
                            if (!s && this.match(3)) {
                                n.elementType = t;
                                this.next();
                                t = this.finishNode(n, "ArrayTypeAnnotation");
                            } else {
                                n.objectType = t;
                                n.indexType = this.flowParseType();
                                this.expect(3);
                                if (r) {
                                    n.optional = s;
                                    t = this.finishNode(n, "OptionalIndexedAccessType");
                                } else {
                                    t = this.finishNode(n, "IndexedAccessType");
                                }
                            }
                        }
                        return t;
                    }
                    flowParsePrefixType() {
                        const e1 = this.startNode();
                        if (this.eat(17)) {
                            e1.typeAnnotation = this.flowParsePrefixType();
                            return this.finishNode(e1, "NullableTypeAnnotation");
                        } else {
                            return this.flowParsePostfixType();
                        }
                    }
                    flowParseAnonFunctionWithoutParens() {
                        const e1 = this.flowParsePrefixType();
                        if (!this.state.noAnonFunctionType && this.eat(19)) {
                            const t = this.startNodeAt(e1.loc.start);
                            t.params = [
                                this.reinterpretTypeAsFunctionTypeParam(e1)
                            ];
                            t.rest = null;
                            t.this = null;
                            t.returnType = this.flowParseType();
                            t.typeParameters = null;
                            return this.finishNode(t, "FunctionTypeAnnotation");
                        }
                        return e1;
                    }
                    flowParseIntersectionType() {
                        const e1 = this.startNode();
                        this.eat(45);
                        const t = this.flowParseAnonFunctionWithoutParens();
                        e1.types = [
                            t
                        ];
                        while(this.eat(45)){
                            e1.types.push(this.flowParseAnonFunctionWithoutParens());
                        }
                        return e1.types.length === 1 ? t : this.finishNode(e1, "IntersectionTypeAnnotation");
                    }
                    flowParseUnionType() {
                        const e1 = this.startNode();
                        this.eat(43);
                        const t = this.flowParseIntersectionType();
                        e1.types = [
                            t
                        ];
                        while(this.eat(43)){
                            e1.types.push(this.flowParseIntersectionType());
                        }
                        return e1.types.length === 1 ? t : this.finishNode(e1, "UnionTypeAnnotation");
                    }
                    flowParseType() {
                        const e1 = this.state.inType;
                        this.state.inType = true;
                        const t = this.flowParseUnionType();
                        this.state.inType = e1;
                        return t;
                    }
                    flowParseTypeOrImplicitInstantiation() {
                        if (this.state.type === 132 && this.state.value === "_") {
                            const e1 = this.state.startLoc;
                            const t = this.parseIdentifier();
                            return this.flowParseGenericType(e1, t);
                        } else {
                            return this.flowParseType();
                        }
                    }
                    flowParseTypeAnnotation() {
                        const e1 = this.startNode();
                        e1.typeAnnotation = this.flowParseTypeInitialiser();
                        return this.finishNode(e1, "TypeAnnotation");
                    }
                    flowParseTypeAnnotatableIdentifier(e1) {
                        const t = e1 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                        if (this.match(14)) {
                            t.typeAnnotation = this.flowParseTypeAnnotation();
                            this.resetEndLocation(t);
                        }
                        return t;
                    }
                    typeCastToParameter(e1) {
                        e1.expression.typeAnnotation = e1.typeAnnotation;
                        this.resetEndLocation(e1.expression, e1.typeAnnotation.loc.end);
                        return e1.expression;
                    }
                    flowParseVariance() {
                        let e1 = null;
                        if (this.match(53)) {
                            e1 = this.startNode();
                            if (this.state.value === "+") {
                                e1.kind = "plus";
                            } else {
                                e1.kind = "minus";
                            }
                            this.next();
                            return this.finishNode(e1, "Variance");
                        }
                        return e1;
                    }
                    parseFunctionBody(e1, t) {
                        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        if (t) {
                            this.forwardNoArrowParamsConversionAt(e1, ()=>super.parseFunctionBody(e1, true, r));
                            return;
                        }
                        super.parseFunctionBody(e1, false, r);
                    }
                    parseFunctionBodyAndFinish(e1, t) {
                        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        if (this.match(14)) {
                            const t = this.startNode();
                            [t.typeAnnotation, e1.predicate] = this.flowParseTypeAndPredicateInitialiser();
                            e1.returnType = t.typeAnnotation ? this.finishNode(t, "TypeAnnotation") : null;
                        }
                        return super.parseFunctionBodyAndFinish(e1, t, r);
                    }
                    parseStatementLike(e1) {
                        if (this.state.strict && this.isContextual(129)) {
                            const e1 = this.lookahead();
                            if (tokenIsKeywordOrIdentifier(e1.type)) {
                                const e1 = this.startNode();
                                this.next();
                                return this.flowParseInterface(e1);
                            }
                        } else if (this.isContextual(126)) {
                            const e1 = this.startNode();
                            this.next();
                            return this.flowParseEnumDeclaration(e1);
                        }
                        const t = super.parseStatementLike(e1);
                        if (this.flowPragma === undefined && !this.isValidDirective(t)) {
                            this.flowPragma = null;
                        }
                        return t;
                    }
                    parseExpressionStatement(e1, t, r) {
                        if (t.type === "Identifier") {
                            if (t.name === "declare") {
                                if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                                    return this.flowParseDeclare(e1);
                                }
                            } else if (tokenIsIdentifier(this.state.type)) {
                                if (t.name === "interface") {
                                    return this.flowParseInterface(e1);
                                } else if (t.name === "type") {
                                    return this.flowParseTypeAlias(e1);
                                } else if (t.name === "opaque") {
                                    return this.flowParseOpaqueType(e1, false);
                                }
                            }
                        }
                        return super.parseExpressionStatement(e1, t, r);
                    }
                    shouldParseExportDeclaration() {
                        const { type: e1 } = this.state;
                        if (e1 === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(e1)) {
                            return !this.state.containsEsc;
                        }
                        return super.shouldParseExportDeclaration();
                    }
                    isExportDefaultSpecifier() {
                        const { type: e1 } = this.state;
                        if (e1 === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(e1)) {
                            return this.state.containsEsc;
                        }
                        return super.isExportDefaultSpecifier();
                    }
                    parseExportDefaultExpression() {
                        if (this.isContextual(126)) {
                            const e1 = this.startNode();
                            this.next();
                            return this.flowParseEnumDeclaration(e1);
                        }
                        return super.parseExportDefaultExpression();
                    }
                    parseConditional(e1, t, r) {
                        if (!this.match(17)) return e1;
                        if (this.state.maybeInArrowParameters) {
                            const t = this.lookaheadCharCode();
                            if (t === 44 || t === 61 || t === 58 || t === 41) {
                                this.setOptionalParametersError(r);
                                return e1;
                            }
                        }
                        this.expect(17);
                        const n = this.state.clone();
                        const s = this.state.noArrowAt;
                        const i = this.startNodeAt(t);
                        let { consequent: a, failed: o } = this.tryParseConditionalConsequent();
                        let [l, c] = this.getArrowLikeExpressions(a);
                        if (o || c.length > 0) {
                            const e1 = [
                                ...s
                            ];
                            if (c.length > 0) {
                                this.state = n;
                                this.state.noArrowAt = e1;
                                for(let t = 0; t < c.length; t++){
                                    e1.push(c[t].start);
                                }
                                ({ consequent: a, failed: o } = this.tryParseConditionalConsequent());
                                [l, c] = this.getArrowLikeExpressions(a);
                            }
                            if (o && l.length > 1) {
                                this.raise(z.AmbiguousConditionalArrow, n.startLoc);
                            }
                            if (o && l.length === 1) {
                                this.state = n;
                                e1.push(l[0].start);
                                this.state.noArrowAt = e1;
                                ({ consequent: a, failed: o } = this.tryParseConditionalConsequent());
                            }
                        }
                        this.getArrowLikeExpressions(a, true);
                        this.state.noArrowAt = s;
                        this.expect(14);
                        i.test = e1;
                        i.consequent = a;
                        i.alternate = this.forwardNoArrowParamsConversionAt(i, ()=>this.parseMaybeAssign(undefined, undefined));
                        return this.finishNode(i, "ConditionalExpression");
                    }
                    tryParseConditionalConsequent() {
                        this.state.noArrowParamsConversionAt.push(this.state.start);
                        const e1 = this.parseMaybeAssignAllowIn();
                        const t = !this.match(14);
                        this.state.noArrowParamsConversionAt.pop();
                        return {
                            consequent: e1,
                            failed: t
                        };
                    }
                    getArrowLikeExpressions(e1, t) {
                        const r = [
                            e1
                        ];
                        const n = [];
                        while(r.length !== 0){
                            const e1 = r.pop();
                            if (e1.type === "ArrowFunctionExpression" && e1.body.type !== "BlockStatement") {
                                if (e1.typeParameters || !e1.returnType) {
                                    this.finishArrowValidation(e1);
                                } else {
                                    n.push(e1);
                                }
                                r.push(e1.body);
                            } else if (e1.type === "ConditionalExpression") {
                                r.push(e1.consequent);
                                r.push(e1.alternate);
                            }
                        }
                        if (t) {
                            n.forEach((e1)=>this.finishArrowValidation(e1));
                            return [
                                n,
                                []
                            ];
                        }
                        return partition(n, (e1)=>e1.params.every((e1)=>this.isAssignable(e1, true)));
                    }
                    finishArrowValidation(e1) {
                        var t;
                        this.toAssignableList(e1.params, (t = e1.extra) == null ? void 0 : t.trailingCommaLoc, false);
                        this.scope.enter(2 | 4);
                        super.checkParams(e1, false, true);
                        this.scope.exit();
                    }
                    forwardNoArrowParamsConversionAt(e1, t) {
                        let r;
                        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e1.start))) {
                            this.state.noArrowParamsConversionAt.push(this.state.start);
                            r = t();
                            this.state.noArrowParamsConversionAt.pop();
                        } else {
                            r = t();
                        }
                        return r;
                    }
                    parseParenItem(e1, t) {
                        const r = super.parseParenItem(e1, t);
                        if (this.eat(17)) {
                            r.optional = true;
                            this.resetEndLocation(e1);
                        }
                        if (this.match(14)) {
                            const e1 = this.startNodeAt(t);
                            e1.expression = r;
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                            return this.finishNode(e1, "TypeCastExpression");
                        }
                        return r;
                    }
                    assertModuleNodeAllowed(e1) {
                        if (e1.type === "ImportDeclaration" && (e1.importKind === "type" || e1.importKind === "typeof") || e1.type === "ExportNamedDeclaration" && e1.exportKind === "type" || e1.type === "ExportAllDeclaration" && e1.exportKind === "type") {
                            return;
                        }
                        super.assertModuleNodeAllowed(e1);
                    }
                    parseExportDeclaration(e1) {
                        if (this.isContextual(130)) {
                            e1.exportKind = "type";
                            const t = this.startNode();
                            this.next();
                            if (this.match(5)) {
                                e1.specifiers = this.parseExportSpecifiers(true);
                                super.parseExportFrom(e1);
                                return null;
                            } else {
                                return this.flowParseTypeAlias(t);
                            }
                        } else if (this.isContextual(131)) {
                            e1.exportKind = "type";
                            const t = this.startNode();
                            this.next();
                            return this.flowParseOpaqueType(t, false);
                        } else if (this.isContextual(129)) {
                            e1.exportKind = "type";
                            const t = this.startNode();
                            this.next();
                            return this.flowParseInterface(t);
                        } else if (this.isContextual(126)) {
                            e1.exportKind = "value";
                            const t = this.startNode();
                            this.next();
                            return this.flowParseEnumDeclaration(t);
                        } else {
                            return super.parseExportDeclaration(e1);
                        }
                    }
                    eatExportStar(e1) {
                        if (super.eatExportStar(e1)) return true;
                        if (this.isContextual(130) && this.lookahead().type === 55) {
                            e1.exportKind = "type";
                            this.next();
                            this.next();
                            return true;
                        }
                        return false;
                    }
                    maybeParseExportNamespaceSpecifier(e1) {
                        const { startLoc: t } = this.state;
                        const r = super.maybeParseExportNamespaceSpecifier(e1);
                        if (r && e1.exportKind === "type") {
                            this.unexpected(t);
                        }
                        return r;
                    }
                    parseClassId(e1, t, r) {
                        super.parseClassId(e1, t, r);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                    }
                    parseClassMember(e1, t, r) {
                        const { startLoc: n } = this.state;
                        if (this.isContextual(125)) {
                            if (super.parseClassMemberFromModifier(e1, t)) {
                                return;
                            }
                            t.declare = true;
                        }
                        super.parseClassMember(e1, t, r);
                        if (t.declare) {
                            if (t.type !== "ClassProperty" && t.type !== "ClassPrivateProperty" && t.type !== "PropertyDefinition") {
                                this.raise(z.DeclareClassElement, n);
                            } else if (t.value) {
                                this.raise(z.DeclareClassFieldInitializer, t.value);
                            }
                        }
                    }
                    isIterator(e1) {
                        return e1 === "iterator" || e1 === "asyncIterator";
                    }
                    readIterator() {
                        const e1 = super.readWord1();
                        const t = "@@" + e1;
                        if (!this.isIterator(e1) || !this.state.inType) {
                            this.raise(p.InvalidIdentifier, this.state.curPosition(), {
                                identifierName: t
                            });
                        }
                        this.finishToken(132, t);
                    }
                    getTokenFromCode(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (e1 === 123 && t === 124) {
                            this.finishOp(6, 2);
                        } else if (this.state.inType && (e1 === 62 || e1 === 60)) {
                            this.finishOp(e1 === 62 ? 48 : 47, 1);
                        } else if (this.state.inType && e1 === 63) {
                            if (t === 46) {
                                this.finishOp(18, 2);
                            } else {
                                this.finishOp(17, 1);
                            }
                        } else if (isIteratorStart(e1, t, this.input.charCodeAt(this.state.pos + 2))) {
                            this.state.pos += 2;
                            this.readIterator();
                        } else {
                            super.getTokenFromCode(e1);
                        }
                    }
                    isAssignable(e1, t) {
                        if (e1.type === "TypeCastExpression") {
                            return this.isAssignable(e1.expression, t);
                        } else {
                            return super.isAssignable(e1, t);
                        }
                    }
                    toAssignable(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        if (!t && e1.type === "AssignmentExpression" && e1.left.type === "TypeCastExpression") {
                            e1.left = this.typeCastToParameter(e1.left);
                        }
                        super.toAssignable(e1, t);
                    }
                    toAssignableList(e1, t, r) {
                        for(let t = 0; t < e1.length; t++){
                            const r = e1[t];
                            if ((r == null ? void 0 : r.type) === "TypeCastExpression") {
                                e1[t] = this.typeCastToParameter(r);
                            }
                        }
                        super.toAssignableList(e1, t, r);
                    }
                    toReferencedList(e1, t) {
                        for(let n = 0; n < e1.length; n++){
                            var r;
                            const s = e1[n];
                            if (s && s.type === "TypeCastExpression" && !((r = s.extra) != null && r.parenthesized) && (e1.length > 1 || !t)) {
                                this.raise(z.TypeCastInPattern, s.typeAnnotation);
                            }
                        }
                        return e1;
                    }
                    parseArrayLike(e1, t, r, n) {
                        const s = super.parseArrayLike(e1, t, r, n);
                        if (t && !this.state.maybeInArrowParameters) {
                            this.toReferencedList(s.elements);
                        }
                        return s;
                    }
                    isValidLVal(e1, t, r) {
                        return e1 === "TypeCastExpression" || super.isValidLVal(e1, t, r);
                    }
                    parseClassProperty(e1) {
                        if (this.match(14)) {
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        return super.parseClassProperty(e1);
                    }
                    parseClassPrivateProperty(e1) {
                        if (this.match(14)) {
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        return super.parseClassPrivateProperty(e1);
                    }
                    isClassMethod() {
                        return this.match(47) || super.isClassMethod();
                    }
                    isClassProperty() {
                        return this.match(14) || super.isClassProperty();
                    }
                    isNonstaticConstructor(e1) {
                        return !this.match(14) && super.isNonstaticConstructor(e1);
                    }
                    pushClassMethod(e1, t, r, n, s, i) {
                        if (t.variance) {
                            this.unexpected(t.variance.loc.start);
                        }
                        delete t.variance;
                        if (this.match(47)) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        super.pushClassMethod(e1, t, r, n, s, i);
                        if (t.params && s) {
                            const e1 = t.params;
                            if (e1.length > 0 && this.isThisParam(e1[0])) {
                                this.raise(z.ThisParamBannedInConstructor, t);
                            }
                        } else if (t.type === "MethodDefinition" && s && t.value.params) {
                            const e1 = t.value.params;
                            if (e1.length > 0 && this.isThisParam(e1[0])) {
                                this.raise(z.ThisParamBannedInConstructor, t);
                            }
                        }
                    }
                    pushClassPrivateMethod(e1, t, r, n) {
                        if (t.variance) {
                            this.unexpected(t.variance.loc.start);
                        }
                        delete t.variance;
                        if (this.match(47)) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        super.pushClassPrivateMethod(e1, t, r, n);
                    }
                    parseClassSuper(e1) {
                        super.parseClassSuper(e1);
                        if (e1.superClass && (this.match(47) || this.match(51))) {
                            {
                                e1.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
                            }
                        }
                        if (this.isContextual(113)) {
                            this.next();
                            const t = e1.implements = [];
                            do {
                                const e1 = this.startNode();
                                e1.id = this.flowParseRestrictedIdentifier(true);
                                if (this.match(47)) {
                                    e1.typeParameters = this.flowParseTypeParameterInstantiation();
                                } else {
                                    e1.typeParameters = null;
                                }
                                t.push(this.finishNode(e1, "ClassImplements"));
                            }while (this.eat(12))
                        }
                    }
                    checkGetterSetterParams(e1) {
                        super.checkGetterSetterParams(e1);
                        const t = this.getObjectOrClassMethodParams(e1);
                        if (t.length > 0) {
                            const r = t[0];
                            if (this.isThisParam(r) && e1.kind === "get") {
                                this.raise(z.GetterMayNotHaveThisParam, r);
                            } else if (this.isThisParam(r)) {
                                this.raise(z.SetterMayNotHaveThisParam, r);
                            }
                        }
                    }
                    parsePropertyNamePrefixOperator(e1) {
                        e1.variance = this.flowParseVariance();
                    }
                    parseObjPropValue(e1, t, r, n, s, i, a) {
                        if (e1.variance) {
                            this.unexpected(e1.variance.loc.start);
                        }
                        delete e1.variance;
                        let o;
                        if (this.match(47) && !i) {
                            o = this.flowParseTypeParameterDeclaration();
                            if (!this.match(10)) this.unexpected();
                        }
                        const l = super.parseObjPropValue(e1, t, r, n, s, i, a);
                        if (o) {
                            (l.value || l).typeParameters = o;
                        }
                        return l;
                    }
                    parseFunctionParamType(e1) {
                        if (this.eat(17)) {
                            if (e1.type !== "Identifier") {
                                this.raise(z.PatternIsOptional, e1);
                            }
                            if (this.isThisParam(e1)) {
                                this.raise(z.ThisParamMayNotBeOptional, e1);
                            }
                            e1.optional = true;
                        }
                        if (this.match(14)) {
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                        } else if (this.isThisParam(e1)) {
                            this.raise(z.ThisParamAnnotationRequired, e1);
                        }
                        if (this.match(29) && this.isThisParam(e1)) {
                            this.raise(z.ThisParamNoDefault, e1);
                        }
                        this.resetEndLocation(e1);
                        return e1;
                    }
                    parseMaybeDefault(e1, t) {
                        const r = super.parseMaybeDefault(e1, t);
                        if (r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start) {
                            this.raise(z.TypeBeforeInitializer, r.typeAnnotation);
                        }
                        return r;
                    }
                    checkImportReflection(e1) {
                        super.checkImportReflection(e1);
                        if (e1.module && e1.importKind !== "value") {
                            this.raise(z.ImportReflectionHasImportType, e1.specifiers[0].loc.start);
                        }
                    }
                    parseImportSpecifierLocal(e1, t, r) {
                        t.local = hasTypeImportKind(e1) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
                        e1.specifiers.push(this.finishImportSpecifier(t, r));
                    }
                    isPotentialImportPhase(e1) {
                        if (super.isPotentialImportPhase(e1)) return true;
                        if (this.isContextual(130)) {
                            if (!e1) return true;
                            const t = this.lookaheadCharCode();
                            return t === 123 || t === 42;
                        }
                        return !e1 && this.isContextual(87);
                    }
                    applyImportPhase(e1, t, r, n) {
                        super.applyImportPhase(e1, t, r, n);
                        if (t) {
                            if (!r && this.match(65)) {
                                return;
                            }
                            e1.exportKind = r === "type" ? r : "value";
                        } else {
                            if (r === "type" && this.match(55)) this.unexpected();
                            e1.importKind = r === "type" || r === "typeof" ? r : "value";
                        }
                    }
                    parseImportSpecifier(e1, t, r, n, s) {
                        const i = e1.imported;
                        let a = null;
                        if (i.type === "Identifier") {
                            if (i.name === "type") {
                                a = "type";
                            } else if (i.name === "typeof") {
                                a = "typeof";
                            }
                        }
                        let o = false;
                        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                            const t = this.parseIdentifier(true);
                            if (a !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                                e1.imported = t;
                                e1.importKind = a;
                                e1.local = cloneIdentifier(t);
                            } else {
                                e1.imported = i;
                                e1.importKind = null;
                                e1.local = this.parseIdentifier();
                            }
                        } else {
                            if (a !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                                e1.imported = this.parseIdentifier(true);
                                e1.importKind = a;
                            } else {
                                if (t) {
                                    throw this.raise(p.ImportBindingIsString, e1, {
                                        importName: i.value
                                    });
                                }
                                e1.imported = i;
                                e1.importKind = null;
                            }
                            if (this.eatContextual(93)) {
                                e1.local = this.parseIdentifier();
                            } else {
                                o = true;
                                e1.local = cloneIdentifier(e1.imported);
                            }
                        }
                        const l = hasTypeImportKind(e1);
                        if (r && l) {
                            this.raise(z.ImportTypeShorthandOnlyInPureImport, e1);
                        }
                        if (r || l) {
                            this.checkReservedType(e1.local.name, e1.local.loc.start, true);
                        }
                        if (o && !r && !l) {
                            this.checkReservedWord(e1.local.name, e1.loc.start, true, true);
                        }
                        return this.finishImportSpecifier(e1, "ImportSpecifier");
                    }
                    parseBindingAtom() {
                        switch(this.state.type){
                            case 78:
                                return this.parseIdentifier(true);
                            default:
                                return super.parseBindingAtom();
                        }
                    }
                    parseFunctionParams(e1, t) {
                        const r = e1.kind;
                        if (r !== "get" && r !== "set" && this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        super.parseFunctionParams(e1, t);
                    }
                    parseVarId(e1, t) {
                        super.parseVarId(e1, t);
                        if (this.match(14)) {
                            e1.id.typeAnnotation = this.flowParseTypeAnnotation();
                            this.resetEndLocation(e1.id);
                        }
                    }
                    parseAsyncArrowFromCallExpression(e1, t) {
                        if (this.match(14)) {
                            const t = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = true;
                            e1.returnType = this.flowParseTypeAnnotation();
                            this.state.noAnonFunctionType = t;
                        }
                        return super.parseAsyncArrowFromCallExpression(e1, t);
                    }
                    shouldParseAsyncArrow() {
                        return this.match(14) || super.shouldParseAsyncArrow();
                    }
                    parseMaybeAssign(e1, t) {
                        var r;
                        let n = null;
                        let s;
                        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
                            n = this.state.clone();
                            s = this.tryParse(()=>super.parseMaybeAssign(e1, t), n);
                            if (!s.error) return s.node;
                            const { context: r } = this.state;
                            const i = r[r.length - 1];
                            if (i === d.j_oTag || i === d.j_expr) {
                                r.pop();
                            }
                        }
                        if ((r = s) != null && r.error || this.match(47)) {
                            var i, a;
                            n = n || this.state.clone();
                            let r;
                            const o = this.tryParse((n)=>{
                                var s;
                                r = this.flowParseTypeParameterDeclaration();
                                const i = this.forwardNoArrowParamsConversionAt(r, ()=>{
                                    const n = super.parseMaybeAssign(e1, t);
                                    this.resetStartLocationFromNode(n, r);
                                    return n;
                                });
                                if ((s = i.extra) != null && s.parenthesized) n();
                                const a = this.maybeUnwrapTypeCastExpression(i);
                                if (a.type !== "ArrowFunctionExpression") n();
                                a.typeParameters = r;
                                this.resetStartLocationFromNode(a, r);
                                return i;
                            }, n);
                            let l = null;
                            if (o.node && this.maybeUnwrapTypeCastExpression(o.node).type === "ArrowFunctionExpression") {
                                if (!o.error && !o.aborted) {
                                    if (o.node.async) {
                                        this.raise(z.UnexpectedTypeParameterBeforeAsyncArrowFunction, r);
                                    }
                                    return o.node;
                                }
                                l = o.node;
                            }
                            if ((i = s) != null && i.node) {
                                this.state = s.failState;
                                return s.node;
                            }
                            if (l) {
                                this.state = o.failState;
                                return l;
                            }
                            if ((a = s) != null && a.thrown) throw s.error;
                            if (o.thrown) throw o.error;
                            throw this.raise(z.UnexpectedTokenAfterTypeParameter, r);
                        }
                        return super.parseMaybeAssign(e1, t);
                    }
                    parseArrow(e1) {
                        if (this.match(14)) {
                            const t = this.tryParse(()=>{
                                const t = this.state.noAnonFunctionType;
                                this.state.noAnonFunctionType = true;
                                const r = this.startNode();
                                [r.typeAnnotation, e1.predicate] = this.flowParseTypeAndPredicateInitialiser();
                                this.state.noAnonFunctionType = t;
                                if (this.canInsertSemicolon()) this.unexpected();
                                if (!this.match(19)) this.unexpected();
                                return r;
                            });
                            if (t.thrown) return null;
                            if (t.error) this.state = t.failState;
                            e1.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null;
                        }
                        return super.parseArrow(e1);
                    }
                    shouldParseArrow(e1) {
                        return this.match(14) || super.shouldParseArrow(e1);
                    }
                    setArrowFunctionParameters(e1, t) {
                        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e1.start))) {
                            e1.params = t;
                        } else {
                            super.setArrowFunctionParameters(e1, t);
                        }
                    }
                    checkParams(e1, t, r) {
                        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                        if (r && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e1.start))) {
                            return;
                        }
                        for(let t = 0; t < e1.params.length; t++){
                            if (this.isThisParam(e1.params[t]) && t > 0) {
                                this.raise(z.ThisParamMustBeFirst, e1.params[t]);
                            }
                        }
                        super.checkParams(e1, t, r, n);
                    }
                    parseParenAndDistinguishExpression(e1) {
                        return super.parseParenAndDistinguishExpression(e1 && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
                    }
                    parseSubscripts(e1, t, r) {
                        if (e1.type === "Identifier" && e1.name === "async" && this.state.noArrowAt.includes(t.index)) {
                            this.next();
                            const r = this.startNodeAt(t);
                            r.callee = e1;
                            r.arguments = super.parseCallExpressionArguments(11);
                            e1 = this.finishNode(r, "CallExpression");
                        } else if (e1.type === "Identifier" && e1.name === "async" && this.match(47)) {
                            const n = this.state.clone();
                            const s = this.tryParse((e1)=>this.parseAsyncArrowWithTypeParameters(t) || e1(), n);
                            if (!s.error && !s.aborted) return s.node;
                            const i = this.tryParse(()=>super.parseSubscripts(e1, t, r), n);
                            if (i.node && !i.error) return i.node;
                            if (s.node) {
                                this.state = s.failState;
                                return s.node;
                            }
                            if (i.node) {
                                this.state = i.failState;
                                return i.node;
                            }
                            throw s.error || i.error;
                        }
                        return super.parseSubscripts(e1, t, r);
                    }
                    parseSubscript(e1, t, r, n) {
                        if (this.match(18) && this.isLookaheadToken_lt()) {
                            n.optionalChainMember = true;
                            if (r) {
                                n.stop = true;
                                return e1;
                            }
                            this.next();
                            const s = this.startNodeAt(t);
                            s.callee = e1;
                            s.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
                            this.expect(10);
                            s.arguments = this.parseCallExpressionArguments(11);
                            s.optional = true;
                            return this.finishCallExpression(s, true);
                        } else if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
                            const r = this.startNodeAt(t);
                            r.callee = e1;
                            const s = this.tryParse(()=>{
                                r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                                this.expect(10);
                                r.arguments = super.parseCallExpressionArguments(11);
                                if (n.optionalChainMember) {
                                    r.optional = false;
                                }
                                return this.finishCallExpression(r, n.optionalChainMember);
                            });
                            if (s.node) {
                                if (s.error) this.state = s.failState;
                                return s.node;
                            }
                        }
                        return super.parseSubscript(e1, t, r, n);
                    }
                    parseNewCallee(e1) {
                        super.parseNewCallee(e1);
                        let t = null;
                        if (this.shouldParseTypes() && this.match(47)) {
                            t = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()).node;
                        }
                        e1.typeArguments = t;
                    }
                    parseAsyncArrowWithTypeParameters(e1) {
                        const t = this.startNodeAt(e1);
                        this.parseFunctionParams(t, false);
                        if (!this.parseArrow(t)) return;
                        return super.parseArrowExpression(t, undefined, true);
                    }
                    readToken_mult_modulo(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (e1 === 42 && t === 47 && this.state.hasFlowComment) {
                            this.state.hasFlowComment = false;
                            this.state.pos += 2;
                            this.nextToken();
                            return;
                        }
                        super.readToken_mult_modulo(e1);
                    }
                    readToken_pipe_amp(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (e1 === 124 && t === 125) {
                            this.finishOp(9, 2);
                            return;
                        }
                        super.readToken_pipe_amp(e1);
                    }
                    parseTopLevel(e1, t) {
                        const r = super.parseTopLevel(e1, t);
                        if (this.state.hasFlowComment) {
                            this.raise(z.UnterminatedFlowComment, this.state.curPosition());
                        }
                        return r;
                    }
                    skipBlockComment() {
                        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                            if (this.state.hasFlowComment) {
                                throw this.raise(z.NestedFlowComment, this.state.startLoc);
                            }
                            this.hasFlowCommentCompletion();
                            const e1 = this.skipFlowComment();
                            if (e1) {
                                this.state.pos += e1;
                                this.state.hasFlowComment = true;
                            }
                            return;
                        }
                        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
                    }
                    skipFlowComment() {
                        const { pos: e1 } = this.state;
                        let t = 2;
                        while([
                            32,
                            9
                        ].includes(this.input.charCodeAt(e1 + t))){
                            t++;
                        }
                        const r = this.input.charCodeAt(t + e1);
                        const n = this.input.charCodeAt(t + e1 + 1);
                        if (r === 58 && n === 58) {
                            return t + 2;
                        }
                        if (this.input.slice(t + e1, t + e1 + 12) === "flow-include") {
                            return t + 12;
                        }
                        if (r === 58 && n !== 58) {
                            return t;
                        }
                        return false;
                    }
                    hasFlowCommentCompletion() {
                        const e1 = this.input.indexOf("*/", this.state.pos);
                        if (e1 === -1) {
                            throw this.raise(p.UnterminatedComment, this.state.curPosition());
                        }
                    }
                    flowEnumErrorBooleanMemberNotInitialized(e1, param) {
                        let { enumName: t, memberName: r } = param;
                        this.raise(z.EnumBooleanMemberNotInitialized, e1, {
                            memberName: r,
                            enumName: t
                        });
                    }
                    flowEnumErrorInvalidMemberInitializer(e1, t) {
                        return this.raise(!t.explicitType ? z.EnumInvalidMemberInitializerUnknownType : t.explicitType === "symbol" ? z.EnumInvalidMemberInitializerSymbolType : z.EnumInvalidMemberInitializerPrimaryType, e1, t);
                    }
                    flowEnumErrorNumberMemberNotInitialized(e1, t) {
                        this.raise(z.EnumNumberMemberNotInitialized, e1, t);
                    }
                    flowEnumErrorStringMemberInconsistentlyInitialized(e1, t) {
                        this.raise(z.EnumStringMemberInconsistentlyInitialized, e1, t);
                    }
                    flowEnumMemberInit() {
                        const e1 = this.state.startLoc;
                        const endOfInit = ()=>this.match(12) || this.match(8);
                        switch(this.state.type){
                            case 135:
                                {
                                    const t = this.parseNumericLiteral(this.state.value);
                                    if (endOfInit()) {
                                        return {
                                            type: "number",
                                            loc: t.loc.start,
                                            value: t
                                        };
                                    }
                                    return {
                                        type: "invalid",
                                        loc: e1
                                    };
                                }
                            case 134:
                                {
                                    const t = this.parseStringLiteral(this.state.value);
                                    if (endOfInit()) {
                                        return {
                                            type: "string",
                                            loc: t.loc.start,
                                            value: t
                                        };
                                    }
                                    return {
                                        type: "invalid",
                                        loc: e1
                                    };
                                }
                            case 85:
                            case 86:
                                {
                                    const t = this.parseBooleanLiteral(this.match(85));
                                    if (endOfInit()) {
                                        return {
                                            type: "boolean",
                                            loc: t.loc.start,
                                            value: t
                                        };
                                    }
                                    return {
                                        type: "invalid",
                                        loc: e1
                                    };
                                }
                            default:
                                return {
                                    type: "invalid",
                                    loc: e1
                                };
                        }
                    }
                    flowEnumMemberRaw() {
                        const e1 = this.state.startLoc;
                        const t = this.parseIdentifier(true);
                        const r = this.eat(29) ? this.flowEnumMemberInit() : {
                            type: "none",
                            loc: e1
                        };
                        return {
                            id: t,
                            init: r
                        };
                    }
                    flowEnumCheckExplicitTypeMismatch(e1, t, r) {
                        const { explicitType: n } = t;
                        if (n === null) {
                            return;
                        }
                        if (n !== r) {
                            this.flowEnumErrorInvalidMemberInitializer(e1, t);
                        }
                    }
                    flowEnumMembers(param) {
                        let { enumName: e1, explicitType: t } = param;
                        const r = new Set;
                        const n = {
                            booleanMembers: [],
                            numberMembers: [],
                            stringMembers: [],
                            defaultedMembers: []
                        };
                        let s = false;
                        while(!this.match(8)){
                            if (this.eat(21)) {
                                s = true;
                                break;
                            }
                            const i = this.startNode();
                            const { id: a, init: o } = this.flowEnumMemberRaw();
                            const l = a.name;
                            if (l === "") {
                                continue;
                            }
                            if (/^[a-z]/.test(l)) {
                                this.raise(z.EnumInvalidMemberName, a, {
                                    memberName: l,
                                    suggestion: l[0].toUpperCase() + l.slice(1),
                                    enumName: e1
                                });
                            }
                            if (r.has(l)) {
                                this.raise(z.EnumDuplicateMemberName, a, {
                                    memberName: l,
                                    enumName: e1
                                });
                            }
                            r.add(l);
                            const c = {
                                enumName: e1,
                                explicitType: t,
                                memberName: l
                            };
                            i.id = a;
                            switch(o.type){
                                case "boolean":
                                    {
                                        this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "boolean");
                                        i.init = o.value;
                                        n.booleanMembers.push(this.finishNode(i, "EnumBooleanMember"));
                                        break;
                                    }
                                case "number":
                                    {
                                        this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "number");
                                        i.init = o.value;
                                        n.numberMembers.push(this.finishNode(i, "EnumNumberMember"));
                                        break;
                                    }
                                case "string":
                                    {
                                        this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "string");
                                        i.init = o.value;
                                        n.stringMembers.push(this.finishNode(i, "EnumStringMember"));
                                        break;
                                    }
                                case "invalid":
                                    {
                                        throw this.flowEnumErrorInvalidMemberInitializer(o.loc, c);
                                    }
                                case "none":
                                    {
                                        switch(t){
                                            case "boolean":
                                                this.flowEnumErrorBooleanMemberNotInitialized(o.loc, c);
                                                break;
                                            case "number":
                                                this.flowEnumErrorNumberMemberNotInitialized(o.loc, c);
                                                break;
                                            default:
                                                n.defaultedMembers.push(this.finishNode(i, "EnumDefaultedMember"));
                                        }
                                    }
                            }
                            if (!this.match(8)) {
                                this.expect(12);
                            }
                        }
                        return {
                            members: n,
                            hasUnknownMembers: s
                        };
                    }
                    flowEnumStringMembers(e1, t, param) {
                        let { enumName: r } = param;
                        if (e1.length === 0) {
                            return t;
                        } else if (t.length === 0) {
                            return e1;
                        } else if (t.length > e1.length) {
                            for (const t of e1){
                                this.flowEnumErrorStringMemberInconsistentlyInitialized(t, {
                                    enumName: r
                                });
                            }
                            return t;
                        } else {
                            for (const e1 of t){
                                this.flowEnumErrorStringMemberInconsistentlyInitialized(e1, {
                                    enumName: r
                                });
                            }
                            return e1;
                        }
                    }
                    flowEnumParseExplicitType(param) {
                        let { enumName: e1 } = param;
                        if (!this.eatContextual(102)) return null;
                        if (!tokenIsIdentifier(this.state.type)) {
                            throw this.raise(z.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
                                enumName: e1
                            });
                        }
                        const { value: t } = this.state;
                        this.next();
                        if (t !== "boolean" && t !== "number" && t !== "string" && t !== "symbol") {
                            this.raise(z.EnumInvalidExplicitType, this.state.startLoc, {
                                enumName: e1,
                                invalidEnumType: t
                            });
                        }
                        return t;
                    }
                    flowEnumBody(e1, t) {
                        const r = t.name;
                        const n = t.loc.start;
                        const s = this.flowEnumParseExplicitType({
                            enumName: r
                        });
                        this.expect(5);
                        const { members: i, hasUnknownMembers: a } = this.flowEnumMembers({
                            enumName: r,
                            explicitType: s
                        });
                        e1.hasUnknownMembers = a;
                        switch(s){
                            case "boolean":
                                e1.explicitType = true;
                                e1.members = i.booleanMembers;
                                this.expect(8);
                                return this.finishNode(e1, "EnumBooleanBody");
                            case "number":
                                e1.explicitType = true;
                                e1.members = i.numberMembers;
                                this.expect(8);
                                return this.finishNode(e1, "EnumNumberBody");
                            case "string":
                                e1.explicitType = true;
                                e1.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, {
                                    enumName: r
                                });
                                this.expect(8);
                                return this.finishNode(e1, "EnumStringBody");
                            case "symbol":
                                e1.members = i.defaultedMembers;
                                this.expect(8);
                                return this.finishNode(e1, "EnumSymbolBody");
                            default:
                                {
                                    const empty = ()=>{
                                        e1.members = [];
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumStringBody");
                                    };
                                    e1.explicitType = false;
                                    const t = i.booleanMembers.length;
                                    const s = i.numberMembers.length;
                                    const a = i.stringMembers.length;
                                    const o = i.defaultedMembers.length;
                                    if (!t && !s && !a && !o) {
                                        return empty();
                                    } else if (!t && !s) {
                                        e1.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, {
                                            enumName: r
                                        });
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumStringBody");
                                    } else if (!s && !a && t >= o) {
                                        for (const e1 of i.defaultedMembers){
                                            this.flowEnumErrorBooleanMemberNotInitialized(e1.loc.start, {
                                                enumName: r,
                                                memberName: e1.id.name
                                            });
                                        }
                                        e1.members = i.booleanMembers;
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumBooleanBody");
                                    } else if (!t && !a && s >= o) {
                                        for (const e1 of i.defaultedMembers){
                                            this.flowEnumErrorNumberMemberNotInitialized(e1.loc.start, {
                                                enumName: r,
                                                memberName: e1.id.name
                                            });
                                        }
                                        e1.members = i.numberMembers;
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumNumberBody");
                                    } else {
                                        this.raise(z.EnumInconsistentMemberValues, n, {
                                            enumName: r
                                        });
                                        return empty();
                                    }
                                }
                        }
                    }
                    flowParseEnumDeclaration(e1) {
                        const t = this.parseIdentifier();
                        e1.id = t;
                        e1.body = this.flowEnumBody(this.startNode(), t);
                        return this.finishNode(e1, "EnumDeclaration");
                    }
                    jsxParseOpeningElementAfterName(e1) {
                        if (this.shouldParseTypes()) {
                            if (this.match(47) || this.match(51)) {
                                e1.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
                            }
                        }
                        return super.jsxParseOpeningElementAfterName(e1);
                    }
                    isLookaheadToken_lt() {
                        const e1 = this.nextTokenStart();
                        if (this.input.charCodeAt(e1) === 60) {
                            const t = this.input.charCodeAt(e1 + 1);
                            return t !== 60 && t !== 61;
                        }
                        return false;
                    }
                    reScan_lt_gt() {
                        const { type: e1 } = this.state;
                        if (e1 === 47) {
                            this.state.pos -= 1;
                            this.readToken_lt();
                        } else if (e1 === 48) {
                            this.state.pos -= 1;
                            this.readToken_gt();
                        }
                    }
                    reScan_lt() {
                        const { type: e1 } = this.state;
                        if (e1 === 51) {
                            this.state.pos -= 2;
                            this.finishOp(47, 1);
                            return 47;
                        }
                        return e1;
                    }
                    maybeUnwrapTypeCastExpression(e1) {
                        return e1.type === "TypeCastExpression" ? e1.expression : e1;
                    }
                    constructor(...e1){
                        super(...e1);
                        this.flowPragma = undefined;
                    }
                }
                return FlowParserMixin;
            };
            const Q = {
                __proto__: null,
                quot: '"',
                amp: "&",
                apos: "'",
                lt: "<",
                gt: ">",
                nbsp: "",
                iexcl: "",
                cent: "",
                pound: "",
                curren: "",
                yen: "",
                brvbar: "",
                sect: "",
                uml: "",
                copy: "",
                ordf: "",
                laquo: "",
                not: "",
                shy: "",
                reg: "",
                macr: "",
                deg: "",
                plusmn: "",
                sup2: "",
                sup3: "",
                acute: "",
                micro: "",
                para: "",
                middot: "",
                cedil: "",
                sup1: "",
                ordm: "",
                raquo: "",
                frac14: "",
                frac12: "",
                frac34: "",
                iquest: "",
                Agrave: "",
                Aacute: "",
                Acirc: "",
                Atilde: "",
                Auml: "",
                Aring: "",
                AElig: "",
                Ccedil: "",
                Egrave: "",
                Eacute: "",
                Ecirc: "",
                Euml: "",
                Igrave: "",
                Iacute: "",
                Icirc: "",
                Iuml: "",
                ETH: "",
                Ntilde: "",
                Ograve: "",
                Oacute: "",
                Ocirc: "",
                Otilde: "",
                Ouml: "",
                times: "",
                Oslash: "",
                Ugrave: "",
                Uacute: "",
                Ucirc: "",
                Uuml: "",
                Yacute: "",
                THORN: "",
                szlig: "",
                agrave: "",
                aacute: "",
                acirc: "",
                atilde: "",
                auml: "",
                aring: "",
                aelig: "",
                ccedil: "",
                egrave: "",
                eacute: "",
                ecirc: "",
                euml: "",
                igrave: "",
                iacute: "",
                icirc: "",
                iuml: "",
                eth: "",
                ntilde: "",
                ograve: "",
                oacute: "",
                ocirc: "",
                otilde: "",
                ouml: "",
                divide: "",
                oslash: "",
                ugrave: "",
                uacute: "",
                ucirc: "",
                uuml: "",
                yacute: "",
                thorn: "",
                yuml: "",
                OElig: "",
                oelig: "",
                Scaron: "",
                scaron: "",
                Yuml: "",
                fnof: "",
                circ: "",
                tilde: "",
                Alpha: "",
                Beta: "",
                Gamma: "",
                Delta: "",
                Epsilon: "",
                Zeta: "",
                Eta: "",
                Theta: "",
                Iota: "",
                Kappa: "",
                Lambda: "",
                Mu: "",
                Nu: "",
                Xi: "",
                Omicron: "",
                Pi: "",
                Rho: "",
                Sigma: "",
                Tau: "",
                Upsilon: "",
                Phi: "",
                Chi: "",
                Psi: "",
                Omega: "",
                alpha: "",
                beta: "",
                gamma: "",
                delta: "",
                epsilon: "",
                zeta: "",
                eta: "",
                theta: "",
                iota: "",
                kappa: "",
                lambda: "",
                mu: "",
                nu: "",
                xi: "",
                omicron: "",
                pi: "",
                rho: "",
                sigmaf: "",
                sigma: "",
                tau: "",
                upsilon: "",
                phi: "",
                chi: "",
                psi: "",
                omega: "",
                thetasym: "",
                upsih: "",
                piv: "",
                ensp: "",
                emsp: "",
                thinsp: "",
                zwnj: "",
                zwj: "",
                lrm: "",
                rlm: "",
                ndash: "",
                mdash: "",
                lsquo: "",
                rsquo: "",
                sbquo: "",
                ldquo: "",
                rdquo: "",
                bdquo: "",
                dagger: "",
                Dagger: "",
                bull: "",
                hellip: "",
                permil: "",
                prime: "",
                Prime: "",
                lsaquo: "",
                rsaquo: "",
                oline: "",
                frasl: "",
                euro: "",
                image: "",
                weierp: "",
                real: "",
                trade: "",
                alefsym: "",
                larr: "",
                uarr: "",
                rarr: "",
                darr: "",
                harr: "",
                crarr: "",
                lArr: "",
                uArr: "",
                rArr: "",
                dArr: "",
                hArr: "",
                forall: "",
                part: "",
                exist: "",
                empty: "",
                nabla: "",
                isin: "",
                notin: "",
                ni: "",
                prod: "",
                sum: "",
                minus: "",
                lowast: "",
                radic: "",
                prop: "",
                infin: "",
                ang: "",
                and: "",
                or: "",
                cap: "",
                cup: "",
                int: "",
                there4: "",
                sim: "",
                cong: "",
                asymp: "",
                ne: "",
                equiv: "",
                le: "",
                ge: "",
                sub: "",
                sup: "",
                nsub: "",
                sube: "",
                supe: "",
                oplus: "",
                otimes: "",
                perp: "",
                sdot: "",
                lceil: "",
                rceil: "",
                lfloor: "",
                rfloor: "",
                lang: "",
                rang: "",
                loz: "",
                spades: "",
                clubs: "",
                hearts: "",
                diams: ""
            };
            const Z = ParseErrorEnum(_templateObject59())({
                AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
                MissingClosingTagElement: (param)=>{
                    let { openingTagName: e1 } = param;
                    return "Expected corresponding JSX closing tag for <".concat(e1, ">.");
                },
                MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
                UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
                UnexpectedToken: (param)=>{
                    let { unexpected: e1, HTMLEntity: t } = param;
                    return "Unexpected token `".concat(e1, "`. Did you mean `").concat(t, "` or `{'").concat(e1, "'}`?");
                },
                UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
                UnterminatedJsxContent: "Unterminated JSX contents.",
                UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
            });
            function isFragment(e1) {
                return e1 ? e1.type === "JSXOpeningFragment" || e1.type === "JSXClosingFragment" : false;
            }
            function getQualifiedJSXName(e1) {
                if (e1.type === "JSXIdentifier") {
                    return e1.name;
                }
                if (e1.type === "JSXNamespacedName") {
                    return e1.namespace.name + ":" + e1.name.name;
                }
                if (e1.type === "JSXMemberExpression") {
                    return getQualifiedJSXName(e1.object) + "." + getQualifiedJSXName(e1.property);
                }
                throw new Error("Node had unexpected type: " + e1.type);
            }
            var jsx = (e1)=>{
                class JSXParserMixin extends e1 {
                    jsxReadToken() {
                        let e1 = "";
                        let t = this.state.pos;
                        for(;;){
                            if (this.state.pos >= this.length) {
                                throw this.raise(Z.UnterminatedJsxContent, this.state.startLoc);
                            }
                            const r = this.input.charCodeAt(this.state.pos);
                            switch(r){
                                case 60:
                                case 123:
                                    if (this.state.pos === this.state.start) {
                                        if (r === 60 && this.state.canStartJSXElement) {
                                            ++this.state.pos;
                                            this.finishToken(143);
                                        } else {
                                            super.getTokenFromCode(r);
                                        }
                                        return;
                                    }
                                    e1 += this.input.slice(t, this.state.pos);
                                    this.finishToken(142, e1);
                                    return;
                                case 38:
                                    e1 += this.input.slice(t, this.state.pos);
                                    e1 += this.jsxReadEntity();
                                    t = this.state.pos;
                                    break;
                                case 62:
                                case 125:
                                default:
                                    if (isNewLine(r)) {
                                        e1 += this.input.slice(t, this.state.pos);
                                        e1 += this.jsxReadNewLine(true);
                                        t = this.state.pos;
                                    } else {
                                        ++this.state.pos;
                                    }
                            }
                        }
                    }
                    jsxReadNewLine(e1) {
                        const t = this.input.charCodeAt(this.state.pos);
                        let r;
                        ++this.state.pos;
                        if (t === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                            ++this.state.pos;
                            r = e1 ? "\n" : "\r\n";
                        } else {
                            r = String.fromCharCode(t);
                        }
                        ++this.state.curLine;
                        this.state.lineStart = this.state.pos;
                        return r;
                    }
                    jsxReadString(e1) {
                        let t = "";
                        let r = ++this.state.pos;
                        for(;;){
                            if (this.state.pos >= this.length) {
                                throw this.raise(p.UnterminatedString, this.state.startLoc);
                            }
                            const n = this.input.charCodeAt(this.state.pos);
                            if (n === e1) break;
                            if (n === 38) {
                                t += this.input.slice(r, this.state.pos);
                                t += this.jsxReadEntity();
                                r = this.state.pos;
                            } else if (isNewLine(n)) {
                                t += this.input.slice(r, this.state.pos);
                                t += this.jsxReadNewLine(false);
                                r = this.state.pos;
                            } else {
                                ++this.state.pos;
                            }
                        }
                        t += this.input.slice(r, this.state.pos++);
                        this.finishToken(134, t);
                    }
                    jsxReadEntity() {
                        const e1 = ++this.state.pos;
                        if (this.codePointAtPos(this.state.pos) === 35) {
                            ++this.state.pos;
                            let e1 = 10;
                            if (this.codePointAtPos(this.state.pos) === 120) {
                                e1 = 16;
                                ++this.state.pos;
                            }
                            const t = this.readInt(e1, undefined, false, "bail");
                            if (t !== null && this.codePointAtPos(this.state.pos) === 59) {
                                ++this.state.pos;
                                return String.fromCodePoint(t);
                            }
                        } else {
                            let t = 0;
                            let r = false;
                            while(t++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) === 59)){
                                ++this.state.pos;
                            }
                            if (r) {
                                const t = this.input.slice(e1, this.state.pos);
                                const r = Q[t];
                                ++this.state.pos;
                                if (r) {
                                    return r;
                                }
                            }
                        }
                        this.state.pos = e1;
                        return "&";
                    }
                    jsxReadWord() {
                        let e1;
                        const t = this.state.pos;
                        do {
                            e1 = this.input.charCodeAt(++this.state.pos);
                        }while (isIdentifierChar(e1) || e1 === 45)
                        this.finishToken(141, this.input.slice(t, this.state.pos));
                    }
                    jsxParseIdentifier() {
                        const e1 = this.startNode();
                        if (this.match(141)) {
                            e1.name = this.state.value;
                        } else if (tokenIsKeyword(this.state.type)) {
                            e1.name = tokenLabelName(this.state.type);
                        } else {
                            this.unexpected();
                        }
                        this.next();
                        return this.finishNode(e1, "JSXIdentifier");
                    }
                    jsxParseNamespacedName() {
                        const e1 = this.state.startLoc;
                        const t = this.jsxParseIdentifier();
                        if (!this.eat(14)) return t;
                        const r = this.startNodeAt(e1);
                        r.namespace = t;
                        r.name = this.jsxParseIdentifier();
                        return this.finishNode(r, "JSXNamespacedName");
                    }
                    jsxParseElementName() {
                        const e1 = this.state.startLoc;
                        let t = this.jsxParseNamespacedName();
                        if (t.type === "JSXNamespacedName") {
                            return t;
                        }
                        while(this.eat(16)){
                            const r = this.startNodeAt(e1);
                            r.object = t;
                            r.property = this.jsxParseIdentifier();
                            t = this.finishNode(r, "JSXMemberExpression");
                        }
                        return t;
                    }
                    jsxParseAttributeValue() {
                        let e1;
                        switch(this.state.type){
                            case 5:
                                e1 = this.startNode();
                                this.setContext(d.brace);
                                this.next();
                                e1 = this.jsxParseExpressionContainer(e1, d.j_oTag);
                                if (e1.expression.type === "JSXEmptyExpression") {
                                    this.raise(Z.AttributeIsEmpty, e1);
                                }
                                return e1;
                            case 143:
                            case 134:
                                return this.parseExprAtom();
                            default:
                                throw this.raise(Z.UnsupportedJsxValue, this.state.startLoc);
                        }
                    }
                    jsxParseEmptyExpression() {
                        const e1 = this.startNodeAt(this.state.lastTokEndLoc);
                        return this.finishNodeAt(e1, "JSXEmptyExpression", this.state.startLoc);
                    }
                    jsxParseSpreadChild(e1) {
                        this.next();
                        e1.expression = this.parseExpression();
                        this.setContext(d.j_expr);
                        this.state.canStartJSXElement = true;
                        this.expect(8);
                        return this.finishNode(e1, "JSXSpreadChild");
                    }
                    jsxParseExpressionContainer(e1, t) {
                        if (this.match(8)) {
                            e1.expression = this.jsxParseEmptyExpression();
                        } else {
                            const t = this.parseExpression();
                            e1.expression = t;
                        }
                        this.setContext(t);
                        this.state.canStartJSXElement = true;
                        this.expect(8);
                        return this.finishNode(e1, "JSXExpressionContainer");
                    }
                    jsxParseAttribute() {
                        const e1 = this.startNode();
                        if (this.match(5)) {
                            this.setContext(d.brace);
                            this.next();
                            this.expect(21);
                            e1.argument = this.parseMaybeAssignAllowIn();
                            this.setContext(d.j_oTag);
                            this.state.canStartJSXElement = true;
                            this.expect(8);
                            return this.finishNode(e1, "JSXSpreadAttribute");
                        }
                        e1.name = this.jsxParseNamespacedName();
                        e1.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
                        return this.finishNode(e1, "JSXAttribute");
                    }
                    jsxParseOpeningElementAt(e1) {
                        const t = this.startNodeAt(e1);
                        if (this.eat(144)) {
                            return this.finishNode(t, "JSXOpeningFragment");
                        }
                        t.name = this.jsxParseElementName();
                        return this.jsxParseOpeningElementAfterName(t);
                    }
                    jsxParseOpeningElementAfterName(e1) {
                        const t = [];
                        while(!this.match(56) && !this.match(144)){
                            t.push(this.jsxParseAttribute());
                        }
                        e1.attributes = t;
                        e1.selfClosing = this.eat(56);
                        this.expect(144);
                        return this.finishNode(e1, "JSXOpeningElement");
                    }
                    jsxParseClosingElementAt(e1) {
                        const t = this.startNodeAt(e1);
                        if (this.eat(144)) {
                            return this.finishNode(t, "JSXClosingFragment");
                        }
                        t.name = this.jsxParseElementName();
                        this.expect(144);
                        return this.finishNode(t, "JSXClosingElement");
                    }
                    jsxParseElementAt(e1) {
                        const t = this.startNodeAt(e1);
                        const r = [];
                        const n = this.jsxParseOpeningElementAt(e1);
                        let s = null;
                        if (!n.selfClosing) {
                            e1: for(;;){
                                switch(this.state.type){
                                    case 143:
                                        e1 = this.state.startLoc;
                                        this.next();
                                        if (this.eat(56)) {
                                            s = this.jsxParseClosingElementAt(e1);
                                            break e1;
                                        }
                                        r.push(this.jsxParseElementAt(e1));
                                        break;
                                    case 142:
                                        r.push(this.parseLiteral(this.state.value, "JSXText"));
                                        break;
                                    case 5:
                                        {
                                            const e1 = this.startNode();
                                            this.setContext(d.brace);
                                            this.next();
                                            if (this.match(21)) {
                                                r.push(this.jsxParseSpreadChild(e1));
                                            } else {
                                                r.push(this.jsxParseExpressionContainer(e1, d.j_expr));
                                            }
                                            break;
                                        }
                                    default:
                                        this.unexpected();
                                }
                            }
                            if (isFragment(n) && !isFragment(s) && s !== null) {
                                this.raise(Z.MissingClosingTagFragment, s);
                            } else if (!isFragment(n) && isFragment(s)) {
                                this.raise(Z.MissingClosingTagElement, s, {
                                    openingTagName: getQualifiedJSXName(n.name)
                                });
                            } else if (!isFragment(n) && !isFragment(s)) {
                                if (getQualifiedJSXName(s.name) !== getQualifiedJSXName(n.name)) {
                                    this.raise(Z.MissingClosingTagElement, s, {
                                        openingTagName: getQualifiedJSXName(n.name)
                                    });
                                }
                            }
                        }
                        if (isFragment(n)) {
                            t.openingFragment = n;
                            t.closingFragment = s;
                        } else {
                            t.openingElement = n;
                            t.closingElement = s;
                        }
                        t.children = r;
                        if (this.match(47)) {
                            throw this.raise(Z.UnwrappedAdjacentJSXElements, this.state.startLoc);
                        }
                        return isFragment(n) ? this.finishNode(t, "JSXFragment") : this.finishNode(t, "JSXElement");
                    }
                    jsxParseElement() {
                        const e1 = this.state.startLoc;
                        this.next();
                        return this.jsxParseElementAt(e1);
                    }
                    setContext(e1) {
                        const { context: t } = this.state;
                        t[t.length - 1] = e1;
                    }
                    parseExprAtom(e1) {
                        if (this.match(143)) {
                            return this.jsxParseElement();
                        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
                            this.replaceToken(143);
                            return this.jsxParseElement();
                        } else {
                            return super.parseExprAtom(e1);
                        }
                    }
                    skipSpace() {
                        const e1 = this.curContext();
                        if (!e1.preserveSpace) super.skipSpace();
                    }
                    getTokenFromCode(e1) {
                        const t = this.curContext();
                        if (t === d.j_expr) {
                            this.jsxReadToken();
                            return;
                        }
                        if (t === d.j_oTag || t === d.j_cTag) {
                            if (isIdentifierStart(e1)) {
                                this.jsxReadWord();
                                return;
                            }
                            if (e1 === 62) {
                                ++this.state.pos;
                                this.finishToken(144);
                                return;
                            }
                            if ((e1 === 34 || e1 === 39) && t === d.j_oTag) {
                                this.jsxReadString(e1);
                                return;
                            }
                        }
                        if (e1 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                            ++this.state.pos;
                            this.finishToken(143);
                            return;
                        }
                        super.getTokenFromCode(e1);
                    }
                    updateContext(e1) {
                        const { context: t, type: r } = this.state;
                        if (r === 56 && e1 === 143) {
                            t.splice(-2, 2, d.j_cTag);
                            this.state.canStartJSXElement = false;
                        } else if (r === 143) {
                            t.push(d.j_oTag);
                        } else if (r === 144) {
                            const r = t[t.length - 1];
                            if (r === d.j_oTag && e1 === 56 || r === d.j_cTag) {
                                t.pop();
                                this.state.canStartJSXElement = t[t.length - 1] === d.j_expr;
                            } else {
                                this.setContext(d.j_expr);
                                this.state.canStartJSXElement = true;
                            }
                        } else {
                            this.state.canStartJSXElement = tokenComesBeforeExpression(r);
                        }
                    }
                }
                return JSXParserMixin;
            };
            class TypeScriptScope extends Scope {
                constructor(...e1){
                    super(...e1);
                    this.tsNames = new Map;
                }
            }
            class TypeScriptScopeHandler extends ScopeHandler {
                createScope(e1) {
                    this.importsStack.push(new Set);
                    return new TypeScriptScope(e1);
                }
                enter(e1) {
                    if (e1 === 256) {
                        this.importsStack.push(new Set);
                    }
                    super.enter(e1);
                }
                exit() {
                    const e1 = super.exit();
                    if (e1 === 256) {
                        this.importsStack.pop();
                    }
                    return e1;
                }
                hasImport(e1, t) {
                    const r = this.importsStack.length;
                    if (this.importsStack[r - 1].has(e1)) {
                        return true;
                    }
                    if (!t && r > 1) {
                        for(let t = 0; t < r - 1; t++){
                            if (this.importsStack[t].has(e1)) return true;
                        }
                    }
                    return false;
                }
                declareName(e1, t, r) {
                    if (t & 4096) {
                        if (this.hasImport(e1, true)) {
                            this.parser.raise(p.VarRedeclaration, r, {
                                identifierName: e1
                            });
                        }
                        this.importsStack[this.importsStack.length - 1].add(e1);
                        return;
                    }
                    const n = this.currentScope();
                    let s = n.tsNames.get(e1) || 0;
                    if (t & 1024) {
                        this.maybeExportDefined(n, e1);
                        n.tsNames.set(e1, s | 16);
                        return;
                    }
                    super.declareName(e1, t, r);
                    if (t & 2) {
                        if (!(t & 1)) {
                            this.checkRedeclarationInScope(n, e1, t, r);
                            this.maybeExportDefined(n, e1);
                        }
                        s = s | 1;
                    }
                    if (t & 256) {
                        s = s | 2;
                    }
                    if (t & 512) {
                        s = s | 4;
                    }
                    if (t & 128) {
                        s = s | 8;
                    }
                    if (s) n.tsNames.set(e1, s);
                }
                isRedeclaredInScope(e1, t, r) {
                    const n = e1.tsNames.get(t);
                    if ((n & 2) > 0) {
                        if (r & 256) {
                            const e1 = !!(r & 512);
                            const t = (n & 4) > 0;
                            return e1 !== t;
                        }
                        return true;
                    }
                    if (r & 128 && (n & 8) > 0) {
                        if (e1.names.get(t) & 2) {
                            return !!(r & 1);
                        } else {
                            return false;
                        }
                    }
                    if (r & 2 && (n & 1) > 0) {
                        return true;
                    }
                    return super.isRedeclaredInScope(e1, t, r);
                }
                checkLocalExport(e1) {
                    const { name: t } = e1;
                    if (this.hasImport(t)) return;
                    const r = this.scopeStack.length;
                    for(let e1 = r - 1; e1 >= 0; e1--){
                        const r = this.scopeStack[e1];
                        const n = r.tsNames.get(t);
                        if ((n & 1) > 0 || (n & 16) > 0) {
                            return;
                        }
                    }
                    super.checkLocalExport(e1);
                }
                constructor(...e1){
                    super(...e1);
                    this.importsStack = [];
                }
            }
            const unwrapParenthesizedExpression = (e1)=>e1.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(e1.expression) : e1;
            class LValParser extends NodeUtils {
                toAssignable(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    var r, n;
                    let s = undefined;
                    if (e1.type === "ParenthesizedExpression" || (r = e1.extra) != null && r.parenthesized) {
                        s = unwrapParenthesizedExpression(e1);
                        if (t) {
                            if (s.type === "Identifier") {
                                this.expressionScope.recordArrowParameterBindingError(p.InvalidParenthesizedAssignment, e1);
                            } else if (s.type !== "MemberExpression" && !this.isOptionalMemberExpression(s)) {
                                this.raise(p.InvalidParenthesizedAssignment, e1);
                            }
                        } else {
                            this.raise(p.InvalidParenthesizedAssignment, e1);
                        }
                    }
                    switch(e1.type){
                        case "Identifier":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "AssignmentPattern":
                        case "RestElement":
                            break;
                        case "ObjectExpression":
                            e1.type = "ObjectPattern";
                            for(let r = 0, n = e1.properties.length, s = n - 1; r < n; r++){
                                var i;
                                const n = e1.properties[r];
                                const a = r === s;
                                this.toAssignableObjectExpressionProp(n, a, t);
                                if (a && n.type === "RestElement" && (i = e1.extra) != null && i.trailingCommaLoc) {
                                    this.raise(p.RestTrailingComma, e1.extra.trailingCommaLoc);
                                }
                            }
                            break;
                        case "ObjectProperty":
                            {
                                const { key: r, value: n } = e1;
                                if (this.isPrivateName(r)) {
                                    this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start);
                                }
                                this.toAssignable(n, t);
                                break;
                            }
                        case "SpreadElement":
                            {
                                throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
                            }
                        case "ArrayExpression":
                            e1.type = "ArrayPattern";
                            this.toAssignableList(e1.elements, (n = e1.extra) == null ? void 0 : n.trailingCommaLoc, t);
                            break;
                        case "AssignmentExpression":
                            if (e1.operator !== "=") {
                                this.raise(p.MissingEqInAssignment, e1.left.loc.end);
                            }
                            e1.type = "AssignmentPattern";
                            delete e1.operator;
                            this.toAssignable(e1.left, t);
                            break;
                        case "ParenthesizedExpression":
                            this.toAssignable(s, t);
                            break;
                    }
                }
                toAssignableObjectExpressionProp(e1, t, r) {
                    if (e1.type === "ObjectMethod") {
                        this.raise(e1.kind === "get" || e1.kind === "set" ? p.PatternHasAccessor : p.PatternHasMethod, e1.key);
                    } else if (e1.type === "SpreadElement") {
                        e1.type = "RestElement";
                        const n = e1.argument;
                        this.checkToRestConversion(n, false);
                        this.toAssignable(n, r);
                        if (!t) {
                            this.raise(p.RestTrailingComma, e1);
                        }
                    } else {
                        this.toAssignable(e1, r);
                    }
                }
                toAssignableList(e1, t, r) {
                    const n = e1.length - 1;
                    for(let s = 0; s <= n; s++){
                        const i = e1[s];
                        if (!i) continue;
                        this.toAssignableListItem(e1, s, r);
                        if (i.type === "RestElement") {
                            if (s < n) {
                                this.raise(p.RestTrailingComma, i);
                            } else if (t) {
                                this.raise(p.RestTrailingComma, t);
                            }
                        }
                    }
                }
                toAssignableListItem(e1, t, r) {
                    const n = e1[t];
                    if (n.type === "SpreadElement") {
                        n.type = "RestElement";
                        const e1 = n.argument;
                        this.checkToRestConversion(e1, true);
                        this.toAssignable(e1, r);
                    } else {
                        this.toAssignable(n, r);
                    }
                }
                isAssignable(e1, t) {
                    switch(e1.type){
                        case "Identifier":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "AssignmentPattern":
                        case "RestElement":
                            return true;
                        case "ObjectExpression":
                            {
                                const t = e1.properties.length - 1;
                                return e1.properties.every((e1, r)=>e1.type !== "ObjectMethod" && (r === t || e1.type !== "SpreadElement") && this.isAssignable(e1));
                            }
                        case "ObjectProperty":
                            return this.isAssignable(e1.value);
                        case "SpreadElement":
                            return this.isAssignable(e1.argument);
                        case "ArrayExpression":
                            return e1.elements.every((e1)=>e1 === null || this.isAssignable(e1));
                        case "AssignmentExpression":
                            return e1.operator === "=";
                        case "ParenthesizedExpression":
                            return this.isAssignable(e1.expression);
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                            return !t;
                        default:
                            return false;
                    }
                }
                toReferencedList(e1, t) {
                    return e1;
                }
                toReferencedListDeep(e1, t) {
                    this.toReferencedList(e1, t);
                    for (const t of e1){
                        if ((t == null ? void 0 : t.type) === "ArrayExpression") {
                            this.toReferencedListDeep(t.elements);
                        }
                    }
                }
                parseSpread(e1) {
                    const t = this.startNode();
                    this.next();
                    t.argument = this.parseMaybeAssignAllowIn(e1, undefined);
                    return this.finishNode(t, "SpreadElement");
                }
                parseRestBinding() {
                    const e1 = this.startNode();
                    this.next();
                    e1.argument = this.parseBindingAtom();
                    return this.finishNode(e1, "RestElement");
                }
                parseBindingAtom() {
                    switch(this.state.type){
                        case 0:
                            {
                                const e1 = this.startNode();
                                this.next();
                                e1.elements = this.parseBindingList(3, 93, 1);
                                return this.finishNode(e1, "ArrayPattern");
                            }
                        case 5:
                            return this.parseObjectLike(8, true);
                    }
                    return this.parseIdentifier();
                }
                parseBindingList(e1, t, r) {
                    const n = r & 1;
                    const s = [];
                    let i = true;
                    while(!this.eat(e1)){
                        if (i) {
                            i = false;
                        } else {
                            this.expect(12);
                        }
                        if (n && this.match(12)) {
                            s.push(null);
                        } else if (this.eat(e1)) {
                            break;
                        } else if (this.match(21)) {
                            let n = this.parseRestBinding();
                            if (this.hasPlugin("flow") || r & 2) {
                                n = this.parseFunctionParamType(n);
                            }
                            s.push(n);
                            if (!this.checkCommaAfterRest(t)) {
                                this.expect(e1);
                                break;
                            }
                        } else {
                            const e1 = [];
                            if (r & 2) {
                                if (this.match(26) && this.hasPlugin("decorators")) {
                                    this.raise(p.UnsupportedParameterDecorator, this.state.startLoc);
                                }
                                while(this.match(26)){
                                    e1.push(this.parseDecorator());
                                }
                            }
                            s.push(this.parseBindingElement(r, e1));
                        }
                    }
                    return s;
                }
                parseBindingRestProperty(e1) {
                    this.next();
                    e1.argument = this.parseIdentifier();
                    this.checkCommaAfterRest(125);
                    return this.finishNode(e1, "RestElement");
                }
                parseBindingProperty() {
                    const { type: e1, startLoc: t } = this.state;
                    if (e1 === 21) {
                        return this.parseBindingRestProperty(this.startNode());
                    }
                    const r = this.startNode();
                    if (e1 === 139) {
                        this.expectPlugin("destructuringPrivate", t);
                        this.classScope.usePrivateName(this.state.value, t);
                        r.key = this.parsePrivateName();
                    } else {
                        this.parsePropertyName(r);
                    }
                    r.method = false;
                    return this.parseObjPropValue(r, t, false, false, true, false);
                }
                parseBindingElement(e1, t) {
                    const r = this.parseMaybeDefault();
                    if (this.hasPlugin("flow") || e1 & 2) {
                        this.parseFunctionParamType(r);
                    }
                    const n = this.parseMaybeDefault(r.loc.start, r);
                    if (t.length) {
                        r.decorators = t;
                    }
                    return n;
                }
                parseFunctionParamType(e1) {
                    return e1;
                }
                parseMaybeDefault(e1, t) {
                    e1 != null ? e1 : e1 = this.state.startLoc;
                    t = t != null ? t : this.parseBindingAtom();
                    if (!this.eat(29)) return t;
                    const r = this.startNodeAt(e1);
                    r.left = t;
                    r.right = this.parseMaybeAssignAllowIn();
                    return this.finishNode(r, "AssignmentPattern");
                }
                isValidLVal(e1, t, r) {
                    switch(e1){
                        case "AssignmentPattern":
                            return "left";
                        case "RestElement":
                            return "argument";
                        case "ObjectProperty":
                            return "value";
                        case "ParenthesizedExpression":
                            return "expression";
                        case "ArrayPattern":
                            return "elements";
                        case "ObjectPattern":
                            return "properties";
                    }
                    return false;
                }
                isOptionalMemberExpression(e1) {
                    return e1.type === "OptionalMemberExpression";
                }
                checkLVal(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 64, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                    var a;
                    const o = e1.type;
                    if (this.isObjectMethod(e1)) return;
                    const l = this.isOptionalMemberExpression(e1);
                    if (l || o === "MemberExpression") {
                        if (l) {
                            this.expectPlugin("optionalChainingAssign", e1.loc.start);
                            if (t.type !== "AssignmentExpression") {
                                this.raise(p.InvalidLhsOptionalChaining, e1, {
                                    ancestor: t
                                });
                            }
                        }
                        if (r !== 64) {
                            this.raise(p.InvalidPropertyBindingPattern, e1);
                        }
                        return;
                    }
                    if (o === "Identifier") {
                        this.checkIdentifier(e1, r, s);
                        const { name: t } = e1;
                        if (n) {
                            if (n.has(t)) {
                                this.raise(p.ParamDupe, e1);
                            } else {
                                n.add(t);
                            }
                        }
                        return;
                    }
                    const c = this.isValidLVal(o, !(i || (a = e1.extra) != null && a.parenthesized) && t.type === "AssignmentExpression", r);
                    if (c === true) return;
                    if (c === false) {
                        const n = r === 64 ? p.InvalidLhs : p.InvalidLhsBinding;
                        this.raise(n, e1, {
                            ancestor: t
                        });
                        return;
                    }
                    let u, d;
                    if (typeof c === "string") {
                        u = c;
                        d = o === "ParenthesizedExpression";
                    } else {
                        [u, d] = c;
                    }
                    const f = o === "ArrayPattern" || o === "ObjectPattern" ? {
                        type: o
                    } : t;
                    const h = e1[u];
                    if (Array.isArray(h)) {
                        for (const e1 of h){
                            if (e1) {
                                this.checkLVal(e1, f, r, n, s, d);
                            }
                        }
                    } else if (h) {
                        this.checkLVal(h, f, r, n, s, d);
                    }
                }
                checkIdentifier(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    if (this.state.strict && (r ? isStrictBindReservedWord(e1.name, this.inModule) : isStrictBindOnlyReservedWord(e1.name))) {
                        if (t === 64) {
                            this.raise(p.StrictEvalArguments, e1, {
                                referenceName: e1.name
                            });
                        } else {
                            this.raise(p.StrictEvalArgumentsBinding, e1, {
                                bindingName: e1.name
                            });
                        }
                    }
                    if (t & 8192 && e1.name === "let") {
                        this.raise(p.LetInLexicalBinding, e1);
                    }
                    if (!(t & 64)) {
                        this.declareNameFromIdentifier(e1, t);
                    }
                }
                declareNameFromIdentifier(e1, t) {
                    this.scope.declareName(e1.name, t, e1.loc.start);
                }
                checkToRestConversion(e1, t) {
                    switch(e1.type){
                        case "ParenthesizedExpression":
                            this.checkToRestConversion(e1.expression, t);
                            break;
                        case "Identifier":
                        case "MemberExpression":
                            break;
                        case "ArrayExpression":
                        case "ObjectExpression":
                            if (t) break;
                        default:
                            this.raise(p.InvalidRestAssignmentPattern, e1);
                    }
                }
                checkCommaAfterRest(e1) {
                    if (!this.match(12)) {
                        return false;
                    }
                    this.raise(this.lookaheadCharCode() === e1 ? p.RestTrailingComma : p.ElementAfterRest, this.state.startLoc);
                    return true;
                }
            }
            function nonNull(e1) {
                if (e1 == null) {
                    throw new Error("Unexpected ".concat(e1, " value."));
                }
                return e1;
            }
            function assert(e1) {
                if (!e1) {
                    throw new Error("Assert fail");
                }
            }
            const ee = ParseErrorEnum(_templateObject60())({
                AbstractMethodHasImplementation: (param)=>{
                    let { methodName: e1 } = param;
                    return "Method '".concat(e1, "' cannot have an implementation because it is marked abstract.");
                },
                AbstractPropertyHasInitializer: (param)=>{
                    let { propertyName: e1 } = param;
                    return "Property '".concat(e1, "' cannot have an initializer because it is marked abstract.");
                },
                AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
                AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
                AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
                ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
                ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
                ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
                ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
                DeclareAccessor: (param)=>{
                    let { kind: e1 } = param;
                    return "'declare' is not allowed in ".concat(e1, "ters.");
                },
                DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
                DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
                DuplicateAccessibilityModifier: (param)=>{
                    let { modifier: e1 } = param;
                    return "Accessibility modifier already seen.";
                },
                DuplicateModifier: (param)=>{
                    let { modifier: e1 } = param;
                    return "Duplicate modifier: '".concat(e1, "'.");
                },
                EmptyHeritageClauseType: (param)=>{
                    let { token: e1 } = param;
                    return "'".concat(e1, "' list cannot be empty.");
                },
                EmptyTypeArguments: "Type argument list cannot be empty.",
                EmptyTypeParameters: "Type parameter list cannot be empty.",
                ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
                ImportAliasHasImportType: "An import alias can not use 'import type'.",
                ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
                IncompatibleModifiers: (param)=>{
                    let { modifiers: e1 } = param;
                    return "'".concat(e1[0], "' modifier cannot be used with '").concat(e1[1], "' modifier.");
                },
                IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
                IndexSignatureHasAccessibility: (param)=>{
                    let { modifier: e1 } = param;
                    return "Index signatures cannot have an accessibility modifier ('".concat(e1, "').");
                },
                IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
                IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
                IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
                InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
                InvalidHeritageClauseType: (param)=>{
                    let { token: e1 } = param;
                    return "'".concat(e1, "' list can only include identifiers or qualified-names with optional type arguments.");
                },
                InvalidModifierOnTypeMember: (param)=>{
                    let { modifier: e1 } = param;
                    return "'".concat(e1, "' modifier cannot appear on a type member.");
                },
                InvalidModifierOnTypeParameter: (param)=>{
                    let { modifier: e1 } = param;
                    return "'".concat(e1, "' modifier cannot appear on a type parameter.");
                },
                InvalidModifierOnTypeParameterPositions: (param)=>{
                    let { modifier: e1 } = param;
                    return "'".concat(e1, "' modifier can only appear on a type parameter of a class, interface or type alias.");
                },
                InvalidModifiersOrder: (param)=>{
                    let { orderedModifiers: e1 } = param;
                    return "'".concat(e1[0], "' modifier must precede '").concat(e1[1], "' modifier.");
                },
                InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
                InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
                MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
                NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
                NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
                OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
                OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
                PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
                PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
                PrivateElementHasAccessibility: (param)=>{
                    let { modifier: e1 } = param;
                    return "Private elements cannot have an accessibility modifier ('".concat(e1, "').");
                },
                ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
                ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
                ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
                SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
                SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
                SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
                SingleTypeParameterWithoutTrailingComma: (param)=>{
                    let { typeParameterName: e1 } = param;
                    return "Single type parameter ".concat(e1, " should have a trailing comma. Example usage: <").concat(e1, ",>.");
                },
                StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
                TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
                TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
                TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
                TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
                UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
                UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
                UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
                UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
                UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
                UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
                UnsupportedSignatureParameterKind: (param)=>{
                    let { type: e1 } = param;
                    return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(e1, ".");
                }
            });
            function keywordTypeFromName(e1) {
                switch(e1){
                    case "any":
                        return "TSAnyKeyword";
                    case "boolean":
                        return "TSBooleanKeyword";
                    case "bigint":
                        return "TSBigIntKeyword";
                    case "never":
                        return "TSNeverKeyword";
                    case "number":
                        return "TSNumberKeyword";
                    case "object":
                        return "TSObjectKeyword";
                    case "string":
                        return "TSStringKeyword";
                    case "symbol":
                        return "TSSymbolKeyword";
                    case "undefined":
                        return "TSUndefinedKeyword";
                    case "unknown":
                        return "TSUnknownKeyword";
                    default:
                        return undefined;
                }
            }
            function tsIsAccessModifier(e1) {
                return e1 === "private" || e1 === "public" || e1 === "protected";
            }
            function tsIsVarianceAnnotations(e1) {
                return e1 === "in" || e1 === "out";
            }
            var typescript = (e1)=>{
                class TypeScriptParserMixin extends e1 {
                    getScopeHandler() {
                        return TypeScriptScopeHandler;
                    }
                    tsIsIdentifier() {
                        return tokenIsIdentifier(this.state.type);
                    }
                    tsTokenCanFollowModifier() {
                        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
                    }
                    tsNextTokenOnSameLineAndCanFollowModifier() {
                        this.next();
                        if (this.hasPrecedingLineBreak()) {
                            return false;
                        }
                        return this.tsTokenCanFollowModifier();
                    }
                    tsNextTokenCanFollowModifier() {
                        if (this.match(106)) {
                            this.next();
                            return this.tsTokenCanFollowModifier();
                        }
                        return this.tsNextTokenOnSameLineAndCanFollowModifier();
                    }
                    tsParseModifier(e1, t) {
                        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
                            return undefined;
                        }
                        const r = this.state.value;
                        if (e1.includes(r)) {
                            if (t && this.tsIsStartOfStaticBlocks()) {
                                return undefined;
                            }
                            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                                return r;
                            }
                        }
                        return undefined;
                    }
                    tsParseModifiers(param, s) {
                        let { allowedModifiers: e1, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: n = ee.InvalidModifierOnTypeMember } = param;
                        const enforceOrder = (e1, t, r, n)=>{
                            if (t === r && s[n]) {
                                this.raise(ee.InvalidModifiersOrder, e1, {
                                    orderedModifiers: [
                                        r,
                                        n
                                    ]
                                });
                            }
                        };
                        const incompatible = (e1, t, r, n)=>{
                            if (s[r] && t === n || s[n] && t === r) {
                                this.raise(ee.IncompatibleModifiers, e1, {
                                    modifiers: [
                                        r,
                                        n
                                    ]
                                });
                            }
                        };
                        for(;;){
                            const { startLoc: i } = this.state;
                            const a = this.tsParseModifier(e1.concat(t != null ? t : []), r);
                            if (!a) break;
                            if (tsIsAccessModifier(a)) {
                                if (s.accessibility) {
                                    this.raise(ee.DuplicateAccessibilityModifier, i, {
                                        modifier: a
                                    });
                                } else {
                                    enforceOrder(i, a, a, "override");
                                    enforceOrder(i, a, a, "static");
                                    enforceOrder(i, a, a, "readonly");
                                    s.accessibility = a;
                                }
                            } else if (tsIsVarianceAnnotations(a)) {
                                if (s[a]) {
                                    this.raise(ee.DuplicateModifier, i, {
                                        modifier: a
                                    });
                                }
                                s[a] = true;
                                enforceOrder(i, a, "in", "out");
                            } else {
                                if (hasOwnProperty.call(s, a)) {
                                    this.raise(ee.DuplicateModifier, i, {
                                        modifier: a
                                    });
                                } else {
                                    enforceOrder(i, a, "static", "readonly");
                                    enforceOrder(i, a, "static", "override");
                                    enforceOrder(i, a, "override", "readonly");
                                    enforceOrder(i, a, "abstract", "override");
                                    incompatible(i, a, "declare", "override");
                                    incompatible(i, a, "static", "abstract");
                                }
                                s[a] = true;
                            }
                            if (t != null && t.includes(a)) {
                                this.raise(n, i, {
                                    modifier: a
                                });
                            }
                        }
                    }
                    tsIsListTerminator(e1) {
                        switch(e1){
                            case "EnumMembers":
                            case "TypeMembers":
                                return this.match(8);
                            case "HeritageClauseElement":
                                return this.match(5);
                            case "TupleElementTypes":
                                return this.match(3);
                            case "TypeParametersOrArguments":
                                return this.match(48);
                        }
                    }
                    tsParseList(e1, t) {
                        const r = [];
                        while(!this.tsIsListTerminator(e1)){
                            r.push(t());
                        }
                        return r;
                    }
                    tsParseDelimitedList(e1, t, r) {
                        return nonNull(this.tsParseDelimitedListWorker(e1, t, true, r));
                    }
                    tsParseDelimitedListWorker(e1, t, r, n) {
                        const s = [];
                        let i = -1;
                        for(;;){
                            if (this.tsIsListTerminator(e1)) {
                                break;
                            }
                            i = -1;
                            const n = t();
                            if (n == null) {
                                return undefined;
                            }
                            s.push(n);
                            if (this.eat(12)) {
                                i = this.state.lastTokStartLoc.index;
                                continue;
                            }
                            if (this.tsIsListTerminator(e1)) {
                                break;
                            }
                            if (r) {
                                this.expect(12);
                            }
                            return undefined;
                        }
                        if (n) {
                            n.value = i;
                        }
                        return s;
                    }
                    tsParseBracketedList(e1, t, r, n, s) {
                        if (!n) {
                            if (r) {
                                this.expect(0);
                            } else {
                                this.expect(47);
                            }
                        }
                        const i = this.tsParseDelimitedList(e1, t, s);
                        if (r) {
                            this.expect(3);
                        } else {
                            this.expect(48);
                        }
                        return i;
                    }
                    tsParseImportType() {
                        const e1 = this.startNode();
                        this.expect(83);
                        this.expect(10);
                        if (!this.match(134)) {
                            this.raise(ee.UnsupportedImportTypeArgument, this.state.startLoc);
                            {
                                e1.argument = super.parseExprAtom();
                            }
                        } else {
                            {
                                e1.argument = this.parseStringLiteral(this.state.value);
                            }
                        }
                        if (this.eat(12) && !this.match(11)) {
                            e1.options = super.parseMaybeAssignAllowIn();
                            this.eat(12);
                        } else {
                            e1.options = null;
                        }
                        this.expect(11);
                        if (this.eat(16)) {
                            e1.qualifier = this.tsParseEntityName(1 | 2);
                        }
                        if (this.match(47)) {
                            {
                                e1.typeParameters = this.tsParseTypeArguments();
                            }
                        }
                        return this.finishNode(e1, "TSImportType");
                    }
                    tsParseEntityName(e1) {
                        let t;
                        if (e1 & 1 && this.match(78)) {
                            if (e1 & 2) {
                                t = this.parseIdentifier(true);
                            } else {
                                const e1 = this.startNode();
                                this.next();
                                t = this.finishNode(e1, "ThisExpression");
                            }
                        } else {
                            t = this.parseIdentifier(!!(e1 & 1));
                        }
                        while(this.eat(16)){
                            const r = this.startNodeAtNode(t);
                            r.left = t;
                            r.right = this.parseIdentifier(!!(e1 & 1));
                            t = this.finishNode(r, "TSQualifiedName");
                        }
                        return t;
                    }
                    tsParseTypeReference() {
                        const e1 = this.startNode();
                        e1.typeName = this.tsParseEntityName(1);
                        if (!this.hasPrecedingLineBreak() && this.match(47)) {
                            {
                                e1.typeParameters = this.tsParseTypeArguments();
                            }
                        }
                        return this.finishNode(e1, "TSTypeReference");
                    }
                    tsParseThisTypePredicate(e1) {
                        this.next();
                        const t = this.startNodeAtNode(e1);
                        t.parameterName = e1;
                        t.typeAnnotation = this.tsParseTypeAnnotation(false);
                        t.asserts = false;
                        return this.finishNode(t, "TSTypePredicate");
                    }
                    tsParseThisTypeNode() {
                        const e1 = this.startNode();
                        this.next();
                        return this.finishNode(e1, "TSThisType");
                    }
                    tsParseTypeQuery() {
                        const e1 = this.startNode();
                        this.expect(87);
                        if (this.match(83)) {
                            e1.exprName = this.tsParseImportType();
                        } else {
                            {
                                e1.exprName = this.tsParseEntityName(1 | 2);
                            }
                        }
                        if (!this.hasPrecedingLineBreak() && this.match(47)) {
                            {
                                e1.typeParameters = this.tsParseTypeArguments();
                            }
                        }
                        return this.finishNode(e1, "TSTypeQuery");
                    }
                    tsParseTypeParameter(e1) {
                        const t = this.startNode();
                        e1(t);
                        t.name = this.tsParseTypeParameterName();
                        t.constraint = this.tsEatThenParseType(81);
                        t.default = this.tsEatThenParseType(29);
                        return this.finishNode(t, "TSTypeParameter");
                    }
                    tsTryParseTypeParameters(e1) {
                        if (this.match(47)) {
                            return this.tsParseTypeParameters(e1);
                        }
                    }
                    tsParseTypeParameters(e1) {
                        const t = this.startNode();
                        if (this.match(47) || this.match(143)) {
                            this.next();
                        } else {
                            this.unexpected();
                        }
                        const r = {
                            value: -1
                        };
                        t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e1), false, true, r);
                        if (t.params.length === 0) {
                            this.raise(ee.EmptyTypeParameters, t);
                        }
                        if (r.value !== -1) {
                            this.addExtra(t, "trailingComma", r.value);
                        }
                        return this.finishNode(t, "TSTypeParameterDeclaration");
                    }
                    tsFillSignature(e1, t) {
                        const r = e1 === 19;
                        const n = "parameters";
                        const s = "typeAnnotation";
                        t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        this.expect(10);
                        t[n] = this.tsParseBindingListForSignature();
                        if (r) {
                            t[s] = this.tsParseTypeOrTypePredicateAnnotation(e1);
                        } else if (this.match(e1)) {
                            t[s] = this.tsParseTypeOrTypePredicateAnnotation(e1);
                        }
                    }
                    tsParseBindingListForSignature() {
                        const e1 = super.parseBindingList(11, 41, 2);
                        for (const t of e1){
                            const { type: e1 } = t;
                            if (e1 === "AssignmentPattern" || e1 === "TSParameterProperty") {
                                this.raise(ee.UnsupportedSignatureParameterKind, t, {
                                    type: e1
                                });
                            }
                        }
                        return e1;
                    }
                    tsParseTypeMemberSemicolon() {
                        if (!this.eat(12) && !this.isLineTerminator()) {
                            this.expect(13);
                        }
                    }
                    tsParseSignatureMember(e1, t) {
                        this.tsFillSignature(14, t);
                        this.tsParseTypeMemberSemicolon();
                        return this.finishNode(t, e1);
                    }
                    tsIsUnambiguouslyIndexSignature() {
                        this.next();
                        if (tokenIsIdentifier(this.state.type)) {
                            this.next();
                            return this.match(14);
                        }
                        return false;
                    }
                    tsTryParseIndexSignature(e1) {
                        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                            return;
                        }
                        this.expect(0);
                        const t = this.parseIdentifier();
                        t.typeAnnotation = this.tsParseTypeAnnotation();
                        this.resetEndLocation(t);
                        this.expect(3);
                        e1.parameters = [
                            t
                        ];
                        const r = this.tsTryParseTypeAnnotation();
                        if (r) e1.typeAnnotation = r;
                        this.tsParseTypeMemberSemicolon();
                        return this.finishNode(e1, "TSIndexSignature");
                    }
                    tsParsePropertyOrMethodSignature(e1, t) {
                        if (this.eat(17)) e1.optional = true;
                        const r = e1;
                        if (this.match(10) || this.match(47)) {
                            if (t) {
                                this.raise(ee.ReadonlyForMethodSignature, e1);
                            }
                            const n = r;
                            if (n.kind && this.match(47)) {
                                this.raise(ee.AccessorCannotHaveTypeParameters, this.state.curPosition());
                            }
                            this.tsFillSignature(14, n);
                            this.tsParseTypeMemberSemicolon();
                            const s = "parameters";
                            const i = "typeAnnotation";
                            if (n.kind === "get") {
                                if (n[s].length > 0) {
                                    this.raise(p.BadGetterArity, this.state.curPosition());
                                    if (this.isThisParam(n[s][0])) {
                                        this.raise(ee.AccessorCannotDeclareThisParameter, this.state.curPosition());
                                    }
                                }
                            } else if (n.kind === "set") {
                                if (n[s].length !== 1) {
                                    this.raise(p.BadSetterArity, this.state.curPosition());
                                } else {
                                    const e1 = n[s][0];
                                    if (this.isThisParam(e1)) {
                                        this.raise(ee.AccessorCannotDeclareThisParameter, this.state.curPosition());
                                    }
                                    if (e1.type === "Identifier" && e1.optional) {
                                        this.raise(ee.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
                                    }
                                    if (e1.type === "RestElement") {
                                        this.raise(ee.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                                    }
                                }
                                if (n[i]) {
                                    this.raise(ee.SetAccessorCannotHaveReturnType, n[i]);
                                }
                            } else {
                                n.kind = "method";
                            }
                            return this.finishNode(n, "TSMethodSignature");
                        } else {
                            const e1 = r;
                            if (t) e1.readonly = true;
                            const n = this.tsTryParseTypeAnnotation();
                            if (n) e1.typeAnnotation = n;
                            this.tsParseTypeMemberSemicolon();
                            return this.finishNode(e1, "TSPropertySignature");
                        }
                    }
                    tsParseTypeMember() {
                        const e1 = this.startNode();
                        if (this.match(10) || this.match(47)) {
                            return this.tsParseSignatureMember("TSCallSignatureDeclaration", e1);
                        }
                        if (this.match(77)) {
                            const t = this.startNode();
                            this.next();
                            if (this.match(10) || this.match(47)) {
                                return this.tsParseSignatureMember("TSConstructSignatureDeclaration", e1);
                            } else {
                                e1.key = this.createIdentifier(t, "new");
                                return this.tsParsePropertyOrMethodSignature(e1, false);
                            }
                        }
                        this.tsParseModifiers({
                            allowedModifiers: [
                                "readonly"
                            ],
                            disallowedModifiers: [
                                "declare",
                                "abstract",
                                "private",
                                "protected",
                                "public",
                                "static",
                                "override"
                            ]
                        }, e1);
                        const t = this.tsTryParseIndexSignature(e1);
                        if (t) {
                            return t;
                        }
                        super.parsePropertyName(e1);
                        if (!e1.computed && e1.key.type === "Identifier" && (e1.key.name === "get" || e1.key.name === "set") && this.tsTokenCanFollowModifier()) {
                            e1.kind = e1.key.name;
                            super.parsePropertyName(e1);
                        }
                        return this.tsParsePropertyOrMethodSignature(e1, !!e1.readonly);
                    }
                    tsParseTypeLiteral() {
                        const e1 = this.startNode();
                        e1.members = this.tsParseObjectTypeMembers();
                        return this.finishNode(e1, "TSTypeLiteral");
                    }
                    tsParseObjectTypeMembers() {
                        this.expect(5);
                        const e1 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                        this.expect(8);
                        return e1;
                    }
                    tsIsStartOfMappedType() {
                        this.next();
                        if (this.eat(53)) {
                            return this.isContextual(122);
                        }
                        if (this.isContextual(122)) {
                            this.next();
                        }
                        if (!this.match(0)) {
                            return false;
                        }
                        this.next();
                        if (!this.tsIsIdentifier()) {
                            return false;
                        }
                        this.next();
                        return this.match(58);
                    }
                    tsParseMappedType() {
                        const e1 = this.startNode();
                        this.expect(5);
                        if (this.match(53)) {
                            e1.readonly = this.state.value;
                            this.next();
                            this.expectContextual(122);
                        } else if (this.eatContextual(122)) {
                            e1.readonly = true;
                        }
                        this.expect(0);
                        {
                            const t = this.startNode();
                            t.name = this.tsParseTypeParameterName();
                            t.constraint = this.tsExpectThenParseType(58);
                            e1.typeParameter = this.finishNode(t, "TSTypeParameter");
                        }
                        e1.nameType = this.eatContextual(93) ? this.tsParseType() : null;
                        this.expect(3);
                        if (this.match(53)) {
                            e1.optional = this.state.value;
                            this.next();
                            this.expect(17);
                        } else if (this.eat(17)) {
                            e1.optional = true;
                        }
                        e1.typeAnnotation = this.tsTryParseType();
                        this.semicolon();
                        this.expect(8);
                        return this.finishNode(e1, "TSMappedType");
                    }
                    tsParseTupleType() {
                        const e1 = this.startNode();
                        e1.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                        let t = false;
                        e1.elementTypes.forEach((e1)=>{
                            const { type: r } = e1;
                            if (t && r !== "TSRestType" && r !== "TSOptionalType" && !(r === "TSNamedTupleMember" && e1.optional)) {
                                this.raise(ee.OptionalTypeBeforeRequired, e1);
                            }
                            t || (t = r === "TSNamedTupleMember" && e1.optional || r === "TSOptionalType");
                        });
                        return this.finishNode(e1, "TSTupleType");
                    }
                    tsParseTupleElementType() {
                        const e1 = this.state.startLoc;
                        const t = this.eat(21);
                        const { startLoc: r } = this.state;
                        let n;
                        let s;
                        let i;
                        let a;
                        const o = tokenIsKeywordOrIdentifier(this.state.type);
                        const l = o ? this.lookaheadCharCode() : null;
                        if (l === 58) {
                            n = true;
                            i = false;
                            s = this.parseIdentifier(true);
                            this.expect(14);
                            a = this.tsParseType();
                        } else if (l === 63) {
                            i = true;
                            const e1 = this.state.value;
                            const t = this.tsParseNonArrayType();
                            if (this.lookaheadCharCode() === 58) {
                                n = true;
                                s = this.createIdentifier(this.startNodeAt(r), e1);
                                this.expect(17);
                                this.expect(14);
                                a = this.tsParseType();
                            } else {
                                n = false;
                                a = t;
                                this.expect(17);
                            }
                        } else {
                            a = this.tsParseType();
                            i = this.eat(17);
                            n = this.eat(14);
                        }
                        if (n) {
                            let e1;
                            if (s) {
                                e1 = this.startNodeAt(r);
                                e1.optional = i;
                                e1.label = s;
                                e1.elementType = a;
                                if (this.eat(17)) {
                                    e1.optional = true;
                                    this.raise(ee.TupleOptionalAfterType, this.state.lastTokStartLoc);
                                }
                            } else {
                                e1 = this.startNodeAt(r);
                                e1.optional = i;
                                this.raise(ee.InvalidTupleMemberLabel, a);
                                e1.label = a;
                                e1.elementType = this.tsParseType();
                            }
                            a = this.finishNode(e1, "TSNamedTupleMember");
                        } else if (i) {
                            const e1 = this.startNodeAt(r);
                            e1.typeAnnotation = a;
                            a = this.finishNode(e1, "TSOptionalType");
                        }
                        if (t) {
                            const t = this.startNodeAt(e1);
                            t.typeAnnotation = a;
                            a = this.finishNode(t, "TSRestType");
                        }
                        return a;
                    }
                    tsParseParenthesizedType() {
                        const e1 = this.startNode();
                        this.expect(10);
                        e1.typeAnnotation = this.tsParseType();
                        this.expect(11);
                        return this.finishNode(e1, "TSParenthesizedType");
                    }
                    tsParseFunctionOrConstructorType(e1, t) {
                        const r = this.startNode();
                        if (e1 === "TSConstructorType") {
                            r.abstract = !!t;
                            if (t) this.next();
                            this.next();
                        }
                        this.tsInAllowConditionalTypesContext(()=>this.tsFillSignature(19, r));
                        return this.finishNode(r, e1);
                    }
                    tsParseLiteralTypeNode() {
                        const e1 = this.startNode();
                        switch(this.state.type){
                            case 135:
                            case 136:
                            case 134:
                            case 85:
                            case 86:
                                e1.literal = super.parseExprAtom();
                                break;
                            default:
                                this.unexpected();
                        }
                        return this.finishNode(e1, "TSLiteralType");
                    }
                    tsParseTemplateLiteralType() {
                        {
                            const e1 = this.startNode();
                            e1.literal = super.parseTemplate(false);
                            return this.finishNode(e1, "TSLiteralType");
                        }
                    }
                    parseTemplateSubstitution() {
                        if (this.state.inType) return this.tsParseType();
                        return super.parseTemplateSubstitution();
                    }
                    tsParseThisTypeOrThisTypePredicate() {
                        const e1 = this.tsParseThisTypeNode();
                        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                            return this.tsParseThisTypePredicate(e1);
                        } else {
                            return e1;
                        }
                    }
                    tsParseNonArrayType() {
                        switch(this.state.type){
                            case 134:
                            case 135:
                            case 136:
                            case 85:
                            case 86:
                                return this.tsParseLiteralTypeNode();
                            case 53:
                                if (this.state.value === "-") {
                                    const e1 = this.startNode();
                                    const t = this.lookahead();
                                    if (t.type !== 135 && t.type !== 136) {
                                        this.unexpected();
                                    }
                                    e1.literal = this.parseMaybeUnary();
                                    return this.finishNode(e1, "TSLiteralType");
                                }
                                break;
                            case 78:
                                return this.tsParseThisTypeOrThisTypePredicate();
                            case 87:
                                return this.tsParseTypeQuery();
                            case 83:
                                return this.tsParseImportType();
                            case 5:
                                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                            case 0:
                                return this.tsParseTupleType();
                            case 10:
                                return this.tsParseParenthesizedType();
                            case 25:
                            case 24:
                                return this.tsParseTemplateLiteralType();
                            default:
                                {
                                    const { type: e1 } = this.state;
                                    if (tokenIsIdentifier(e1) || e1 === 88 || e1 === 84) {
                                        const t = e1 === 88 ? "TSVoidKeyword" : e1 === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                                        if (t !== undefined && this.lookaheadCharCode() !== 46) {
                                            const e1 = this.startNode();
                                            this.next();
                                            return this.finishNode(e1, t);
                                        }
                                        return this.tsParseTypeReference();
                                    }
                                }
                        }
                        this.unexpected();
                    }
                    tsParseArrayTypeOrHigher() {
                        const { startLoc: e1 } = this.state;
                        let t = this.tsParseNonArrayType();
                        while(!this.hasPrecedingLineBreak() && this.eat(0)){
                            if (this.match(3)) {
                                const r = this.startNodeAt(e1);
                                r.elementType = t;
                                this.expect(3);
                                t = this.finishNode(r, "TSArrayType");
                            } else {
                                const r = this.startNodeAt(e1);
                                r.objectType = t;
                                r.indexType = this.tsParseType();
                                this.expect(3);
                                t = this.finishNode(r, "TSIndexedAccessType");
                            }
                        }
                        return t;
                    }
                    tsParseTypeOperator() {
                        const e1 = this.startNode();
                        const t = this.state.value;
                        this.next();
                        e1.operator = t;
                        e1.typeAnnotation = this.tsParseTypeOperatorOrHigher();
                        if (t === "readonly") {
                            this.tsCheckTypeAnnotationForReadOnly(e1);
                        }
                        return this.finishNode(e1, "TSTypeOperator");
                    }
                    tsCheckTypeAnnotationForReadOnly(e1) {
                        switch(e1.typeAnnotation.type){
                            case "TSTupleType":
                            case "TSArrayType":
                                return;
                            default:
                                this.raise(ee.UnexpectedReadonly, e1);
                        }
                    }
                    tsParseInferType() {
                        const e1 = this.startNode();
                        this.expectContextual(115);
                        const t = this.startNode();
                        t.name = this.tsParseTypeParameterName();
                        t.constraint = this.tsTryParse(()=>this.tsParseConstraintForInferType());
                        e1.typeParameter = this.finishNode(t, "TSTypeParameter");
                        return this.finishNode(e1, "TSInferType");
                    }
                    tsParseConstraintForInferType() {
                        if (this.eat(81)) {
                            const e1 = this.tsInDisallowConditionalTypesContext(()=>this.tsParseType());
                            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
                                return e1;
                            }
                        }
                    }
                    tsParseTypeOperatorOrHigher() {
                        const e1 = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
                        return e1 ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(()=>this.tsParseArrayTypeOrHigher());
                    }
                    tsParseUnionOrIntersectionType(e1, t, r) {
                        const n = this.startNode();
                        const s = this.eat(r);
                        const i = [];
                        do {
                            i.push(t());
                        }while (this.eat(r))
                        if (i.length === 1 && !s) {
                            return i[0];
                        }
                        n.types = i;
                        return this.finishNode(n, e1);
                    }
                    tsParseIntersectionTypeOrHigher() {
                        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
                    }
                    tsParseUnionTypeOrHigher() {
                        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
                    }
                    tsIsStartOfFunctionType() {
                        if (this.match(47)) {
                            return true;
                        }
                        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                    }
                    tsSkipParameterStart() {
                        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                            this.next();
                            return true;
                        }
                        if (this.match(5)) {
                            const { errors: e1 } = this.state;
                            const t = e1.length;
                            try {
                                this.parseObjectLike(8, true);
                                return e1.length === t;
                            } catch (e1) {
                                return false;
                            }
                        }
                        if (this.match(0)) {
                            this.next();
                            const { errors: e1 } = this.state;
                            const t = e1.length;
                            try {
                                super.parseBindingList(3, 93, 1);
                                return e1.length === t;
                            } catch (e1) {
                                return false;
                            }
                        }
                        return false;
                    }
                    tsIsUnambiguouslyStartOfFunctionType() {
                        this.next();
                        if (this.match(11) || this.match(21)) {
                            return true;
                        }
                        if (this.tsSkipParameterStart()) {
                            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
                                return true;
                            }
                            if (this.match(11)) {
                                this.next();
                                if (this.match(19)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    tsParseTypeOrTypePredicateAnnotation(e1) {
                        return this.tsInType(()=>{
                            const t = this.startNode();
                            this.expect(e1);
                            const r = this.startNode();
                            const n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                            if (n && this.match(78)) {
                                let e1 = this.tsParseThisTypeOrThisTypePredicate();
                                if (e1.type === "TSThisType") {
                                    r.parameterName = e1;
                                    r.asserts = true;
                                    r.typeAnnotation = null;
                                    e1 = this.finishNode(r, "TSTypePredicate");
                                } else {
                                    this.resetStartLocationFromNode(e1, r);
                                    e1.asserts = true;
                                }
                                t.typeAnnotation = e1;
                                return this.finishNode(t, "TSTypeAnnotation");
                            }
                            const s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                            if (!s) {
                                if (!n) {
                                    return this.tsParseTypeAnnotation(false, t);
                                }
                                r.parameterName = this.parseIdentifier();
                                r.asserts = n;
                                r.typeAnnotation = null;
                                t.typeAnnotation = this.finishNode(r, "TSTypePredicate");
                                return this.finishNode(t, "TSTypeAnnotation");
                            }
                            const i = this.tsParseTypeAnnotation(false);
                            r.parameterName = s;
                            r.typeAnnotation = i;
                            r.asserts = n;
                            t.typeAnnotation = this.finishNode(r, "TSTypePredicate");
                            return this.finishNode(t, "TSTypeAnnotation");
                        });
                    }
                    tsTryParseTypeOrTypePredicateAnnotation() {
                        if (this.match(14)) {
                            return this.tsParseTypeOrTypePredicateAnnotation(14);
                        }
                    }
                    tsTryParseTypeAnnotation() {
                        if (this.match(14)) {
                            return this.tsParseTypeAnnotation();
                        }
                    }
                    tsTryParseType() {
                        return this.tsEatThenParseType(14);
                    }
                    tsParseTypePredicatePrefix() {
                        const e1 = this.parseIdentifier();
                        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                            this.next();
                            return e1;
                        }
                    }
                    tsParseTypePredicateAsserts() {
                        if (this.state.type !== 109) {
                            return false;
                        }
                        const e1 = this.state.containsEsc;
                        this.next();
                        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
                            return false;
                        }
                        if (e1) {
                            this.raise(p.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
                                reservedWord: "asserts"
                            });
                        }
                        return true;
                    }
                    tsParseTypeAnnotation() {
                        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
                        this.tsInType(()=>{
                            if (e1) this.expect(14);
                            t.typeAnnotation = this.tsParseType();
                        });
                        return this.finishNode(t, "TSTypeAnnotation");
                    }
                    tsParseType() {
                        assert(this.state.inType);
                        const e1 = this.tsParseNonConditionalType();
                        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
                            return e1;
                        }
                        const t = this.startNodeAtNode(e1);
                        t.checkType = e1;
                        t.extendsType = this.tsInDisallowConditionalTypesContext(()=>this.tsParseNonConditionalType());
                        this.expect(17);
                        t.trueType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType());
                        this.expect(14);
                        t.falseType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType());
                        return this.finishNode(t, "TSConditionalType");
                    }
                    isAbstractConstructorSignature() {
                        return this.isContextual(124) && this.lookahead().type === 77;
                    }
                    tsParseNonConditionalType() {
                        if (this.tsIsStartOfFunctionType()) {
                            return this.tsParseFunctionOrConstructorType("TSFunctionType");
                        }
                        if (this.match(77)) {
                            return this.tsParseFunctionOrConstructorType("TSConstructorType");
                        } else if (this.isAbstractConstructorSignature()) {
                            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
                        }
                        return this.tsParseUnionTypeOrHigher();
                    }
                    tsParseTypeAssertion() {
                        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                            this.raise(ee.ReservedTypeAssertion, this.state.startLoc);
                        }
                        const e1 = this.startNode();
                        e1.typeAnnotation = this.tsInType(()=>{
                            this.next();
                            return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
                        });
                        this.expect(48);
                        e1.expression = this.parseMaybeUnary();
                        return this.finishNode(e1, "TSTypeAssertion");
                    }
                    tsParseHeritageClause(e1) {
                        const t = this.state.startLoc;
                        const r = this.tsParseDelimitedList("HeritageClauseElement", ()=>{
                            {
                                const e1 = this.startNode();
                                e1.expression = this.tsParseEntityName(1 | 2);
                                if (this.match(47)) {
                                    e1.typeParameters = this.tsParseTypeArguments();
                                }
                                return this.finishNode(e1, "TSExpressionWithTypeArguments");
                            }
                        });
                        if (!r.length) {
                            this.raise(ee.EmptyHeritageClauseType, t, {
                                token: e1
                            });
                        }
                        return r;
                    }
                    tsParseInterfaceDeclaration(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        if (this.hasFollowingLineBreak()) return null;
                        this.expectContextual(129);
                        if (t.declare) e1.declare = true;
                        if (tokenIsIdentifier(this.state.type)) {
                            e1.id = this.parseIdentifier();
                            this.checkIdentifier(e1.id, 130);
                        } else {
                            e1.id = null;
                            this.raise(ee.MissingInterfaceName, this.state.startLoc);
                        }
                        e1.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                        if (this.eat(81)) {
                            e1.extends = this.tsParseHeritageClause("extends");
                        }
                        const r = this.startNode();
                        r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
                        e1.body = this.finishNode(r, "TSInterfaceBody");
                        return this.finishNode(e1, "TSInterfaceDeclaration");
                    }
                    tsParseTypeAliasDeclaration(e1) {
                        e1.id = this.parseIdentifier();
                        this.checkIdentifier(e1.id, 2);
                        e1.typeAnnotation = this.tsInType(()=>{
                            e1.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
                            this.expect(29);
                            if (this.isContextual(114) && this.lookahead().type !== 16) {
                                const e1 = this.startNode();
                                this.next();
                                return this.finishNode(e1, "TSIntrinsicKeyword");
                            }
                            return this.tsParseType();
                        });
                        this.semicolon();
                        return this.finishNode(e1, "TSTypeAliasDeclaration");
                    }
                    tsInTopLevelContext(e1) {
                        if (this.curContext() !== d.brace) {
                            const t = this.state.context;
                            this.state.context = [
                                t[0]
                            ];
                            try {
                                return e1();
                            } finally{
                                this.state.context = t;
                            }
                        } else {
                            return e1();
                        }
                    }
                    tsInType(e1) {
                        const t = this.state.inType;
                        this.state.inType = true;
                        try {
                            return e1();
                        } finally{
                            this.state.inType = t;
                        }
                    }
                    tsInDisallowConditionalTypesContext(e1) {
                        const t = this.state.inDisallowConditionalTypesContext;
                        this.state.inDisallowConditionalTypesContext = true;
                        try {
                            return e1();
                        } finally{
                            this.state.inDisallowConditionalTypesContext = t;
                        }
                    }
                    tsInAllowConditionalTypesContext(e1) {
                        const t = this.state.inDisallowConditionalTypesContext;
                        this.state.inDisallowConditionalTypesContext = false;
                        try {
                            return e1();
                        } finally{
                            this.state.inDisallowConditionalTypesContext = t;
                        }
                    }
                    tsEatThenParseType(e1) {
                        if (this.match(e1)) {
                            return this.tsNextThenParseType();
                        }
                    }
                    tsExpectThenParseType(e1) {
                        return this.tsInType(()=>{
                            this.expect(e1);
                            return this.tsParseType();
                        });
                    }
                    tsNextThenParseType() {
                        return this.tsInType(()=>{
                            this.next();
                            return this.tsParseType();
                        });
                    }
                    tsParseEnumMember() {
                        const e1 = this.startNode();
                        e1.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
                        if (this.eat(29)) {
                            e1.initializer = super.parseMaybeAssignAllowIn();
                        }
                        return this.finishNode(e1, "TSEnumMember");
                    }
                    tsParseEnumDeclaration(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        if (t.const) e1.const = true;
                        if (t.declare) e1.declare = true;
                        this.expectContextual(126);
                        e1.id = this.parseIdentifier();
                        this.checkIdentifier(e1.id, e1.const ? 8971 : 8459);
                        {
                            this.expect(5);
                            e1.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
                            this.expect(8);
                        }
                        return this.finishNode(e1, "TSEnumDeclaration");
                    }
                    tsParseEnumBody() {
                        const e1 = this.startNode();
                        this.expect(5);
                        e1.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
                        this.expect(8);
                        return this.finishNode(e1, "TSEnumBody");
                    }
                    tsParseModuleBlock() {
                        const e1 = this.startNode();
                        this.scope.enter(0);
                        this.expect(5);
                        super.parseBlockOrModuleBlockBody(e1.body = [], undefined, true, 8);
                        this.scope.exit();
                        return this.finishNode(e1, "TSModuleBlock");
                    }
                    tsParseModuleOrNamespaceDeclaration(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        e1.id = this.parseIdentifier();
                        if (!t) {
                            this.checkIdentifier(e1.id, 1024);
                        }
                        if (this.eat(16)) {
                            const t = this.startNode();
                            this.tsParseModuleOrNamespaceDeclaration(t, true);
                            e1.body = t;
                        } else {
                            this.scope.enter(256);
                            this.prodParam.enter(0);
                            e1.body = this.tsParseModuleBlock();
                            this.prodParam.exit();
                            this.scope.exit();
                        }
                        return this.finishNode(e1, "TSModuleDeclaration");
                    }
                    tsParseAmbientExternalModuleDeclaration(e1) {
                        if (this.isContextual(112)) {
                            e1.kind = "global";
                            {
                                e1.global = true;
                            }
                            e1.id = this.parseIdentifier();
                        } else if (this.match(134)) {
                            e1.kind = "module";
                            e1.id = super.parseStringLiteral(this.state.value);
                        } else {
                            this.unexpected();
                        }
                        if (this.match(5)) {
                            this.scope.enter(256);
                            this.prodParam.enter(0);
                            e1.body = this.tsParseModuleBlock();
                            this.prodParam.exit();
                            this.scope.exit();
                        } else {
                            this.semicolon();
                        }
                        return this.finishNode(e1, "TSModuleDeclaration");
                    }
                    tsParseImportEqualsDeclaration(e1, t, r) {
                        {
                            e1.isExport = r || false;
                        }
                        e1.id = t || this.parseIdentifier();
                        this.checkIdentifier(e1.id, 4096);
                        this.expect(29);
                        const n = this.tsParseModuleReference();
                        if (e1.importKind === "type" && n.type !== "TSExternalModuleReference") {
                            this.raise(ee.ImportAliasHasImportType, n);
                        }
                        e1.moduleReference = n;
                        this.semicolon();
                        return this.finishNode(e1, "TSImportEqualsDeclaration");
                    }
                    tsIsExternalModuleReference() {
                        return this.isContextual(119) && this.lookaheadCharCode() === 40;
                    }
                    tsParseModuleReference() {
                        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
                    }
                    tsParseExternalModuleReference() {
                        const e1 = this.startNode();
                        this.expectContextual(119);
                        this.expect(10);
                        if (!this.match(134)) {
                            this.unexpected();
                        }
                        e1.expression = super.parseExprAtom();
                        this.expect(11);
                        this.sawUnambiguousESM = true;
                        return this.finishNode(e1, "TSExternalModuleReference");
                    }
                    tsLookAhead(e1) {
                        const t = this.state.clone();
                        const r = e1();
                        this.state = t;
                        return r;
                    }
                    tsTryParseAndCatch(e1) {
                        const t = this.tryParse((t)=>e1() || t());
                        if (t.aborted || !t.node) return;
                        if (t.error) this.state = t.failState;
                        return t.node;
                    }
                    tsTryParse(e1) {
                        const t = this.state.clone();
                        const r = e1();
                        if (r !== undefined && r !== false) {
                            return r;
                        }
                        this.state = t;
                    }
                    tsTryParseDeclare(e1) {
                        if (this.isLineTerminator()) {
                            return;
                        }
                        let t = this.state.type;
                        let r;
                        if (this.isContextual(100)) {
                            t = 74;
                            r = "let";
                        }
                        return this.tsInAmbientContext(()=>{
                            switch(t){
                                case 68:
                                    e1.declare = true;
                                    return super.parseFunctionStatement(e1, false, false);
                                case 80:
                                    e1.declare = true;
                                    return this.parseClass(e1, true, false);
                                case 126:
                                    return this.tsParseEnumDeclaration(e1, {
                                        declare: true
                                    });
                                case 112:
                                    return this.tsParseAmbientExternalModuleDeclaration(e1);
                                case 75:
                                case 74:
                                    if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                                        e1.declare = true;
                                        return this.parseVarStatement(e1, r || this.state.value, true);
                                    }
                                    this.expect(75);
                                    return this.tsParseEnumDeclaration(e1, {
                                        const: true,
                                        declare: true
                                    });
                                case 129:
                                    {
                                        const t = this.tsParseInterfaceDeclaration(e1, {
                                            declare: true
                                        });
                                        if (t) return t;
                                    }
                                default:
                                    if (tokenIsIdentifier(t)) {
                                        return this.tsParseDeclaration(e1, this.state.value, true, null);
                                    }
                            }
                        });
                    }
                    tsTryParseExportDeclaration() {
                        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
                    }
                    tsParseExpressionStatement(e1, t, r) {
                        switch(t.name){
                            case "declare":
                                {
                                    const t = this.tsTryParseDeclare(e1);
                                    if (t) {
                                        t.declare = true;
                                    }
                                    return t;
                                }
                            case "global":
                                if (this.match(5)) {
                                    this.scope.enter(256);
                                    this.prodParam.enter(0);
                                    const r = e1;
                                    r.kind = "global";
                                    {
                                        e1.global = true;
                                    }
                                    r.id = t;
                                    r.body = this.tsParseModuleBlock();
                                    this.scope.exit();
                                    this.prodParam.exit();
                                    return this.finishNode(r, "TSModuleDeclaration");
                                }
                                break;
                            default:
                                return this.tsParseDeclaration(e1, t.name, false, r);
                        }
                    }
                    tsParseDeclaration(e1, t, r, n) {
                        switch(t){
                            case "abstract":
                                if (this.tsCheckLineTerminator(r) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                                    return this.tsParseAbstractDeclaration(e1, n);
                                }
                                break;
                            case "module":
                                if (this.tsCheckLineTerminator(r)) {
                                    if (this.match(134)) {
                                        return this.tsParseAmbientExternalModuleDeclaration(e1);
                                    } else if (tokenIsIdentifier(this.state.type)) {
                                        e1.kind = "module";
                                        return this.tsParseModuleOrNamespaceDeclaration(e1);
                                    }
                                }
                                break;
                            case "namespace":
                                if (this.tsCheckLineTerminator(r) && tokenIsIdentifier(this.state.type)) {
                                    e1.kind = "namespace";
                                    return this.tsParseModuleOrNamespaceDeclaration(e1);
                                }
                                break;
                            case "type":
                                if (this.tsCheckLineTerminator(r) && tokenIsIdentifier(this.state.type)) {
                                    return this.tsParseTypeAliasDeclaration(e1);
                                }
                                break;
                        }
                    }
                    tsCheckLineTerminator(e1) {
                        if (e1) {
                            if (this.hasFollowingLineBreak()) return false;
                            this.next();
                            return true;
                        }
                        return !this.isLineTerminator();
                    }
                    tsTryParseGenericAsyncArrowFunction(e1) {
                        if (!this.match(47)) return;
                        const t = this.state.maybeInArrowParameters;
                        this.state.maybeInArrowParameters = true;
                        const r = this.tsTryParseAndCatch(()=>{
                            const t = this.startNodeAt(e1);
                            t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
                            super.parseFunctionParams(t);
                            t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
                            this.expect(19);
                            return t;
                        });
                        this.state.maybeInArrowParameters = t;
                        if (!r) return;
                        return super.parseArrowExpression(r, null, true);
                    }
                    tsParseTypeArgumentsInExpression() {
                        if (this.reScan_lt() !== 47) return;
                        return this.tsParseTypeArguments();
                    }
                    tsParseTypeArguments() {
                        const e1 = this.startNode();
                        e1.params = this.tsInType(()=>this.tsInTopLevelContext(()=>{
                                this.expect(47);
                                return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
                            }));
                        if (e1.params.length === 0) {
                            this.raise(ee.EmptyTypeArguments, e1);
                        } else if (!this.state.inType && this.curContext() === d.brace) {
                            this.reScan_lt_gt();
                        }
                        this.expect(48);
                        return this.finishNode(e1, "TSTypeParameterInstantiation");
                    }
                    tsIsDeclarationStart() {
                        return tokenIsTSDeclarationStart(this.state.type);
                    }
                    isExportDefaultSpecifier() {
                        if (this.tsIsDeclarationStart()) return false;
                        return super.isExportDefaultSpecifier();
                    }
                    parseBindingElement(e1, t) {
                        const r = this.state.startLoc;
                        const n = {};
                        this.tsParseModifiers({
                            allowedModifiers: [
                                "public",
                                "private",
                                "protected",
                                "override",
                                "readonly"
                            ]
                        }, n);
                        const s = n.accessibility;
                        const i = n.override;
                        const a = n.readonly;
                        if (!(e1 & 4) && (s || a || i)) {
                            this.raise(ee.UnexpectedParameterModifier, r);
                        }
                        const o = this.parseMaybeDefault();
                        if (e1 & 2) {
                            this.parseFunctionParamType(o);
                        }
                        const l = this.parseMaybeDefault(o.loc.start, o);
                        if (s || a || i) {
                            const e1 = this.startNodeAt(r);
                            if (t.length) {
                                e1.decorators = t;
                            }
                            if (s) e1.accessibility = s;
                            if (a) e1.readonly = a;
                            if (i) e1.override = i;
                            if (l.type !== "Identifier" && l.type !== "AssignmentPattern") {
                                this.raise(ee.UnsupportedParameterPropertyKind, e1);
                            }
                            e1.parameter = l;
                            return this.finishNode(e1, "TSParameterProperty");
                        }
                        if (t.length) {
                            o.decorators = t;
                        }
                        return l;
                    }
                    isSimpleParameter(e1) {
                        return e1.type === "TSParameterProperty" && super.isSimpleParameter(e1.parameter) || super.isSimpleParameter(e1);
                    }
                    tsDisallowOptionalPattern(e1) {
                        for (const t of e1.params){
                            if (t.type !== "Identifier" && t.optional && !this.state.isAmbientContext) {
                                this.raise(ee.PatternIsOptional, t);
                            }
                        }
                    }
                    setArrowFunctionParameters(e1, t, r) {
                        super.setArrowFunctionParameters(e1, t, r);
                        this.tsDisallowOptionalPattern(e1);
                    }
                    parseFunctionBodyAndFinish(e1, t) {
                        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        if (this.match(14)) {
                            e1.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                        }
                        const n = t === "FunctionDeclaration" ? "TSDeclareFunction" : t === "ClassMethod" || t === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
                        if (n && !this.match(5) && this.isLineTerminator()) {
                            return this.finishNode(e1, n);
                        }
                        if (n === "TSDeclareFunction" && this.state.isAmbientContext) {
                            this.raise(ee.DeclareFunctionHasImplementation, e1);
                            if (e1.declare) {
                                return super.parseFunctionBodyAndFinish(e1, n, r);
                            }
                        }
                        this.tsDisallowOptionalPattern(e1);
                        return super.parseFunctionBodyAndFinish(e1, t, r);
                    }
                    registerFunctionStatementId(e1) {
                        if (!e1.body && e1.id) {
                            this.checkIdentifier(e1.id, 1024);
                        } else {
                            super.registerFunctionStatementId(e1);
                        }
                    }
                    tsCheckForInvalidTypeCasts(e1) {
                        e1.forEach((e1)=>{
                            if ((e1 == null ? void 0 : e1.type) === "TSTypeCastExpression") {
                                this.raise(ee.UnexpectedTypeAnnotation, e1.typeAnnotation);
                            }
                        });
                    }
                    toReferencedList(e1, t) {
                        this.tsCheckForInvalidTypeCasts(e1);
                        return e1;
                    }
                    parseArrayLike(e1, t, r, n) {
                        const s = super.parseArrayLike(e1, t, r, n);
                        if (s.type === "ArrayExpression") {
                            this.tsCheckForInvalidTypeCasts(s.elements);
                        }
                        return s;
                    }
                    parseSubscript(e1, t, r, n) {
                        if (!this.hasPrecedingLineBreak() && this.match(35)) {
                            this.state.canStartJSXElement = false;
                            this.next();
                            const r = this.startNodeAt(t);
                            r.expression = e1;
                            return this.finishNode(r, "TSNonNullExpression");
                        }
                        let s = false;
                        if (this.match(18) && this.lookaheadCharCode() === 60) {
                            if (r) {
                                n.stop = true;
                                return e1;
                            }
                            n.optionalChainMember = s = true;
                            this.next();
                        }
                        if (this.match(47) || this.match(51)) {
                            let i;
                            const a = this.tsTryParseAndCatch(()=>{
                                if (!r && this.atPossibleAsyncArrow(e1)) {
                                    const e1 = this.tsTryParseGenericAsyncArrowFunction(t);
                                    if (e1) {
                                        return e1;
                                    }
                                }
                                const a = this.tsParseTypeArgumentsInExpression();
                                if (!a) return;
                                if (s && !this.match(10)) {
                                    i = this.state.curPosition();
                                    return;
                                }
                                if (tokenIsTemplate(this.state.type)) {
                                    const r = super.parseTaggedTemplateExpression(e1, t, n);
                                    {
                                        r.typeParameters = a;
                                    }
                                    return r;
                                }
                                if (!r && this.eat(10)) {
                                    const r = this.startNodeAt(t);
                                    r.callee = e1;
                                    r.arguments = this.parseCallExpressionArguments(11);
                                    this.tsCheckForInvalidTypeCasts(r.arguments);
                                    {
                                        r.typeParameters = a;
                                    }
                                    if (n.optionalChainMember) {
                                        r.optional = s;
                                    }
                                    return this.finishCallExpression(r, n.optionalChainMember);
                                }
                                const o = this.state.type;
                                if (o === 48 || o === 52 || o !== 10 && tokenCanStartExpression(o) && !this.hasPrecedingLineBreak()) {
                                    return;
                                }
                                const l = this.startNodeAt(t);
                                l.expression = e1;
                                {
                                    l.typeParameters = a;
                                }
                                return this.finishNode(l, "TSInstantiationExpression");
                            });
                            if (i) {
                                this.unexpected(i, 10);
                            }
                            if (a) {
                                if (a.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                                    this.raise(ee.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
                                }
                                return a;
                            }
                        }
                        return super.parseSubscript(e1, t, r, n);
                    }
                    parseNewCallee(e1) {
                        var t;
                        super.parseNewCallee(e1);
                        const { callee: r } = e1;
                        if (r.type === "TSInstantiationExpression" && !((t = r.extra) != null && t.parenthesized)) {
                            {
                                e1.typeParameters = r.typeParameters;
                            }
                            e1.callee = r.expression;
                        }
                    }
                    parseExprOp(e1, t, r) {
                        let n;
                        if (tokenOperatorPrecedence(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
                            const s = this.startNodeAt(t);
                            s.expression = e1;
                            s.typeAnnotation = this.tsInType(()=>{
                                this.next();
                                if (this.match(75)) {
                                    if (n) {
                                        this.raise(p.UnexpectedKeyword, this.state.startLoc, {
                                            keyword: "const"
                                        });
                                    }
                                    return this.tsParseTypeReference();
                                }
                                return this.tsParseType();
                            });
                            this.finishNode(s, n ? "TSSatisfiesExpression" : "TSAsExpression");
                            this.reScan_lt_gt();
                            return this.parseExprOp(s, t, r);
                        }
                        return super.parseExprOp(e1, t, r);
                    }
                    checkReservedWord(e1, t, r, n) {
                        if (!this.state.isAmbientContext) {
                            super.checkReservedWord(e1, t, r, n);
                        }
                    }
                    checkImportReflection(e1) {
                        super.checkImportReflection(e1);
                        if (e1.module && e1.importKind !== "value") {
                            this.raise(ee.ImportReflectionHasImportType, e1.specifiers[0].loc.start);
                        }
                    }
                    checkDuplicateExports() {}
                    isPotentialImportPhase(e1) {
                        if (super.isPotentialImportPhase(e1)) return true;
                        if (this.isContextual(130)) {
                            const t = this.lookaheadCharCode();
                            return e1 ? t === 123 || t === 42 : t !== 61;
                        }
                        return !e1 && this.isContextual(87);
                    }
                    applyImportPhase(e1, t, r, n) {
                        super.applyImportPhase(e1, t, r, n);
                        if (t) {
                            e1.exportKind = r === "type" ? "type" : "value";
                        } else {
                            e1.importKind = r === "type" || r === "typeof" ? r : "value";
                        }
                    }
                    parseImport(e1) {
                        if (this.match(134)) {
                            e1.importKind = "value";
                            return super.parseImport(e1);
                        }
                        let t;
                        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
                            e1.importKind = "value";
                            return this.tsParseImportEqualsDeclaration(e1);
                        } else if (this.isContextual(130)) {
                            const r = this.parseMaybeImportPhase(e1, false);
                            if (this.lookaheadCharCode() === 61) {
                                return this.tsParseImportEqualsDeclaration(e1, r);
                            } else {
                                t = super.parseImportSpecifiersAndAfter(e1, r);
                            }
                        } else {
                            t = super.parseImport(e1);
                        }
                        if (t.importKind === "type" && t.specifiers.length > 1 && t.specifiers[0].type === "ImportDefaultSpecifier") {
                            this.raise(ee.TypeImportCannotSpecifyDefaultAndNamed, t);
                        }
                        return t;
                    }
                    parseExport(e1, t) {
                        if (this.match(83)) {
                            const t = e1;
                            this.next();
                            let r = null;
                            if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
                                r = this.parseMaybeImportPhase(t, false);
                            } else {
                                t.importKind = "value";
                            }
                            const n = this.tsParseImportEqualsDeclaration(t, r, true);
                            {
                                return n;
                            }
                        } else if (this.eat(29)) {
                            const t = e1;
                            t.expression = super.parseExpression();
                            this.semicolon();
                            this.sawUnambiguousESM = true;
                            return this.finishNode(t, "TSExportAssignment");
                        } else if (this.eatContextual(93)) {
                            const t = e1;
                            this.expectContextual(128);
                            t.id = this.parseIdentifier();
                            this.semicolon();
                            return this.finishNode(t, "TSNamespaceExportDeclaration");
                        } else {
                            return super.parseExport(e1, t);
                        }
                    }
                    isAbstractClass() {
                        return this.isContextual(124) && this.lookahead().type === 80;
                    }
                    parseExportDefaultExpression() {
                        if (this.isAbstractClass()) {
                            const e1 = this.startNode();
                            this.next();
                            e1.abstract = true;
                            return this.parseClass(e1, true, true);
                        }
                        if (this.match(129)) {
                            const e1 = this.tsParseInterfaceDeclaration(this.startNode());
                            if (e1) return e1;
                        }
                        return super.parseExportDefaultExpression();
                    }
                    parseVarStatement(e1, t) {
                        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        const { isAmbientContext: n } = this.state;
                        const s = super.parseVarStatement(e1, t, r || n);
                        if (!n) return s;
                        for (const { id: e1, init: r } of s.declarations){
                            if (!r) continue;
                            if (t !== "const" || !!e1.typeAnnotation) {
                                this.raise(ee.InitializerNotAllowedInAmbientContext, r);
                            } else if (!isValidAmbientConstInitializer(r, this.hasPlugin("estree"))) {
                                this.raise(ee.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, r);
                            }
                        }
                        return s;
                    }
                    parseStatementContent(e1, t) {
                        if (this.match(75) && this.isLookaheadContextual("enum")) {
                            const e1 = this.startNode();
                            this.expect(75);
                            return this.tsParseEnumDeclaration(e1, {
                                const: true
                            });
                        }
                        if (this.isContextual(126)) {
                            return this.tsParseEnumDeclaration(this.startNode());
                        }
                        if (this.isContextual(129)) {
                            const e1 = this.tsParseInterfaceDeclaration(this.startNode());
                            if (e1) return e1;
                        }
                        return super.parseStatementContent(e1, t);
                    }
                    parseAccessModifier() {
                        return this.tsParseModifier([
                            "public",
                            "protected",
                            "private"
                        ]);
                    }
                    tsHasSomeModifiers(e1, t) {
                        return t.some((t)=>{
                            if (tsIsAccessModifier(t)) {
                                return e1.accessibility === t;
                            }
                            return !!e1[t];
                        });
                    }
                    tsIsStartOfStaticBlocks() {
                        return this.isContextual(106) && this.lookaheadCharCode() === 123;
                    }
                    parseClassMember(e1, t, r) {
                        const n = [
                            "declare",
                            "private",
                            "public",
                            "protected",
                            "override",
                            "abstract",
                            "readonly",
                            "static"
                        ];
                        this.tsParseModifiers({
                            allowedModifiers: n,
                            disallowedModifiers: [
                                "in",
                                "out"
                            ],
                            stopOnStartOfClassStaticBlock: true,
                            errorTemplate: ee.InvalidModifierOnTypeParameterPositions
                        }, t);
                        const callParseClassMemberWithIsStatic = ()=>{
                            if (this.tsIsStartOfStaticBlocks()) {
                                this.next();
                                this.next();
                                if (this.tsHasSomeModifiers(t, n)) {
                                    this.raise(ee.StaticBlockCannotHaveModifier, this.state.curPosition());
                                }
                                super.parseClassStaticBlock(e1, t);
                            } else {
                                this.parseClassMemberWithIsStatic(e1, t, r, !!t.static);
                            }
                        };
                        if (t.declare) {
                            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
                        } else {
                            callParseClassMemberWithIsStatic();
                        }
                    }
                    parseClassMemberWithIsStatic(e1, t, r, n) {
                        const s = this.tsTryParseIndexSignature(t);
                        if (s) {
                            e1.body.push(s);
                            if (t.abstract) {
                                this.raise(ee.IndexSignatureHasAbstract, t);
                            }
                            if (t.accessibility) {
                                this.raise(ee.IndexSignatureHasAccessibility, t, {
                                    modifier: t.accessibility
                                });
                            }
                            if (t.declare) {
                                this.raise(ee.IndexSignatureHasDeclare, t);
                            }
                            if (t.override) {
                                this.raise(ee.IndexSignatureHasOverride, t);
                            }
                            return;
                        }
                        if (!this.state.inAbstractClass && t.abstract) {
                            this.raise(ee.NonAbstractClassHasAbstractMethod, t);
                        }
                        if (t.override) {
                            if (!r.hadSuperClass) {
                                this.raise(ee.OverrideNotInSubClass, t);
                            }
                        }
                        super.parseClassMemberWithIsStatic(e1, t, r, n);
                    }
                    parsePostMemberNameModifiers(e1) {
                        const t = this.eat(17);
                        if (t) e1.optional = true;
                        if (e1.readonly && this.match(10)) {
                            this.raise(ee.ClassMethodHasReadonly, e1);
                        }
                        if (e1.declare && this.match(10)) {
                            this.raise(ee.ClassMethodHasDeclare, e1);
                        }
                    }
                    parseExpressionStatement(e1, t, r) {
                        const n = t.type === "Identifier" ? this.tsParseExpressionStatement(e1, t, r) : undefined;
                        return n || super.parseExpressionStatement(e1, t, r);
                    }
                    shouldParseExportDeclaration() {
                        if (this.tsIsDeclarationStart()) return true;
                        return super.shouldParseExportDeclaration();
                    }
                    parseConditional(e1, t, r) {
                        if (!this.match(17)) return e1;
                        if (this.state.maybeInArrowParameters) {
                            const t = this.lookaheadCharCode();
                            if (t === 44 || t === 61 || t === 58 || t === 41) {
                                this.setOptionalParametersError(r);
                                return e1;
                            }
                        }
                        return super.parseConditional(e1, t, r);
                    }
                    parseParenItem(e1, t) {
                        const r = super.parseParenItem(e1, t);
                        if (this.eat(17)) {
                            r.optional = true;
                            this.resetEndLocation(e1);
                        }
                        if (this.match(14)) {
                            const r = this.startNodeAt(t);
                            r.expression = e1;
                            r.typeAnnotation = this.tsParseTypeAnnotation();
                            return this.finishNode(r, "TSTypeCastExpression");
                        }
                        return e1;
                    }
                    parseExportDeclaration(e1) {
                        if (!this.state.isAmbientContext && this.isContextual(125)) {
                            return this.tsInAmbientContext(()=>this.parseExportDeclaration(e1));
                        }
                        const t = this.state.startLoc;
                        const r = this.eatContextual(125);
                        if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
                            throw this.raise(ee.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
                        }
                        const n = tokenIsIdentifier(this.state.type);
                        const s = n && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e1);
                        if (!s) return null;
                        if (s.type === "TSInterfaceDeclaration" || s.type === "TSTypeAliasDeclaration" || r) {
                            e1.exportKind = "type";
                        }
                        if (r && s.type !== "TSImportEqualsDeclaration") {
                            this.resetStartLocation(s, t);
                            s.declare = true;
                        }
                        return s;
                    }
                    parseClassId(e1, t, r, n) {
                        if ((!t || r) && this.isContextual(113)) {
                            return;
                        }
                        super.parseClassId(e1, t, r, e1.declare ? 1024 : 8331);
                        const s = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                        if (s) e1.typeParameters = s;
                    }
                    parseClassPropertyAnnotation(e1) {
                        if (!e1.optional) {
                            if (this.eat(35)) {
                                e1.definite = true;
                            } else if (this.eat(17)) {
                                e1.optional = true;
                            }
                        }
                        const t = this.tsTryParseTypeAnnotation();
                        if (t) e1.typeAnnotation = t;
                    }
                    parseClassProperty(e1) {
                        this.parseClassPropertyAnnotation(e1);
                        if (this.state.isAmbientContext && !(e1.readonly && !e1.typeAnnotation) && this.match(29)) {
                            this.raise(ee.DeclareClassFieldHasInitializer, this.state.startLoc);
                        }
                        if (e1.abstract && this.match(29)) {
                            const { key: t } = e1;
                            this.raise(ee.AbstractPropertyHasInitializer, this.state.startLoc, {
                                propertyName: t.type === "Identifier" && !e1.computed ? t.name : "[".concat(this.input.slice(this.offsetToSourcePos(t.start), this.offsetToSourcePos(t.end)), "]")
                            });
                        }
                        return super.parseClassProperty(e1);
                    }
                    parseClassPrivateProperty(e1) {
                        if (e1.abstract) {
                            this.raise(ee.PrivateElementHasAbstract, e1);
                        }
                        if (e1.accessibility) {
                            this.raise(ee.PrivateElementHasAccessibility, e1, {
                                modifier: e1.accessibility
                            });
                        }
                        this.parseClassPropertyAnnotation(e1);
                        return super.parseClassPrivateProperty(e1);
                    }
                    parseClassAccessorProperty(e1) {
                        this.parseClassPropertyAnnotation(e1);
                        if (e1.optional) {
                            this.raise(ee.AccessorCannotBeOptional, e1);
                        }
                        return super.parseClassAccessorProperty(e1);
                    }
                    pushClassMethod(e1, t, r, n, s, i) {
                        const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (a && s) {
                            this.raise(ee.ConstructorHasTypeParameters, a);
                        }
                        const { declare: o = false, kind: l } = t;
                        if (o && (l === "get" || l === "set")) {
                            this.raise(ee.DeclareAccessor, t, {
                                kind: l
                            });
                        }
                        if (a) t.typeParameters = a;
                        super.pushClassMethod(e1, t, r, n, s, i);
                    }
                    pushClassPrivateMethod(e1, t, r, n) {
                        const s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (s) t.typeParameters = s;
                        super.pushClassPrivateMethod(e1, t, r, n);
                    }
                    declareClassPrivateMethodInScope(e1, t) {
                        if (e1.type === "TSDeclareMethod") return;
                        if (e1.type === "MethodDefinition" && !hasOwnProperty.call(e1.value, "body")) {
                            return;
                        }
                        super.declareClassPrivateMethodInScope(e1, t);
                    }
                    parseClassSuper(e1) {
                        super.parseClassSuper(e1);
                        if (e1.superClass && (this.match(47) || this.match(51))) {
                            {
                                e1.superTypeParameters = this.tsParseTypeArgumentsInExpression();
                            }
                        }
                        if (this.eatContextual(113)) {
                            e1.implements = this.tsParseHeritageClause("implements");
                        }
                    }
                    parseObjPropValue(e1, t, r, n, s, i, a) {
                        const o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (o) e1.typeParameters = o;
                        return super.parseObjPropValue(e1, t, r, n, s, i, a);
                    }
                    parseFunctionParams(e1, t) {
                        const r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (r) e1.typeParameters = r;
                        super.parseFunctionParams(e1, t);
                    }
                    parseVarId(e1, t) {
                        super.parseVarId(e1, t);
                        if (e1.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
                            e1.definite = true;
                        }
                        const r = this.tsTryParseTypeAnnotation();
                        if (r) {
                            e1.id.typeAnnotation = r;
                            this.resetEndLocation(e1.id);
                        }
                    }
                    parseAsyncArrowFromCallExpression(e1, t) {
                        if (this.match(14)) {
                            e1.returnType = this.tsParseTypeAnnotation();
                        }
                        return super.parseAsyncArrowFromCallExpression(e1, t);
                    }
                    parseMaybeAssign(e1, t) {
                        var r, n, s, i, a;
                        let o;
                        let l;
                        let c;
                        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
                            o = this.state.clone();
                            l = this.tryParse(()=>super.parseMaybeAssign(e1, t), o);
                            if (!l.error) return l.node;
                            const { context: r } = this.state;
                            const n = r[r.length - 1];
                            if (n === d.j_oTag || n === d.j_expr) {
                                r.pop();
                            }
                        }
                        if (!((r = l) != null && r.error) && !this.match(47)) {
                            return super.parseMaybeAssign(e1, t);
                        }
                        if (!o || o === this.state) o = this.state.clone();
                        let p;
                        const u = this.tryParse((r)=>{
                            var n, s;
                            p = this.tsParseTypeParameters(this.tsParseConstModifier);
                            const i = super.parseMaybeAssign(e1, t);
                            if (i.type !== "ArrowFunctionExpression" || (n = i.extra) != null && n.parenthesized) {
                                r();
                            }
                            if (((s = p) == null ? void 0 : s.params.length) !== 0) {
                                this.resetStartLocationFromNode(i, p);
                            }
                            i.typeParameters = p;
                            return i;
                        }, o);
                        if (!u.error && !u.aborted) {
                            if (p) this.reportReservedArrowTypeParam(p);
                            return u.node;
                        }
                        if (!l) {
                            assert(!this.hasPlugin("jsx"));
                            c = this.tryParse(()=>super.parseMaybeAssign(e1, t), o);
                            if (!c.error) return c.node;
                        }
                        if ((n = l) != null && n.node) {
                            this.state = l.failState;
                            return l.node;
                        }
                        if (u.node) {
                            this.state = u.failState;
                            if (p) this.reportReservedArrowTypeParam(p);
                            return u.node;
                        }
                        if ((s = c) != null && s.node) {
                            this.state = c.failState;
                            return c.node;
                        }
                        throw ((i = l) == null ? void 0 : i.error) || u.error || ((a = c) == null ? void 0 : a.error);
                    }
                    reportReservedArrowTypeParam(e1) {
                        var t;
                        if (e1.params.length === 1 && !e1.params[0].constraint && !((t = e1.extra) != null && t.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                            this.raise(ee.ReservedArrowTypeParam, e1);
                        }
                    }
                    parseMaybeUnary(e1, t) {
                        if (!this.hasPlugin("jsx") && this.match(47)) {
                            return this.tsParseTypeAssertion();
                        }
                        return super.parseMaybeUnary(e1, t);
                    }
                    parseArrow(e1) {
                        if (this.match(14)) {
                            const t = this.tryParse((e1)=>{
                                const t = this.tsParseTypeOrTypePredicateAnnotation(14);
                                if (this.canInsertSemicolon() || !this.match(19)) e1();
                                return t;
                            });
                            if (t.aborted) return;
                            if (!t.thrown) {
                                if (t.error) this.state = t.failState;
                                e1.returnType = t.node;
                            }
                        }
                        return super.parseArrow(e1);
                    }
                    parseFunctionParamType(e1) {
                        if (this.eat(17)) {
                            e1.optional = true;
                        }
                        const t = this.tsTryParseTypeAnnotation();
                        if (t) e1.typeAnnotation = t;
                        this.resetEndLocation(e1);
                        return e1;
                    }
                    isAssignable(e1, t) {
                        switch(e1.type){
                            case "TSTypeCastExpression":
                                return this.isAssignable(e1.expression, t);
                            case "TSParameterProperty":
                                return true;
                            default:
                                return super.isAssignable(e1, t);
                        }
                    }
                    toAssignable(e1) {
                        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        switch(e1.type){
                            case "ParenthesizedExpression":
                                this.toAssignableParenthesizedExpression(e1, t);
                                break;
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSNonNullExpression":
                            case "TSTypeAssertion":
                                if (t) {
                                    this.expressionScope.recordArrowParameterBindingError(ee.UnexpectedTypeCastInParameter, e1);
                                } else {
                                    this.raise(ee.UnexpectedTypeCastInParameter, e1);
                                }
                                this.toAssignable(e1.expression, t);
                                break;
                            case "AssignmentExpression":
                                if (!t && e1.left.type === "TSTypeCastExpression") {
                                    e1.left = this.typeCastToParameter(e1.left);
                                }
                            default:
                                super.toAssignable(e1, t);
                        }
                    }
                    toAssignableParenthesizedExpression(e1, t) {
                        switch(e1.expression.type){
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSNonNullExpression":
                            case "TSTypeAssertion":
                            case "ParenthesizedExpression":
                                this.toAssignable(e1.expression, t);
                                break;
                            default:
                                super.toAssignable(e1, t);
                        }
                    }
                    checkToRestConversion(e1, t) {
                        switch(e1.type){
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSTypeAssertion":
                            case "TSNonNullExpression":
                                this.checkToRestConversion(e1.expression, false);
                                break;
                            default:
                                super.checkToRestConversion(e1, t);
                        }
                    }
                    isValidLVal(e1, t, r) {
                        switch(e1){
                            case "TSTypeCastExpression":
                                return true;
                            case "TSParameterProperty":
                                return "parameter";
                            case "TSNonNullExpression":
                                return "expression";
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSTypeAssertion":
                                return (r !== 64 || !t) && [
                                    "expression",
                                    true
                                ];
                            default:
                                return super.isValidLVal(e1, t, r);
                        }
                    }
                    parseBindingAtom() {
                        if (this.state.type === 78) {
                            return this.parseIdentifier(true);
                        }
                        return super.parseBindingAtom();
                    }
                    parseMaybeDecoratorArguments(e1, t) {
                        if (this.match(47) || this.match(51)) {
                            const r = this.tsParseTypeArgumentsInExpression();
                            if (this.match(10)) {
                                const n = super.parseMaybeDecoratorArguments(e1, t);
                                {
                                    n.typeParameters = r;
                                }
                                return n;
                            }
                            this.unexpected(null, 10);
                        }
                        return super.parseMaybeDecoratorArguments(e1, t);
                    }
                    checkCommaAfterRest(e1) {
                        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e1) {
                            this.next();
                            return false;
                        }
                        return super.checkCommaAfterRest(e1);
                    }
                    isClassMethod() {
                        return this.match(47) || super.isClassMethod();
                    }
                    isClassProperty() {
                        return this.match(35) || this.match(14) || super.isClassProperty();
                    }
                    parseMaybeDefault(e1, t) {
                        const r = super.parseMaybeDefault(e1, t);
                        if (r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start) {
                            this.raise(ee.TypeAnnotationAfterAssign, r.typeAnnotation);
                        }
                        return r;
                    }
                    getTokenFromCode(e1) {
                        if (this.state.inType) {
                            if (e1 === 62) {
                                this.finishOp(48, 1);
                                return;
                            }
                            if (e1 === 60) {
                                this.finishOp(47, 1);
                                return;
                            }
                        }
                        super.getTokenFromCode(e1);
                    }
                    reScan_lt_gt() {
                        const { type: e1 } = this.state;
                        if (e1 === 47) {
                            this.state.pos -= 1;
                            this.readToken_lt();
                        } else if (e1 === 48) {
                            this.state.pos -= 1;
                            this.readToken_gt();
                        }
                    }
                    reScan_lt() {
                        const { type: e1 } = this.state;
                        if (e1 === 51) {
                            this.state.pos -= 2;
                            this.finishOp(47, 1);
                            return 47;
                        }
                        return e1;
                    }
                    toAssignableListItem(e1, t, r) {
                        const n = e1[t];
                        if (n.type === "TSTypeCastExpression") {
                            e1[t] = this.typeCastToParameter(n);
                        }
                        super.toAssignableListItem(e1, t, r);
                    }
                    typeCastToParameter(e1) {
                        e1.expression.typeAnnotation = e1.typeAnnotation;
                        this.resetEndLocation(e1.expression, e1.typeAnnotation.loc.end);
                        return e1.expression;
                    }
                    shouldParseArrow(e1) {
                        if (this.match(14)) {
                            return e1.every((e1)=>this.isAssignable(e1, true));
                        }
                        return super.shouldParseArrow(e1);
                    }
                    shouldParseAsyncArrow() {
                        return this.match(14) || super.shouldParseAsyncArrow();
                    }
                    canHaveLeadingDecorator() {
                        return super.canHaveLeadingDecorator() || this.isAbstractClass();
                    }
                    jsxParseOpeningElementAfterName(e1) {
                        if (this.match(47) || this.match(51)) {
                            const t = this.tsTryParseAndCatch(()=>this.tsParseTypeArgumentsInExpression());
                            if (t) {
                                {
                                    e1.typeParameters = t;
                                }
                            }
                        }
                        return super.jsxParseOpeningElementAfterName(e1);
                    }
                    getGetterSetterExpectedParamCount(e1) {
                        const t = super.getGetterSetterExpectedParamCount(e1);
                        const r = this.getObjectOrClassMethodParams(e1);
                        const n = r[0];
                        const s = n && this.isThisParam(n);
                        return s ? t + 1 : t;
                    }
                    parseCatchClauseParam() {
                        const e1 = super.parseCatchClauseParam();
                        const t = this.tsTryParseTypeAnnotation();
                        if (t) {
                            e1.typeAnnotation = t;
                            this.resetEndLocation(e1);
                        }
                        return e1;
                    }
                    tsInAmbientContext(e1) {
                        const { isAmbientContext: t, strict: r } = this.state;
                        this.state.isAmbientContext = true;
                        this.state.strict = false;
                        try {
                            return e1();
                        } finally{
                            this.state.isAmbientContext = t;
                            this.state.strict = r;
                        }
                    }
                    parseClass(e1, t, r) {
                        const n = this.state.inAbstractClass;
                        this.state.inAbstractClass = !!e1.abstract;
                        try {
                            return super.parseClass(e1, t, r);
                        } finally{
                            this.state.inAbstractClass = n;
                        }
                    }
                    tsParseAbstractDeclaration(e1, t) {
                        if (this.match(80)) {
                            e1.abstract = true;
                            return this.maybeTakeDecorators(t, this.parseClass(e1, true, false));
                        } else if (this.isContextual(129)) {
                            if (!this.hasFollowingLineBreak()) {
                                e1.abstract = true;
                                this.raise(ee.NonClassMethodPropertyHasAbstractModifer, e1);
                                return this.tsParseInterfaceDeclaration(e1);
                            }
                        } else {
                            this.unexpected(null, 80);
                        }
                    }
                    parseMethod(e1, t, r, n, s, i, a) {
                        const o = super.parseMethod(e1, t, r, n, s, i, a);
                        if (o.abstract) {
                            const e1 = this.hasPlugin("estree");
                            const t = e1 ? o.value : o;
                            if (t.body) {
                                const { key: e1 } = o;
                                this.raise(ee.AbstractMethodHasImplementation, o, {
                                    methodName: e1.type === "Identifier" && !o.computed ? e1.name : "[".concat(this.input.slice(this.offsetToSourcePos(e1.start), this.offsetToSourcePos(e1.end)), "]")
                                });
                            }
                        }
                        return o;
                    }
                    tsParseTypeParameterName() {
                        const e1 = this.parseIdentifier();
                        return e1.name;
                    }
                    shouldParseAsAmbientContext() {
                        return !!this.getPluginOption("typescript", "dts");
                    }
                    parse() {
                        if (this.shouldParseAsAmbientContext()) {
                            this.state.isAmbientContext = true;
                        }
                        return super.parse();
                    }
                    getExpression() {
                        if (this.shouldParseAsAmbientContext()) {
                            this.state.isAmbientContext = true;
                        }
                        return super.getExpression();
                    }
                    parseExportSpecifier(e1, t, r, n) {
                        if (!t && n) {
                            this.parseTypeOnlyImportExportSpecifier(e1, false, r);
                            return this.finishNode(e1, "ExportSpecifier");
                        }
                        e1.exportKind = "value";
                        return super.parseExportSpecifier(e1, t, r, n);
                    }
                    parseImportSpecifier(e1, t, r, n, s) {
                        if (!t && n) {
                            this.parseTypeOnlyImportExportSpecifier(e1, true, r);
                            return this.finishNode(e1, "ImportSpecifier");
                        }
                        e1.importKind = "value";
                        return super.parseImportSpecifier(e1, t, r, n, r ? 4098 : 4096);
                    }
                    parseTypeOnlyImportExportSpecifier(e1, t, r) {
                        const n = t ? "imported" : "local";
                        const s = t ? "local" : "exported";
                        let i = e1[n];
                        let a;
                        let o = false;
                        let l = true;
                        const c = i.loc.start;
                        if (this.isContextual(93)) {
                            const e1 = this.parseIdentifier();
                            if (this.isContextual(93)) {
                                const r = this.parseIdentifier();
                                if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                    o = true;
                                    i = e1;
                                    a = t ? this.parseIdentifier() : this.parseModuleExportName();
                                    l = false;
                                } else {
                                    a = r;
                                    l = false;
                                }
                            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                l = false;
                                a = t ? this.parseIdentifier() : this.parseModuleExportName();
                            } else {
                                o = true;
                                i = e1;
                            }
                        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                            o = true;
                            if (t) {
                                i = this.parseIdentifier(true);
                                if (!this.isContextual(93)) {
                                    this.checkReservedWord(i.name, i.loc.start, true, true);
                                }
                            } else {
                                i = this.parseModuleExportName();
                            }
                        }
                        if (o && r) {
                            this.raise(t ? ee.TypeModifierIsUsedInTypeImports : ee.TypeModifierIsUsedInTypeExports, c);
                        }
                        e1[n] = i;
                        e1[s] = a;
                        const p = t ? "importKind" : "exportKind";
                        e1[p] = o ? "type" : "value";
                        if (l && this.eatContextual(93)) {
                            e1[s] = t ? this.parseIdentifier() : this.parseModuleExportName();
                        }
                        if (!e1[s]) {
                            e1[s] = cloneIdentifier(e1[n]);
                        }
                        if (t) {
                            this.checkIdentifier(e1[s], o ? 4098 : 4096);
                        }
                    }
                    constructor(...e1){
                        super(...e1);
                        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
                            allowedModifiers: [
                                "in",
                                "out"
                            ],
                            disallowedModifiers: [
                                "const",
                                "public",
                                "private",
                                "protected",
                                "readonly",
                                "declare",
                                "abstract",
                                "override"
                            ],
                            errorTemplate: ee.InvalidModifierOnTypeParameter
                        });
                        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
                            allowedModifiers: [
                                "const"
                            ],
                            disallowedModifiers: [
                                "in",
                                "out"
                            ],
                            errorTemplate: ee.InvalidModifierOnTypeParameterPositions
                        });
                        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
                            allowedModifiers: [
                                "in",
                                "out",
                                "const"
                            ],
                            disallowedModifiers: [
                                "public",
                                "private",
                                "protected",
                                "readonly",
                                "declare",
                                "abstract",
                                "override"
                            ],
                            errorTemplate: ee.InvalidModifierOnTypeParameter
                        });
                    }
                }
                return TypeScriptParserMixin;
            };
            function isPossiblyLiteralEnum(e1) {
                if (e1.type !== "MemberExpression") return false;
                const { computed: t, property: r } = e1;
                if (t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0)) {
                    return false;
                }
                return isUncomputedMemberExpressionChain(e1.object);
            }
            function isValidAmbientConstInitializer(e1, t) {
                var r;
                const { type: n } = e1;
                if ((r = e1.extra) != null && r.parenthesized) {
                    return false;
                }
                if (t) {
                    if (n === "Literal") {
                        const { value: t } = e1;
                        if (typeof t === "string" || typeof t === "boolean") {
                            return true;
                        }
                    }
                } else {
                    if (n === "StringLiteral" || n === "BooleanLiteral") {
                        return true;
                    }
                }
                if (isNumber(e1, t) || isNegativeNumber(e1, t)) {
                    return true;
                }
                if (n === "TemplateLiteral" && e1.expressions.length === 0) {
                    return true;
                }
                if (isPossiblyLiteralEnum(e1)) {
                    return true;
                }
                return false;
            }
            function isNumber(e1, t) {
                if (t) {
                    return e1.type === "Literal" && (typeof e1.value === "number" || "bigint" in e1);
                }
                return e1.type === "NumericLiteral" || e1.type === "BigIntLiteral";
            }
            function isNegativeNumber(e1, t) {
                if (e1.type === "UnaryExpression") {
                    const { operator: r, argument: n } = e1;
                    if (r === "-" && isNumber(n, t)) {
                        return true;
                    }
                }
                return false;
            }
            function isUncomputedMemberExpressionChain(e1) {
                if (e1.type === "Identifier") return true;
                if (e1.type !== "MemberExpression" || e1.computed) {
                    return false;
                }
                return isUncomputedMemberExpressionChain(e1.object);
            }
            const te = ParseErrorEnum(_templateObject61())({
                ClassNameIsRequired: "A class name is required.",
                UnexpectedSpace: "Unexpected space in placeholder."
            });
            var placeholders = (e1)=>{
                class PlaceholdersParserMixin extends e1 {
                    parsePlaceholder(e1) {
                        if (this.match(133)) {
                            const t = this.startNode();
                            this.next();
                            this.assertNoSpace();
                            t.name = super.parseIdentifier(true);
                            this.assertNoSpace();
                            this.expect(133);
                            return this.finishPlaceholder(t, e1);
                        }
                    }
                    finishPlaceholder(e1, t) {
                        let r = e1;
                        if (!r.expectedNode || !r.type) {
                            r = this.finishNode(r, "Placeholder");
                        }
                        r.expectedNode = t;
                        return r;
                    }
                    getTokenFromCode(e1) {
                        if (e1 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                            this.finishOp(133, 2);
                        } else {
                            super.getTokenFromCode(e1);
                        }
                    }
                    parseExprAtom(e1) {
                        return this.parsePlaceholder("Expression") || super.parseExprAtom(e1);
                    }
                    parseIdentifier(e1) {
                        return this.parsePlaceholder("Identifier") || super.parseIdentifier(e1);
                    }
                    checkReservedWord(e1, t, r, n) {
                        if (e1 !== undefined) {
                            super.checkReservedWord(e1, t, r, n);
                        }
                    }
                    parseBindingAtom() {
                        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
                    }
                    isValidLVal(e1, t, r) {
                        return e1 === "Placeholder" || super.isValidLVal(e1, t, r);
                    }
                    toAssignable(e1, t) {
                        if (e1 && e1.type === "Placeholder" && e1.expectedNode === "Expression") {
                            e1.expectedNode = "Pattern";
                        } else {
                            super.toAssignable(e1, t);
                        }
                    }
                    chStartsBindingIdentifier(e1, t) {
                        if (super.chStartsBindingIdentifier(e1, t)) {
                            return true;
                        }
                        const r = this.lookahead();
                        if (r.type === 133) {
                            return true;
                        }
                        return false;
                    }
                    verifyBreakContinue(e1, t) {
                        if (e1.label && e1.label.type === "Placeholder") return;
                        super.verifyBreakContinue(e1, t);
                    }
                    parseExpressionStatement(e1, t) {
                        var r;
                        if (t.type !== "Placeholder" || (r = t.extra) != null && r.parenthesized) {
                            return super.parseExpressionStatement(e1, t);
                        }
                        if (this.match(14)) {
                            const r = e1;
                            r.label = this.finishPlaceholder(t, "Identifier");
                            this.next();
                            r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
                            return this.finishNode(r, "LabeledStatement");
                        }
                        this.semicolon();
                        const n = e1;
                        n.name = t.name;
                        return this.finishPlaceholder(n, "Statement");
                    }
                    parseBlock(e1, t, r) {
                        return this.parsePlaceholder("BlockStatement") || super.parseBlock(e1, t, r);
                    }
                    parseFunctionId(e1) {
                        return this.parsePlaceholder("Identifier") || super.parseFunctionId(e1);
                    }
                    parseClass(e1, t, r) {
                        const n = t ? "ClassDeclaration" : "ClassExpression";
                        this.next();
                        const s = this.state.strict;
                        const i = this.parsePlaceholder("Identifier");
                        if (i) {
                            if (this.match(81) || this.match(133) || this.match(5)) {
                                e1.id = i;
                            } else if (r || !t) {
                                e1.id = null;
                                e1.body = this.finishPlaceholder(i, "ClassBody");
                                return this.finishNode(e1, n);
                            } else {
                                throw this.raise(te.ClassNameIsRequired, this.state.startLoc);
                            }
                        } else {
                            this.parseClassId(e1, t, r);
                        }
                        super.parseClassSuper(e1);
                        e1.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e1.superClass, s);
                        return this.finishNode(e1, n);
                    }
                    parseExport(e1, t) {
                        const r = this.parsePlaceholder("Identifier");
                        if (!r) return super.parseExport(e1, t);
                        const n = e1;
                        if (!this.isContextual(98) && !this.match(12)) {
                            n.specifiers = [];
                            n.source = null;
                            n.declaration = this.finishPlaceholder(r, "Declaration");
                            return this.finishNode(n, "ExportNamedDeclaration");
                        }
                        this.expectPlugin("exportDefaultFrom");
                        const s = this.startNode();
                        s.exported = r;
                        n.specifiers = [
                            this.finishNode(s, "ExportDefaultSpecifier")
                        ];
                        return super.parseExport(n, t);
                    }
                    isExportDefaultSpecifier() {
                        if (this.match(65)) {
                            const e1 = this.nextTokenStart();
                            if (this.isUnparsedContextual(e1, "from")) {
                                if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(e1 + 4))) {
                                    return true;
                                }
                            }
                        }
                        return super.isExportDefaultSpecifier();
                    }
                    maybeParseExportDefaultSpecifier(e1, t) {
                        var r;
                        if ((r = e1.specifiers) != null && r.length) {
                            return true;
                        }
                        return super.maybeParseExportDefaultSpecifier(e1, t);
                    }
                    checkExport(e1) {
                        const { specifiers: t } = e1;
                        if (t != null && t.length) {
                            e1.specifiers = t.filter((e1)=>e1.exported.type === "Placeholder");
                        }
                        super.checkExport(e1);
                        e1.specifiers = t;
                    }
                    parseImport(e1) {
                        const t = this.parsePlaceholder("Identifier");
                        if (!t) return super.parseImport(e1);
                        e1.specifiers = [];
                        if (!this.isContextual(98) && !this.match(12)) {
                            e1.source = this.finishPlaceholder(t, "StringLiteral");
                            this.semicolon();
                            return this.finishNode(e1, "ImportDeclaration");
                        }
                        const r = this.startNodeAtNode(t);
                        r.local = t;
                        e1.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier"));
                        if (this.eat(12)) {
                            const t = this.maybeParseStarImportSpecifier(e1);
                            if (!t) this.parseNamedImportSpecifiers(e1);
                        }
                        this.expectContextual(98);
                        e1.source = this.parseImportSource();
                        this.semicolon();
                        return this.finishNode(e1, "ImportDeclaration");
                    }
                    parseImportSource() {
                        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
                    }
                    assertNoSpace() {
                        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
                            this.raise(te.UnexpectedSpace, this.state.lastTokEndLoc);
                        }
                    }
                }
                return PlaceholdersParserMixin;
            };
            var v8intrinsic = (e1)=>{
                class V8IntrinsicMixin extends e1 {
                    parseV8Intrinsic() {
                        if (this.match(54)) {
                            const e1 = this.state.startLoc;
                            const t = this.startNode();
                            this.next();
                            if (tokenIsIdentifier(this.state.type)) {
                                const e1 = this.parseIdentifierName();
                                const r = this.createIdentifier(t, e1);
                                r.type = "V8IntrinsicIdentifier";
                                if (this.match(10)) {
                                    return r;
                                }
                            }
                            this.unexpected(e1);
                        }
                    }
                    parseExprAtom(e1) {
                        return this.parseV8Intrinsic() || super.parseExprAtom(e1);
                    }
                }
                return V8IntrinsicMixin;
            };
            const re = [
                "minimal",
                "fsharp",
                "hack",
                "smart"
            ];
            const ne = [
                "^^",
                "@@",
                "^",
                "%",
                "#"
            ];
            function validatePlugins(e1) {
                if (e1.has("decorators")) {
                    if (e1.has("decorators-legacy")) {
                        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                    }
                    const t = e1.get("decorators").decoratorsBeforeExport;
                    if (t != null && typeof t !== "boolean") {
                        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                    }
                    const r = e1.get("decorators").allowCallParenthesized;
                    if (r != null && typeof r !== "boolean") {
                        throw new Error("'allowCallParenthesized' must be a boolean.");
                    }
                }
                if (e1.has("flow") && e1.has("typescript")) {
                    throw new Error("Cannot combine flow and typescript plugins.");
                }
                if (e1.has("placeholders") && e1.has("v8intrinsic")) {
                    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
                }
                if (e1.has("pipelineOperator")) {
                    var t;
                    const r = e1.get("pipelineOperator").proposal;
                    if (!re.includes(r)) {
                        const e1 = re.map((e1)=>'"'.concat(e1, '"')).join(", ");
                        throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(e1, "."));
                    }
                    const n = ((t = e1.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash";
                    if (r === "hack") {
                        if (e1.has("placeholders")) {
                            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                        }
                        if (e1.has("v8intrinsic")) {
                            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                        }
                        const t = e1.get("pipelineOperator").topicToken;
                        if (!ne.includes(t)) {
                            const e1 = ne.map((e1)=>'"'.concat(e1, '"')).join(", ");
                            throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(e1, "."));
                        }
                        if (t === "#" && n) {
                            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `'.concat(JSON.stringify([
                                "recordAndTuple",
                                e1.get("recordAndTuple")
                            ]), "`."));
                        }
                    } else if (r === "smart" && n) {
                        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `'.concat(JSON.stringify([
                            "recordAndTuple",
                            e1.get("recordAndTuple")
                        ]), "`."));
                    }
                }
                if (e1.has("moduleAttributes")) {
                    {
                        if (e1.has("deprecatedImportAssert") || e1.has("importAssertions")) {
                            throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
                        }
                        const t = e1.get("moduleAttributes").version;
                        if (t !== "may-2020") {
                            throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
                        }
                    }
                }
                if (e1.has("importAssertions")) {
                    if (e1.has("deprecatedImportAssert")) {
                        throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
                    }
                }
                if (!e1.has("deprecatedImportAssert") && e1.has("importAttributes") && e1.get("importAttributes").deprecatedAssertSyntax) {
                    {
                        e1.set("deprecatedImportAssert", {});
                    }
                }
                if (e1.has("recordAndTuple")) {
                    const t = e1.get("recordAndTuple").syntaxType;
                    if (t != null) {
                        {
                            const e1 = [
                                "hash",
                                "bar"
                            ];
                            if (!e1.includes(t)) {
                                throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e1.map((e1)=>"'".concat(e1, "'")).join(", "));
                            }
                        }
                    }
                }
                if (e1.has("asyncDoExpressions") && !e1.has("doExpressions")) {
                    const e1 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                    e1.missingPlugins = "doExpressions";
                    throw e1;
                }
                if (e1.has("optionalChainingAssign") && e1.get("optionalChainingAssign").version !== "2023-07") {
                    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is '2023-07'.");
                }
            }
            const se = {
                estree: estree,
                jsx: jsx,
                flow: flow,
                typescript: typescript,
                v8intrinsic: v8intrinsic,
                placeholders: placeholders
            };
            const ie = Object.keys(se);
            class ExpressionParser extends LValParser {
                checkProto(e1, t, r, n) {
                    if (e1.type === "SpreadElement" || this.isObjectMethod(e1) || e1.computed || e1.shorthand) {
                        return r;
                    }
                    const s = e1.key;
                    const i = s.type === "Identifier" ? s.name : s.value;
                    if (i === "__proto__") {
                        if (t) {
                            this.raise(p.RecordNoProto, s);
                            return true;
                        }
                        if (r) {
                            if (n) {
                                if (n.doubleProtoLoc === null) {
                                    n.doubleProtoLoc = s.loc.start;
                                }
                            } else {
                                this.raise(p.DuplicateProto, s);
                            }
                        }
                        return true;
                    }
                    return r;
                }
                shouldExitDescending(e1, t) {
                    return e1.type === "ArrowFunctionExpression" && this.offsetToSourcePos(e1.start) === t;
                }
                getExpression() {
                    this.enterInitialScopes();
                    this.nextToken();
                    const e1 = this.parseExpression();
                    if (!this.match(140)) {
                        this.unexpected();
                    }
                    this.finalizeRemainingComments();
                    e1.comments = this.comments;
                    e1.errors = this.state.errors;
                    if (this.optionFlags & 256) {
                        e1.tokens = this.tokens;
                    }
                    return e1;
                }
                parseExpression(e1, t) {
                    if (e1) {
                        return this.disallowInAnd(()=>this.parseExpressionBase(t));
                    }
                    return this.allowInAnd(()=>this.parseExpressionBase(t));
                }
                parseExpressionBase(e1) {
                    const t = this.state.startLoc;
                    const r = this.parseMaybeAssign(e1);
                    if (this.match(12)) {
                        const n = this.startNodeAt(t);
                        n.expressions = [
                            r
                        ];
                        while(this.eat(12)){
                            n.expressions.push(this.parseMaybeAssign(e1));
                        }
                        this.toReferencedList(n.expressions);
                        return this.finishNode(n, "SequenceExpression");
                    }
                    return r;
                }
                parseMaybeAssignDisallowIn(e1, t) {
                    return this.disallowInAnd(()=>this.parseMaybeAssign(e1, t));
                }
                parseMaybeAssignAllowIn(e1, t) {
                    return this.allowInAnd(()=>this.parseMaybeAssign(e1, t));
                }
                setOptionalParametersError(e1) {
                    e1.optionalParametersLoc = this.state.startLoc;
                }
                parseMaybeAssign(e1, t) {
                    const r = this.state.startLoc;
                    const n = this.isContextual(108);
                    if (n) {
                        if (this.prodParam.hasYield) {
                            this.next();
                            let e1 = this.parseYield(r);
                            if (t) {
                                e1 = t.call(this, e1, r);
                            }
                            return e1;
                        }
                    }
                    let s;
                    if (e1) {
                        s = false;
                    } else {
                        e1 = new ExpressionErrors;
                        s = true;
                    }
                    const { type: i } = this.state;
                    if (i === 10 || tokenIsIdentifier(i)) {
                        this.state.potentialArrowAt = this.state.start;
                    }
                    let a = this.parseMaybeConditional(e1);
                    if (t) {
                        a = t.call(this, a, r);
                    }
                    if (tokenIsAssignment(this.state.type)) {
                        const t = this.startNodeAt(r);
                        const n = this.state.value;
                        t.operator = n;
                        if (this.match(29)) {
                            this.toAssignable(a, true);
                            t.left = a;
                            const n = r.index;
                            if (e1.doubleProtoLoc != null && e1.doubleProtoLoc.index >= n) {
                                e1.doubleProtoLoc = null;
                            }
                            if (e1.shorthandAssignLoc != null && e1.shorthandAssignLoc.index >= n) {
                                e1.shorthandAssignLoc = null;
                            }
                            if (e1.privateKeyLoc != null && e1.privateKeyLoc.index >= n) {
                                this.checkDestructuringPrivate(e1);
                                e1.privateKeyLoc = null;
                            }
                        } else {
                            t.left = a;
                        }
                        this.next();
                        t.right = this.parseMaybeAssign();
                        this.checkLVal(a, this.finishNode(t, "AssignmentExpression"));
                        return t;
                    } else if (s) {
                        this.checkExpressionErrors(e1, true);
                    }
                    if (n) {
                        const { type: e1 } = this.state;
                        const t = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(e1) : tokenCanStartExpression(e1) && !this.match(54);
                        if (t && !this.isAmbiguousPrefixOrIdentifier()) {
                            this.raiseOverwrite(p.YieldNotInGeneratorFunction, r);
                            return this.parseYield(r);
                        }
                    }
                    return a;
                }
                parseMaybeConditional(e1) {
                    const t = this.state.startLoc;
                    const r = this.state.potentialArrowAt;
                    const n = this.parseExprOps(e1);
                    if (this.shouldExitDescending(n, r)) {
                        return n;
                    }
                    return this.parseConditional(n, t, e1);
                }
                parseConditional(e1, t, r) {
                    if (this.eat(17)) {
                        const r = this.startNodeAt(t);
                        r.test = e1;
                        r.consequent = this.parseMaybeAssignAllowIn();
                        this.expect(14);
                        r.alternate = this.parseMaybeAssign();
                        return this.finishNode(r, "ConditionalExpression");
                    }
                    return e1;
                }
                parseMaybeUnaryOrPrivate(e1) {
                    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e1);
                }
                parseExprOps(e1) {
                    const t = this.state.startLoc;
                    const r = this.state.potentialArrowAt;
                    const n = this.parseMaybeUnaryOrPrivate(e1);
                    if (this.shouldExitDescending(n, r)) {
                        return n;
                    }
                    return this.parseExprOp(n, t, -1);
                }
                parseExprOp(e1, t, r) {
                    if (this.isPrivateName(e1)) {
                        const t = this.getPrivateNameSV(e1);
                        if (r >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
                            this.raise(p.PrivateInExpectedIn, e1, {
                                identifierName: t
                            });
                        }
                        this.classScope.usePrivateName(t, e1.loc.start);
                    }
                    const n = this.state.type;
                    if (tokenIsOperator(n) && (this.prodParam.hasIn || !this.match(58))) {
                        let s = tokenOperatorPrecedence(n);
                        if (s > r) {
                            if (n === 39) {
                                this.expectPlugin("pipelineOperator");
                                if (this.state.inFSharpPipelineDirectBody) {
                                    return e1;
                                }
                                this.checkPipelineAtInfixOperator(e1, t);
                            }
                            const i = this.startNodeAt(t);
                            i.left = e1;
                            i.operator = this.state.value;
                            const a = n === 41 || n === 42;
                            const o = n === 40;
                            if (o) {
                                s = tokenOperatorPrecedence(42);
                            }
                            this.next();
                            if (n === 39 && this.hasPlugin([
                                "pipelineOperator",
                                {
                                    proposal: "minimal"
                                }
                            ])) {
                                if (this.state.type === 96 && this.prodParam.hasAwait) {
                                    throw this.raise(p.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                                }
                            }
                            i.right = this.parseExprOpRightExpr(n, s);
                            const l = this.finishNode(i, a || o ? "LogicalExpression" : "BinaryExpression");
                            const c = this.state.type;
                            if (o && (c === 41 || c === 42) || a && c === 40) {
                                throw this.raise(p.MixingCoalesceWithLogical, this.state.startLoc);
                            }
                            return this.parseExprOp(l, t, r);
                        }
                    }
                    return e1;
                }
                parseExprOpRightExpr(e1, t) {
                    const r = this.state.startLoc;
                    switch(e1){
                        case 39:
                            switch(this.getPluginOption("pipelineOperator", "proposal")){
                                case "hack":
                                    return this.withTopicBindingContext(()=>this.parseHackPipeBody());
                                case "fsharp":
                                    return this.withSoloAwaitPermittingContext(()=>this.parseFSharpPipelineBody(t));
                            }
                            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
                                return this.withTopicBindingContext(()=>{
                                    if (this.prodParam.hasYield && this.isContextual(108)) {
                                        throw this.raise(p.PipeBodyIsTighter, this.state.startLoc);
                                    }
                                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e1, t), r);
                                });
                            }
                        default:
                            return this.parseExprOpBaseRightExpr(e1, t);
                    }
                }
                parseExprOpBaseRightExpr(e1, t) {
                    const r = this.state.startLoc;
                    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, tokenIsRightAssociative(e1) ? t - 1 : t);
                }
                parseHackPipeBody() {
                    var e1;
                    const { startLoc: t } = this.state;
                    const r = this.parseMaybeAssign();
                    const n = o.has(r.type);
                    if (n && !((e1 = r.extra) != null && e1.parenthesized)) {
                        this.raise(p.PipeUnparenthesizedBody, t, {
                            type: r.type
                        });
                    }
                    if (!this.topicReferenceWasUsedInCurrentContext()) {
                        this.raise(p.PipeTopicUnused, t);
                    }
                    return r;
                }
                checkExponentialAfterUnary(e1) {
                    if (this.match(57)) {
                        this.raise(p.UnexpectedTokenUnaryExponentiation, e1.argument);
                    }
                }
                parseMaybeUnary(e1, t) {
                    const r = this.state.startLoc;
                    const n = this.isContextual(96);
                    if (n && this.recordAwaitIfAllowed()) {
                        this.next();
                        const e1 = this.parseAwait(r);
                        if (!t) this.checkExponentialAfterUnary(e1);
                        return e1;
                    }
                    const s = this.match(34);
                    const i = this.startNode();
                    if (tokenIsPrefix(this.state.type)) {
                        i.operator = this.state.value;
                        i.prefix = true;
                        if (this.match(72)) {
                            this.expectPlugin("throwExpressions");
                        }
                        const r = this.match(89);
                        this.next();
                        i.argument = this.parseMaybeUnary(null, true);
                        this.checkExpressionErrors(e1, true);
                        if (this.state.strict && r) {
                            const e1 = i.argument;
                            if (e1.type === "Identifier") {
                                this.raise(p.StrictDelete, i);
                            } else if (this.hasPropertyAsPrivateName(e1)) {
                                this.raise(p.DeletePrivateField, i);
                            }
                        }
                        if (!s) {
                            if (!t) {
                                this.checkExponentialAfterUnary(i);
                            }
                            return this.finishNode(i, "UnaryExpression");
                        }
                    }
                    const a = this.parseUpdate(i, s, e1);
                    if (n) {
                        const { type: e1 } = this.state;
                        const t = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(e1) : tokenCanStartExpression(e1) && !this.match(54);
                        if (t && !this.isAmbiguousPrefixOrIdentifier()) {
                            this.raiseOverwrite(p.AwaitNotInAsyncContext, r);
                            return this.parseAwait(r);
                        }
                    }
                    return a;
                }
                parseUpdate(e1, t, r) {
                    if (t) {
                        const t = e1;
                        this.checkLVal(t.argument, this.finishNode(t, "UpdateExpression"));
                        return e1;
                    }
                    const n = this.state.startLoc;
                    let s = this.parseExprSubscripts(r);
                    if (this.checkExpressionErrors(r, false)) return s;
                    while(tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()){
                        const e1 = this.startNodeAt(n);
                        e1.operator = this.state.value;
                        e1.prefix = false;
                        e1.argument = s;
                        this.next();
                        this.checkLVal(s, s = this.finishNode(e1, "UpdateExpression"));
                    }
                    return s;
                }
                parseExprSubscripts(e1) {
                    const t = this.state.startLoc;
                    const r = this.state.potentialArrowAt;
                    const n = this.parseExprAtom(e1);
                    if (this.shouldExitDescending(n, r)) {
                        return n;
                    }
                    return this.parseSubscripts(n, t);
                }
                parseSubscripts(e1, t, r) {
                    const n = {
                        optionalChainMember: false,
                        maybeAsyncArrow: this.atPossibleAsyncArrow(e1),
                        stop: false
                    };
                    do {
                        e1 = this.parseSubscript(e1, t, r, n);
                        n.maybeAsyncArrow = false;
                    }while (!n.stop)
                    return e1;
                }
                parseSubscript(e1, t, r, n) {
                    const { type: s } = this.state;
                    if (!r && s === 15) {
                        return this.parseBind(e1, t, r, n);
                    } else if (tokenIsTemplate(s)) {
                        return this.parseTaggedTemplateExpression(e1, t, n);
                    }
                    let i = false;
                    if (s === 18) {
                        if (r) {
                            this.raise(p.OptionalChainingNoNew, this.state.startLoc);
                            if (this.lookaheadCharCode() === 40) {
                                n.stop = true;
                                return e1;
                            }
                        }
                        n.optionalChainMember = i = true;
                        this.next();
                    }
                    if (!r && this.match(10)) {
                        return this.parseCoverCallAndAsyncArrowHead(e1, t, n, i);
                    } else {
                        const r = this.eat(0);
                        if (r || i || this.eat(16)) {
                            return this.parseMember(e1, t, n, r, i);
                        } else {
                            n.stop = true;
                            return e1;
                        }
                    }
                }
                parseMember(e1, t, r, n, s) {
                    const i = this.startNodeAt(t);
                    i.object = e1;
                    i.computed = n;
                    if (n) {
                        i.property = this.parseExpression();
                        this.expect(3);
                    } else if (this.match(139)) {
                        if (e1.type === "Super") {
                            this.raise(p.SuperPrivateField, t);
                        }
                        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                        i.property = this.parsePrivateName();
                    } else {
                        i.property = this.parseIdentifier(true);
                    }
                    if (r.optionalChainMember) {
                        i.optional = s;
                        return this.finishNode(i, "OptionalMemberExpression");
                    } else {
                        return this.finishNode(i, "MemberExpression");
                    }
                }
                parseBind(e1, t, r, n) {
                    const s = this.startNodeAt(t);
                    s.object = e1;
                    this.next();
                    s.callee = this.parseNoCallExpr();
                    n.stop = true;
                    return this.parseSubscripts(this.finishNode(s, "BindExpression"), t, r);
                }
                parseCoverCallAndAsyncArrowHead(e1, t, r, n) {
                    const s = this.state.maybeInArrowParameters;
                    let i = null;
                    this.state.maybeInArrowParameters = true;
                    this.next();
                    const a = this.startNodeAt(t);
                    a.callee = e1;
                    const { maybeAsyncArrow: o, optionalChainMember: l } = r;
                    if (o) {
                        this.expressionScope.enter(newAsyncArrowScope());
                        i = new ExpressionErrors;
                    }
                    if (l) {
                        a.optional = n;
                    }
                    if (n) {
                        a.arguments = this.parseCallExpressionArguments(11);
                    } else {
                        a.arguments = this.parseCallExpressionArguments(11, e1.type !== "Super", a, i);
                    }
                    let c = this.finishCallExpression(a, l);
                    if (o && this.shouldParseAsyncArrow() && !n) {
                        r.stop = true;
                        this.checkDestructuringPrivate(i);
                        this.expressionScope.validateAsPattern();
                        this.expressionScope.exit();
                        c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), c);
                    } else {
                        if (o) {
                            this.checkExpressionErrors(i, true);
                            this.expressionScope.exit();
                        }
                        this.toReferencedArguments(c);
                    }
                    this.state.maybeInArrowParameters = s;
                    return c;
                }
                toReferencedArguments(e1, t) {
                    this.toReferencedListDeep(e1.arguments, t);
                }
                parseTaggedTemplateExpression(e1, t, r) {
                    const n = this.startNodeAt(t);
                    n.tag = e1;
                    n.quasi = this.parseTemplate(true);
                    if (r.optionalChainMember) {
                        this.raise(p.OptionalChainingNoTemplate, t);
                    }
                    return this.finishNode(n, "TaggedTemplateExpression");
                }
                atPossibleAsyncArrow(e1) {
                    return e1.type === "Identifier" && e1.name === "async" && this.state.lastTokEndLoc.index === e1.end && !this.canInsertSemicolon() && e1.end - e1.start === 5 && this.offsetToSourcePos(e1.start) === this.state.potentialArrowAt;
                }
                finishCallExpression(e1, t) {
                    if (e1.callee.type === "Import") {
                        if (e1.arguments.length === 0 || e1.arguments.length > 2) {
                            this.raise(p.ImportCallArity, e1);
                        } else {
                            for (const t of e1.arguments){
                                if (t.type === "SpreadElement") {
                                    this.raise(p.ImportCallSpreadArgument, t);
                                }
                            }
                        }
                    }
                    return this.finishNode(e1, t ? "OptionalCallExpression" : "CallExpression");
                }
                parseCallExpressionArguments(e1, t, r, n) {
                    const s = [];
                    let i = true;
                    const a = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = false;
                    while(!this.eat(e1)){
                        if (i) {
                            i = false;
                        } else {
                            this.expect(12);
                            if (this.match(e1)) {
                                if (r) {
                                    this.addTrailingCommaExtraToNode(r);
                                }
                                this.next();
                                break;
                            }
                        }
                        s.push(this.parseExprListItem(false, n, t));
                    }
                    this.state.inFSharpPipelineDirectBody = a;
                    return s;
                }
                shouldParseAsyncArrow() {
                    return this.match(19) && !this.canInsertSemicolon();
                }
                parseAsyncArrowFromCallExpression(e1, t) {
                    var r;
                    this.resetPreviousNodeTrailingComments(t);
                    this.expect(19);
                    this.parseArrowExpression(e1, t.arguments, true, (r = t.extra) == null ? void 0 : r.trailingCommaLoc);
                    if (t.innerComments) {
                        setInnerComments(e1, t.innerComments);
                    }
                    if (t.callee.trailingComments) {
                        setInnerComments(e1, t.callee.trailingComments);
                    }
                    return e1;
                }
                parseNoCallExpr() {
                    const e1 = this.state.startLoc;
                    return this.parseSubscripts(this.parseExprAtom(), e1, true);
                }
                parseExprAtom(e1) {
                    let t;
                    let r = null;
                    const { type: n } = this.state;
                    switch(n){
                        case 79:
                            return this.parseSuper();
                        case 83:
                            t = this.startNode();
                            this.next();
                            if (this.match(16)) {
                                return this.parseImportMetaProperty(t);
                            }
                            if (this.match(10)) {
                                if (this.optionFlags & 512) {
                                    return this.parseImportCall(t);
                                } else {
                                    return this.finishNode(t, "Import");
                                }
                            } else {
                                this.raise(p.UnsupportedImport, this.state.lastTokStartLoc);
                                return this.finishNode(t, "Import");
                            }
                        case 78:
                            t = this.startNode();
                            this.next();
                            return this.finishNode(t, "ThisExpression");
                        case 90:
                            {
                                return this.parseDo(this.startNode(), false);
                            }
                        case 56:
                        case 31:
                            {
                                this.readRegexp();
                                return this.parseRegExpLiteral(this.state.value);
                            }
                        case 135:
                            return this.parseNumericLiteral(this.state.value);
                        case 136:
                            return this.parseBigIntLiteral(this.state.value);
                        case 134:
                            return this.parseStringLiteral(this.state.value);
                        case 84:
                            return this.parseNullLiteral();
                        case 85:
                            return this.parseBooleanLiteral(true);
                        case 86:
                            return this.parseBooleanLiteral(false);
                        case 10:
                            {
                                const e1 = this.state.potentialArrowAt === this.state.start;
                                return this.parseParenAndDistinguishExpression(e1);
                            }
                        case 2:
                        case 1:
                            {
                                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                            }
                        case 0:
                            {
                                return this.parseArrayLike(3, true, false, e1);
                            }
                        case 6:
                        case 7:
                            {
                                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                            }
                        case 5:
                            {
                                return this.parseObjectLike(8, false, false, e1);
                            }
                        case 68:
                            return this.parseFunctionOrFunctionSent();
                        case 26:
                            r = this.parseDecorators();
                        case 80:
                            return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), false);
                        case 77:
                            return this.parseNewOrNewTarget();
                        case 25:
                        case 24:
                            return this.parseTemplate(false);
                        case 15:
                            {
                                t = this.startNode();
                                this.next();
                                t.object = null;
                                const e1 = t.callee = this.parseNoCallExpr();
                                if (e1.type === "MemberExpression") {
                                    return this.finishNode(t, "BindExpression");
                                } else {
                                    throw this.raise(p.UnsupportedBind, e1);
                                }
                            }
                        case 139:
                            {
                                this.raise(p.PrivateInExpectedIn, this.state.startLoc, {
                                    identifierName: this.state.value
                                });
                                return this.parsePrivateName();
                            }
                        case 33:
                            {
                                return this.parseTopicReferenceThenEqualsSign(54, "%");
                            }
                        case 32:
                            {
                                return this.parseTopicReferenceThenEqualsSign(44, "^");
                            }
                        case 37:
                        case 38:
                            {
                                return this.parseTopicReference("hack");
                            }
                        case 44:
                        case 54:
                        case 27:
                            {
                                const e1 = this.getPluginOption("pipelineOperator", "proposal");
                                if (e1) {
                                    return this.parseTopicReference(e1);
                                }
                                this.unexpected();
                                break;
                            }
                        case 47:
                            {
                                const e1 = this.input.codePointAt(this.nextTokenStart());
                                if (isIdentifierStart(e1) || e1 === 62) {
                                    this.expectOnePlugin([
                                        "jsx",
                                        "flow",
                                        "typescript"
                                    ]);
                                } else {
                                    this.unexpected();
                                }
                                break;
                            }
                        default:
                            if (n === 137) {
                                return this.parseDecimalLiteral(this.state.value);
                            }
                            if (tokenIsIdentifier(n)) {
                                if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                                    return this.parseModuleExpression();
                                }
                                const e1 = this.state.potentialArrowAt === this.state.start;
                                const t = this.state.containsEsc;
                                const r = this.parseIdentifier();
                                if (!t && r.name === "async" && !this.canInsertSemicolon()) {
                                    const { type: e1 } = this.state;
                                    if (e1 === 68) {
                                        this.resetPreviousNodeTrailingComments(r);
                                        this.next();
                                        return this.parseAsyncFunctionExpression(this.startNodeAtNode(r));
                                    } else if (tokenIsIdentifier(e1)) {
                                        if (this.lookaheadCharCode() === 61) {
                                            return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r));
                                        } else {
                                            return r;
                                        }
                                    } else if (e1 === 90) {
                                        this.resetPreviousNodeTrailingComments(r);
                                        return this.parseDo(this.startNodeAtNode(r), true);
                                    }
                                }
                                if (e1 && this.match(19) && !this.canInsertSemicolon()) {
                                    this.next();
                                    return this.parseArrowExpression(this.startNodeAtNode(r), [
                                        r
                                    ], false);
                                }
                                return r;
                            } else {
                                this.unexpected();
                            }
                    }
                }
                parseTopicReferenceThenEqualsSign(e1, t) {
                    const r = this.getPluginOption("pipelineOperator", "proposal");
                    if (r) {
                        this.state.type = e1;
                        this.state.value = t;
                        this.state.pos--;
                        this.state.end--;
                        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
                        return this.parseTopicReference(r);
                    } else {
                        this.unexpected();
                    }
                }
                parseTopicReference(e1) {
                    const t = this.startNode();
                    const r = this.state.startLoc;
                    const n = this.state.type;
                    this.next();
                    return this.finishTopicReference(t, r, e1, n);
                }
                finishTopicReference(e1, t, r, n) {
                    if (this.testTopicReferenceConfiguration(r, t, n)) {
                        if (r === "hack") {
                            if (!this.topicReferenceIsAllowedInCurrentContext()) {
                                this.raise(p.PipeTopicUnbound, t);
                            }
                            this.registerTopicReference();
                            return this.finishNode(e1, "TopicReference");
                        } else {
                            if (!this.topicReferenceIsAllowedInCurrentContext()) {
                                this.raise(p.PrimaryTopicNotAllowed, t);
                            }
                            this.registerTopicReference();
                            return this.finishNode(e1, "PipelinePrimaryTopicReference");
                        }
                    } else {
                        throw this.raise(p.PipeTopicUnconfiguredToken, t, {
                            token: tokenLabelName(n)
                        });
                    }
                }
                testTopicReferenceConfiguration(e1, t, r) {
                    switch(e1){
                        case "hack":
                            {
                                return this.hasPlugin([
                                    "pipelineOperator",
                                    {
                                        topicToken: tokenLabelName(r)
                                    }
                                ]);
                            }
                        case "smart":
                            return r === 27;
                        default:
                            throw this.raise(p.PipeTopicRequiresHackPipes, t);
                    }
                }
                parseAsyncArrowUnaryFunction(e1) {
                    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
                    const t = [
                        this.parseIdentifier()
                    ];
                    this.prodParam.exit();
                    if (this.hasPrecedingLineBreak()) {
                        this.raise(p.LineTerminatorBeforeArrow, this.state.curPosition());
                    }
                    this.expect(19);
                    return this.parseArrowExpression(e1, t, true);
                }
                parseDo(e1, t) {
                    this.expectPlugin("doExpressions");
                    if (t) {
                        this.expectPlugin("asyncDoExpressions");
                    }
                    e1.async = t;
                    this.next();
                    const r = this.state.labels;
                    this.state.labels = [];
                    if (t) {
                        this.prodParam.enter(2);
                        e1.body = this.parseBlock();
                        this.prodParam.exit();
                    } else {
                        e1.body = this.parseBlock();
                    }
                    this.state.labels = r;
                    return this.finishNode(e1, "DoExpression");
                }
                parseSuper() {
                    const e1 = this.startNode();
                    this.next();
                    if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
                        this.raise(p.SuperNotAllowed, e1);
                    } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
                        this.raise(p.UnexpectedSuper, e1);
                    }
                    if (!this.match(10) && !this.match(0) && !this.match(16)) {
                        this.raise(p.UnsupportedSuper, e1);
                    }
                    return this.finishNode(e1, "Super");
                }
                parsePrivateName() {
                    const e1 = this.startNode();
                    const t = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
                    const r = this.state.value;
                    this.next();
                    e1.id = this.createIdentifier(t, r);
                    return this.finishNode(e1, "PrivateName");
                }
                parseFunctionOrFunctionSent() {
                    const e1 = this.startNode();
                    this.next();
                    if (this.prodParam.hasYield && this.match(16)) {
                        const t = this.createIdentifier(this.startNodeAtNode(e1), "function");
                        this.next();
                        if (this.match(103)) {
                            this.expectPlugin("functionSent");
                        } else if (!this.hasPlugin("functionSent")) {
                            this.unexpected();
                        }
                        return this.parseMetaProperty(e1, t, "sent");
                    }
                    return this.parseFunction(e1);
                }
                parseMetaProperty(e1, t, r) {
                    e1.meta = t;
                    const n = this.state.containsEsc;
                    e1.property = this.parseIdentifier(true);
                    if (e1.property.name !== r || n) {
                        this.raise(p.UnsupportedMetaProperty, e1.property, {
                            target: t.name,
                            onlyValidPropertyName: r
                        });
                    }
                    return this.finishNode(e1, "MetaProperty");
                }
                parseImportMetaProperty(e1) {
                    const t = this.createIdentifier(this.startNodeAtNode(e1), "import");
                    this.next();
                    if (this.isContextual(101)) {
                        if (!this.inModule) {
                            this.raise(p.ImportMetaOutsideModule, t);
                        }
                        this.sawUnambiguousESM = true;
                    } else if (this.isContextual(105) || this.isContextual(97)) {
                        const t = this.isContextual(105);
                        this.expectPlugin(t ? "sourcePhaseImports" : "deferredImportEvaluation");
                        if (!(this.optionFlags & 512)) {
                            throw this.raise(p.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
                                phase: this.state.value
                            });
                        }
                        this.next();
                        e1.phase = t ? "source" : "defer";
                        return this.parseImportCall(e1);
                    }
                    return this.parseMetaProperty(e1, t, "meta");
                }
                parseLiteralAtNode(e1, t, r) {
                    this.addExtra(r, "rawValue", e1);
                    this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end));
                    r.value = e1;
                    this.next();
                    return this.finishNode(r, t);
                }
                parseLiteral(e1, t) {
                    const r = this.startNode();
                    return this.parseLiteralAtNode(e1, t, r);
                }
                parseStringLiteral(e1) {
                    return this.parseLiteral(e1, "StringLiteral");
                }
                parseNumericLiteral(e1) {
                    return this.parseLiteral(e1, "NumericLiteral");
                }
                parseBigIntLiteral(e1) {
                    return this.parseLiteral(e1, "BigIntLiteral");
                }
                parseDecimalLiteral(e1) {
                    return this.parseLiteral(e1, "DecimalLiteral");
                }
                parseRegExpLiteral(e1) {
                    const t = this.startNode();
                    this.addExtra(t, "raw", this.input.slice(this.offsetToSourcePos(t.start), this.state.end));
                    t.pattern = e1.pattern;
                    t.flags = e1.flags;
                    this.next();
                    return this.finishNode(t, "RegExpLiteral");
                }
                parseBooleanLiteral(e1) {
                    const t = this.startNode();
                    t.value = e1;
                    this.next();
                    return this.finishNode(t, "BooleanLiteral");
                }
                parseNullLiteral() {
                    const e1 = this.startNode();
                    this.next();
                    return this.finishNode(e1, "NullLiteral");
                }
                parseParenAndDistinguishExpression(e1) {
                    const t = this.state.startLoc;
                    let r;
                    this.next();
                    this.expressionScope.enter(newArrowHeadScope());
                    const n = this.state.maybeInArrowParameters;
                    const s = this.state.inFSharpPipelineDirectBody;
                    this.state.maybeInArrowParameters = true;
                    this.state.inFSharpPipelineDirectBody = false;
                    const i = this.state.startLoc;
                    const a = [];
                    const o = new ExpressionErrors;
                    let l = true;
                    let c;
                    let p;
                    while(!this.match(11)){
                        if (l) {
                            l = false;
                        } else {
                            this.expect(12, o.optionalParametersLoc === null ? null : o.optionalParametersLoc);
                            if (this.match(11)) {
                                p = this.state.startLoc;
                                break;
                            }
                        }
                        if (this.match(21)) {
                            const e1 = this.state.startLoc;
                            c = this.state.startLoc;
                            a.push(this.parseParenItem(this.parseRestBinding(), e1));
                            if (!this.checkCommaAfterRest(41)) {
                                break;
                            }
                        } else {
                            a.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
                        }
                    }
                    const u = this.state.lastTokEndLoc;
                    this.expect(11);
                    this.state.maybeInArrowParameters = n;
                    this.state.inFSharpPipelineDirectBody = s;
                    let d = this.startNodeAt(t);
                    if (e1 && this.shouldParseArrow(a) && (d = this.parseArrow(d))) {
                        this.checkDestructuringPrivate(o);
                        this.expressionScope.validateAsPattern();
                        this.expressionScope.exit();
                        this.parseArrowExpression(d, a, false);
                        return d;
                    }
                    this.expressionScope.exit();
                    if (!a.length) {
                        this.unexpected(this.state.lastTokStartLoc);
                    }
                    if (p) this.unexpected(p);
                    if (c) this.unexpected(c);
                    this.checkExpressionErrors(o, true);
                    this.toReferencedListDeep(a, true);
                    if (a.length > 1) {
                        r = this.startNodeAt(i);
                        r.expressions = a;
                        this.finishNode(r, "SequenceExpression");
                        this.resetEndLocation(r, u);
                    } else {
                        r = a[0];
                    }
                    return this.wrapParenthesis(t, r);
                }
                wrapParenthesis(e1, t) {
                    if (!(this.optionFlags & 1024)) {
                        this.addExtra(t, "parenthesized", true);
                        this.addExtra(t, "parenStart", e1.index);
                        this.takeSurroundingComments(t, e1.index, this.state.lastTokEndLoc.index);
                        return t;
                    }
                    const r = this.startNodeAt(e1);
                    r.expression = t;
                    return this.finishNode(r, "ParenthesizedExpression");
                }
                shouldParseArrow(e1) {
                    return !this.canInsertSemicolon();
                }
                parseArrow(e1) {
                    if (this.eat(19)) {
                        return e1;
                    }
                }
                parseParenItem(e1, t) {
                    return e1;
                }
                parseNewOrNewTarget() {
                    const e1 = this.startNode();
                    this.next();
                    if (this.match(16)) {
                        const t = this.createIdentifier(this.startNodeAtNode(e1), "new");
                        this.next();
                        const r = this.parseMetaProperty(e1, t, "target");
                        if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {
                            this.raise(p.UnexpectedNewTarget, r);
                        }
                        return r;
                    }
                    return this.parseNew(e1);
                }
                parseNew(e1) {
                    this.parseNewCallee(e1);
                    if (this.eat(10)) {
                        const t = this.parseExprList(11);
                        this.toReferencedList(t);
                        e1.arguments = t;
                    } else {
                        e1.arguments = [];
                    }
                    return this.finishNode(e1, "NewExpression");
                }
                parseNewCallee(e1) {
                    const t = this.match(83);
                    const r = this.parseNoCallExpr();
                    e1.callee = r;
                    if (t && (r.type === "Import" || r.type === "ImportExpression")) {
                        this.raise(p.ImportCallNotNewExpression, r);
                    }
                }
                parseTemplateElement(e1) {
                    const { start: t, startLoc: r, end: n, value: s } = this.state;
                    const i = t + 1;
                    const a = this.startNodeAt(createPositionWithColumnOffset(r, 1));
                    if (s === null) {
                        if (!e1) {
                            this.raise(p.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
                        }
                    }
                    const o = this.match(24);
                    const l = o ? -1 : -2;
                    const c = n + l;
                    a.value = {
                        raw: this.input.slice(i, c).replace(/\r\n?/g, "\n"),
                        cooked: s === null ? null : s.slice(1, l)
                    };
                    a.tail = o;
                    this.next();
                    const u = this.finishNode(a, "TemplateElement");
                    this.resetEndLocation(u, createPositionWithColumnOffset(this.state.lastTokEndLoc, l));
                    return u;
                }
                parseTemplate(e1) {
                    const t = this.startNode();
                    let r = this.parseTemplateElement(e1);
                    const n = [
                        r
                    ];
                    const s = [];
                    while(!r.tail){
                        s.push(this.parseTemplateSubstitution());
                        this.readTemplateContinuation();
                        n.push(r = this.parseTemplateElement(e1));
                    }
                    t.expressions = s;
                    t.quasis = n;
                    return this.finishNode(t, "TemplateLiteral");
                }
                parseTemplateSubstitution() {
                    return this.parseExpression();
                }
                parseObjectLike(e1, t, r, n) {
                    if (r) {
                        this.expectPlugin("recordAndTuple");
                    }
                    const s = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = false;
                    let i = false;
                    let a = true;
                    const o = this.startNode();
                    o.properties = [];
                    this.next();
                    while(!this.match(e1)){
                        if (a) {
                            a = false;
                        } else {
                            this.expect(12);
                            if (this.match(e1)) {
                                this.addTrailingCommaExtraToNode(o);
                                break;
                            }
                        }
                        let s;
                        if (t) {
                            s = this.parseBindingProperty();
                        } else {
                            s = this.parsePropertyDefinition(n);
                            i = this.checkProto(s, r, i, n);
                        }
                        if (r && !this.isObjectProperty(s) && s.type !== "SpreadElement") {
                            this.raise(p.InvalidRecordProperty, s);
                        }
                        {
                            if (s.shorthand) {
                                this.addExtra(s, "shorthand", true);
                            }
                        }
                        o.properties.push(s);
                    }
                    this.next();
                    this.state.inFSharpPipelineDirectBody = s;
                    let l = "ObjectExpression";
                    if (t) {
                        l = "ObjectPattern";
                    } else if (r) {
                        l = "RecordExpression";
                    }
                    return this.finishNode(o, l);
                }
                addTrailingCommaExtraToNode(e1) {
                    this.addExtra(e1, "trailingComma", this.state.lastTokStartLoc.index);
                    this.addExtra(e1, "trailingCommaLoc", this.state.lastTokStartLoc, false);
                }
                maybeAsyncOrAccessorProp(e1) {
                    return !e1.computed && e1.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
                }
                parsePropertyDefinition(e1) {
                    let t = [];
                    if (this.match(26)) {
                        if (this.hasPlugin("decorators")) {
                            this.raise(p.UnsupportedPropertyDecorator, this.state.startLoc);
                        }
                        while(this.match(26)){
                            t.push(this.parseDecorator());
                        }
                    }
                    const r = this.startNode();
                    let n = false;
                    let s = false;
                    let i;
                    if (this.match(21)) {
                        if (t.length) this.unexpected();
                        return this.parseSpread();
                    }
                    if (t.length) {
                        r.decorators = t;
                        t = [];
                    }
                    r.method = false;
                    if (e1) {
                        i = this.state.startLoc;
                    }
                    let a = this.eat(55);
                    this.parsePropertyNamePrefixOperator(r);
                    const o = this.state.containsEsc;
                    this.parsePropertyName(r, e1);
                    if (!a && !o && this.maybeAsyncOrAccessorProp(r)) {
                        const { key: e1 } = r;
                        const t = e1.name;
                        if (t === "async" && !this.hasPrecedingLineBreak()) {
                            n = true;
                            this.resetPreviousNodeTrailingComments(e1);
                            a = this.eat(55);
                            this.parsePropertyName(r);
                        }
                        if (t === "get" || t === "set") {
                            s = true;
                            this.resetPreviousNodeTrailingComments(e1);
                            r.kind = t;
                            if (this.match(55)) {
                                a = true;
                                this.raise(p.AccessorIsGenerator, this.state.curPosition(), {
                                    kind: t
                                });
                                this.next();
                            }
                            this.parsePropertyName(r);
                        }
                    }
                    return this.parseObjPropValue(r, i, a, n, false, s, e1);
                }
                getGetterSetterExpectedParamCount(e1) {
                    return e1.kind === "get" ? 0 : 1;
                }
                getObjectOrClassMethodParams(e1) {
                    return e1.params;
                }
                checkGetterSetterParams(e1) {
                    var t;
                    const r = this.getGetterSetterExpectedParamCount(e1);
                    const n = this.getObjectOrClassMethodParams(e1);
                    if (n.length !== r) {
                        this.raise(e1.kind === "get" ? p.BadGetterArity : p.BadSetterArity, e1);
                    }
                    if (e1.kind === "set" && ((t = n[n.length - 1]) == null ? void 0 : t.type) === "RestElement") {
                        this.raise(p.BadSetterRestParameter, e1);
                    }
                }
                parseObjectMethod(e1, t, r, n, s) {
                    if (s) {
                        const r = this.parseMethod(e1, t, false, false, false, "ObjectMethod");
                        this.checkGetterSetterParams(r);
                        return r;
                    }
                    if (r || t || this.match(10)) {
                        if (n) this.unexpected();
                        e1.kind = "method";
                        e1.method = true;
                        return this.parseMethod(e1, t, r, false, false, "ObjectMethod");
                    }
                }
                parseObjectProperty(e1, t, r, n) {
                    e1.shorthand = false;
                    if (this.eat(14)) {
                        e1.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n);
                        return this.finishNode(e1, "ObjectProperty");
                    }
                    if (!e1.computed && e1.key.type === "Identifier") {
                        this.checkReservedWord(e1.key.name, e1.key.loc.start, true, false);
                        if (r) {
                            e1.value = this.parseMaybeDefault(t, cloneIdentifier(e1.key));
                        } else if (this.match(29)) {
                            const r = this.state.startLoc;
                            if (n != null) {
                                if (n.shorthandAssignLoc === null) {
                                    n.shorthandAssignLoc = r;
                                }
                            } else {
                                this.raise(p.InvalidCoverInitializedName, r);
                            }
                            e1.value = this.parseMaybeDefault(t, cloneIdentifier(e1.key));
                        } else {
                            e1.value = cloneIdentifier(e1.key);
                        }
                        e1.shorthand = true;
                        return this.finishNode(e1, "ObjectProperty");
                    }
                }
                parseObjPropValue(e1, t, r, n, s, i, a) {
                    const o = this.parseObjectMethod(e1, r, n, s, i) || this.parseObjectProperty(e1, t, s, a);
                    if (!o) this.unexpected();
                    return o;
                }
                parsePropertyName(e1, t) {
                    if (this.eat(0)) {
                        e1.computed = true;
                        e1.key = this.parseMaybeAssignAllowIn();
                        this.expect(3);
                    } else {
                        const { type: r, value: n } = this.state;
                        let s;
                        if (tokenIsKeywordOrIdentifier(r)) {
                            s = this.parseIdentifier(true);
                        } else {
                            switch(r){
                                case 135:
                                    s = this.parseNumericLiteral(n);
                                    break;
                                case 134:
                                    s = this.parseStringLiteral(n);
                                    break;
                                case 136:
                                    s = this.parseBigIntLiteral(n);
                                    break;
                                case 139:
                                    {
                                        const e1 = this.state.startLoc;
                                        if (t != null) {
                                            if (t.privateKeyLoc === null) {
                                                t.privateKeyLoc = e1;
                                            }
                                        } else {
                                            this.raise(p.UnexpectedPrivateField, e1);
                                        }
                                        s = this.parsePrivateName();
                                        break;
                                    }
                                default:
                                    if (r === 137) {
                                        s = this.parseDecimalLiteral(n);
                                        break;
                                    }
                                    this.unexpected();
                            }
                        }
                        e1.key = s;
                        if (r !== 139) {
                            e1.computed = false;
                        }
                    }
                }
                initFunction(e1, t) {
                    e1.id = null;
                    e1.generator = false;
                    e1.async = t;
                }
                parseMethod(e1, t, r, n, s, i) {
                    let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                    this.initFunction(e1, r);
                    e1.generator = t;
                    this.scope.enter(2 | 16 | (a ? 64 : 0) | (s ? 32 : 0));
                    this.prodParam.enter(functionFlags(r, e1.generator));
                    this.parseFunctionParams(e1, n);
                    const o = this.parseFunctionBodyAndFinish(e1, i, true);
                    this.prodParam.exit();
                    this.scope.exit();
                    return o;
                }
                parseArrayLike(e1, t, r, n) {
                    if (r) {
                        this.expectPlugin("recordAndTuple");
                    }
                    const s = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = false;
                    const i = this.startNode();
                    this.next();
                    i.elements = this.parseExprList(e1, !r, n, i);
                    this.state.inFSharpPipelineDirectBody = s;
                    return this.finishNode(i, r ? "TupleExpression" : "ArrayExpression");
                }
                parseArrowExpression(e1, t, r, n) {
                    this.scope.enter(2 | 4);
                    let s = functionFlags(r, false);
                    if (!this.match(5) && this.prodParam.hasIn) {
                        s |= 8;
                    }
                    this.prodParam.enter(s);
                    this.initFunction(e1, r);
                    const i = this.state.maybeInArrowParameters;
                    if (t) {
                        this.state.maybeInArrowParameters = true;
                        this.setArrowFunctionParameters(e1, t, n);
                    }
                    this.state.maybeInArrowParameters = false;
                    this.parseFunctionBody(e1, true);
                    this.prodParam.exit();
                    this.scope.exit();
                    this.state.maybeInArrowParameters = i;
                    return this.finishNode(e1, "ArrowFunctionExpression");
                }
                setArrowFunctionParameters(e1, t, r) {
                    this.toAssignableList(t, r, false);
                    e1.params = t;
                }
                parseFunctionBodyAndFinish(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    this.parseFunctionBody(e1, false, r);
                    return this.finishNode(e1, t);
                }
                parseFunctionBody(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    const n = t && !this.match(5);
                    this.expressionScope.enter(newExpressionScope());
                    if (n) {
                        e1.body = this.parseMaybeAssign();
                        this.checkParams(e1, false, t, false);
                    } else {
                        const n = this.state.strict;
                        const s = this.state.labels;
                        this.state.labels = [];
                        this.prodParam.enter(this.prodParam.currentFlags() | 4);
                        e1.body = this.parseBlock(true, false, (s)=>{
                            const i = !this.isSimpleParamList(e1.params);
                            if (s && i) {
                                this.raise(p.IllegalLanguageModeDirective, (e1.kind === "method" || e1.kind === "constructor") && !!e1.key ? e1.key.loc.end : e1);
                            }
                            const a = !n && this.state.strict;
                            this.checkParams(e1, !this.state.strict && !t && !r && !i, t, a);
                            if (this.state.strict && e1.id) {
                                this.checkIdentifier(e1.id, 65, a);
                            }
                        });
                        this.prodParam.exit();
                        this.state.labels = s;
                    }
                    this.expressionScope.exit();
                }
                isSimpleParameter(e1) {
                    return e1.type === "Identifier";
                }
                isSimpleParamList(e1) {
                    for(let t = 0, r = e1.length; t < r; t++){
                        if (!this.isSimpleParameter(e1[t])) return false;
                    }
                    return true;
                }
                checkParams(e1, t, r) {
                    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                    const s = !t && new Set;
                    const i = {
                        type: "FormalParameters"
                    };
                    for (const t of e1.params){
                        this.checkLVal(t, i, 5, s, n);
                    }
                }
                parseExprList(e1, t, r, n) {
                    const s = [];
                    let i = true;
                    while(!this.eat(e1)){
                        if (i) {
                            i = false;
                        } else {
                            this.expect(12);
                            if (this.match(e1)) {
                                if (n) {
                                    this.addTrailingCommaExtraToNode(n);
                                }
                                this.next();
                                break;
                            }
                        }
                        s.push(this.parseExprListItem(t, r));
                    }
                    return s;
                }
                parseExprListItem(e1, t, r) {
                    let n;
                    if (this.match(12)) {
                        if (!e1) {
                            this.raise(p.UnexpectedToken, this.state.curPosition(), {
                                unexpected: ","
                            });
                        }
                        n = null;
                    } else if (this.match(21)) {
                        const e1 = this.state.startLoc;
                        n = this.parseParenItem(this.parseSpread(t), e1);
                    } else if (this.match(17)) {
                        this.expectPlugin("partialApplication");
                        if (!r) {
                            this.raise(p.UnexpectedArgumentPlaceholder, this.state.startLoc);
                        }
                        const e1 = this.startNode();
                        this.next();
                        n = this.finishNode(e1, "ArgumentPlaceholder");
                    } else {
                        n = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
                    }
                    return n;
                }
                parseIdentifier(e1) {
                    const t = this.startNode();
                    const r = this.parseIdentifierName(e1);
                    return this.createIdentifier(t, r);
                }
                createIdentifier(e1, t) {
                    e1.name = t;
                    e1.loc.identifierName = t;
                    return this.finishNode(e1, "Identifier");
                }
                parseIdentifierName(e1) {
                    let t;
                    const { startLoc: r, type: n } = this.state;
                    if (tokenIsKeywordOrIdentifier(n)) {
                        t = this.state.value;
                    } else {
                        this.unexpected();
                    }
                    const s = tokenKeywordOrIdentifierIsKeyword(n);
                    if (e1) {
                        if (s) {
                            this.replaceToken(132);
                        }
                    } else {
                        this.checkReservedWord(t, r, s, false);
                    }
                    this.next();
                    return t;
                }
                checkReservedWord(e1, t, r, n) {
                    if (e1.length > 10) {
                        return;
                    }
                    if (!canBeReservedWord(e1)) {
                        return;
                    }
                    if (r && isKeyword(e1)) {
                        this.raise(p.UnexpectedKeyword, t, {
                            keyword: e1
                        });
                        return;
                    }
                    const s = !this.state.strict ? isReservedWord : n ? isStrictBindReservedWord : isStrictReservedWord;
                    if (s(e1, this.inModule)) {
                        this.raise(p.UnexpectedReservedWord, t, {
                            reservedWord: e1
                        });
                        return;
                    } else if (e1 === "yield") {
                        if (this.prodParam.hasYield) {
                            this.raise(p.YieldBindingIdentifier, t);
                            return;
                        }
                    } else if (e1 === "await") {
                        if (this.prodParam.hasAwait) {
                            this.raise(p.AwaitBindingIdentifier, t);
                            return;
                        }
                        if (this.scope.inStaticBlock) {
                            this.raise(p.AwaitBindingIdentifierInStaticBlock, t);
                            return;
                        }
                        this.expressionScope.recordAsyncArrowParametersError(t);
                    } else if (e1 === "arguments") {
                        if (this.scope.inClassAndNotInNonArrowFunction) {
                            this.raise(p.ArgumentsInClass, t);
                            return;
                        }
                    }
                }
                recordAwaitIfAllowed() {
                    const e1 = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
                    if (e1 && !this.scope.inFunction) {
                        this.state.hasTopLevelAwait = true;
                    }
                    return e1;
                }
                parseAwait(e1) {
                    const t = this.startNodeAt(e1);
                    this.expressionScope.recordParameterInitializerError(p.AwaitExpressionFormalParameter, t);
                    if (this.eat(55)) {
                        this.raise(p.ObsoleteAwaitStar, t);
                    }
                    if (!this.scope.inFunction && !(this.optionFlags & 1)) {
                        if (this.isAmbiguousPrefixOrIdentifier()) {
                            this.ambiguousScriptDifferentAst = true;
                        } else {
                            this.sawUnambiguousESM = true;
                        }
                    }
                    if (!this.state.soloAwait) {
                        t.argument = this.parseMaybeUnary(null, true);
                    }
                    return this.finishNode(t, "AwaitExpression");
                }
                isAmbiguousPrefixOrIdentifier() {
                    if (this.hasPrecedingLineBreak()) return true;
                    const { type: e1 } = this.state;
                    return e1 === 53 || e1 === 10 || e1 === 0 || tokenIsTemplate(e1) || e1 === 102 && !this.state.containsEsc || e1 === 138 || e1 === 56 || this.hasPlugin("v8intrinsic") && e1 === 54;
                }
                parseYield(e1) {
                    const t = this.startNodeAt(e1);
                    this.expressionScope.recordParameterInitializerError(p.YieldInParameter, t);
                    let r = false;
                    let n = null;
                    if (!this.hasPrecedingLineBreak()) {
                        r = this.eat(55);
                        switch(this.state.type){
                            case 13:
                            case 140:
                            case 8:
                            case 11:
                            case 3:
                            case 9:
                            case 14:
                            case 12:
                                if (!r) break;
                            default:
                                n = this.parseMaybeAssign();
                        }
                    }
                    t.delegate = r;
                    t.argument = n;
                    return this.finishNode(t, "YieldExpression");
                }
                parseImportCall(e1) {
                    this.next();
                    e1.source = this.parseMaybeAssignAllowIn();
                    e1.options = null;
                    if (this.eat(12)) {
                        if (!this.match(11)) {
                            e1.options = this.parseMaybeAssignAllowIn();
                            if (this.eat(12) && !this.match(11)) {
                                do {
                                    this.parseMaybeAssignAllowIn();
                                }while (this.eat(12) && !this.match(11))
                                this.raise(p.ImportCallArity, e1);
                            }
                        }
                    }
                    this.expect(11);
                    return this.finishNode(e1, "ImportExpression");
                }
                checkPipelineAtInfixOperator(e1, t) {
                    if (this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "smart"
                        }
                    ])) {
                        if (e1.type === "SequenceExpression") {
                            this.raise(p.PipelineHeadSequenceExpression, t);
                        }
                    }
                }
                parseSmartPipelineBodyInStyle(e1, t) {
                    if (this.isSimpleReference(e1)) {
                        const r = this.startNodeAt(t);
                        r.callee = e1;
                        return this.finishNode(r, "PipelineBareFunction");
                    } else {
                        const r = this.startNodeAt(t);
                        this.checkSmartPipeTopicBodyEarlyErrors(t);
                        r.expression = e1;
                        return this.finishNode(r, "PipelineTopicExpression");
                    }
                }
                isSimpleReference(e1) {
                    switch(e1.type){
                        case "MemberExpression":
                            return !e1.computed && this.isSimpleReference(e1.object);
                        case "Identifier":
                            return true;
                        default:
                            return false;
                    }
                }
                checkSmartPipeTopicBodyEarlyErrors(e1) {
                    if (this.match(19)) {
                        throw this.raise(p.PipelineBodyNoArrow, this.state.startLoc);
                    }
                    if (!this.topicReferenceWasUsedInCurrentContext()) {
                        this.raise(p.PipelineTopicUnused, e1);
                    }
                }
                withTopicBindingContext(e1) {
                    const t = this.state.topicContext;
                    this.state.topicContext = {
                        maxNumOfResolvableTopics: 1,
                        maxTopicIndex: null
                    };
                    try {
                        return e1();
                    } finally{
                        this.state.topicContext = t;
                    }
                }
                withSmartMixTopicForbiddingContext(e1) {
                    if (this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "smart"
                        }
                    ])) {
                        const t = this.state.topicContext;
                        this.state.topicContext = {
                            maxNumOfResolvableTopics: 0,
                            maxTopicIndex: null
                        };
                        try {
                            return e1();
                        } finally{
                            this.state.topicContext = t;
                        }
                    } else {
                        return e1();
                    }
                }
                withSoloAwaitPermittingContext(e1) {
                    const t = this.state.soloAwait;
                    this.state.soloAwait = true;
                    try {
                        return e1();
                    } finally{
                        this.state.soloAwait = t;
                    }
                }
                allowInAnd(e1) {
                    const t = this.prodParam.currentFlags();
                    const r = 8 & ~t;
                    if (r) {
                        this.prodParam.enter(t | 8);
                        try {
                            return e1();
                        } finally{
                            this.prodParam.exit();
                        }
                    }
                    return e1();
                }
                disallowInAnd(e1) {
                    const t = this.prodParam.currentFlags();
                    const r = 8 & t;
                    if (r) {
                        this.prodParam.enter(t & ~8);
                        try {
                            return e1();
                        } finally{
                            this.prodParam.exit();
                        }
                    }
                    return e1();
                }
                registerTopicReference() {
                    this.state.topicContext.maxTopicIndex = 0;
                }
                topicReferenceIsAllowedInCurrentContext() {
                    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
                }
                topicReferenceWasUsedInCurrentContext() {
                    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
                }
                parseFSharpPipelineBody(e1) {
                    const t = this.state.startLoc;
                    this.state.potentialArrowAt = this.state.start;
                    const r = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = true;
                    const n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e1);
                    this.state.inFSharpPipelineDirectBody = r;
                    return n;
                }
                parseModuleExpression() {
                    this.expectPlugin("moduleBlocks");
                    const e1 = this.startNode();
                    this.next();
                    if (!this.match(5)) {
                        this.unexpected(null, 5);
                    }
                    const t = this.startNodeAt(this.state.endLoc);
                    this.next();
                    const r = this.initializeScopes(true);
                    this.enterInitialScopes();
                    try {
                        e1.body = this.parseProgram(t, 8, "module");
                    } finally{
                        r();
                    }
                    return this.finishNode(e1, "ModuleExpression");
                }
                parsePropertyNamePrefixOperator(e1) {}
            }
            const ae = {
                kind: 1
            }, oe = {
                kind: 2
            };
            const le = /[\uD800-\uDFFF]/u;
            const ce = /in(?:stanceof)?/y;
            function babel7CompatTokens(e1, t, r) {
                for(let n = 0; n < e1.length; n++){
                    const s = e1[n];
                    const { type: i } = s;
                    if (typeof i === "number") {
                        {
                            if (i === 139) {
                                const { loc: t, start: r, value: i, end: a } = s;
                                const o = r + 1;
                                const l = createPositionWithColumnOffset(t.start, 1);
                                e1.splice(n, 1, new Token({
                                    type: getExportedToken(27),
                                    value: "#",
                                    start: r,
                                    end: o,
                                    startLoc: t.start,
                                    endLoc: l
                                }), new Token({
                                    type: getExportedToken(132),
                                    value: i,
                                    start: o,
                                    end: a,
                                    startLoc: l,
                                    endLoc: t.end
                                }));
                                n++;
                                continue;
                            }
                            if (tokenIsTemplate(i)) {
                                const { loc: a, start: o, value: l, end: c } = s;
                                const p = o + 1;
                                const u = createPositionWithColumnOffset(a.start, 1);
                                let d;
                                if (t.charCodeAt(o - r) === 96) {
                                    d = new Token({
                                        type: getExportedToken(22),
                                        value: "`",
                                        start: o,
                                        end: p,
                                        startLoc: a.start,
                                        endLoc: u
                                    });
                                } else {
                                    d = new Token({
                                        type: getExportedToken(8),
                                        value: "}",
                                        start: o,
                                        end: p,
                                        startLoc: a.start,
                                        endLoc: u
                                    });
                                }
                                let f, h, m, y;
                                if (i === 24) {
                                    h = c - 1;
                                    m = createPositionWithColumnOffset(a.end, -1);
                                    f = l === null ? null : l.slice(1, -1);
                                    y = new Token({
                                        type: getExportedToken(22),
                                        value: "`",
                                        start: h,
                                        end: c,
                                        startLoc: m,
                                        endLoc: a.end
                                    });
                                } else {
                                    h = c - 2;
                                    m = createPositionWithColumnOffset(a.end, -2);
                                    f = l === null ? null : l.slice(1, -2);
                                    y = new Token({
                                        type: getExportedToken(23),
                                        value: "${",
                                        start: h,
                                        end: c,
                                        startLoc: m,
                                        endLoc: a.end
                                    });
                                }
                                e1.splice(n, 1, d, new Token({
                                    type: getExportedToken(20),
                                    value: f,
                                    start: p,
                                    end: h,
                                    startLoc: u,
                                    endLoc: m
                                }), y);
                                n += 2;
                                continue;
                            }
                        }
                        s.type = getExportedToken(i);
                    }
                }
                return e1;
            }
            class StatementParser extends ExpressionParser {
                parseTopLevel(e1, t) {
                    e1.program = this.parseProgram(t);
                    e1.comments = this.comments;
                    if (this.optionFlags & 256) {
                        e1.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
                    }
                    return this.finishNode(e1, "File");
                }
                parseProgram(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 140, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
                    e1.sourceType = r;
                    e1.interpreter = this.parseInterpreterDirective();
                    this.parseBlockBody(e1, true, true, t);
                    if (this.inModule) {
                        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {
                            for (const [e1, t] of Array.from(this.scope.undefinedExports)){
                                this.raise(p.ModuleExportUndefined, t, {
                                    localName: e1
                                });
                            }
                        }
                        this.addExtra(e1, "topLevelAwait", this.state.hasTopLevelAwait);
                    }
                    let n;
                    if (t === 140) {
                        n = this.finishNode(e1, "Program");
                    } else {
                        n = this.finishNodeAt(e1, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
                    }
                    return n;
                }
                stmtToDirective(e1) {
                    const t = e1;
                    t.type = "Directive";
                    t.value = t.expression;
                    delete t.expression;
                    const r = t.value;
                    const n = r.value;
                    const s = this.input.slice(this.offsetToSourcePos(r.start), this.offsetToSourcePos(r.end));
                    const i = r.value = s.slice(1, -1);
                    this.addExtra(r, "raw", s);
                    this.addExtra(r, "rawValue", i);
                    this.addExtra(r, "expressionValue", n);
                    r.type = "DirectiveLiteral";
                    return t;
                }
                parseInterpreterDirective() {
                    if (!this.match(28)) {
                        return null;
                    }
                    const e1 = this.startNode();
                    e1.value = this.state.value;
                    this.next();
                    return this.finishNode(e1, "InterpreterDirective");
                }
                isLet() {
                    if (!this.isContextual(100)) {
                        return false;
                    }
                    return this.hasFollowingBindingAtom();
                }
                chStartsBindingIdentifier(e1, t) {
                    if (isIdentifierStart(e1)) {
                        ce.lastIndex = t;
                        if (ce.test(this.input)) {
                            const e1 = this.codePointAtPos(ce.lastIndex);
                            if (!isIdentifierChar(e1) && e1 !== 92) {
                                return false;
                            }
                        }
                        return true;
                    } else if (e1 === 92) {
                        return true;
                    } else {
                        return false;
                    }
                }
                chStartsBindingPattern(e1) {
                    return e1 === 91 || e1 === 123;
                }
                hasFollowingBindingAtom() {
                    const e1 = this.nextTokenStart();
                    const t = this.codePointAtPos(e1);
                    return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e1);
                }
                hasInLineFollowingBindingIdentifierOrBrace() {
                    const e1 = this.nextTokenInLineStart();
                    const t = this.codePointAtPos(e1);
                    return t === 123 || this.chStartsBindingIdentifier(t, e1);
                }
                startsUsingForOf() {
                    const { type: e1, containsEsc: t } = this.lookahead();
                    if (e1 === 102 && !t) {
                        return false;
                    } else if (tokenIsIdentifier(e1) && !this.hasFollowingLineBreak()) {
                        this.expectPlugin("explicitResourceManagement");
                        return true;
                    }
                }
                startsAwaitUsing() {
                    let e1 = this.nextTokenInLineStart();
                    if (this.isUnparsedContextual(e1, "using")) {
                        e1 = this.nextTokenInLineStartSince(e1 + 5);
                        const t = this.codePointAtPos(e1);
                        if (this.chStartsBindingIdentifier(t, e1)) {
                            this.expectPlugin("explicitResourceManagement");
                            return true;
                        }
                    }
                    return false;
                }
                parseModuleItem() {
                    return this.parseStatementLike(1 | 2 | 4 | 8);
                }
                parseStatementListItem() {
                    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
                }
                parseStatementOrSloppyAnnexBFunctionDeclaration() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    let t = 0;
                    if (this.options.annexB && !this.state.strict) {
                        t |= 4;
                        if (e1) {
                            t |= 8;
                        }
                    }
                    return this.parseStatementLike(t);
                }
                parseStatement() {
                    return this.parseStatementLike(0);
                }
                parseStatementLike(e1) {
                    let t = null;
                    if (this.match(26)) {
                        t = this.parseDecorators(true);
                    }
                    return this.parseStatementContent(e1, t);
                }
                parseStatementContent(e1, t) {
                    const r = this.state.type;
                    const n = this.startNode();
                    const s = !!(e1 & 2);
                    const i = !!(e1 & 4);
                    const a = e1 & 1;
                    switch(r){
                        case 60:
                            return this.parseBreakContinueStatement(n, true);
                        case 63:
                            return this.parseBreakContinueStatement(n, false);
                        case 64:
                            return this.parseDebuggerStatement(n);
                        case 90:
                            return this.parseDoWhileStatement(n);
                        case 91:
                            return this.parseForStatement(n);
                        case 68:
                            if (this.lookaheadCharCode() === 46) break;
                            if (!i) {
                                this.raise(this.state.strict ? p.StrictFunction : this.options.annexB ? p.SloppyFunctionAnnexB : p.SloppyFunction, this.state.startLoc);
                            }
                            return this.parseFunctionStatement(n, false, !s && i);
                        case 80:
                            if (!s) this.unexpected();
                            return this.parseClass(this.maybeTakeDecorators(t, n), true);
                        case 69:
                            return this.parseIfStatement(n);
                        case 70:
                            return this.parseReturnStatement(n);
                        case 71:
                            return this.parseSwitchStatement(n);
                        case 72:
                            return this.parseThrowStatement(n);
                        case 73:
                            return this.parseTryStatement(n);
                        case 96:
                            if (!this.state.containsEsc && this.startsAwaitUsing()) {
                                if (!this.recordAwaitIfAllowed()) {
                                    this.raise(p.AwaitUsingNotInAsyncContext, n);
                                } else if (!s) {
                                    this.raise(p.UnexpectedLexicalDeclaration, n);
                                }
                                this.next();
                                return this.parseVarStatement(n, "await using");
                            }
                            break;
                        case 107:
                            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
                                break;
                            }
                            this.expectPlugin("explicitResourceManagement");
                            if (!this.scope.inModule && this.scope.inTopLevel) {
                                this.raise(p.UnexpectedUsingDeclaration, this.state.startLoc);
                            } else if (!s) {
                                this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc);
                            }
                            return this.parseVarStatement(n, "using");
                        case 100:
                            {
                                if (this.state.containsEsc) {
                                    break;
                                }
                                const e1 = this.nextTokenStart();
                                const t = this.codePointAtPos(e1);
                                if (t !== 91) {
                                    if (!s && this.hasFollowingLineBreak()) break;
                                    if (!this.chStartsBindingIdentifier(t, e1) && t !== 123) {
                                        break;
                                    }
                                }
                            }
                        case 75:
                            {
                                if (!s) {
                                    this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc);
                                }
                            }
                        case 74:
                            {
                                const e1 = this.state.value;
                                return this.parseVarStatement(n, e1);
                            }
                        case 92:
                            return this.parseWhileStatement(n);
                        case 76:
                            return this.parseWithStatement(n);
                        case 5:
                            return this.parseBlock();
                        case 13:
                            return this.parseEmptyStatement(n);
                        case 83:
                            {
                                const e1 = this.lookaheadCharCode();
                                if (e1 === 40 || e1 === 46) {
                                    break;
                                }
                            }
                        case 82:
                            {
                                if (!(this.optionFlags & 8) && !a) {
                                    this.raise(p.UnexpectedImportExport, this.state.startLoc);
                                }
                                this.next();
                                let e1;
                                if (r === 83) {
                                    e1 = this.parseImport(n);
                                } else {
                                    e1 = this.parseExport(n, t);
                                }
                                this.assertModuleNodeAllowed(e1);
                                return e1;
                            }
                        default:
                            {
                                if (this.isAsyncFunction()) {
                                    if (!s) {
                                        this.raise(p.AsyncFunctionInSingleStatementContext, this.state.startLoc);
                                    }
                                    this.next();
                                    return this.parseFunctionStatement(n, true, !s && i);
                                }
                            }
                    }
                    const o = this.state.value;
                    const l = this.parseExpression();
                    if (tokenIsIdentifier(r) && l.type === "Identifier" && this.eat(14)) {
                        return this.parseLabeledStatement(n, o, l, e1);
                    } else {
                        return this.parseExpressionStatement(n, l, t);
                    }
                }
                assertModuleNodeAllowed(e1) {
                    if (!(this.optionFlags & 8) && !this.inModule) {
                        this.raise(p.ImportOutsideModule, e1);
                    }
                }
                decoratorsEnabledBeforeExport() {
                    if (this.hasPlugin("decorators-legacy")) return true;
                    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
                }
                maybeTakeDecorators(e1, t, r) {
                    if (e1) {
                        var n;
                        if ((n = t.decorators) != null && n.length) {
                            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
                                this.raise(p.DecoratorsBeforeAfterExport, t.decorators[0]);
                            }
                            t.decorators.unshift(...e1);
                        } else {
                            t.decorators = e1;
                        }
                        this.resetStartLocationFromNode(t, e1[0]);
                        if (r) this.resetStartLocationFromNode(r, t);
                    }
                    return t;
                }
                canHaveLeadingDecorator() {
                    return this.match(80);
                }
                parseDecorators(e1) {
                    const t = [];
                    do {
                        t.push(this.parseDecorator());
                    }while (this.match(26))
                    if (this.match(82)) {
                        if (!e1) {
                            this.unexpected();
                        }
                        if (!this.decoratorsEnabledBeforeExport()) {
                            this.raise(p.DecoratorExportClass, this.state.startLoc);
                        }
                    } else if (!this.canHaveLeadingDecorator()) {
                        throw this.raise(p.UnexpectedLeadingDecorator, this.state.startLoc);
                    }
                    return t;
                }
                parseDecorator() {
                    this.expectOnePlugin([
                        "decorators",
                        "decorators-legacy"
                    ]);
                    const e1 = this.startNode();
                    this.next();
                    if (this.hasPlugin("decorators")) {
                        const t = this.state.startLoc;
                        let r;
                        if (this.match(10)) {
                            const t = this.state.startLoc;
                            this.next();
                            r = this.parseExpression();
                            this.expect(11);
                            r = this.wrapParenthesis(t, r);
                            const n = this.state.startLoc;
                            e1.expression = this.parseMaybeDecoratorArguments(r, t);
                            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && e1.expression !== r) {
                                this.raise(p.DecoratorArgumentsOutsideParentheses, n);
                            }
                        } else {
                            r = this.parseIdentifier(false);
                            while(this.eat(16)){
                                const e1 = this.startNodeAt(t);
                                e1.object = r;
                                if (this.match(139)) {
                                    this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                                    e1.property = this.parsePrivateName();
                                } else {
                                    e1.property = this.parseIdentifier(true);
                                }
                                e1.computed = false;
                                r = this.finishNode(e1, "MemberExpression");
                            }
                            e1.expression = this.parseMaybeDecoratorArguments(r, t);
                        }
                    } else {
                        e1.expression = this.parseExprSubscripts();
                    }
                    return this.finishNode(e1, "Decorator");
                }
                parseMaybeDecoratorArguments(e1, t) {
                    if (this.eat(10)) {
                        const r = this.startNodeAt(t);
                        r.callee = e1;
                        r.arguments = this.parseCallExpressionArguments(11);
                        this.toReferencedList(r.arguments);
                        return this.finishNode(r, "CallExpression");
                    }
                    return e1;
                }
                parseBreakContinueStatement(e1, t) {
                    this.next();
                    if (this.isLineTerminator()) {
                        e1.label = null;
                    } else {
                        e1.label = this.parseIdentifier();
                        this.semicolon();
                    }
                    this.verifyBreakContinue(e1, t);
                    return this.finishNode(e1, t ? "BreakStatement" : "ContinueStatement");
                }
                verifyBreakContinue(e1, t) {
                    let r;
                    for(r = 0; r < this.state.labels.length; ++r){
                        const n = this.state.labels[r];
                        if (e1.label == null || n.name === e1.label.name) {
                            if (n.kind != null && (t || n.kind === 1)) {
                                break;
                            }
                            if (e1.label && t) break;
                        }
                    }
                    if (r === this.state.labels.length) {
                        const r = t ? "BreakStatement" : "ContinueStatement";
                        this.raise(p.IllegalBreakContinue, e1, {
                            type: r
                        });
                    }
                }
                parseDebuggerStatement(e1) {
                    this.next();
                    this.semicolon();
                    return this.finishNode(e1, "DebuggerStatement");
                }
                parseHeaderExpression() {
                    this.expect(10);
                    const e1 = this.parseExpression();
                    this.expect(11);
                    return e1;
                }
                parseDoWhileStatement(e1) {
                    this.next();
                    this.state.labels.push(ae);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.state.labels.pop();
                    this.expect(92);
                    e1.test = this.parseHeaderExpression();
                    this.eat(13);
                    return this.finishNode(e1, "DoWhileStatement");
                }
                parseForStatement(e1) {
                    this.next();
                    this.state.labels.push(ae);
                    let t = null;
                    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
                        t = this.state.startLoc;
                        this.next();
                    }
                    this.scope.enter(0);
                    this.expect(10);
                    if (this.match(13)) {
                        if (t !== null) {
                            this.unexpected(t);
                        }
                        return this.parseFor(e1, null);
                    }
                    const r = this.isContextual(100);
                    {
                        const n = this.isContextual(96) && this.startsAwaitUsing();
                        const s = n || this.isContextual(107) && this.startsUsingForOf();
                        const i = r && this.hasFollowingBindingAtom() || s;
                        if (this.match(74) || this.match(75) || i) {
                            const r = this.startNode();
                            let i;
                            if (n) {
                                i = "await using";
                                if (!this.recordAwaitIfAllowed()) {
                                    this.raise(p.AwaitUsingNotInAsyncContext, this.state.startLoc);
                                }
                                this.next();
                            } else {
                                i = this.state.value;
                            }
                            this.next();
                            this.parseVar(r, true, i);
                            const a = this.finishNode(r, "VariableDeclaration");
                            const o = this.match(58);
                            if (o && s) {
                                this.raise(p.ForInUsing, a);
                            }
                            if ((o || this.isContextual(102)) && a.declarations.length === 1) {
                                return this.parseForIn(e1, a, t);
                            }
                            if (t !== null) {
                                this.unexpected(t);
                            }
                            return this.parseFor(e1, a);
                        }
                    }
                    const n = this.isContextual(95);
                    const s = new ExpressionErrors;
                    const i = this.parseExpression(true, s);
                    const a = this.isContextual(102);
                    if (a) {
                        if (r) {
                            this.raise(p.ForOfLet, i);
                        }
                        if (t === null && n && i.type === "Identifier") {
                            this.raise(p.ForOfAsync, i);
                        }
                    }
                    if (a || this.match(58)) {
                        this.checkDestructuringPrivate(s);
                        this.toAssignable(i, true);
                        const r = a ? "ForOfStatement" : "ForInStatement";
                        this.checkLVal(i, {
                            type: r
                        });
                        return this.parseForIn(e1, i, t);
                    } else {
                        this.checkExpressionErrors(s, true);
                    }
                    if (t !== null) {
                        this.unexpected(t);
                    }
                    return this.parseFor(e1, i);
                }
                parseFunctionStatement(e1, t, r) {
                    this.next();
                    return this.parseFunction(e1, 1 | (r ? 2 : 0) | (t ? 8 : 0));
                }
                parseIfStatement(e1) {
                    this.next();
                    e1.test = this.parseHeaderExpression();
                    e1.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
                    e1.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
                    return this.finishNode(e1, "IfStatement");
                }
                parseReturnStatement(e1) {
                    if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
                        this.raise(p.IllegalReturn, this.state.startLoc);
                    }
                    this.next();
                    if (this.isLineTerminator()) {
                        e1.argument = null;
                    } else {
                        e1.argument = this.parseExpression();
                        this.semicolon();
                    }
                    return this.finishNode(e1, "ReturnStatement");
                }
                parseSwitchStatement(e1) {
                    this.next();
                    e1.discriminant = this.parseHeaderExpression();
                    const t = e1.cases = [];
                    this.expect(5);
                    this.state.labels.push(oe);
                    this.scope.enter(0);
                    let r;
                    for(let e1; !this.match(8);){
                        if (this.match(61) || this.match(65)) {
                            const n = this.match(61);
                            if (r) this.finishNode(r, "SwitchCase");
                            t.push(r = this.startNode());
                            r.consequent = [];
                            this.next();
                            if (n) {
                                r.test = this.parseExpression();
                            } else {
                                if (e1) {
                                    this.raise(p.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
                                }
                                e1 = true;
                                r.test = null;
                            }
                            this.expect(14);
                        } else {
                            if (r) {
                                r.consequent.push(this.parseStatementListItem());
                            } else {
                                this.unexpected();
                            }
                        }
                    }
                    this.scope.exit();
                    if (r) this.finishNode(r, "SwitchCase");
                    this.next();
                    this.state.labels.pop();
                    return this.finishNode(e1, "SwitchStatement");
                }
                parseThrowStatement(e1) {
                    this.next();
                    if (this.hasPrecedingLineBreak()) {
                        this.raise(p.NewlineAfterThrow, this.state.lastTokEndLoc);
                    }
                    e1.argument = this.parseExpression();
                    this.semicolon();
                    return this.finishNode(e1, "ThrowStatement");
                }
                parseCatchClauseParam() {
                    const e1 = this.parseBindingAtom();
                    this.scope.enter(this.options.annexB && e1.type === "Identifier" ? 8 : 0);
                    this.checkLVal(e1, {
                        type: "CatchClause"
                    }, 9);
                    return e1;
                }
                parseTryStatement(e1) {
                    this.next();
                    e1.block = this.parseBlock();
                    e1.handler = null;
                    if (this.match(62)) {
                        const t = this.startNode();
                        this.next();
                        if (this.match(10)) {
                            this.expect(10);
                            t.param = this.parseCatchClauseParam();
                            this.expect(11);
                        } else {
                            t.param = null;
                            this.scope.enter(0);
                        }
                        t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseBlock(false, false));
                        this.scope.exit();
                        e1.handler = this.finishNode(t, "CatchClause");
                    }
                    e1.finalizer = this.eat(67) ? this.parseBlock() : null;
                    if (!e1.handler && !e1.finalizer) {
                        this.raise(p.NoCatchOrFinally, e1);
                    }
                    return this.finishNode(e1, "TryStatement");
                }
                parseVarStatement(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    this.next();
                    this.parseVar(e1, false, t, r);
                    this.semicolon();
                    return this.finishNode(e1, "VariableDeclaration");
                }
                parseWhileStatement(e1) {
                    this.next();
                    e1.test = this.parseHeaderExpression();
                    this.state.labels.push(ae);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.state.labels.pop();
                    return this.finishNode(e1, "WhileStatement");
                }
                parseWithStatement(e1) {
                    if (this.state.strict) {
                        this.raise(p.StrictWith, this.state.startLoc);
                    }
                    this.next();
                    e1.object = this.parseHeaderExpression();
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    return this.finishNode(e1, "WithStatement");
                }
                parseEmptyStatement(e1) {
                    this.next();
                    return this.finishNode(e1, "EmptyStatement");
                }
                parseLabeledStatement(e1, t, r, n) {
                    for (const e1 of this.state.labels){
                        if (e1.name === t) {
                            this.raise(p.LabelRedeclaration, r, {
                                labelName: t
                            });
                        }
                    }
                    const s = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
                    for(let t = this.state.labels.length - 1; t >= 0; t--){
                        const r = this.state.labels[t];
                        if (r.statementStart === e1.start) {
                            r.statementStart = this.sourceToOffsetPos(this.state.start);
                            r.kind = s;
                        } else {
                            break;
                        }
                    }
                    this.state.labels.push({
                        name: t,
                        kind: s,
                        statementStart: this.sourceToOffsetPos(this.state.start)
                    });
                    e1.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
                    this.state.labels.pop();
                    e1.label = r;
                    return this.finishNode(e1, "LabeledStatement");
                }
                parseExpressionStatement(e1, t, r) {
                    e1.expression = t;
                    this.semicolon();
                    return this.finishNode(e1, "ExpressionStatement");
                }
                parseBlock() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, r = arguments.length > 2 ? arguments[2] : void 0;
                    const n = this.startNode();
                    if (e1) {
                        this.state.strictErrors.clear();
                    }
                    this.expect(5);
                    if (t) {
                        this.scope.enter(0);
                    }
                    this.parseBlockBody(n, e1, false, 8, r);
                    if (t) {
                        this.scope.exit();
                    }
                    return this.finishNode(n, "BlockStatement");
                }
                isValidDirective(e1) {
                    return e1.type === "ExpressionStatement" && e1.expression.type === "StringLiteral" && !e1.expression.extra.parenthesized;
                }
                parseBlockBody(e1, t, r, n, s) {
                    const i = e1.body = [];
                    const a = e1.directives = [];
                    this.parseBlockOrModuleBlockBody(i, t ? a : undefined, r, n, s);
                }
                parseBlockOrModuleBlockBody(e1, t, r, n, s) {
                    const i = this.state.strict;
                    let a = false;
                    let o = false;
                    while(!this.match(n)){
                        const n = r ? this.parseModuleItem() : this.parseStatementListItem();
                        if (t && !o) {
                            if (this.isValidDirective(n)) {
                                const e1 = this.stmtToDirective(n);
                                t.push(e1);
                                if (!a && e1.value.value === "use strict") {
                                    a = true;
                                    this.setStrict(true);
                                }
                                continue;
                            }
                            o = true;
                            this.state.strictErrors.clear();
                        }
                        e1.push(n);
                    }
                    s == null || s.call(this, a);
                    if (!i) {
                        this.setStrict(false);
                    }
                    this.next();
                }
                parseFor(e1, t) {
                    e1.init = t;
                    this.semicolon(false);
                    e1.test = this.match(13) ? null : this.parseExpression();
                    this.semicolon(false);
                    e1.update = this.match(11) ? null : this.parseExpression();
                    this.expect(11);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.scope.exit();
                    this.state.labels.pop();
                    return this.finishNode(e1, "ForStatement");
                }
                parseForIn(e1, t, r) {
                    const n = this.match(58);
                    this.next();
                    if (n) {
                        if (r !== null) this.unexpected(r);
                    } else {
                        e1.await = r !== null;
                    }
                    if (t.type === "VariableDeclaration" && t.declarations[0].init != null && (!n || !this.options.annexB || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier")) {
                        this.raise(p.ForInOfLoopInitializer, t, {
                            type: n ? "ForInStatement" : "ForOfStatement"
                        });
                    }
                    if (t.type === "AssignmentPattern") {
                        this.raise(p.InvalidLhs, t, {
                            ancestor: {
                                type: "ForStatement"
                            }
                        });
                    }
                    e1.left = t;
                    e1.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn();
                    this.expect(11);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.scope.exit();
                    this.state.labels.pop();
                    return this.finishNode(e1, n ? "ForInStatement" : "ForOfStatement");
                }
                parseVar(e1, t, r) {
                    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                    const s = e1.declarations = [];
                    e1.kind = r;
                    for(;;){
                        const e1 = this.startNode();
                        this.parseVarId(e1, r);
                        e1.init = !this.eat(29) ? null : t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
                        if (e1.init === null && !n) {
                            if (e1.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(102)))) {
                                this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                                    kind: "destructuring"
                                });
                            } else if ((r === "const" || r === "using" || r === "await using") && !(this.match(58) || this.isContextual(102))) {
                                this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                                    kind: r
                                });
                            }
                        }
                        s.push(this.finishNode(e1, "VariableDeclarator"));
                        if (!this.eat(12)) break;
                    }
                    return e1;
                }
                parseVarId(e1, t) {
                    const r = this.parseBindingAtom();
                    if (t === "using" || t === "await using") {
                        if (r.type === "ArrayPattern" || r.type === "ObjectPattern") {
                            this.raise(p.UsingDeclarationHasBindingPattern, r.loc.start);
                        }
                    }
                    this.checkLVal(r, {
                        type: "VariableDeclarator"
                    }, t === "var" ? 5 : 8201);
                    e1.id = r;
                }
                parseAsyncFunctionExpression(e1) {
                    return this.parseFunction(e1, 8);
                }
                parseFunction(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                    const r = t & 2;
                    const n = !!(t & 1);
                    const s = n && !(t & 4);
                    const i = !!(t & 8);
                    this.initFunction(e1, i);
                    if (this.match(55)) {
                        if (r) {
                            this.raise(p.GeneratorInSingleStatementContext, this.state.startLoc);
                        }
                        this.next();
                        e1.generator = true;
                    }
                    if (n) {
                        e1.id = this.parseFunctionId(s);
                    }
                    const a = this.state.maybeInArrowParameters;
                    this.state.maybeInArrowParameters = false;
                    this.scope.enter(2);
                    this.prodParam.enter(functionFlags(i, e1.generator));
                    if (!n) {
                        e1.id = this.parseFunctionId();
                    }
                    this.parseFunctionParams(e1, false);
                    this.withSmartMixTopicForbiddingContext(()=>{
                        this.parseFunctionBodyAndFinish(e1, n ? "FunctionDeclaration" : "FunctionExpression");
                    });
                    this.prodParam.exit();
                    this.scope.exit();
                    if (n && !r) {
                        this.registerFunctionStatementId(e1);
                    }
                    this.state.maybeInArrowParameters = a;
                    return e1;
                }
                parseFunctionId(e1) {
                    return e1 || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
                }
                parseFunctionParams(e1, t) {
                    this.expect(10);
                    this.expressionScope.enter(newParameterDeclarationScope());
                    e1.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0));
                    this.expressionScope.exit();
                }
                registerFunctionStatementId(e1) {
                    if (!e1.id) return;
                    this.scope.declareName(e1.id.name, !this.options.annexB || this.state.strict || e1.generator || e1.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e1.id.loc.start);
                }
                parseClass(e1, t, r) {
                    this.next();
                    const n = this.state.strict;
                    this.state.strict = true;
                    this.parseClassId(e1, t, r);
                    this.parseClassSuper(e1);
                    e1.body = this.parseClassBody(!!e1.superClass, n);
                    return this.finishNode(e1, t ? "ClassDeclaration" : "ClassExpression");
                }
                isClassProperty() {
                    return this.match(29) || this.match(13) || this.match(8);
                }
                isClassMethod() {
                    return this.match(10);
                }
                nameIsConstructor(e1) {
                    return e1.type === "Identifier" && e1.name === "constructor" || e1.type === "StringLiteral" && e1.value === "constructor";
                }
                isNonstaticConstructor(e1) {
                    return !e1.computed && !e1.static && this.nameIsConstructor(e1.key);
                }
                parseClassBody(e1, t) {
                    this.classScope.enter();
                    const r = {
                        hadConstructor: false,
                        hadSuperClass: e1
                    };
                    let n = [];
                    const s = this.startNode();
                    s.body = [];
                    this.expect(5);
                    this.withSmartMixTopicForbiddingContext(()=>{
                        while(!this.match(8)){
                            if (this.eat(13)) {
                                if (n.length > 0) {
                                    throw this.raise(p.DecoratorSemicolon, this.state.lastTokEndLoc);
                                }
                                continue;
                            }
                            if (this.match(26)) {
                                n.push(this.parseDecorator());
                                continue;
                            }
                            const e1 = this.startNode();
                            if (n.length) {
                                e1.decorators = n;
                                this.resetStartLocationFromNode(e1, n[0]);
                                n = [];
                            }
                            this.parseClassMember(s, e1, r);
                            if (e1.kind === "constructor" && e1.decorators && e1.decorators.length > 0) {
                                this.raise(p.DecoratorConstructor, e1);
                            }
                        }
                    });
                    this.state.strict = t;
                    this.next();
                    if (n.length) {
                        throw this.raise(p.TrailingDecorator, this.state.startLoc);
                    }
                    this.classScope.exit();
                    return this.finishNode(s, "ClassBody");
                }
                parseClassMemberFromModifier(e1, t) {
                    const r = this.parseIdentifier(true);
                    if (this.isClassMethod()) {
                        const n = t;
                        n.kind = "method";
                        n.computed = false;
                        n.key = r;
                        n.static = false;
                        this.pushClassMethod(e1, n, false, false, false, false);
                        return true;
                    } else if (this.isClassProperty()) {
                        const n = t;
                        n.computed = false;
                        n.key = r;
                        n.static = false;
                        e1.body.push(this.parseClassProperty(n));
                        return true;
                    }
                    this.resetPreviousNodeTrailingComments(r);
                    return false;
                }
                parseClassMember(e1, t, r) {
                    const n = this.isContextual(106);
                    if (n) {
                        if (this.parseClassMemberFromModifier(e1, t)) {
                            return;
                        }
                        if (this.eat(5)) {
                            this.parseClassStaticBlock(e1, t);
                            return;
                        }
                    }
                    this.parseClassMemberWithIsStatic(e1, t, r, n);
                }
                parseClassMemberWithIsStatic(e1, t, r, n) {
                    const s = t;
                    const i = t;
                    const a = t;
                    const o = t;
                    const l = t;
                    const c = s;
                    const u = s;
                    t.static = n;
                    this.parsePropertyNamePrefixOperator(t);
                    if (this.eat(55)) {
                        c.kind = "method";
                        const t = this.match(139);
                        this.parseClassElementName(c);
                        if (t) {
                            this.pushClassPrivateMethod(e1, i, true, false);
                            return;
                        }
                        if (this.isNonstaticConstructor(s)) {
                            this.raise(p.ConstructorIsGenerator, s.key);
                        }
                        this.pushClassMethod(e1, s, true, false, false, false);
                        return;
                    }
                    const d = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
                    const f = this.parseClassElementName(t);
                    const h = d ? f.name : null;
                    const m = this.isPrivateName(f);
                    const y = this.state.startLoc;
                    this.parsePostMemberNameModifiers(u);
                    if (this.isClassMethod()) {
                        c.kind = "method";
                        if (m) {
                            this.pushClassPrivateMethod(e1, i, false, false);
                            return;
                        }
                        const n = this.isNonstaticConstructor(s);
                        let a = false;
                        if (n) {
                            s.kind = "constructor";
                            if (r.hadConstructor && !this.hasPlugin("typescript")) {
                                this.raise(p.DuplicateConstructor, f);
                            }
                            if (n && this.hasPlugin("typescript") && t.override) {
                                this.raise(p.OverrideOnConstructor, f);
                            }
                            r.hadConstructor = true;
                            a = r.hadSuperClass;
                        }
                        this.pushClassMethod(e1, s, false, false, n, a);
                    } else if (this.isClassProperty()) {
                        if (m) {
                            this.pushClassPrivateProperty(e1, o);
                        } else {
                            this.pushClassProperty(e1, a);
                        }
                    } else if (h === "async" && !this.isLineTerminator()) {
                        this.resetPreviousNodeTrailingComments(f);
                        const t = this.eat(55);
                        if (u.optional) {
                            this.unexpected(y);
                        }
                        c.kind = "method";
                        const r = this.match(139);
                        this.parseClassElementName(c);
                        this.parsePostMemberNameModifiers(u);
                        if (r) {
                            this.pushClassPrivateMethod(e1, i, t, true);
                        } else {
                            if (this.isNonstaticConstructor(s)) {
                                this.raise(p.ConstructorIsAsync, s.key);
                            }
                            this.pushClassMethod(e1, s, t, true, false, false);
                        }
                    } else if ((h === "get" || h === "set") && !(this.match(55) && this.isLineTerminator())) {
                        this.resetPreviousNodeTrailingComments(f);
                        c.kind = h;
                        const t = this.match(139);
                        this.parseClassElementName(s);
                        if (t) {
                            this.pushClassPrivateMethod(e1, i, false, false);
                        } else {
                            if (this.isNonstaticConstructor(s)) {
                                this.raise(p.ConstructorIsAccessor, s.key);
                            }
                            this.pushClassMethod(e1, s, false, false, false, false);
                        }
                        this.checkGetterSetterParams(s);
                    } else if (h === "accessor" && !this.isLineTerminator()) {
                        this.expectPlugin("decoratorAutoAccessors");
                        this.resetPreviousNodeTrailingComments(f);
                        const t = this.match(139);
                        this.parseClassElementName(a);
                        this.pushClassAccessorProperty(e1, l, t);
                    } else if (this.isLineTerminator()) {
                        if (m) {
                            this.pushClassPrivateProperty(e1, o);
                        } else {
                            this.pushClassProperty(e1, a);
                        }
                    } else {
                        this.unexpected();
                    }
                }
                parseClassElementName(e1) {
                    const { type: t, value: r } = this.state;
                    if ((t === 132 || t === 134) && e1.static && r === "prototype") {
                        this.raise(p.StaticPrototype, this.state.startLoc);
                    }
                    if (t === 139) {
                        if (r === "constructor") {
                            this.raise(p.ConstructorClassPrivateField, this.state.startLoc);
                        }
                        const t = this.parsePrivateName();
                        e1.key = t;
                        return t;
                    }
                    this.parsePropertyName(e1);
                    return e1.key;
                }
                parseClassStaticBlock(e1, t) {
                    var r;
                    this.scope.enter(64 | 128 | 16);
                    const n = this.state.labels;
                    this.state.labels = [];
                    this.prodParam.enter(0);
                    const s = t.body = [];
                    this.parseBlockOrModuleBlockBody(s, undefined, false, 8);
                    this.prodParam.exit();
                    this.scope.exit();
                    this.state.labels = n;
                    e1.body.push(this.finishNode(t, "StaticBlock"));
                    if ((r = t.decorators) != null && r.length) {
                        this.raise(p.DecoratorStaticBlock, t);
                    }
                }
                pushClassProperty(e1, t) {
                    if (!t.computed && this.nameIsConstructor(t.key)) {
                        this.raise(p.ConstructorClassField, t.key);
                    }
                    e1.body.push(this.parseClassProperty(t));
                }
                pushClassPrivateProperty(e1, t) {
                    const r = this.parseClassPrivateProperty(t);
                    e1.body.push(r);
                    this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
                }
                pushClassAccessorProperty(e1, t, r) {
                    if (!r && !t.computed && this.nameIsConstructor(t.key)) {
                        this.raise(p.ConstructorClassField, t.key);
                    }
                    const n = this.parseClassAccessorProperty(t);
                    e1.body.push(n);
                    if (r) {
                        this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
                    }
                }
                pushClassMethod(e1, t, r, n, s, i) {
                    e1.body.push(this.parseMethod(t, r, n, s, i, "ClassMethod", true));
                }
                pushClassPrivateMethod(e1, t, r, n) {
                    const s = this.parseMethod(t, r, n, false, false, "ClassPrivateMethod", true);
                    e1.body.push(s);
                    const i = s.kind === "get" ? s.static ? 6 : 2 : s.kind === "set" ? s.static ? 5 : 1 : 0;
                    this.declareClassPrivateMethodInScope(s, i);
                }
                declareClassPrivateMethodInScope(e1, t) {
                    this.classScope.declarePrivateName(this.getPrivateNameSV(e1.key), t, e1.key.loc.start);
                }
                parsePostMemberNameModifiers(e1) {}
                parseClassPrivateProperty(e1) {
                    this.parseInitializer(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ClassPrivateProperty");
                }
                parseClassProperty(e1) {
                    this.parseInitializer(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ClassProperty");
                }
                parseClassAccessorProperty(e1) {
                    this.parseInitializer(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ClassAccessorProperty");
                }
                parseInitializer(e1) {
                    this.scope.enter(64 | 16);
                    this.expressionScope.enter(newExpressionScope());
                    this.prodParam.enter(0);
                    e1.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
                    this.expressionScope.exit();
                    this.prodParam.exit();
                    this.scope.exit();
                }
                parseClassId(e1, t, r) {
                    let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 8331;
                    if (tokenIsIdentifier(this.state.type)) {
                        e1.id = this.parseIdentifier();
                        if (t) {
                            this.declareNameFromIdentifier(e1.id, n);
                        }
                    } else {
                        if (r || !t) {
                            e1.id = null;
                        } else {
                            throw this.raise(p.MissingClassName, this.state.startLoc);
                        }
                    }
                }
                parseClassSuper(e1) {
                    e1.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
                }
                parseExport(e1, t) {
                    const r = this.parseMaybeImportPhase(e1, true);
                    const n = this.maybeParseExportDefaultSpecifier(e1, r);
                    const s = !n || this.eat(12);
                    const i = s && this.eatExportStar(e1);
                    const a = i && this.maybeParseExportNamespaceSpecifier(e1);
                    const o = s && (!a || this.eat(12));
                    const l = n || i;
                    if (i && !a) {
                        if (n) this.unexpected();
                        if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, e1);
                        }
                        this.parseExportFrom(e1, true);
                        this.sawUnambiguousESM = true;
                        return this.finishNode(e1, "ExportAllDeclaration");
                    }
                    const c = this.maybeParseExportNamedSpecifiers(e1);
                    if (n && s && !i && !c) {
                        this.unexpected(null, 5);
                    }
                    if (a && o) {
                        this.unexpected(null, 98);
                    }
                    let u;
                    if (l || c) {
                        u = false;
                        if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, e1);
                        }
                        this.parseExportFrom(e1, l);
                    } else {
                        u = this.maybeParseExportDeclaration(e1);
                    }
                    if (l || c || u) {
                        var d;
                        const r = e1;
                        this.checkExport(r, true, false, !!r.source);
                        if (((d = r.declaration) == null ? void 0 : d.type) === "ClassDeclaration") {
                            this.maybeTakeDecorators(t, r.declaration, r);
                        } else if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, e1);
                        }
                        this.sawUnambiguousESM = true;
                        return this.finishNode(r, "ExportNamedDeclaration");
                    }
                    if (this.eat(65)) {
                        const r = e1;
                        const n = this.parseExportDefaultExpression();
                        r.declaration = n;
                        if (n.type === "ClassDeclaration") {
                            this.maybeTakeDecorators(t, n, r);
                        } else if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, e1);
                        }
                        this.checkExport(r, true, true);
                        this.sawUnambiguousESM = true;
                        return this.finishNode(r, "ExportDefaultDeclaration");
                    }
                    this.unexpected(null, 5);
                }
                eatExportStar(e1) {
                    return this.eat(55);
                }
                maybeParseExportDefaultSpecifier(e1, t) {
                    if (t || this.isExportDefaultSpecifier()) {
                        this.expectPlugin("exportDefaultFrom", t == null ? void 0 : t.loc.start);
                        const r = t || this.parseIdentifier(true);
                        const n = this.startNodeAtNode(r);
                        n.exported = r;
                        e1.specifiers = [
                            this.finishNode(n, "ExportDefaultSpecifier")
                        ];
                        return true;
                    }
                    return false;
                }
                maybeParseExportNamespaceSpecifier(e1) {
                    if (this.isContextual(93)) {
                        var t, r;
                        (r = (t = e1).specifiers) != null ? r : t.specifiers = [];
                        const n = this.startNodeAt(this.state.lastTokStartLoc);
                        this.next();
                        n.exported = this.parseModuleExportName();
                        e1.specifiers.push(this.finishNode(n, "ExportNamespaceSpecifier"));
                        return true;
                    }
                    return false;
                }
                maybeParseExportNamedSpecifiers(e1) {
                    if (this.match(5)) {
                        const t = e1;
                        if (!t.specifiers) t.specifiers = [];
                        const r = t.exportKind === "type";
                        t.specifiers.push(...this.parseExportSpecifiers(r));
                        t.source = null;
                        if (this.hasPlugin("importAssertions")) {
                            t.assertions = [];
                        } else {
                            t.attributes = [];
                        }
                        t.declaration = null;
                        return true;
                    }
                    return false;
                }
                maybeParseExportDeclaration(e1) {
                    if (this.shouldParseExportDeclaration()) {
                        e1.specifiers = [];
                        e1.source = null;
                        if (this.hasPlugin("importAssertions")) {
                            e1.assertions = [];
                        } else {
                            e1.attributes = [];
                        }
                        e1.declaration = this.parseExportDeclaration(e1);
                        return true;
                    }
                    return false;
                }
                isAsyncFunction() {
                    if (!this.isContextual(95)) return false;
                    const e1 = this.nextTokenInLineStart();
                    return this.isUnparsedContextual(e1, "function");
                }
                parseExportDefaultExpression() {
                    const e1 = this.startNode();
                    if (this.match(68)) {
                        this.next();
                        return this.parseFunction(e1, 1 | 4);
                    } else if (this.isAsyncFunction()) {
                        this.next();
                        this.next();
                        return this.parseFunction(e1, 1 | 4 | 8);
                    }
                    if (this.match(80)) {
                        return this.parseClass(e1, true, true);
                    }
                    if (this.match(26)) {
                        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                            this.raise(p.DecoratorBeforeExport, this.state.startLoc);
                        }
                        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
                    }
                    if (this.match(75) || this.match(74) || this.isLet()) {
                        throw this.raise(p.UnsupportedDefaultExport, this.state.startLoc);
                    }
                    const t = this.parseMaybeAssignAllowIn();
                    this.semicolon();
                    return t;
                }
                parseExportDeclaration(e1) {
                    if (this.match(80)) {
                        const e1 = this.parseClass(this.startNode(), true, false);
                        return e1;
                    }
                    return this.parseStatementListItem();
                }
                isExportDefaultSpecifier() {
                    const { type: e1 } = this.state;
                    if (tokenIsIdentifier(e1)) {
                        if (e1 === 95 && !this.state.containsEsc || e1 === 100) {
                            return false;
                        }
                        if ((e1 === 130 || e1 === 129) && !this.state.containsEsc) {
                            const { type: e1 } = this.lookahead();
                            if (tokenIsIdentifier(e1) && e1 !== 98 || e1 === 5) {
                                this.expectOnePlugin([
                                    "flow",
                                    "typescript"
                                ]);
                                return false;
                            }
                        }
                    } else if (!this.match(65)) {
                        return false;
                    }
                    const t = this.nextTokenStart();
                    const r = this.isUnparsedContextual(t, "from");
                    if (this.input.charCodeAt(t) === 44 || tokenIsIdentifier(this.state.type) && r) {
                        return true;
                    }
                    if (this.match(65) && r) {
                        const e1 = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
                        return e1 === 34 || e1 === 39;
                    }
                    return false;
                }
                parseExportFrom(e1, t) {
                    if (this.eatContextual(98)) {
                        e1.source = this.parseImportSource();
                        this.checkExport(e1);
                        this.maybeParseImportAttributes(e1);
                        this.checkJSONModuleImport(e1);
                    } else if (t) {
                        this.unexpected();
                    }
                    this.semicolon();
                }
                shouldParseExportDeclaration() {
                    const { type: e1 } = this.state;
                    if (e1 === 26) {
                        this.expectOnePlugin([
                            "decorators",
                            "decorators-legacy"
                        ]);
                        if (this.hasPlugin("decorators")) {
                            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                                this.raise(p.DecoratorBeforeExport, this.state.startLoc);
                            }
                            return true;
                        }
                    }
                    if (this.isContextual(107)) {
                        this.raise(p.UsingDeclarationExport, this.state.startLoc);
                        return true;
                    }
                    if (this.isContextual(96) && this.startsAwaitUsing()) {
                        this.raise(p.UsingDeclarationExport, this.state.startLoc);
                        return true;
                    }
                    return e1 === 74 || e1 === 75 || e1 === 68 || e1 === 80 || this.isLet() || this.isAsyncFunction();
                }
                checkExport(e1, t, r, n) {
                    if (t) {
                        var s;
                        if (r) {
                            this.checkDuplicateExports(e1, "default");
                            if (this.hasPlugin("exportDefaultFrom")) {
                                var i;
                                const t = e1.declaration;
                                if (t.type === "Identifier" && t.name === "from" && t.end - t.start === 4 && !((i = t.extra) != null && i.parenthesized)) {
                                    this.raise(p.ExportDefaultFromAsIdentifier, t);
                                }
                            }
                        } else if ((s = e1.specifiers) != null && s.length) {
                            for (const t of e1.specifiers){
                                const { exported: e1 } = t;
                                const r = e1.type === "Identifier" ? e1.name : e1.value;
                                this.checkDuplicateExports(t, r);
                                if (!n && t.local) {
                                    const { local: e1 } = t;
                                    if (e1.type !== "Identifier") {
                                        this.raise(p.ExportBindingIsString, t, {
                                            localName: e1.value,
                                            exportName: r
                                        });
                                    } else {
                                        this.checkReservedWord(e1.name, e1.loc.start, true, false);
                                        this.scope.checkLocalExport(e1);
                                    }
                                }
                            }
                        } else if (e1.declaration) {
                            const t = e1.declaration;
                            if (t.type === "FunctionDeclaration" || t.type === "ClassDeclaration") {
                                const { id: r } = t;
                                if (!r) throw new Error("Assertion failure");
                                this.checkDuplicateExports(e1, r.name);
                            } else if (t.type === "VariableDeclaration") {
                                for (const e1 of t.declarations){
                                    this.checkDeclaration(e1.id);
                                }
                            }
                        }
                    }
                }
                checkDeclaration(e1) {
                    if (e1.type === "Identifier") {
                        this.checkDuplicateExports(e1, e1.name);
                    } else if (e1.type === "ObjectPattern") {
                        for (const t of e1.properties){
                            this.checkDeclaration(t);
                        }
                    } else if (e1.type === "ArrayPattern") {
                        for (const t of e1.elements){
                            if (t) {
                                this.checkDeclaration(t);
                            }
                        }
                    } else if (e1.type === "ObjectProperty") {
                        this.checkDeclaration(e1.value);
                    } else if (e1.type === "RestElement") {
                        this.checkDeclaration(e1.argument);
                    } else if (e1.type === "AssignmentPattern") {
                        this.checkDeclaration(e1.left);
                    }
                }
                checkDuplicateExports(e1, t) {
                    if (this.exportedIdentifiers.has(t)) {
                        if (t === "default") {
                            this.raise(p.DuplicateDefaultExport, e1);
                        } else {
                            this.raise(p.DuplicateExport, e1, {
                                exportName: t
                            });
                        }
                    }
                    this.exportedIdentifiers.add(t);
                }
                parseExportSpecifiers(e1) {
                    const t = [];
                    let r = true;
                    this.expect(5);
                    while(!this.eat(8)){
                        if (r) {
                            r = false;
                        } else {
                            this.expect(12);
                            if (this.eat(8)) break;
                        }
                        const n = this.isContextual(130);
                        const s = this.match(134);
                        const i = this.startNode();
                        i.local = this.parseModuleExportName();
                        t.push(this.parseExportSpecifier(i, s, e1, n));
                    }
                    return t;
                }
                parseExportSpecifier(e1, t, r, n) {
                    if (this.eatContextual(93)) {
                        e1.exported = this.parseModuleExportName();
                    } else if (t) {
                        e1.exported = cloneStringLiteral(e1.local);
                    } else if (!e1.exported) {
                        e1.exported = cloneIdentifier(e1.local);
                    }
                    return this.finishNode(e1, "ExportSpecifier");
                }
                parseModuleExportName() {
                    if (this.match(134)) {
                        const e1 = this.parseStringLiteral(this.state.value);
                        const t = le.exec(e1.value);
                        if (t) {
                            this.raise(p.ModuleExportNameHasLoneSurrogate, e1, {
                                surrogateCharCode: t[0].charCodeAt(0)
                            });
                        }
                        return e1;
                    }
                    return this.parseIdentifier(true);
                }
                isJSONModuleImport(e1) {
                    if (e1.assertions != null) {
                        return e1.assertions.some((param)=>{
                            let { key: e1, value: t } = param;
                            return t.value === "json" && (e1.type === "Identifier" ? e1.name === "type" : e1.value === "type");
                        });
                    }
                    return false;
                }
                checkImportReflection(e1) {
                    const { specifiers: t } = e1;
                    const r = t.length === 1 ? t[0].type : null;
                    if (e1.phase === "source") {
                        if (r !== "ImportDefaultSpecifier") {
                            this.raise(p.SourcePhaseImportRequiresDefault, t[0].loc.start);
                        }
                    } else if (e1.phase === "defer") {
                        if (r !== "ImportNamespaceSpecifier") {
                            this.raise(p.DeferImportRequiresNamespace, t[0].loc.start);
                        }
                    } else if (e1.module) {
                        var n;
                        if (r !== "ImportDefaultSpecifier") {
                            this.raise(p.ImportReflectionNotBinding, t[0].loc.start);
                        }
                        if (((n = e1.assertions) == null ? void 0 : n.length) > 0) {
                            this.raise(p.ImportReflectionHasAssertion, t[0].loc.start);
                        }
                    }
                }
                checkJSONModuleImport(e1) {
                    if (this.isJSONModuleImport(e1) && e1.type !== "ExportAllDeclaration") {
                        const { specifiers: t } = e1;
                        if (t != null) {
                            const e1 = t.find((e1)=>{
                                let t;
                                if (e1.type === "ExportSpecifier") {
                                    t = e1.local;
                                } else if (e1.type === "ImportSpecifier") {
                                    t = e1.imported;
                                }
                                if (t !== undefined) {
                                    return t.type === "Identifier" ? t.name !== "default" : t.value !== "default";
                                }
                            });
                            if (e1 !== undefined) {
                                this.raise(p.ImportJSONBindingNotDefault, e1.loc.start);
                            }
                        }
                    }
                }
                isPotentialImportPhase(e1) {
                    if (e1) return false;
                    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
                }
                applyImportPhase(e1, t, r, n) {
                    if (t) {
                        return;
                    }
                    if (r === "module") {
                        this.expectPlugin("importReflection", n);
                        e1.module = true;
                    } else if (this.hasPlugin("importReflection")) {
                        e1.module = false;
                    }
                    if (r === "source") {
                        this.expectPlugin("sourcePhaseImports", n);
                        e1.phase = "source";
                    } else if (r === "defer") {
                        this.expectPlugin("deferredImportEvaluation", n);
                        e1.phase = "defer";
                    } else if (this.hasPlugin("sourcePhaseImports")) {
                        e1.phase = null;
                    }
                }
                parseMaybeImportPhase(e1, t) {
                    if (!this.isPotentialImportPhase(t)) {
                        this.applyImportPhase(e1, t, null);
                        return null;
                    }
                    const r = this.parseIdentifier(true);
                    const { type: n } = this.state;
                    const s = tokenIsKeywordOrIdentifier(n) ? n !== 98 || this.lookaheadCharCode() === 102 : n !== 12;
                    if (s) {
                        this.resetPreviousIdentifierLeadingComments(r);
                        this.applyImportPhase(e1, t, r.name, r.loc.start);
                        return null;
                    } else {
                        this.applyImportPhase(e1, t, null);
                        return r;
                    }
                }
                isPrecedingIdImportPhase(e1) {
                    const { type: t } = this.state;
                    return tokenIsIdentifier(t) ? t !== 98 || this.lookaheadCharCode() === 102 : t !== 12;
                }
                parseImport(e1) {
                    if (this.match(134)) {
                        return this.parseImportSourceAndAttributes(e1);
                    }
                    return this.parseImportSpecifiersAndAfter(e1, this.parseMaybeImportPhase(e1, false));
                }
                parseImportSpecifiersAndAfter(e1, t) {
                    e1.specifiers = [];
                    const r = this.maybeParseDefaultImportSpecifier(e1, t);
                    const n = !r || this.eat(12);
                    const s = n && this.maybeParseStarImportSpecifier(e1);
                    if (n && !s) this.parseNamedImportSpecifiers(e1);
                    this.expectContextual(98);
                    return this.parseImportSourceAndAttributes(e1);
                }
                parseImportSourceAndAttributes(e1) {
                    var t;
                    (t = e1.specifiers) != null ? t : e1.specifiers = [];
                    e1.source = this.parseImportSource();
                    this.maybeParseImportAttributes(e1);
                    this.checkImportReflection(e1);
                    this.checkJSONModuleImport(e1);
                    this.semicolon();
                    this.sawUnambiguousESM = true;
                    return this.finishNode(e1, "ImportDeclaration");
                }
                parseImportSource() {
                    if (!this.match(134)) this.unexpected();
                    return this.parseExprAtom();
                }
                parseImportSpecifierLocal(e1, t, r) {
                    t.local = this.parseIdentifier();
                    e1.specifiers.push(this.finishImportSpecifier(t, r));
                }
                finishImportSpecifier(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 8201;
                    this.checkLVal(e1.local, {
                        type: t
                    }, r);
                    return this.finishNode(e1, t);
                }
                parseImportAttributes() {
                    this.expect(5);
                    const e1 = [];
                    const t = new Set;
                    do {
                        if (this.match(8)) {
                            break;
                        }
                        const r = this.startNode();
                        const n = this.state.value;
                        if (t.has(n)) {
                            this.raise(p.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
                                key: n
                            });
                        }
                        t.add(n);
                        if (this.match(134)) {
                            r.key = this.parseStringLiteral(n);
                        } else {
                            r.key = this.parseIdentifier(true);
                        }
                        this.expect(14);
                        if (!this.match(134)) {
                            throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
                        }
                        r.value = this.parseStringLiteral(this.state.value);
                        e1.push(this.finishNode(r, "ImportAttribute"));
                    }while (this.eat(12))
                    this.expect(8);
                    return e1;
                }
                parseModuleAttributes() {
                    const e1 = [];
                    const t = new Set;
                    do {
                        const r = this.startNode();
                        r.key = this.parseIdentifier(true);
                        if (r.key.name !== "type") {
                            this.raise(p.ModuleAttributeDifferentFromType, r.key);
                        }
                        if (t.has(r.key.name)) {
                            this.raise(p.ModuleAttributesWithDuplicateKeys, r.key, {
                                key: r.key.name
                            });
                        }
                        t.add(r.key.name);
                        this.expect(14);
                        if (!this.match(134)) {
                            throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
                        }
                        r.value = this.parseStringLiteral(this.state.value);
                        e1.push(this.finishNode(r, "ImportAttribute"));
                    }while (this.eat(12))
                    return e1;
                }
                maybeParseImportAttributes(e1) {
                    let t;
                    {
                        var r = false;
                    }
                    if (this.match(76)) {
                        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                            return;
                        }
                        this.next();
                        if (this.hasPlugin("moduleAttributes")) {
                            t = this.parseModuleAttributes();
                            this.addExtra(e1, "deprecatedWithLegacySyntax", true);
                        } else {
                            t = this.parseImportAttributes();
                        }
                        {
                            r = true;
                        }
                    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
                        if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
                            this.raise(p.ImportAttributesUseAssert, this.state.startLoc);
                        }
                        if (!this.hasPlugin("importAssertions")) {
                            this.addExtra(e1, "deprecatedAssertSyntax", true);
                        }
                        this.next();
                        t = this.parseImportAttributes();
                    } else {
                        t = [];
                    }
                    if (!r && this.hasPlugin("importAssertions")) {
                        e1.assertions = t;
                    } else {
                        e1.attributes = t;
                    }
                }
                maybeParseDefaultImportSpecifier(e1, t) {
                    if (t) {
                        const r = this.startNodeAtNode(t);
                        r.local = t;
                        e1.specifiers.push(this.finishImportSpecifier(r, "ImportDefaultSpecifier"));
                        return true;
                    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                        this.parseImportSpecifierLocal(e1, this.startNode(), "ImportDefaultSpecifier");
                        return true;
                    }
                    return false;
                }
                maybeParseStarImportSpecifier(e1) {
                    if (this.match(55)) {
                        const t = this.startNode();
                        this.next();
                        this.expectContextual(93);
                        this.parseImportSpecifierLocal(e1, t, "ImportNamespaceSpecifier");
                        return true;
                    }
                    return false;
                }
                parseNamedImportSpecifiers(e1) {
                    let t = true;
                    this.expect(5);
                    while(!this.eat(8)){
                        if (t) {
                            t = false;
                        } else {
                            if (this.eat(14)) {
                                throw this.raise(p.DestructureNamedImport, this.state.startLoc);
                            }
                            this.expect(12);
                            if (this.eat(8)) break;
                        }
                        const r = this.startNode();
                        const n = this.match(134);
                        const s = this.isContextual(130);
                        r.imported = this.parseModuleExportName();
                        const i = this.parseImportSpecifier(r, n, e1.importKind === "type" || e1.importKind === "typeof", s, undefined);
                        e1.specifiers.push(i);
                    }
                }
                parseImportSpecifier(e1, t, r, n, s) {
                    if (this.eatContextual(93)) {
                        e1.local = this.parseIdentifier();
                    } else {
                        const { imported: r } = e1;
                        if (t) {
                            throw this.raise(p.ImportBindingIsString, e1, {
                                importName: r.value
                            });
                        }
                        this.checkReservedWord(r.name, e1.loc.start, true, true);
                        if (!e1.local) {
                            e1.local = cloneIdentifier(r);
                        }
                    }
                    return this.finishImportSpecifier(e1, "ImportSpecifier", s);
                }
                isThisParam(e1) {
                    return e1.type === "Identifier" && e1.name === "this";
                }
            }
            class Parser extends StatementParser {
                getScopeHandler() {
                    return ScopeHandler;
                }
                parse() {
                    this.enterInitialScopes();
                    const e1 = this.startNode();
                    const t = this.startNode();
                    this.nextToken();
                    e1.errors = null;
                    this.parseTopLevel(e1, t);
                    e1.errors = this.state.errors;
                    e1.comments.length = this.state.commentsLen;
                    return e1;
                }
                constructor(e1, t, r){
                    e1 = getOptions(e1);
                    super(e1, t);
                    this.options = e1;
                    this.initializeScopes();
                    this.plugins = r;
                    this.filename = e1.sourceFilename;
                    this.startIndex = e1.startIndex;
                    let n = 0;
                    if (e1.allowAwaitOutsideFunction) {
                        n |= 1;
                    }
                    if (e1.allowReturnOutsideFunction) {
                        n |= 2;
                    }
                    if (e1.allowImportExportEverywhere) {
                        n |= 8;
                    }
                    if (e1.allowSuperOutsideMethod) {
                        n |= 16;
                    }
                    if (e1.allowUndeclaredExports) {
                        n |= 64;
                    }
                    if (e1.allowNewTargetOutsideFunction) {
                        n |= 4;
                    }
                    if (e1.allowYieldOutsideFunction) {
                        n |= 32;
                    }
                    if (e1.ranges) {
                        n |= 128;
                    }
                    if (e1.tokens) {
                        n |= 256;
                    }
                    if (e1.createImportExpressions) {
                        n |= 512;
                    }
                    if (e1.createParenthesizedExpressions) {
                        n |= 1024;
                    }
                    if (e1.errorRecovery) {
                        n |= 2048;
                    }
                    if (e1.attachComment) {
                        n |= 4096;
                    }
                    if (e1.annexB) {
                        n |= 8192;
                    }
                    this.optionFlags = n;
                }
            }
            function parse(e1, t) {
                var r;
                if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
                    t = Object.assign({}, t);
                    try {
                        t.sourceType = "module";
                        const r = getParser(t, e1);
                        const n = r.parse();
                        if (r.sawUnambiguousESM) {
                            return n;
                        }
                        if (r.ambiguousScriptDifferentAst) {
                            try {
                                t.sourceType = "script";
                                return getParser(t, e1).parse();
                            } catch (e1) {}
                        } else {
                            n.program.sourceType = "script";
                        }
                        return n;
                    } catch (r) {
                        try {
                            t.sourceType = "script";
                            return getParser(t, e1).parse();
                        } catch (e1) {}
                        throw r;
                    }
                } else {
                    return getParser(t, e1).parse();
                }
            }
            function parseExpression(e1, t) {
                const r = getParser(t, e1);
                if (r.options.strictMode) {
                    r.state.strict = true;
                }
                return r.getExpression();
            }
            function generateExportedTokenTypes(e1) {
                const t = {};
                for (const r of Object.keys(e1)){
                    t[r] = getExportedToken(e1[r]);
                }
                return t;
            }
            const pe = generateExportedTokenTypes(I);
            function getParser(e1, t) {
                let r = Parser;
                const n = new Map;
                if (e1 != null && e1.plugins) {
                    for (const t of e1.plugins){
                        let e1, r;
                        if (typeof t === "string") {
                            e1 = t;
                        } else {
                            [e1, r] = t;
                        }
                        if (!n.has(e1)) {
                            n.set(e1, r || {});
                        }
                    }
                    validatePlugins(n);
                    r = getParserClass(n);
                }
                return new r(e1, t, n);
            }
            const ue = new Map;
            function getParserClass(e1) {
                const t = [];
                for (const r of ie){
                    if (e1.has(r)) {
                        t.push(r);
                    }
                }
                const r = t.join("|");
                let n = ue.get(r);
                if (!n) {
                    n = Parser;
                    for (const e1 of t){
                        n = se[e1](n);
                    }
                    ue.set(r, n);
                }
                return n;
            }
            t.parse = parse;
            t.parseExpression = parseExpression;
            t.tokTypes = pe;
        },
        2698: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9045);
            var s = t["default"] = (0, n.declare)((e1)=>{
                e1.assertVersion(7);
                return {
                    name: "syntax-jsx",
                    manipulateOptions (e1, t) {
                        {
                            if (t.plugins.some((e1)=>(Array.isArray(e1) ? e1[0] : e1) === "typescript")) {
                                return;
                            }
                        }
                        t.plugins.push("jsx");
                    }
                };
            });
        },
        8184: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9045);
            {
                var removePlugin = function(e1, t) {
                    const r = [];
                    e1.forEach((e1, n)=>{
                        const s = Array.isArray(e1) ? e1[0] : e1;
                        if (s === t) {
                            r.unshift(n);
                        }
                    });
                    for (const t of r){
                        e1.splice(t, 1);
                    }
                };
            }
            var s = t["default"] = (0, n.declare)((e1, t)=>{
                e1.assertVersion(7);
                const { disallowAmbiguousJSXLike: r, dts: n } = t;
                {
                    var { isTSX: s } = t;
                }
                return {
                    name: "syntax-typescript",
                    manipulateOptions (e1, t) {
                        {
                            const { plugins: e1 } = t;
                            removePlugin(e1, "flow");
                            removePlugin(e1, "jsx");
                            {
                                e1.push("objectRestSpread", "classProperties");
                            }
                            if (s) {
                                e1.push("jsx");
                            }
                        }
                        t.plugins.push([
                            "typescript",
                            {
                                disallowAmbiguousJSXLike: r,
                                dts: n
                            }
                        ]);
                    }
                };
            });
        },
        3086: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transformDynamicImport = transformDynamicImport;
            var n = r(2358);
            var s = r(9460);
            const requireNoInterop = (e1)=>n.template.expression.ast(_templateObject62(), e1);
            const requireInterop = (e1, t)=>n.types.callExpression(t.addHelper("interopRequireWildcard"), [
                    requireNoInterop(e1)
                ]);
            function transformDynamicImport(e1, t, r) {
                const n = t ? requireNoInterop : requireInterop;
                e1.replaceWith((0, s.buildDynamicImport)(e1.node, true, false, (e1)=>n(e1, r)));
            }
        },
        5735: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.defineCommonJSHook = defineCommonJSHook;
            t.makeInvokers = makeInvokers;
            const r = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
            function defineCommonJSHook(e1, t) {
                let n = e1.get(r);
                if (!n) e1.set(r, n = []);
                n.push(t);
            }
            function findMap(e1, t) {
                if (e1) {
                    for (const r of e1){
                        const e1 = t(r);
                        if (e1 != null) return e1;
                    }
                }
            }
            function makeInvokers(e1) {
                const t = e1.get(r);
                return {
                    getWrapperPayload () {
                        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                            e1[_key] = arguments[_key];
                        }
                        return findMap(t, (t)=>t.getWrapperPayload == null ? void 0 : t.getWrapperPayload(...e1));
                    },
                    wrapReference () {
                        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                            e1[_key] = arguments[_key];
                        }
                        return findMap(t, (t)=>t.wrapReference == null ? void 0 : t.wrapReference(...e1));
                    },
                    buildRequireWrapper () {
                        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                            e1[_key] = arguments[_key];
                        }
                        return findMap(t, (t)=>t.buildRequireWrapper == null ? void 0 : t.buildRequireWrapper(...e1));
                    }
                };
            }
        },
        7179: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            Object.defineProperty(t, "defineCommonJSHook", {
                enumerable: true,
                get: function() {
                    return l.defineCommonJSHook;
                }
            });
            var n = r(9045);
            var s = r(9460);
            var i = r(2358);
            var a = r(3086);
            var o = r(2461);
            var l = r(5735);
            var c = t["default"] = (0, n.declare)((e1, t)=>{
                var r, n, c;
                e1.assertVersion(7);
                const { strictNamespace: p = false, mjsStrictNamespace: u = p, allowTopLevelThis: d, strict: f, strictMode: h, noInterop: m, importInterop: y, lazy: g = false, allowCommonJSExports: b = true, loose: T = false } = t;
                const S = (r = e1.assumption("constantReexports")) != null ? r : T;
                const x = (n = e1.assumption("enumerableModuleMeta")) != null ? n : T;
                const E = (c = e1.assumption("noIncompleteNsImportDetection")) != null ? c : false;
                if (typeof g !== "boolean" && typeof g !== "function" && (!Array.isArray(g) || !g.every((e1)=>typeof e1 === "string"))) {
                    throw new Error(".lazy must be a boolean, array of strings, or a function");
                }
                if (typeof p !== "boolean") {
                    throw new Error(".strictNamespace must be a boolean, or undefined");
                }
                if (typeof u !== "boolean") {
                    throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
                }
                const getAssertion = (e1)=>i.template.expression.ast(_templateObject63(), e1);
                const P = {
                    ReferencedIdentifier (e1) {
                        const t = e1.node.name;
                        if (t !== "module" && t !== "exports") return;
                        const r = e1.scope.getBinding(t);
                        const n = this.scope.getBinding(t);
                        if (n !== r || e1.parentPath.isObjectProperty({
                            value: e1.node
                        }) && e1.parentPath.parentPath.isObjectPattern() || e1.parentPath.isAssignmentExpression({
                            left: e1.node
                        }) || e1.isAssignmentExpression({
                            left: e1.node
                        })) {
                            return;
                        }
                        e1.replaceWith(getAssertion(t));
                    },
                    UpdateExpression (e1) {
                        const t = e1.get("argument");
                        if (!t.isIdentifier()) return;
                        const r = t.node.name;
                        if (r !== "module" && r !== "exports") return;
                        const n = e1.scope.getBinding(r);
                        const s = this.scope.getBinding(r);
                        if (s !== n) return;
                        e1.replaceWith(i.types.assignmentExpression(e1.node.operator[0] + "=", t.node, getAssertion(r)));
                    },
                    AssignmentExpression (e1) {
                        const t = e1.get("left");
                        if (t.isIdentifier()) {
                            const r = t.node.name;
                            if (r !== "module" && r !== "exports") return;
                            const n = e1.scope.getBinding(r);
                            const s = this.scope.getBinding(r);
                            if (s !== n) return;
                            const a = e1.get("right");
                            a.replaceWith(i.types.sequenceExpression([
                                a.node,
                                getAssertion(r)
                            ]));
                        } else if (t.isPattern()) {
                            const r = t.getOuterBindingIdentifiers();
                            const n = Object.keys(r).find((t)=>{
                                if (t !== "module" && t !== "exports") return false;
                                return this.scope.getBinding(t) === e1.scope.getBinding(t);
                            });
                            if (n) {
                                const t = e1.get("right");
                                t.replaceWith(i.types.sequenceExpression([
                                    t.node,
                                    getAssertion(n)
                                ]));
                            }
                        }
                    }
                };
                return {
                    name: "transform-modules-commonjs",
                    pre () {
                        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
                        if (g) (0, l.defineCommonJSHook)(this.file, (0, o.lazyImportsHook)(g));
                    },
                    visitor: {
                        ["CallExpression" + (e1.types.importExpression ? "|ImportExpression" : "")] (e1) {
                            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
                            if (e1.isCallExpression() && !i.types.isImport(e1.node.callee)) return;
                            let { scope: t } = e1;
                            do {
                                t.rename("require");
                            }while (t = t.parent)
                            (0, a.transformDynamicImport)(e1, m, this.file);
                        },
                        Program: {
                            exit (e1, r) {
                                if (!(0, s.isModule)(e1)) return;
                                e1.scope.rename("exports");
                                e1.scope.rename("module");
                                e1.scope.rename("require");
                                e1.scope.rename("__filename");
                                e1.scope.rename("__dirname");
                                if (!b) {
                                    e1.traverse(P, {
                                        scope: e1.scope
                                    });
                                }
                                let n = (0, s.getModuleName)(this.file.opts, t);
                                if (n) n = i.types.stringLiteral(n);
                                const a = (0, l.makeInvokers)(this.file);
                                const { meta: o, headers: c } = (0, s.rewriteModuleStatementsAndPrepareHeader)(e1, {
                                    exportName: "exports",
                                    constantReexports: S,
                                    enumerableModuleMeta: x,
                                    strict: f,
                                    strictMode: h,
                                    allowTopLevelThis: d,
                                    noInterop: m,
                                    importInterop: y,
                                    wrapReference: a.wrapReference,
                                    getWrapperPayload: a.getWrapperPayload,
                                    esNamespaceOnly: typeof r.filename === "string" && /\.mjs$/.test(r.filename) ? u : p,
                                    noIncompleteNsImportDetection: E,
                                    filename: this.file.opts.filename
                                });
                                for (const [t, r] of o.source){
                                    const n = i.types.callExpression(i.types.identifier("require"), [
                                        i.types.stringLiteral(t)
                                    ]);
                                    let l;
                                    if ((0, s.isSideEffectImport)(r)) {
                                        if (g && r.wrap === "function") {
                                            throw new Error("Assertion failure");
                                        }
                                        l = i.types.expressionStatement(n);
                                    } else {
                                        var T;
                                        const t = (0, s.wrapInterop)(e1, n, r.interop) || n;
                                        if (r.wrap) {
                                            const e1 = a.buildRequireWrapper(r.name, t, r.wrap, r.referenced);
                                            if (e1 === false) continue;
                                            else l = e1;
                                        }
                                        (T = l) != null ? T : l = i.template.statement.ast(_templateObject64(), r.name, t);
                                    }
                                    l.loc = r.loc;
                                    c.push(l);
                                    c.push(...(0, s.buildNamespaceInitStatements)(o, r, S, a.wrapReference));
                                }
                                (0, s.ensureStatementsHoisted)(c);
                                e1.unshiftContainer("body", c);
                                e1.get("body").forEach((e1)=>{
                                    if (!c.includes(e1.node)) return;
                                    if (e1.isVariableDeclaration()) {
                                        e1.scope.registerDeclaration(e1);
                                    }
                                });
                            }
                        }
                    }
                };
            });
        },
        2461: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.lazyImportsHook = void 0;
            var n = r(2358);
            var s = r(9460);
            const lazyImportsHook = (e1)=>({
                    name: "@babel/plugin-transform-modules-commonjs/lazy",
                    version: "7.26.3",
                    getWrapperPayload (t, r) {
                        if ((0, s.isSideEffectImport)(r) || r.reexportAll) {
                            return null;
                        }
                        if (e1 === true) {
                            return t.includes(".") ? null : "lazy/function";
                        }
                        if (Array.isArray(e1)) {
                            return !e1.includes(t) ? null : "lazy/function";
                        }
                        if (typeof e1 === "function") {
                            return e1(t) ? "lazy/function" : null;
                        }
                    },
                    buildRequireWrapper (e1, t, r, s) {
                        if (r === "lazy/function") {
                            if (!s) return false;
                            return n.template.statement.ast(_templateObject65(), e1, t, e1);
                        }
                    },
                    wrapReference (e1, t) {
                        if (t === "lazy/function") return n.types.callExpression(e1, []);
                    }
                });
            t.lazyImportsHook = lazyImportsHook;
        },
        7077: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.EXPORTED_CONST_ENUMS_IN_NAMESPACE = void 0;
            t["default"] = transpileConstEnum;
            var n = r(5886);
            const s = t.EXPORTED_CONST_ENUMS_IN_NAMESPACE = new WeakSet;
            function transpileConstEnum(e1, t) {
                const { name: r } = e1.node.id;
                const i = e1.parentPath.isExportNamedDeclaration();
                let a = i;
                if (!a && t.isProgram(e1.parent)) {
                    a = e1.parent.body.some((e1)=>t.isExportNamedDeclaration(e1) && e1.exportKind !== "type" && !e1.source && e1.specifiers.some((e1)=>t.isExportSpecifier(e1) && e1.exportKind !== "type" && e1.local.name === r));
                }
                const { enumValues: o } = (0, n.translateEnumValues)(e1, t);
                if (a || s.has(e1.node)) {
                    const n = t.objectExpression(o.map((param)=>{
                        let [e1, r] = param;
                        return t.objectProperty(t.isValidIdentifier(e1) ? t.identifier(e1) : t.stringLiteral(e1), r);
                    }));
                    if (e1.scope.hasOwnBinding(r)) {
                        (i ? e1.parentPath : e1).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [
                            e1.node.id,
                            n
                        ])));
                    } else {
                        e1.replaceWith(t.variableDeclaration("var", [
                            t.variableDeclarator(e1.node.id, n)
                        ]));
                        e1.scope.registerDeclaration(e1);
                    }
                    return;
                }
                const l = new Map(o);
                e1.scope.path.traverse({
                    Scope (e1) {
                        if (e1.scope.hasOwnBinding(r)) e1.skip();
                    },
                    MemberExpression (e1) {
                        if (!t.isIdentifier(e1.node.object, {
                            name: r
                        })) return;
                        let n;
                        if (e1.node.computed) {
                            if (t.isStringLiteral(e1.node.property)) {
                                n = e1.node.property.value;
                            } else {
                                return;
                            }
                        } else if (t.isIdentifier(e1.node.property)) {
                            n = e1.node.property.name;
                        } else {
                            return;
                        }
                        if (!l.has(n)) return;
                        e1.replaceWith(t.cloneNode(l.get(n)));
                    }
                });
                e1.remove();
            }
        },
        5886: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = transpileEnum;
            t.isSyntacticallyString = isSyntacticallyString;
            t.translateEnumValues = translateEnumValues;
            var n = r(2358);
            var s = r(9491);
            var i = r(344);
            var a = r(9102);
            const o = new WeakMap;
            const l = n.template.expression("\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  ");
            function transpileEnum(e1, t) {
                const { node: r, parentPath: n } = e1;
                if (r.declare) {
                    e1.remove();
                    return;
                }
                const s = r.id.name;
                const { fill: a, data: c, isPure: p } = enumFill(e1, t, r.id);
                switch(n.type){
                    case "BlockStatement":
                    case "ExportNamedDeclaration":
                    case "Program":
                        {
                            const u = t.isProgram(e1.parent);
                            const d = seen(n);
                            let f = t.objectExpression([]);
                            if (d || u) {
                                f = t.logicalExpression("||", t.cloneNode(a.ID), f);
                            }
                            const h = l(Object.assign({}, a, {
                                INIT: f
                            }));
                            if (p) (0, i.default)(h);
                            if (d) {
                                const s = n.isExportDeclaration() ? n : e1;
                                s.replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(r.id), h)));
                            } else {
                                e1.scope.registerDeclaration(e1.replaceWith(t.variableDeclaration(u ? "var" : "let", [
                                    t.variableDeclarator(r.id, h)
                                ]))[0]);
                            }
                            o.set(e1.scope.getBindingIdentifier(s), c);
                            break;
                        }
                    default:
                        throw new Error("Unexpected enum parent '".concat(e1.parent.type));
                }
                function seen(e1) {
                    if (e1.isExportDeclaration()) {
                        return seen(e1.parentPath);
                    }
                    if (e1.getData(s)) {
                        return true;
                    } else {
                        e1.setData(s, true);
                        return false;
                    }
                }
            }
            const c = n.template.statement('\n  ENUM["NAME"] = VALUE;\n');
            const p = n.template.statement('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n');
            const buildEnumMember = (e1, t)=>(e1 ? c : p)(t);
            function enumFill(e1, t, r) {
                const { enumValues: n, data: s, isPure: i } = translateEnumValues(e1, t);
                const a = e1.get("members");
                const o = [];
                for(let e1 = 0; e1 < a.length; e1++){
                    const [s, i] = n[e1];
                    o.push(t.inheritsComments(buildEnumMember(isSyntacticallyString(i), {
                        ENUM: t.cloneNode(r),
                        NAME: s,
                        VALUE: i
                    }), a[e1].node));
                }
                return {
                    fill: {
                        ID: t.cloneNode(r),
                        ASSIGNMENTS: o
                    },
                    data: s,
                    isPure: i
                };
            }
            function isSyntacticallyString(e1) {
                e1 = (0, a.skipTransparentExprWrapperNodes)(e1);
                switch(e1.type){
                    case "BinaryExpression":
                        {
                            const t = e1.left;
                            const r = e1.right;
                            return e1.operator === "+" && (isSyntacticallyString(t) || isSyntacticallyString(r));
                        }
                    case "TemplateLiteral":
                    case "StringLiteral":
                        return true;
                }
                return false;
            }
            function ReferencedIdentifier(e1, t) {
                const { seen: r, path: n, t: s } = t;
                const i = e1.node.name;
                if (r.has(i)) {
                    {
                        for(let t = e1.scope; t !== n.scope; t = t.parent){
                            if (t.hasOwnBinding(i)) {
                                return;
                            }
                        }
                    }
                    e1.replaceWith(s.memberExpression(s.cloneNode(n.node.id), s.cloneNode(e1.node)));
                    e1.skip();
                }
            }
            const u = {
                ReferencedIdentifier: ReferencedIdentifier
            };
            function translateEnumValues(e1, t) {
                var r;
                const n = e1.scope.getBindingIdentifier(e1.node.id.name);
                const i = (r = o.get(n)) != null ? r : new Map;
                let a = -1;
                let l;
                let c = true;
                const p = e1.get("members");
                const d = p.map((r)=>{
                    const n = r.node;
                    const o = t.isIdentifier(n.id) ? n.id.name : n.id.value;
                    const p = r.get("initializer");
                    const d = n.initializer;
                    let f;
                    if (d) {
                        a = computeConstantValue(p, i);
                        if (a !== undefined) {
                            i.set(o, a);
                            s(typeof a === "number" || typeof a === "string");
                            if (a === Infinity || Number.isNaN(a)) {
                                f = t.identifier(String(a));
                            } else if (a === -Infinity) {
                                f = t.unaryExpression("-", t.identifier("Infinity"));
                            } else {
                                f = t.valueToNode(a);
                            }
                        } else {
                            c && (c = p.isPure());
                            if (p.isReferencedIdentifier()) {
                                ReferencedIdentifier(p, {
                                    t: t,
                                    seen: i,
                                    path: e1
                                });
                            } else {
                                p.traverse(u, {
                                    t: t,
                                    seen: i,
                                    path: e1
                                });
                            }
                            f = p.node;
                            i.set(o, undefined);
                        }
                    } else if (typeof a === "number") {
                        a += 1;
                        f = t.numericLiteral(a);
                        i.set(o, a);
                    } else if (typeof a === "string") {
                        throw e1.buildCodeFrameError("Enum member must have initializer.");
                    } else {
                        const r = t.memberExpression(t.cloneNode(e1.node.id), t.stringLiteral(l), true);
                        f = t.binaryExpression("+", t.numericLiteral(1), r);
                        i.set(o, undefined);
                    }
                    l = o;
                    return [
                        o,
                        f
                    ];
                });
                return {
                    isPure: c,
                    data: i,
                    enumValues: d
                };
            }
            function computeConstantValue(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Set;
                return evaluate(e1);
                //TURBOPACK unreachable
                ;
                function evaluate(e1) {
                    const n = e1.node;
                    switch(n.type){
                        case "MemberExpression":
                            return evaluateRef(e1, t, r);
                        case "StringLiteral":
                            return n.value;
                        case "UnaryExpression":
                            return evalUnaryExpression(e1);
                        case "BinaryExpression":
                            return evalBinaryExpression(e1);
                        case "NumericLiteral":
                            return n.value;
                        case "ParenthesizedExpression":
                            return evaluate(e1.get("expression"));
                        case "Identifier":
                            return evaluateRef(e1, t, r);
                        case "TemplateLiteral":
                            {
                                if (n.quasis.length === 1) {
                                    return n.quasis[0].value.cooked;
                                }
                                const s = e1.get("expressions");
                                const i = n.quasis;
                                let a = "";
                                for(let e1 = 0; e1 < i.length; e1++){
                                    a += i[e1].value.cooked;
                                    if (e1 + 1 < i.length) {
                                        const n = evaluateRef(s[e1], t, r);
                                        if (n === undefined) return undefined;
                                        a += n;
                                    }
                                }
                                return a;
                            }
                        default:
                            return undefined;
                    }
                }
                function evaluateRef(e1, t, r) {
                    if (e1.isMemberExpression()) {
                        const t = e1.node;
                        const r = t.object;
                        const s = t.property;
                        if (!n.types.isIdentifier(r) || (t.computed ? !n.types.isStringLiteral(s) : !n.types.isIdentifier(s))) {
                            return;
                        }
                        const i = e1.scope.getBindingIdentifier(r.name);
                        const a = o.get(i);
                        if (!a) return;
                        return a.get(s.computed ? s.value : s.name);
                    } else if (e1.isIdentifier()) {
                        const n = e1.node.name;
                        if ([
                            "Infinity",
                            "NaN"
                        ].includes(n)) {
                            return Number(n);
                        }
                        let s = t == null ? void 0 : t.get(n);
                        if (s !== undefined) {
                            return s;
                        }
                        if (t != null && t.has(n)) {
                            return undefined;
                        }
                        if (r.has(e1.node)) return;
                        r.add(e1.node);
                        s = computeConstantValue(e1.resolve(), t, r);
                        return s;
                    }
                }
                function evalUnaryExpression(e1) {
                    const t = evaluate(e1.get("argument"));
                    if (t === undefined) {
                        return undefined;
                    }
                    switch(e1.node.operator){
                        case "+":
                            return t;
                        case "-":
                            return -t;
                        case "~":
                            return ~t;
                        default:
                            return undefined;
                    }
                }
                function evalBinaryExpression(e1) {
                    const t = evaluate(e1.get("left"));
                    if (t === undefined) {
                        return undefined;
                    }
                    const r = evaluate(e1.get("right"));
                    if (r === undefined) {
                        return undefined;
                    }
                    switch(e1.node.operator){
                        case "|":
                            return t | r;
                        case "&":
                            return t & r;
                        case ">>":
                            return t >> r;
                        case ">>>":
                            return t >>> r;
                        case "<<":
                            return t << r;
                        case "^":
                            return t ^ r;
                        case "*":
                            return t * r;
                        case "/":
                            return t / r;
                        case "+":
                            return t + r;
                        case "-":
                            return t - r;
                        case "%":
                            return t % r;
                        case "**":
                            return Math.pow(t, r);
                        default:
                            return undefined;
                    }
                }
            }
        },
        9878: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.GLOBAL_TYPES = void 0;
            t.isGlobalType = isGlobalType;
            t.registerGlobalType = registerGlobalType;
            const r = t.GLOBAL_TYPES = new WeakMap;
            function isGlobalType(param, t) {
                let { scope: e1 } = param;
                if (e1.hasBinding(t)) return false;
                if (r.get(e1).has(t)) return true;
                console.warn('The exported identifier "'.concat(t, "\" is not declared in Babel's scope tracker\n") + 'as a JavaScript value binding, and "@babel/plugin-transform-typescript"\n' + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + '"'.concat(t, '" without registering it in the scope tracker. If you are the author\n') + ' of that plugin, please use "scope.registerDeclaration(declarationPath)".');
                return false;
            }
            function registerGlobalType(e1, t) {
                r.get(e1).add(t);
            }
        },
        7687: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9045);
            var s = r(8184);
            var i = r(3713);
            var a = r(7077);
            var o = r(5886);
            var l = r(9878);
            var c = r(723);
            function isInType(e1) {
                switch(e1.parent.type){
                    case "TSTypeReference":
                    case "TSExpressionWithTypeArguments":
                    case "TSExpressionWithTypeArguments":
                    case "TSTypeQuery":
                        return true;
                    case "TSQualifiedName":
                        return e1.parentPath.findParent((e1)=>e1.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
                    case "ExportSpecifier":
                        return e1.parent.exportKind === "type" || e1.parentPath.parent.exportKind === "type";
                    default:
                        return false;
                }
            }
            const p = new WeakMap;
            const u = new WeakSet;
            function safeRemove(e1) {
                const t = e1.getBindingIdentifiers();
                for (const r of Object.keys(t)){
                    const n = e1.scope.getBinding(r);
                    if (n && n.identifier === t[r]) {
                        n.scope.removeBinding(r);
                    }
                }
                e1.opts.noScope = true;
                e1.remove();
                e1.opts.noScope = false;
            }
            function assertCjsTransformEnabled(e1, t, r, n) {
                let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
                if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs") {
                    throw e1.buildCodeFrameError("`".concat(r, "` is only supported when compiling modules to CommonJS.\n") + "Please consider using `".concat(n, "`").concat(s, ", or add ") + "@babel/plugin-transform-modules-commonjs to your Babel config.");
                }
            }
            var d = t["default"] = (0, n.declare)((e1, t)=>{
                const { types: r, template: n } = e1;
                e1.assertVersion(7);
                const d = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/;
                const { allowNamespaces: f = true, jsxPragma: h = "React.createElement", jsxPragmaFrag: m = "React.Fragment", onlyRemoveTypeImports: y = false, optimizeConstEnums: g = false } = t;
                {
                    var { allowDeclareFields: b = false } = t;
                }
                const T = {
                    field (e1) {
                        const { node: t } = e1;
                        {
                            if (!b && t.declare) {
                                throw e1.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
                            }
                        }
                        if (t.declare) {
                            if (t.value) {
                                throw e1.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
                            }
                            if (!t.decorators) {
                                e1.remove();
                            }
                        } else if (t.definite) {
                            if (t.value) {
                                throw e1.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
                            }
                            {
                                if (!b && !t.decorators && !r.isClassPrivateProperty(t)) {
                                    e1.remove();
                                }
                            }
                        } else if (t.abstract) {
                            e1.remove();
                        } else {
                            if (!b && !t.value && !t.decorators && !r.isClassPrivateProperty(t)) {
                                e1.remove();
                            }
                        }
                        if (t.accessibility) t.accessibility = null;
                        if (t.abstract) t.abstract = null;
                        if (t.readonly) t.readonly = null;
                        if (t.optional) t.optional = null;
                        if (t.typeAnnotation) t.typeAnnotation = null;
                        if (t.definite) t.definite = null;
                        if (t.declare) t.declare = null;
                        if (t.override) t.override = null;
                    },
                    method (param) {
                        let { node: e1 } = param;
                        if (e1.accessibility) e1.accessibility = null;
                        if (e1.abstract) e1.abstract = null;
                        if (e1.optional) e1.optional = null;
                        if (e1.override) e1.override = null;
                    },
                    constructor (e1, t) {
                        if (e1.node.accessibility) e1.node.accessibility = null;
                        const s = [];
                        const { scope: a } = e1;
                        for (const t of e1.get("params")){
                            const e1 = t.node;
                            if (e1.type === "TSParameterProperty") {
                                const i = e1.parameter;
                                if (u.has(i)) continue;
                                u.add(i);
                                let o;
                                if (r.isIdentifier(i)) {
                                    o = i;
                                } else if (r.isAssignmentPattern(i) && r.isIdentifier(i.left)) {
                                    o = i.left;
                                } else {
                                    throw t.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                                }
                                s.push(n.statement.ast(_templateObject66(), r.cloneNode(o), r.cloneNode(o)));
                                t.replaceWith(t.get("parameter"));
                                a.registerBinding("param", t);
                            }
                        }
                        (0, i.injectInitialization)(t, e1, s);
                    }
                };
                return {
                    name: "transform-typescript",
                    inherits: s.default,
                    visitor: {
                        Pattern: visitPattern,
                        Identifier: visitPattern,
                        RestElement: visitPattern,
                        Program: {
                            enter (e1, t) {
                                const { file: r } = t;
                                let n = null;
                                let s = null;
                                const i = e1.scope;
                                if (!l.GLOBAL_TYPES.has(i)) {
                                    l.GLOBAL_TYPES.set(i, new Set);
                                }
                                if (r.ast.comments) {
                                    for (const e1 of r.ast.comments){
                                        const t = d.exec(e1.value);
                                        if (t) {
                                            if (t[1]) {
                                                s = t[2];
                                            } else {
                                                n = t[2];
                                            }
                                        }
                                    }
                                }
                                let a = n || h;
                                if (a) {
                                    [a] = a.split(".");
                                }
                                let o = s || m;
                                if (o) {
                                    [o] = o.split(".");
                                }
                                for (let r of e1.get("body")){
                                    if (r.isImportDeclaration()) {
                                        if (!p.has(t.file.ast.program)) {
                                            p.set(t.file.ast.program, true);
                                        }
                                        if (r.node.importKind === "type") {
                                            for (const e1 of r.node.specifiers){
                                                (0, l.registerGlobalType)(i, e1.local.name);
                                            }
                                            r.remove();
                                            continue;
                                        }
                                        const n = new Set;
                                        const s = r.node.specifiers.length;
                                        const isAllSpecifiersElided = ()=>s > 0 && s === n.size;
                                        for (const e1 of r.node.specifiers){
                                            if (e1.type === "ImportSpecifier" && e1.importKind === "type") {
                                                (0, l.registerGlobalType)(i, e1.local.name);
                                                const t = r.scope.getBinding(e1.local.name);
                                                if (t) {
                                                    n.add(t.path);
                                                }
                                            }
                                        }
                                        if (y) {
                                            p.set(e1.node, false);
                                        } else {
                                            if (r.node.specifiers.length === 0) {
                                                p.set(e1.node, false);
                                                continue;
                                            }
                                            for (const t of r.node.specifiers){
                                                const s = r.scope.getBinding(t.local.name);
                                                if (s && !n.has(s.path)) {
                                                    if (isImportTypeOnly({
                                                        binding: s,
                                                        programPath: e1,
                                                        pragmaImportName: a,
                                                        pragmaFragImportName: o
                                                    })) {
                                                        n.add(s.path);
                                                    } else {
                                                        p.set(e1.node, false);
                                                    }
                                                }
                                            }
                                        }
                                        if (isAllSpecifiersElided() && !y) {
                                            r.remove();
                                        } else {
                                            for (const e1 of n){
                                                e1.remove();
                                            }
                                        }
                                        continue;
                                    }
                                    if (!y && r.isTSImportEqualsDeclaration()) {
                                        const { id: t } = r.node;
                                        const n = r.scope.getBinding(t.name);
                                        if (n && !r.node.isExport && isImportTypeOnly({
                                            binding: n,
                                            programPath: e1,
                                            pragmaImportName: a,
                                            pragmaFragImportName: o
                                        })) {
                                            r.remove();
                                            continue;
                                        }
                                    }
                                    if (r.isExportDeclaration()) {
                                        r = r.get("declaration");
                                    }
                                    if (r.isVariableDeclaration({
                                        declare: true
                                    })) {
                                        for (const e1 of Object.keys(r.getBindingIdentifiers())){
                                            (0, l.registerGlobalType)(i, e1);
                                        }
                                    } else if (r.isTSTypeAliasDeclaration() || r.isTSDeclareFunction() && r.get("id").isIdentifier() || r.isTSInterfaceDeclaration() || r.isClassDeclaration({
                                        declare: true
                                    }) || r.isTSEnumDeclaration({
                                        declare: true
                                    }) || r.isTSModuleDeclaration({
                                        declare: true
                                    }) && r.get("id").isIdentifier()) {
                                        (0, l.registerGlobalType)(i, r.node.id.name);
                                    }
                                }
                            },
                            exit (e1) {
                                if (e1.node.sourceType === "module" && p.get(e1.node)) {
                                    e1.pushContainer("body", r.exportNamedDeclaration());
                                }
                            }
                        },
                        ExportNamedDeclaration (e1, t) {
                            if (!p.has(t.file.ast.program)) {
                                p.set(t.file.ast.program, true);
                            }
                            if (e1.node.exportKind === "type") {
                                e1.remove();
                                return;
                            }
                            if (e1.node.source && e1.node.specifiers.length > 0 && e1.node.specifiers.every((e1)=>e1.type === "ExportSpecifier" && e1.exportKind === "type")) {
                                e1.remove();
                                return;
                            }
                            if (!e1.node.source && e1.node.specifiers.length > 0 && e1.node.specifiers.every((t)=>r.isExportSpecifier(t) && (0, l.isGlobalType)(e1, t.local.name))) {
                                e1.remove();
                                return;
                            }
                            if (r.isTSModuleDeclaration(e1.node.declaration)) {
                                const t = e1.node.declaration;
                                if (!r.isStringLiteral(t.id)) {
                                    const n = (0, c.getFirstIdentifier)(t.id);
                                    if (e1.scope.hasOwnBinding(n.name)) {
                                        e1.replaceWith(t);
                                    } else {
                                        const [s] = e1.replaceWithMultiple([
                                            r.exportNamedDeclaration(r.variableDeclaration("let", [
                                                r.variableDeclarator(r.cloneNode(n))
                                            ])),
                                            t
                                        ]);
                                        e1.scope.registerDeclaration(s);
                                    }
                                }
                            }
                            p.set(t.file.ast.program, false);
                        },
                        ExportAllDeclaration (e1) {
                            if (e1.node.exportKind === "type") e1.remove();
                        },
                        ExportSpecifier (e1) {
                            const t = e1.parent;
                            if (!t.source && (0, l.isGlobalType)(e1, e1.node.local.name) || e1.node.exportKind === "type") {
                                e1.remove();
                            }
                        },
                        ExportDefaultDeclaration (e1, t) {
                            if (!p.has(t.file.ast.program)) {
                                p.set(t.file.ast.program, true);
                            }
                            if (r.isIdentifier(e1.node.declaration) && (0, l.isGlobalType)(e1, e1.node.declaration.name)) {
                                e1.remove();
                                return;
                            }
                            p.set(t.file.ast.program, false);
                        },
                        TSDeclareFunction (e1) {
                            safeRemove(e1);
                        },
                        TSDeclareMethod (e1) {
                            safeRemove(e1);
                        },
                        VariableDeclaration (e1) {
                            if (e1.node.declare) {
                                safeRemove(e1);
                            }
                        },
                        VariableDeclarator (param) {
                            let { node: e1 } = param;
                            if (e1.definite) e1.definite = null;
                        },
                        TSIndexSignature (e1) {
                            e1.remove();
                        },
                        ClassDeclaration (e1) {
                            const { node: t } = e1;
                            if (t.declare) {
                                safeRemove(e1);
                            }
                        },
                        Class (e1) {
                            const { node: t } = e1;
                            if (t.typeParameters) t.typeParameters = null;
                            {
                                if (t.superTypeParameters) t.superTypeParameters = null;
                            }
                            if (t.implements) t.implements = null;
                            if (t.abstract) t.abstract = null;
                            e1.get("body.body").forEach((t)=>{
                                if (t.isClassMethod() || t.isClassPrivateMethod()) {
                                    if (t.node.kind === "constructor") {
                                        T.constructor(t, e1);
                                    } else {
                                        T.method(t);
                                    }
                                } else if (t.isClassProperty() || t.isClassPrivateProperty() || t.isClassAccessorProperty()) {
                                    T.field(t);
                                }
                            });
                        },
                        Function (e1) {
                            const { node: t } = e1;
                            if (t.typeParameters) t.typeParameters = null;
                            if (t.returnType) t.returnType = null;
                            const n = t.params;
                            if (n.length > 0 && r.isIdentifier(n[0], {
                                name: "this"
                            })) {
                                n.shift();
                            }
                        },
                        TSModuleDeclaration (e1) {
                            (0, c.default)(e1, f);
                        },
                        TSInterfaceDeclaration (e1) {
                            e1.remove();
                        },
                        TSTypeAliasDeclaration (e1) {
                            e1.remove();
                        },
                        TSEnumDeclaration (e1) {
                            if (g && e1.node.const) {
                                (0, a.default)(e1, r);
                            } else {
                                (0, o.default)(e1, r);
                            }
                        },
                        TSImportEqualsDeclaration (e1, t) {
                            const { id: n, moduleReference: s } = e1.node;
                            let i;
                            let a;
                            if (r.isTSExternalModuleReference(s)) {
                                assertCjsTransformEnabled(e1, t, "import ".concat(n.name, " = require(...);"), "import ".concat(n.name, " from '...';"), " alongside Typescript's --allowSyntheticDefaultImports option");
                                i = r.callExpression(r.identifier("require"), [
                                    s.expression
                                ]);
                                a = "const";
                            } else {
                                i = entityNameToExpr(s);
                                a = "var";
                            }
                            const o = r.variableDeclaration(a, [
                                r.variableDeclarator(n, i)
                            ]);
                            {
                                e1.replaceWith(e1.node.isExport ? r.exportNamedDeclaration(o) : o);
                            }
                            e1.scope.registerDeclaration(e1);
                        },
                        TSExportAssignment (e1, t) {
                            assertCjsTransformEnabled(e1, t, "export = <value>;", "export default <value>;");
                            e1.replaceWith(n.statement.ast(_templateObject67(), e1.node.expression));
                        },
                        TSTypeAssertion (e1) {
                            e1.replaceWith(e1.node.expression);
                        },
                        ["TSAsExpression".concat(r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")] (e1) {
                            let { node: t } = e1;
                            do {
                                t = t.expression;
                            }while (r.isTSAsExpression(t) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(t))
                            e1.replaceWith(t);
                        },
                        [e1.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"] (e1) {
                            e1.replaceWith(e1.node.expression);
                        },
                        CallExpression (e1) {
                            {
                                e1.node.typeParameters = null;
                            }
                        },
                        OptionalCallExpression (e1) {
                            {
                                e1.node.typeParameters = null;
                            }
                        },
                        NewExpression (e1) {
                            {
                                e1.node.typeParameters = null;
                            }
                        },
                        JSXOpeningElement (e1) {
                            {
                                e1.node.typeParameters = null;
                            }
                        },
                        TaggedTemplateExpression (e1) {
                            {
                                e1.node.typeParameters = null;
                            }
                        }
                    }
                };
                //TURBOPACK unreachable
                ;
                function entityNameToExpr(e1) {
                    if (r.isTSQualifiedName(e1)) {
                        return r.memberExpression(entityNameToExpr(e1.left), e1.right);
                    }
                    return e1;
                }
                function visitPattern(param) {
                    let { node: e1 } = param;
                    if (e1.typeAnnotation) e1.typeAnnotation = null;
                    if (r.isIdentifier(e1) && e1.optional) e1.optional = null;
                }
                function isImportTypeOnly(param) {
                    let { binding: e1, programPath: t, pragmaImportName: r, pragmaFragImportName: n } = param;
                    for (const t of e1.referencePaths){
                        if (!isInType(t)) {
                            return false;
                        }
                    }
                    if (e1.identifier.name !== r && e1.identifier.name !== n) {
                        return true;
                    }
                    let s = false;
                    t.traverse({
                        "JSXElement|JSXFragment" (e1) {
                            s = true;
                            e1.stop();
                        }
                    });
                    return !s;
                }
            });
        },
        723: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = transpileNamespace;
            t.getFirstIdentifier = getFirstIdentifier;
            var n = r(2358);
            var s = r(9878);
            var i = r(7077);
            function getFirstIdentifier(e1) {
                if (n.types.isIdentifier(e1)) {
                    return e1;
                }
                return getFirstIdentifier(e1.left);
            }
            function transpileNamespace(e1, t) {
                if (e1.node.declare || e1.node.id.type === "StringLiteral") {
                    e1.remove();
                    return;
                }
                if (!t) {
                    throw e1.get("id").buildCodeFrameError("Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
                }
                const r = getFirstIdentifier(e1.node.id).name;
                const n = handleNested(e1, e1.node);
                if (n === null) {
                    const t = e1.findParent((e1)=>e1.isProgram());
                    (0, s.registerGlobalType)(t.scope, r);
                    e1.remove();
                } else if (e1.scope.hasOwnBinding(r)) {
                    e1.replaceWith(n);
                } else {
                    e1.scope.registerDeclaration(e1.replaceWithMultiple([
                        getDeclaration(r),
                        n
                    ])[0]);
                }
            }
            function getDeclaration(e1) {
                return n.types.variableDeclaration("let", [
                    n.types.variableDeclarator(n.types.identifier(e1))
                ]);
            }
            function getMemberExpression(e1, t) {
                return n.types.memberExpression(n.types.identifier(e1), n.types.identifier(t));
            }
            function handleVariableDeclaration(e1, t, r) {
                if (e1.kind !== "const") {
                    throw r.file.buildCodeFrameError(e1, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
                }
                const { declarations: s } = e1;
                if (s.every((e1)=>n.types.isIdentifier(e1.id))) {
                    for (const e1 of s){
                        e1.init = n.types.assignmentExpression("=", getMemberExpression(t, e1.id.name), e1.init);
                    }
                    return [
                        e1
                    ];
                }
                const i = n.types.getBindingIdentifiers(e1);
                const a = [];
                for(const e1 in i){
                    a.push(n.types.assignmentExpression("=", getMemberExpression(t, e1), n.types.cloneNode(i[e1])));
                }
                return [
                    e1,
                    n.types.expressionStatement(n.types.sequenceExpression(a))
                ];
            }
            function buildNestedAmbientModuleError(e1, t) {
                return e1.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
            }
            function handleNested(e1, t, r) {
                const s = new Set;
                const a = t.id;
                const o = e1.scope.generateUid(a.name);
                const l = t.body;
                let c = t.id;
                let p;
                {
                    p = n.types.isTSModuleBlock(l) ? l.body : [
                        n.types.exportNamedDeclaration(l)
                    ];
                }
                let u = true;
                for(let t = 0; t < p.length; t++){
                    const r = p[t];
                    switch(r.type){
                        case "TSModuleDeclaration":
                            {
                                if (!n.types.isIdentifier(r.id)) {
                                    throw buildNestedAmbientModuleError(e1, r);
                                }
                                const i = handleNested(e1, r);
                                if (i !== null) {
                                    u = false;
                                    const e1 = r.id.name;
                                    if (s.has(e1)) {
                                        p[t] = i;
                                    } else {
                                        s.add(e1);
                                        p.splice(t++, 1, getDeclaration(e1), i);
                                    }
                                }
                                continue;
                            }
                        case "TSEnumDeclaration":
                        case "FunctionDeclaration":
                        case "ClassDeclaration":
                            u = false;
                            s.add(r.id.name);
                            continue;
                        case "VariableDeclaration":
                            {
                                u = false;
                                for(const e1 in n.types.getBindingIdentifiers(r)){
                                    s.add(e1);
                                }
                                continue;
                            }
                        default:
                            u && (u = n.types.isTypeScript(r));
                            continue;
                        case "ExportNamedDeclaration":
                    }
                    if ("declare" in r.declaration && r.declaration.declare) {
                        continue;
                    }
                    switch(r.declaration.type){
                        case "TSEnumDeclaration":
                            i.EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(r.declaration);
                        case "FunctionDeclaration":
                        case "ClassDeclaration":
                            {
                                u = false;
                                const e1 = r.declaration.id.name;
                                s.add(e1);
                                p.splice(t++, 1, r.declaration, n.types.expressionStatement(n.types.assignmentExpression("=", getMemberExpression(o, e1), n.types.identifier(e1))));
                                break;
                            }
                        case "VariableDeclaration":
                            {
                                u = false;
                                const n = handleVariableDeclaration(r.declaration, o, e1.hub);
                                p.splice(t, n.length, ...n);
                                t += n.length - 1;
                                break;
                            }
                        case "TSModuleDeclaration":
                            {
                                if (!n.types.isIdentifier(r.declaration.id)) {
                                    throw buildNestedAmbientModuleError(e1, r.declaration);
                                }
                                const i = handleNested(e1, r.declaration, n.types.identifier(o));
                                if (i !== null) {
                                    u = false;
                                    const e1 = r.declaration.id.name;
                                    if (s.has(e1)) {
                                        p[t] = i;
                                    } else {
                                        s.add(e1);
                                        p.splice(t++, 1, getDeclaration(e1), i);
                                    }
                                } else {
                                    p.splice(t, 1);
                                    t--;
                                }
                            }
                    }
                }
                if (u) return null;
                let d = n.types.objectExpression([]);
                if (r) {
                    const e1 = n.types.memberExpression(r, a);
                    d = n.template.expression.ast(_templateObject68(), n.types.cloneNode(e1), n.types.cloneNode(e1), d);
                }
                return n.template.statement.ast(_templateObject69(), n.types.identifier(o), p, a, n.types.cloneNode(a), d);
            }
        },
        8782: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(9045);
            var s = r(7687);
            r(2698);
            var i = r(7179);
            var a = r(3146);
            function _interopDefault(e1) {
                return e1 && e1.__esModule ? e1 : {
                    default: e1
                };
            }
            var o = _interopDefault(s);
            var l = _interopDefault(i);
            const c = new a.OptionValidator("@babel/preset-typescript");
            function normalizeOptions() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                let { allowNamespaces: t = true, jsxPragma: r, onlyRemoveTypeImports: n } = e1;
                const s = {
                    ignoreExtensions: "ignoreExtensions",
                    allowNamespaces: "allowNamespaces",
                    disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
                    jsxPragma: "jsxPragma",
                    jsxPragmaFrag: "jsxPragmaFrag",
                    onlyRemoveTypeImports: "onlyRemoveTypeImports",
                    optimizeConstEnums: "optimizeConstEnums",
                    rewriteImportExtensions: "rewriteImportExtensions",
                    allExtensions: "allExtensions",
                    isTSX: "isTSX"
                };
                const i = c.validateStringOption(s.jsxPragmaFrag, e1.jsxPragmaFrag, "React.Fragment");
                {
                    var a = c.validateBooleanOption(s.allExtensions, e1.allExtensions, false);
                    var o = c.validateBooleanOption(s.isTSX, e1.isTSX, false);
                    if (o) {
                        c.invariant(a, "isTSX:true requires allExtensions:true");
                    }
                }
                const l = c.validateBooleanOption(s.ignoreExtensions, e1.ignoreExtensions, false);
                const p = c.validateBooleanOption(s.disallowAmbiguousJSXLike, e1.disallowAmbiguousJSXLike, false);
                if (p) {
                    {
                        c.invariant(a, "disallowAmbiguousJSXLike:true requires allExtensions:true");
                    }
                }
                const u = c.validateBooleanOption(s.optimizeConstEnums, e1.optimizeConstEnums, false);
                const d = c.validateBooleanOption(s.rewriteImportExtensions, e1.rewriteImportExtensions, false);
                const f = {
                    ignoreExtensions: l,
                    allowNamespaces: t,
                    disallowAmbiguousJSXLike: p,
                    jsxPragma: r,
                    jsxPragmaFrag: i,
                    onlyRemoveTypeImports: n,
                    optimizeConstEnums: u,
                    rewriteImportExtensions: d
                };
                {
                    f.allExtensions = a;
                    f.isTSX = o;
                }
                return f;
            }
            var p = n.declare(function(param) {
                let { types: e1, template: t } = param;
                function maybeReplace(r, n, s) {
                    if (!r) return;
                    if (e1.isStringLiteral(r)) {
                        if (/^\.\.?\//.test(r.value)) {
                            r.value = r.value.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+)?)\.([cm]?)ts$/i, function(e1, t, r, n, s) {
                                return t ? ".js" : r && (!n || !s) ? e1 : r + n + "." + s.toLowerCase() + "js";
                            });
                        }
                        return;
                    }
                    if (s.availableHelper("tsRewriteRelativeImportExtensions")) {
                        n.replaceWith(e1.callExpression(s.addHelper("tsRewriteRelativeImportExtensions"), [
                            r
                        ]));
                    } else {
                        n.replaceWith(t.expression.ast(_templateObject70(), r));
                    }
                }
                return {
                    name: "preset-typescript/plugin-rewrite-ts-imports",
                    visitor: {
                        "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration" (t, r) {
                            const n = t.node;
                            const s = e1.isImportDeclaration(n) ? n.importKind : n.exportKind;
                            if (s === "value") {
                                maybeReplace(n.source, t.get("source"), r);
                            }
                        },
                        CallExpression (t, r) {
                            if (e1.isImport(t.node.callee)) {
                                maybeReplace(t.node.arguments[0], t.get("arguments.0"), r);
                            }
                        },
                        ImportExpression (e1, t) {
                            maybeReplace(e1.node.source, e1.get("source"), t);
                        }
                    }
                };
            });
            var u = n.declarePreset((e1, t)=>{
                e1.assertVersion(7);
                const { allExtensions: r, ignoreExtensions: n, allowNamespaces: s, disallowAmbiguousJSXLike: i, isTSX: a, jsxPragma: c, jsxPragmaFrag: u, onlyRemoveTypeImports: d, optimizeConstEnums: f, rewriteImportExtensions: h } = normalizeOptions(t);
                const pluginOptions = (e1)=>({
                        allowDeclareFields: t.allowDeclareFields,
                        allowNamespaces: s,
                        disallowAmbiguousJSXLike: e1,
                        jsxPragma: c,
                        jsxPragmaFrag: u,
                        onlyRemoveTypeImports: d,
                        optimizeConstEnums: f
                    });
                const getPlugins = (e1, t)=>{
                    {
                        return [
                            [
                                o.default,
                                Object.assign({
                                    isTSX: e1
                                }, pluginOptions(t))
                            ]
                        ];
                    }
                };
                const m = r || n;
                return {
                    plugins: h ? [
                        p
                    ] : [],
                    overrides: m ? [
                        {
                            plugins: getPlugins(a, i)
                        }
                    ] : [
                        {
                            test: /\.ts$/,
                            plugins: getPlugins(false, false)
                        },
                        {
                            test: /\.mts$/,
                            sourceType: "module",
                            plugins: getPlugins(false, true)
                        },
                        {
                            test: /\.cts$/,
                            sourceType: "unambiguous",
                            plugins: [
                                [
                                    l.default,
                                    {
                                        allowTopLevelThis: true
                                    }
                                ],
                                [
                                    o.default,
                                    pluginOptions(true)
                                ]
                            ]
                        },
                        {
                            test: /\.tsx$/,
                            plugins: getPlugins(true, false)
                        }
                    ]
                };
            });
            t["default"] = u;
        },
        3725: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createTemplateBuilder;
            var n = r(6657);
            var s = r(1510);
            var i = r(8671);
            const a = (0, n.validate)({
                placeholderPattern: false
            });
            function createTemplateBuilder(e1, t) {
                const r = new WeakMap;
                const o = new WeakMap;
                const l = t || (0, n.validate)(null);
                return Object.assign(function(t) {
                    for(var _len = arguments.length, a = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        a[_key - 1] = arguments[_key];
                    }
                    if (typeof t === "string") {
                        if (a.length > 1) throw new Error("Unexpected extra params.");
                        return extendedTrace((0, s.default)(e1, t, (0, n.merge)(l, (0, n.validate)(a[0]))));
                    } else if (Array.isArray(t)) {
                        let n = r.get(t);
                        if (!n) {
                            n = (0, i.default)(e1, t, l);
                            r.set(t, n);
                        }
                        return extendedTrace(n(a));
                    } else if (typeof t === "object" && t) {
                        if (a.length > 0) throw new Error("Unexpected extra params.");
                        return createTemplateBuilder(e1, (0, n.merge)(l, (0, n.validate)(t)));
                    }
                    throw new Error("Unexpected template param ".concat(typeof t));
                }, {
                    ast: function(t) {
                        for(var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                            r[_key - 1] = arguments[_key];
                        }
                        if (typeof t === "string") {
                            if (r.length > 1) throw new Error("Unexpected extra params.");
                            return (0, s.default)(e1, t, (0, n.merge)((0, n.merge)(l, (0, n.validate)(r[0])), a))();
                        } else if (Array.isArray(t)) {
                            let s = o.get(t);
                            if (!s) {
                                s = (0, i.default)(e1, t, (0, n.merge)(l, a));
                                o.set(t, s);
                            }
                            return s(r)();
                        }
                        throw new Error("Unexpected template param ".concat(typeof t));
                    }
                });
            }
            function extendedTrace(e1) {
                let t = "";
                try {
                    throw new Error;
                } catch (e1) {
                    if (e1.stack) {
                        t = e1.stack.split("\n").slice(3).join("\n");
                    }
                }
                return (r)=>{
                    try {
                        return e1(r);
                    } catch (e1) {
                        e1.stack += "\n    =============\n".concat(t);
                        throw e1;
                    }
                };
            }
        },
        4792: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.statements = t.statement = t.smart = t.program = t.expression = void 0;
            var n = r(3061);
            const { assertExpressionStatement: s } = n;
            function makeStatementFormatter(e1) {
                return {
                    code: (e1)=>"/* @babel/template */;\n".concat(e1),
                    validate: ()=>{},
                    unwrap: (t)=>e1(t.program.body.slice(1))
                };
            }
            const i = t.smart = makeStatementFormatter((e1)=>{
                if (e1.length > 1) {
                    return e1;
                } else {
                    return e1[0];
                }
            });
            const a = t.statements = makeStatementFormatter((e1)=>e1);
            const o = t.statement = makeStatementFormatter((e1)=>{
                if (e1.length === 0) {
                    throw new Error("Found nothing to return.");
                }
                if (e1.length > 1) {
                    throw new Error("Found multiple statements but wanted one");
                }
                return e1[0];
            });
            const l = t.expression = {
                code: (e1)=>"(\n".concat(e1, "\n)"),
                validate: (e1)=>{
                    if (e1.program.body.length > 1) {
                        throw new Error("Found multiple statements but wanted one");
                    }
                    if (l.unwrap(e1).start === 0) {
                        throw new Error("Parse result included parens.");
                    }
                },
                unwrap: (param)=>{
                    let { program: e1 } = param;
                    const [t] = e1.body;
                    s(t);
                    return t.expression;
                }
            };
            const c = t.program = {
                code: (e1)=>e1,
                validate: ()=>{},
                unwrap: (e1)=>e1.program
            };
        },
        5326: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.statements = t.statement = t.smart = t.program = t.expression = t["default"] = void 0;
            var n = r(4792);
            var s = r(3725);
            const i = t.smart = (0, s.default)(n.smart);
            const a = t.statement = (0, s.default)(n.statement);
            const o = t.statements = (0, s.default)(n.statements);
            const l = t.expression = (0, s.default)(n.expression);
            const c = t.program = (0, s.default)(n.program);
            var p = t["default"] = Object.assign(i.bind(undefined), {
                smart: i,
                statement: a,
                statements: o,
                expression: l,
                program: c,
                ast: i.ast
            });
        },
        8671: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = literalTemplate;
            var n = r(6657);
            var s = r(2082);
            var i = r(9534);
            function literalTemplate(e1, t, r) {
                const { metadata: s, names: a } = buildLiteralData(e1, t, r);
                return (t)=>{
                    const r = {};
                    t.forEach((e1, t)=>{
                        r[a[t]] = e1;
                    });
                    return (t)=>{
                        const a = (0, n.normalizeReplacements)(t);
                        if (a) {
                            Object.keys(a).forEach((e1)=>{
                                if (hasOwnProperty.call(r, e1)) {
                                    throw new Error("Unexpected replacement overlap.");
                                }
                            });
                        }
                        return e1.unwrap((0, i.default)(s, a ? Object.assign(a, r) : r));
                    };
                };
            }
            function buildLiteralData(e1, t, r) {
                let n = "BABEL_TPL$";
                const i = t.join("");
                do {
                    n = "$$" + n;
                }while (i.includes(n))
                const { names: a, code: o } = buildTemplateCode(t, n);
                const l = (0, s.default)(e1, e1.code(o), {
                    parser: r.parser,
                    placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
                    placeholderPattern: r.placeholderPattern,
                    preserveComments: r.preserveComments,
                    syntacticPlaceholders: r.syntacticPlaceholders
                });
                return {
                    metadata: l,
                    names: a
                };
            }
            function buildTemplateCode(e1, t) {
                const r = [];
                let n = e1[0];
                for(let s = 1; s < e1.length; s++){
                    const i = "".concat(t).concat(s - 1);
                    r.push(i);
                    n += i + e1[s];
                }
                return {
                    names: r,
                    code: n
                };
            }
        },
        6657: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.merge = merge;
            t.normalizeReplacements = normalizeReplacements;
            t.validate = validate;
            const r = [
                "placeholderWhitelist",
                "placeholderPattern",
                "preserveComments",
                "syntacticPlaceholders"
            ];
            function _objectWithoutPropertiesLoose(e1, t) {
                if (null == e1) return {};
                var r = {};
                for(var n in e1)if (({}).hasOwnProperty.call(e1, n)) {
                    if (-1 !== t.indexOf(n)) continue;
                    r[n] = e1[n];
                }
                return r;
            }
            function merge(e1, t) {
                const { placeholderWhitelist: r = e1.placeholderWhitelist, placeholderPattern: n = e1.placeholderPattern, preserveComments: s = e1.preserveComments, syntacticPlaceholders: i = e1.syntacticPlaceholders } = t;
                return {
                    parser: Object.assign({}, e1.parser, t.parser),
                    placeholderWhitelist: r,
                    placeholderPattern: n,
                    preserveComments: s,
                    syntacticPlaceholders: i
                };
            }
            function validate(e1) {
                if (e1 != null && typeof e1 !== "object") {
                    throw new Error("Unknown template options.");
                }
                const t = e1 || {}, { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a } = t, o = _objectWithoutPropertiesLoose(t, r);
                if (n != null && !(n instanceof Set)) {
                    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
                }
                if (s != null && !(s instanceof RegExp) && s !== false) {
                    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
                }
                if (i != null && typeof i !== "boolean") {
                    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
                }
                if (a != null && typeof a !== "boolean") {
                    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
                }
                if (a === true && (n != null || s != null)) {
                    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
                }
                return {
                    parser: o,
                    placeholderWhitelist: n || undefined,
                    placeholderPattern: s == null ? undefined : s,
                    preserveComments: i == null ? undefined : i,
                    syntacticPlaceholders: a == null ? undefined : a
                };
            }
            function normalizeReplacements(e1) {
                if (Array.isArray(e1)) {
                    return e1.reduce((e1, t, r)=>{
                        e1["$" + r] = t;
                        return e1;
                    }, {});
                } else if (typeof e1 === "object" || e1 == null) {
                    return e1 || undefined;
                }
                throw new Error("Template replacements must be an array, object, null, or undefined");
            }
        },
        2082: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = parseAndBuildMetadata;
            var n = r(3061);
            var s = r(9849);
            var i = r(3554);
            const { isCallExpression: a, isExpressionStatement: o, isFunction: l, isIdentifier: c, isJSXIdentifier: p, isNewExpression: u, isPlaceholder: d, isStatement: f, isStringLiteral: h, removePropertiesDeep: m, traverse: y } = n;
            const g = /^[_$A-Z0-9]+$/;
            function parseAndBuildMetadata(e1, t, r) {
                const { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a } = r;
                const o = parseWithCodeFrame(t, r.parser, a);
                m(o, {
                    preserveComments: i
                });
                e1.validate(o);
                const l = {
                    syntactic: {
                        placeholders: [],
                        placeholderNames: new Set
                    },
                    legacy: {
                        placeholders: [],
                        placeholderNames: new Set
                    },
                    placeholderWhitelist: n,
                    placeholderPattern: s,
                    syntacticPlaceholders: a
                };
                y(o, placeholderVisitorHandler, l);
                return Object.assign({
                    ast: o
                }, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
            }
            function placeholderVisitorHandler(e1, t, r) {
                var n;
                let s;
                let i = r.syntactic.placeholders.length > 0;
                if (d(e1)) {
                    if (r.syntacticPlaceholders === false) {
                        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
                    }
                    s = e1.name.name;
                    i = true;
                } else if (i || r.syntacticPlaceholders) {
                    return;
                } else if (c(e1) || p(e1)) {
                    s = e1.name;
                } else if (h(e1)) {
                    s = e1.value;
                } else {
                    return;
                }
                if (i && (r.placeholderPattern != null || r.placeholderWhitelist != null)) {
                    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
                }
                if (!i && (r.placeholderPattern === false || !(r.placeholderPattern || g).test(s)) && !((n = r.placeholderWhitelist) != null && n.has(s))) {
                    return;
                }
                t = t.slice();
                const { node: m, key: y } = t[t.length - 1];
                let b;
                if (h(e1) || d(e1, {
                    expectedNode: "StringLiteral"
                })) {
                    b = "string";
                } else if (u(m) && y === "arguments" || a(m) && y === "arguments" || l(m) && y === "params") {
                    b = "param";
                } else if (o(m) && !d(e1)) {
                    b = "statement";
                    t = t.slice(0, -1);
                } else if (f(e1) && d(e1)) {
                    b = "statement";
                } else {
                    b = "other";
                }
                const { placeholders: T, placeholderNames: S } = !i ? r.legacy : r.syntactic;
                T.push({
                    name: s,
                    type: b,
                    resolve: (e1)=>resolveAncestors(e1, t),
                    isDuplicate: S.has(s)
                });
                S.add(s);
            }
            function resolveAncestors(e1, t) {
                let r = e1;
                for(let e1 = 0; e1 < t.length - 1; e1++){
                    const { key: n, index: s } = t[e1];
                    if (s === undefined) {
                        r = r[n];
                    } else {
                        r = r[n][s];
                    }
                }
                const { key: n, index: s } = t[t.length - 1];
                return {
                    parent: r,
                    key: n,
                    index: s
                };
            }
            function parseWithCodeFrame(e1, t, r) {
                const n = (t.plugins || []).slice();
                if (r !== false) {
                    n.push("placeholders");
                }
                t = Object.assign({
                    allowAwaitOutsideFunction: true,
                    allowReturnOutsideFunction: true,
                    allowNewTargetOutsideFunction: true,
                    allowSuperOutsideMethod: true,
                    allowYieldOutsideFunction: true,
                    sourceType: "module"
                }, t, {
                    plugins: n
                });
                try {
                    return (0, s.parse)(e1, t);
                } catch (t) {
                    const r = t.loc;
                    if (r) {
                        t.message += "\n" + (0, i.codeFrameColumns)(e1, {
                            start: r
                        });
                        t.code = "BABEL_TEMPLATE_PARSE_ERROR";
                    }
                    throw t;
                }
            }
        },
        9534: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = populatePlaceholders;
            var n = r(3061);
            const { blockStatement: s, cloneNode: i, emptyStatement: a, expressionStatement: o, identifier: l, isStatement: c, isStringLiteral: p, stringLiteral: u, validate: d } = n;
            function populatePlaceholders(e1, t) {
                const r = i(e1.ast);
                if (t) {
                    e1.placeholders.forEach((e1)=>{
                        if (!hasOwnProperty.call(t, e1.name)) {
                            const t = e1.name;
                            throw new Error('Error: No substitution given for "'.concat(t, "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['").concat(t, "'])}\n            - { placeholderPattern: /^").concat(t, "$/ }"));
                        }
                    });
                    Object.keys(t).forEach((t)=>{
                        if (!e1.placeholderNames.has(t)) {
                            throw new Error('Unknown substitution "'.concat(t, '" given'));
                        }
                    });
                }
                e1.placeholders.slice().reverse().forEach((e1)=>{
                    try {
                        applyReplacement(e1, r, t && t[e1.name] || null);
                    } catch (t) {
                        t.message = '@babel/template placeholder "'.concat(e1.name, '": ').concat(t.message);
                        throw t;
                    }
                });
                return r;
            }
            function applyReplacement(e1, t, r) {
                if (e1.isDuplicate) {
                    if (Array.isArray(r)) {
                        r = r.map((e1)=>i(e1));
                    } else if (typeof r === "object") {
                        r = i(r);
                    }
                }
                const { parent: n, key: f, index: h } = e1.resolve(t);
                if (e1.type === "string") {
                    if (typeof r === "string") {
                        r = u(r);
                    }
                    if (!r || !p(r)) {
                        throw new Error("Expected string substitution");
                    }
                } else if (e1.type === "statement") {
                    if (h === undefined) {
                        if (!r) {
                            r = a();
                        } else if (Array.isArray(r)) {
                            r = s(r);
                        } else if (typeof r === "string") {
                            r = o(l(r));
                        } else if (!c(r)) {
                            r = o(r);
                        }
                    } else {
                        if (r && !Array.isArray(r)) {
                            if (typeof r === "string") {
                                r = l(r);
                            }
                            if (!c(r)) {
                                r = o(r);
                            }
                        }
                    }
                } else if (e1.type === "param") {
                    if (typeof r === "string") {
                        r = l(r);
                    }
                    if (h === undefined) throw new Error("Assertion failure.");
                } else {
                    if (typeof r === "string") {
                        r = l(r);
                    }
                    if (Array.isArray(r)) {
                        throw new Error("Cannot replace single expression with an array.");
                    }
                }
                function set(e1, t, r) {
                    const n = e1[t];
                    e1[t] = r;
                    if (n.type === "Identifier" || n.type === "Placeholder") {
                        if (n.typeAnnotation) {
                            r.typeAnnotation = n.typeAnnotation;
                        }
                        if (n.optional) {
                            r.optional = n.optional;
                        }
                        if (n.decorators) {
                            r.decorators = n.decorators;
                        }
                    }
                }
                if (h === undefined) {
                    d(n, f, r);
                    set(n, f, r);
                } else {
                    const t = n[f].slice();
                    if (e1.type === "statement" || e1.type === "param") {
                        if (r == null) {
                            t.splice(h, 1);
                        } else if (Array.isArray(r)) {
                            t.splice(h, 1, ...r);
                        } else {
                            set(t, h, r);
                        }
                    } else {
                        set(t, h, r);
                    }
                    d(n, f, t);
                    n[f] = t;
                }
            }
        },
        1510: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = stringTemplate;
            var n = r(6657);
            var s = r(2082);
            var i = r(9534);
            function stringTemplate(e1, t, r) {
                t = e1.code(t);
                let a;
                return (o)=>{
                    const l = (0, n.normalizeReplacements)(o);
                    if (!a) a = (0, s.default)(e1, t, r);
                    return e1.unwrap((0, i.default)(a, l));
                };
            }
        },
        8099: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.clear = clear;
            t.clearPath = clearPath;
            t.clearScope = clearScope;
            t.getCachedPaths = getCachedPaths;
            t.getOrCreateCachedPaths = getOrCreateCachedPaths;
            t.scope = t.path = void 0;
            let r = t.path = new WeakMap;
            let n = t.scope = new WeakMap;
            function clear() {
                clearPath();
                clearScope();
            }
            function clearPath() {
                t.path = r = new WeakMap;
            }
            function clearScope() {
                t.scope = n = new WeakMap;
            }
            const s = Object.freeze({});
            function getCachedPaths(e1, t) {
                var n;
                {
                    e1 = null;
                }
                return (n = r.get(e1 != null ? e1 : s)) == null ? void 0 : n.get(t);
            }
            function getOrCreateCachedPaths(e1, t) {
                {
                    e1 = null;
                }
                let n = r.get(e1 != null ? e1 : s);
                if (!n) r.set(e1 != null ? e1 : s, n = new WeakMap);
                let i = n.get(t);
                if (!i) n.set(t, i = new Map);
                return i;
            }
        },
        5530: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9111);
            var s = r(3061);
            var i = r(4144);
            const { VISITOR_KEYS: a } = s;
            class TraversalContext {
                shouldVisit(e1) {
                    const t = this.opts;
                    if (t.enter || t.exit) return true;
                    if (t[e1.type]) return true;
                    const r = a[e1.type];
                    if (!(r != null && r.length)) return false;
                    for (const t of r){
                        if (e1[t]) {
                            return true;
                        }
                    }
                    return false;
                }
                create(e1, t, r, s) {
                    return n.default.get({
                        parentPath: this.parentPath,
                        parent: e1,
                        container: t,
                        key: r,
                        listKey: s
                    });
                }
                maybeQueue(e1, t) {
                    if (this.queue) {
                        if (t) {
                            this.queue.push(e1);
                        } else {
                            this.priorityQueue.push(e1);
                        }
                    }
                }
                visitMultiple(e1, t, r) {
                    if (e1.length === 0) return false;
                    const n = [];
                    for(let s = 0; s < e1.length; s++){
                        const i = e1[s];
                        if (i && this.shouldVisit(i)) {
                            n.push(this.create(t, e1, s, r));
                        }
                    }
                    return this.visitQueue(n);
                }
                visitSingle(e1, t) {
                    if (this.shouldVisit(e1[t])) {
                        return this.visitQueue([
                            this.create(e1, e1, t)
                        ]);
                    } else {
                        return false;
                    }
                }
                visitQueue(e1) {
                    this.queue = e1;
                    this.priorityQueue = [];
                    const t = new WeakSet;
                    let r = false;
                    let n = 0;
                    for(; n < e1.length;){
                        const s = e1[n];
                        n++;
                        i.resync.call(s);
                        if (s.contexts.length === 0 || s.contexts[s.contexts.length - 1] !== this) {
                            i.pushContext.call(s, this);
                        }
                        if (s.key === null) continue;
                        const { node: a } = s;
                        if (t.has(a)) continue;
                        if (a) t.add(a);
                        if (s.visit()) {
                            r = true;
                            break;
                        }
                        if (this.priorityQueue.length) {
                            r = this.visitQueue(this.priorityQueue);
                            this.priorityQueue = [];
                            this.queue = e1;
                            if (r) break;
                        }
                    }
                    for(let t = 0; t < n; t++){
                        i.popContext.call(e1[t]);
                    }
                    this.queue = null;
                    return r;
                }
                visit(e1, t) {
                    const r = e1[t];
                    if (!r) return false;
                    if (Array.isArray(r)) {
                        return this.visitMultiple(r, e1, t);
                    } else {
                        return this.visitSingle(e1, t);
                    }
                }
                constructor(e1, t, r, n){
                    this.queue = null;
                    this.priorityQueue = null;
                    this.parentPath = n;
                    this.scope = e1;
                    this.state = r;
                    this.opts = t;
                }
            }
            t["default"] = TraversalContext;
        },
        6903: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class Hub {
                getCode() {}
                getScope() {}
                addHelper() {
                    throw new Error("Helpers are not supported by the default hub.");
                }
                buildError(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : TypeError;
                    return new r(t);
                }
            }
            t["default"] = Hub;
        },
        8026: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "Hub", {
                enumerable: true,
                get: function() {
                    return c.default;
                }
            });
            Object.defineProperty(t, "NodePath", {
                enumerable: true,
                get: function() {
                    return o.default;
                }
            });
            Object.defineProperty(t, "Scope", {
                enumerable: true,
                get: function() {
                    return l.default;
                }
            });
            t.visitors = t["default"] = void 0;
            r(4144);
            var n = r(5621);
            t.visitors = n;
            var s = r(3061);
            var i = r(8099);
            var a = r(6265);
            var o = r(9111);
            var l = r(9877);
            var c = r(6903);
            const { VISITOR_KEYS: p, removeProperties: u, traverseFast: d } = s;
            function traverse(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0, o = arguments.length > 5 ? arguments[5] : void 0;
                if (!e1) return;
                if (!t.noScope && !r) {
                    if (e1.type !== "Program" && e1.type !== "File") {
                        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + "Instead of that you tried to traverse a ".concat(e1.type, " node without ") + "passing scope and parentPath.");
                    }
                }
                if (!i && o) {
                    throw new Error("visitSelf can only be used when providing a NodePath.");
                }
                if (!p[e1.type]) {
                    return;
                }
                n.explode(t);
                (0, a.traverseNode)(e1, t, r, s, i, null, o);
            }
            var f = t["default"] = traverse;
            traverse.visitors = n;
            traverse.verify = n.verify;
            traverse.explode = n.explode;
            traverse.cheap = function(e1, t) {
                d(e1, t);
                return;
            };
            traverse.node = function(e1, t, r, n, s, i) {
                (0, a.traverseNode)(e1, t, r, n, s, i);
            };
            traverse.clearNode = function(e1, t) {
                u(e1, t);
            };
            traverse.removeProperties = function(e1, t) {
                d(e1, traverse.clearNode, t);
                return e1;
            };
            traverse.hasType = function(e1, t, r) {
                if (r != null && r.includes(e1.type)) return false;
                if (e1.type === t) return true;
                return d(e1, function(e1) {
                    if (r != null && r.includes(e1.type)) {
                        return d.skip;
                    }
                    if (e1.type === t) {
                        return d.stop;
                    }
                });
            };
            traverse.cache = i;
        },
        8073: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.find = find;
            t.findParent = findParent;
            t.getAncestry = getAncestry;
            t.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
            t.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
            t.getFunctionParent = getFunctionParent;
            t.getStatementParent = getStatementParent;
            t.inType = inType;
            t.isAncestor = isAncestor;
            t.isDescendant = isDescendant;
            var n = r(3061);
            const { VISITOR_KEYS: s } = n;
            function findParent(e1) {
                let t = this;
                while(t = t.parentPath){
                    if (e1(t)) return t;
                }
                return null;
            }
            function find(e1) {
                let t = this;
                do {
                    if (e1(t)) return t;
                }while (t = t.parentPath)
                return null;
            }
            function getFunctionParent() {
                return this.findParent((e1)=>e1.isFunction());
            }
            function getStatementParent() {
                let e1 = this;
                do {
                    if (!e1.parentPath || Array.isArray(e1.container) && e1.isStatement()) {
                        break;
                    } else {
                        e1 = e1.parentPath;
                    }
                }while (e1)
                if (e1 && (e1.isProgram() || e1.isFile())) {
                    throw new Error("File/Program node, we can't possibly find a statement parent to this");
                }
                return e1;
            }
            function getEarliestCommonAncestorFrom(e1) {
                return this.getDeepestCommonAncestorFrom(e1, function(e1, t, r) {
                    let n;
                    const i = s[e1.type];
                    for (const e1 of r){
                        const r = e1[t + 1];
                        if (!n) {
                            n = r;
                            continue;
                        }
                        if (r.listKey && n.listKey === r.listKey) {
                            if (r.key < n.key) {
                                n = r;
                                continue;
                            }
                        }
                        const s = i.indexOf(n.parentKey);
                        const a = i.indexOf(r.parentKey);
                        if (s > a) {
                            n = r;
                        }
                    }
                    return n;
                });
            }
            function getDeepestCommonAncestorFrom(e1, t) {
                if (!e1.length) {
                    return this;
                }
                if (e1.length === 1) {
                    return e1[0];
                }
                let r = Infinity;
                let n, s;
                const i = e1.map((e1)=>{
                    const t = [];
                    do {
                        t.unshift(e1);
                    }while ((e1 = e1.parentPath) && e1 !== this)
                    if (t.length < r) {
                        r = t.length;
                    }
                    return t;
                });
                const a = i[0];
                e1: for(let e1 = 0; e1 < r; e1++){
                    const t = a[e1];
                    for (const r of i){
                        if (r[e1] !== t) {
                            break e1;
                        }
                    }
                    n = e1;
                    s = t;
                }
                if (s) {
                    if (t) {
                        return t(s, n, i);
                    } else {
                        return s;
                    }
                } else {
                    throw new Error("Couldn't find intersection");
                }
            }
            function getAncestry() {
                let e1 = this;
                const t = [];
                do {
                    t.push(e1);
                }while (e1 = e1.parentPath)
                return t;
            }
            function isAncestor(e1) {
                return e1.isDescendant(this);
            }
            function isDescendant(e1) {
                return !!this.findParent((t)=>t === e1);
            }
            function inType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                let t = this;
                while(t){
                    if (e1.includes(t.node.type)) return true;
                    t = t.parentPath;
                }
                return false;
            }
        },
        3162: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.addComment = addComment;
            t.addComments = addComments;
            t.shareCommentsWithSiblings = shareCommentsWithSiblings;
            var n = r(3061);
            const { addComment: s, addComments: i } = n;
            function shareCommentsWithSiblings() {
                if (typeof this.key === "string") return;
                const e1 = this.node;
                if (!e1) return;
                const t = e1.trailingComments;
                const r = e1.leadingComments;
                if (!t && !r) return;
                const n = this.getSibling(this.key - 1);
                const s = this.getSibling(this.key + 1);
                const i = Boolean(n.node);
                const a = Boolean(s.node);
                if (i) {
                    if (r) {
                        n.addComments("trailing", removeIfExisting(r, n.node.trailingComments));
                    }
                    if (t && !a) n.addComments("trailing", t);
                }
                if (a) {
                    if (t) {
                        s.addComments("leading", removeIfExisting(t, s.node.leadingComments));
                    }
                    if (r && !i) s.addComments("leading", r);
                }
            }
            function removeIfExisting(e1, t) {
                if (!(t != null && t.length)) return e1;
                const r = new Set(t);
                return e1.filter((e1)=>!r.has(e1));
            }
            function addComment(e1, t, r) {
                s(this.node, e1, t, r);
            }
            function addComments(e1, t) {
                i(this.node, e1, t);
            }
        },
        4144: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._call = _call;
            t._getQueueContexts = _getQueueContexts;
            t._resyncKey = _resyncKey;
            t._resyncList = _resyncList;
            t._resyncParent = _resyncParent;
            t._resyncRemoved = _resyncRemoved;
            t.call = call;
            t.isDenylisted = isDenylisted;
            t.popContext = popContext;
            t.pushContext = pushContext;
            t.requeue = requeue;
            t.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
            t.resync = resync;
            t.setContext = setContext;
            t.setKey = setKey;
            t.setScope = setScope;
            t.setup = setup;
            t.skip = skip;
            t.skipKey = skipKey;
            t.stop = stop;
            t.visit = visit;
            var n = r(6265);
            var s = r(9111);
            var i = r(6035);
            var a = r(3061);
            function call(e1) {
                const t = this.opts;
                this.debug(e1);
                if (this.node) {
                    if (_call.call(this, t[e1])) return true;
                }
                if (this.node) {
                    var r;
                    return _call.call(this, (r = t[this.node.type]) == null ? void 0 : r[e1]);
                }
                return false;
            }
            function _call(e1) {
                if (!e1) return false;
                for (const t of e1){
                    if (!t) continue;
                    const e1 = this.node;
                    if (!e1) return true;
                    const r = t.call(this.state, this, this.state);
                    if (r && typeof r === "object" && typeof r.then === "function") {
                        throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
                    }
                    if (r) {
                        throw new Error("Unexpected return value from visitor method ".concat(t));
                    }
                    if (this.node !== e1) return true;
                    if (this._traverseFlags > 0) return true;
                }
                return false;
            }
            function isDenylisted() {
                var e1;
                const t = (e1 = this.opts.denylist) != null ? e1 : this.opts.blacklist;
                return t == null ? void 0 : t.includes(this.node.type);
            }
            {
                t.isBlacklisted = isDenylisted;
            }
            function restoreContext(e1, t) {
                if (e1.context !== t) {
                    e1.context = t;
                    e1.state = t.state;
                    e1.opts = t.opts;
                }
            }
            function visit() {
                var e1, t;
                if (!this.node) {
                    return false;
                }
                if (this.isDenylisted()) {
                    return false;
                }
                if ((e1 = (t = this.opts).shouldSkip) != null && e1.call(t, this)) {
                    return false;
                }
                const r = this.context;
                if (this.shouldSkip || call.call(this, "enter")) {
                    this.debug("Skip...");
                    return this.shouldStop;
                }
                restoreContext(this, r);
                this.debug("Recursing into...");
                this.shouldStop = (0, n.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
                restoreContext(this, r);
                call.call(this, "exit");
                return this.shouldStop;
            }
            function skip() {
                this.shouldSkip = true;
            }
            function skipKey(e1) {
                if (this.skipKeys == null) {
                    this.skipKeys = {};
                }
                this.skipKeys[e1] = true;
            }
            function stop() {
                this._traverseFlags |= s.SHOULD_SKIP | s.SHOULD_STOP;
            }
            function setScope() {
                var e1, t;
                if ((e1 = this.opts) != null && e1.noScope) return;
                let r = this.parentPath;
                if ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) {
                    r = r.parentPath;
                }
                let n;
                while(r && !n){
                    var s;
                    if ((s = r.opts) != null && s.noScope) return;
                    n = r.scope;
                    r = r.parentPath;
                }
                this.scope = this.getScope(n);
                (t = this.scope) == null || t.init();
            }
            function setContext(e1) {
                if (this.skipKeys != null) {
                    this.skipKeys = {};
                }
                this._traverseFlags = 0;
                if (e1) {
                    this.context = e1;
                    this.state = e1.state;
                    this.opts = e1.opts;
                }
                setScope.call(this);
                return this;
            }
            function resync() {
                if (this.removed) return;
                _resyncParent.call(this);
                _resyncList.call(this);
                _resyncKey.call(this);
            }
            function _resyncParent() {
                if (this.parentPath) {
                    this.parent = this.parentPath.node;
                }
            }
            function _resyncKey() {
                if (!this.container) return;
                if (this.node === this.container[this.key]) {
                    return;
                }
                if (Array.isArray(this.container)) {
                    for(let e1 = 0; e1 < this.container.length; e1++){
                        if (this.container[e1] === this.node) {
                            setKey.call(this, e1);
                            return;
                        }
                    }
                } else {
                    for (const e1 of Object.keys(this.container)){
                        if (this.container[e1] === this.node) {
                            setKey.call(this, e1);
                            return;
                        }
                    }
                }
                this.key = null;
            }
            function _resyncList() {
                if (!this.parent || !this.inList) return;
                const e1 = this.parent[this.listKey];
                if (this.container === e1) return;
                this.container = e1 || null;
            }
            function _resyncRemoved() {
                if (this.key == null || !this.container || this.container[this.key] !== this.node) {
                    i._markRemoved.call(this);
                }
            }
            function popContext() {
                this.contexts.pop();
                if (this.contexts.length > 0) {
                    this.setContext(this.contexts[this.contexts.length - 1]);
                } else {
                    this.setContext(undefined);
                }
            }
            function pushContext(e1) {
                this.contexts.push(e1);
                this.setContext(e1);
            }
            function setup(e1, t, r, n) {
                this.listKey = r;
                this.container = t;
                this.parentPath = e1 || this.parentPath;
                setKey.call(this, n);
            }
            function setKey(e1) {
                var t;
                this.key = e1;
                this.node = this.container[this.key];
                this.type = (t = this.node) == null ? void 0 : t.type;
            }
            function requeue() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
                if (e1.removed) return;
                const t = this.contexts;
                for (const r of t){
                    r.maybeQueue(e1);
                }
            }
            function requeueComputedKeyAndDecorators() {
                const { context: e1, node: t } = this;
                if (!a.isPrivate(t) && t.computed) {
                    e1.maybeQueue(this.get("key"));
                }
                if (t.decorators) {
                    for (const t of this.get("decorators")){
                        e1.maybeQueue(t);
                    }
                }
            }
            function _getQueueContexts() {
                let e1 = this;
                let t = this.contexts;
                while(!t.length){
                    e1 = e1.parentPath;
                    if (!e1) break;
                    t = e1.contexts;
                }
                return t;
            }
        },
        2919: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.arrowFunctionToExpression = arrowFunctionToExpression;
            t.ensureBlock = ensureBlock;
            t.ensureFunctionName = ensureFunctionName;
            t.splitExportDeclaration = splitExportDeclaration;
            t.toComputedKey = toComputedKey;
            t.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
            var n = r(3061);
            var s = r(5326);
            var i = r(5621);
            var a = r(4144);
            const { arrowFunctionExpression: o, assignmentExpression: l, binaryExpression: c, blockStatement: p, callExpression: u, conditionalExpression: d, expressionStatement: f, identifier: h, isIdentifier: m, jsxIdentifier: y, logicalExpression: g, LOGICAL_OPERATORS: b, memberExpression: T, metaProperty: S, numericLiteral: x, objectExpression: E, restElement: P, returnStatement: v, sequenceExpression: A, spreadElement: w, stringLiteral: I, super: C, thisExpression: O, toExpression: N, unaryExpression: k, toBindingIdentifierName: _, isFunction: D, isAssignmentPattern: M, isRestElement: L, getFunctionName: j, cloneNode: F, variableDeclaration: B, variableDeclarator: R, exportNamedDeclaration: U, exportSpecifier: K, inherits: V } = n;
            function toComputedKey() {
                let e1;
                if (this.isMemberExpression()) {
                    e1 = this.node.property;
                } else if (this.isProperty() || this.isMethod()) {
                    e1 = this.node.key;
                } else {
                    throw new ReferenceError("todo");
                }
                if (!this.node.computed) {
                    if (m(e1)) e1 = I(e1.name);
                }
                return e1;
            }
            function ensureBlock() {
                const e1 = this.get("body");
                const t = e1.node;
                if (Array.isArray(e1)) {
                    throw new Error("Can't convert array path to a block statement");
                }
                if (!t) {
                    throw new Error("Can't convert node without a body");
                }
                if (e1.isBlockStatement()) {
                    return t;
                }
                const r = [];
                let n = "body";
                let s;
                let i;
                if (e1.isStatement()) {
                    i = "body";
                    s = 0;
                    r.push(e1.node);
                } else {
                    n += ".body.0";
                    if (this.isFunction()) {
                        s = "argument";
                        r.push(v(e1.node));
                    } else {
                        s = "expression";
                        r.push(f(e1.node));
                    }
                }
                this.node.body = p(r);
                const o = this.get(n);
                a.setup.call(e1, o, i ? o.node[i] : o.node, i, s);
                return this.node;
            }
            {
                t.arrowFunctionToShadowed = function() {
                    if (!this.isArrowFunctionExpression()) return;
                    this.arrowFunctionToExpression();
                };
            }
            function unwrapFunctionEnvironment() {
                if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
                    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
                }
                hoistFunctionEnvironment(this);
            }
            function setType(e1, t) {
                e1.node.type = t;
            }
            function arrowFunctionToExpression() {
                let { allowInsertArrow: e1 = true, allowInsertArrowWithRest: t = e1, noNewArrows: r = !((e1)=>(e1 = arguments[0]) == null ? void 0 : e1.specCompliant)() } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                if (!this.isArrowFunctionExpression()) {
                    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
                }
                let n = this;
                if (!r) {
                    var s;
                    n = (s = n.ensureFunctionName(false)) != null ? s : n;
                }
                const { thisBinding: i, fnPath: a } = hoistFunctionEnvironment(n, r, e1, t);
                a.ensureBlock();
                setType(a, "FunctionExpression");
                if (!r) {
                    const e1 = i ? null : a.scope.generateUidIdentifier("arrowCheckId");
                    if (e1) {
                        a.parentPath.scope.push({
                            id: e1,
                            init: E([])
                        });
                    }
                    a.get("body").unshiftContainer("body", f(u(this.hub.addHelper("newArrowCheck"), [
                        O(),
                        e1 ? h(e1.name) : h(i)
                    ])));
                    a.replaceWith(u(T(a.node, h("bind")), [
                        e1 ? h(e1.name) : O()
                    ]));
                    return a.get("callee.object");
                }
                return a;
            }
            const W = (0, i.environmentVisitor)({
                CallExpression (e1, param) {
                    let { allSuperCalls: t } = param;
                    if (!e1.get("callee").isSuper()) return;
                    t.push(e1);
                }
            });
            function hoistFunctionEnvironment(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                let s;
                let i = e1.findParent((e1)=>{
                    if (e1.isArrowFunctionExpression()) {
                        s != null ? s : s = e1;
                        return false;
                    }
                    return e1.isFunction() || e1.isProgram() || e1.isClassProperty({
                        static: false
                    }) || e1.isClassPrivateProperty({
                        static: false
                    });
                });
                const a = i.isClassMethod({
                    kind: "constructor"
                });
                if (i.isClassProperty() || i.isClassPrivateProperty()) {
                    if (s) {
                        i = s;
                    } else if (r) {
                        e1.replaceWith(u(o([], N(e1.node)), []));
                        i = e1.get("callee");
                        e1 = i.get("body");
                    } else {
                        throw e1.buildCodeFrameError("Unable to transform arrow inside class property");
                    }
                }
                const { thisPaths: l, argumentsPaths: p, newTargetPaths: f, superProps: m, superCalls: g } = getScopeInformation(e1);
                if (a && g.length > 0) {
                    if (!r) {
                        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super()` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                    }
                    if (!n) {
                        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', " + "it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                    }
                    const e1 = [];
                    i.traverse(W, {
                        allSuperCalls: e1
                    });
                    const t = getSuperBinding(i);
                    e1.forEach((e1)=>{
                        const r = h(t);
                        r.loc = e1.node.callee.loc;
                        e1.get("callee").replaceWith(r);
                    });
                }
                if (p.length > 0) {
                    const e1 = getBinding(i, "arguments", ()=>{
                        const args = ()=>h("arguments");
                        if (i.scope.path.isProgram()) {
                            return d(c("===", k("typeof", args()), I("undefined")), i.scope.buildUndefinedNode(), args());
                        } else {
                            return args();
                        }
                    });
                    p.forEach((t)=>{
                        const r = h(e1);
                        r.loc = t.node.loc;
                        t.replaceWith(r);
                    });
                }
                if (f.length > 0) {
                    const e1 = getBinding(i, "newtarget", ()=>S(h("new"), h("target")));
                    f.forEach((t)=>{
                        const r = h(e1);
                        r.loc = t.node.loc;
                        t.replaceWith(r);
                    });
                }
                if (m.length > 0) {
                    if (!r) {
                        throw m[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                    }
                    const e1 = m.reduce((e1, t)=>e1.concat(standardizeSuperProperty(t)), []);
                    e1.forEach((e1)=>{
                        const t = e1.node.computed ? "" : e1.get("property").node.name;
                        const r = e1.parentPath;
                        const n = r.isAssignmentExpression({
                            left: e1.node
                        });
                        const s = r.isCallExpression({
                            callee: e1.node
                        });
                        const a = r.isTaggedTemplateExpression({
                            tag: e1.node
                        });
                        const o = getSuperPropBinding(i, n, t);
                        const c = [];
                        if (e1.node.computed) {
                            c.push(e1.get("property").node);
                        }
                        if (n) {
                            const e1 = r.node.right;
                            c.push(e1);
                        }
                        const p = u(h(o), c);
                        if (s) {
                            r.unshiftContainer("arguments", O());
                            e1.replaceWith(T(p, h("call")));
                            l.push(r.get("arguments.0"));
                        } else if (n) {
                            r.replaceWith(p);
                        } else if (a) {
                            e1.replaceWith(u(T(p, h("bind"), false), [
                                O()
                            ]));
                            l.push(e1.get("arguments.0"));
                        } else {
                            e1.replaceWith(p);
                        }
                    });
                }
                let b;
                if (l.length > 0 || !t) {
                    b = getThisBinding(i, a);
                    if (t || a && hasSuperClass(i)) {
                        l.forEach((e1)=>{
                            const t = e1.isJSX() ? y(b) : h(b);
                            t.loc = e1.node.loc;
                            e1.replaceWith(t);
                        });
                        if (!t) b = null;
                    }
                }
                return {
                    thisBinding: b,
                    fnPath: e1
                };
            }
            function isLogicalOp(e1) {
                return b.includes(e1);
            }
            function standardizeSuperProperty(e1) {
                if (e1.parentPath.isAssignmentExpression() && e1.parentPath.node.operator !== "=") {
                    const t = e1.parentPath;
                    const r = t.node.operator.slice(0, -1);
                    const n = t.node.right;
                    const s = isLogicalOp(r);
                    if (e1.node.computed) {
                        const i = e1.scope.generateDeclaredUidIdentifier("tmp");
                        const a = e1.node.object;
                        const o = e1.node.property;
                        t.get("left").replaceWith(T(a, l("=", i, o), true));
                        t.get("right").replaceWith(rightExpression(s ? "=" : r, T(a, h(i.name), true), n));
                    } else {
                        const i = e1.node.object;
                        const a = e1.node.property;
                        t.get("left").replaceWith(T(i, a));
                        t.get("right").replaceWith(rightExpression(s ? "=" : r, T(i, h(a.name)), n));
                    }
                    if (s) {
                        t.replaceWith(g(r, t.node.left, t.node.right));
                    } else {
                        t.node.operator = "=";
                    }
                    return [
                        t.get("left"),
                        t.get("right").get("left")
                    ];
                } else if (e1.parentPath.isUpdateExpression()) {
                    const t = e1.parentPath;
                    const r = e1.scope.generateDeclaredUidIdentifier("tmp");
                    const n = e1.node.computed ? e1.scope.generateDeclaredUidIdentifier("prop") : null;
                    const s = [
                        l("=", r, T(e1.node.object, n ? l("=", n, e1.node.property) : e1.node.property, e1.node.computed)),
                        l("=", T(e1.node.object, n ? h(n.name) : e1.node.property, e1.node.computed), c(e1.parentPath.node.operator[0], h(r.name), x(1)))
                    ];
                    if (!e1.parentPath.node.prefix) {
                        s.push(h(r.name));
                    }
                    t.replaceWith(A(s));
                    const i = t.get("expressions.0.right");
                    const a = t.get("expressions.1.left");
                    return [
                        i,
                        a
                    ];
                }
                return [
                    e1
                ];
                //TURBOPACK unreachable
                ;
                function rightExpression(e1, t, r) {
                    if (e1 === "=") {
                        return l("=", t, r);
                    } else {
                        return c(e1, t, r);
                    }
                }
            }
            function hasSuperClass(e1) {
                return e1.isClassMethod() && !!e1.parentPath.parentPath.node.superClass;
            }
            const $ = (0, i.environmentVisitor)({
                CallExpression (e1, param) {
                    let { supers: t, thisBinding: r } = param;
                    if (!e1.get("callee").isSuper()) return;
                    if (t.has(e1.node)) return;
                    t.add(e1.node);
                    e1.replaceWithMultiple([
                        e1.node,
                        l("=", h(r), h("this"))
                    ]);
                }
            });
            function getThisBinding(e1, t) {
                return getBinding(e1, "this", (r)=>{
                    if (!t || !hasSuperClass(e1)) return O();
                    e1.traverse($, {
                        supers: new WeakSet,
                        thisBinding: r
                    });
                });
            }
            function getSuperBinding(e1) {
                return getBinding(e1, "supercall", ()=>{
                    const t = e1.scope.generateUidIdentifier("args");
                    return o([
                        P(t)
                    ], u(C(), [
                        w(h(t.name))
                    ]));
                });
            }
            function getSuperPropBinding(e1, t, r) {
                const n = t ? "set" : "get";
                return getBinding(e1, "superprop_".concat(n, ":").concat(r || ""), ()=>{
                    const n = [];
                    let s;
                    if (r) {
                        s = T(C(), h(r));
                    } else {
                        const t = e1.scope.generateUidIdentifier("prop");
                        n.unshift(t);
                        s = T(C(), h(t.name), true);
                    }
                    if (t) {
                        const t = e1.scope.generateUidIdentifier("value");
                        n.push(t);
                        s = l("=", s, h(t.name));
                    }
                    return o(n, s);
                });
            }
            function getBinding(e1, t, r) {
                const n = "binding:" + t;
                let s = e1.getData(n);
                if (!s) {
                    const i = e1.scope.generateUidIdentifier(t);
                    s = i.name;
                    e1.setData(n, s);
                    e1.scope.push({
                        id: i,
                        init: r(s)
                    });
                }
                return s;
            }
            const q = (0, i.environmentVisitor)({
                ThisExpression (e1, param) {
                    let { thisPaths: t } = param;
                    t.push(e1);
                },
                JSXIdentifier (e1, param) {
                    let { thisPaths: t } = param;
                    if (e1.node.name !== "this") return;
                    if (!e1.parentPath.isJSXMemberExpression({
                        object: e1.node
                    }) && !e1.parentPath.isJSXOpeningElement({
                        name: e1.node
                    })) {
                        return;
                    }
                    t.push(e1);
                },
                CallExpression (e1, param) {
                    let { superCalls: t } = param;
                    if (e1.get("callee").isSuper()) t.push(e1);
                },
                MemberExpression (e1, param) {
                    let { superProps: t } = param;
                    if (e1.get("object").isSuper()) t.push(e1);
                },
                Identifier (e1, param) {
                    let { argumentsPaths: t } = param;
                    if (!e1.isReferencedIdentifier({
                        name: "arguments"
                    })) return;
                    let r = e1.scope;
                    do {
                        if (r.hasOwnBinding("arguments")) {
                            r.rename("arguments");
                            return;
                        }
                        if (r.path.isFunction() && !r.path.isArrowFunctionExpression()) {
                            break;
                        }
                    }while (r = r.parent)
                    t.push(e1);
                },
                MetaProperty (e1, param) {
                    let { newTargetPaths: t } = param;
                    if (!e1.get("meta").isIdentifier({
                        name: "new"
                    })) return;
                    if (!e1.get("property").isIdentifier({
                        name: "target"
                    })) return;
                    t.push(e1);
                }
            });
            function getScopeInformation(e1) {
                const t = [];
                const r = [];
                const n = [];
                const s = [];
                const i = [];
                e1.traverse(q, {
                    thisPaths: t,
                    argumentsPaths: r,
                    newTargetPaths: n,
                    superProps: s,
                    superCalls: i
                });
                return {
                    thisPaths: t,
                    argumentsPaths: r,
                    newTargetPaths: n,
                    superProps: s,
                    superCalls: i
                };
            }
            function splitExportDeclaration() {
                if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
                    throw new Error("Only default and named export declarations can be split.");
                }
                if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
                    throw new Error("It doesn't make sense to split exported specifiers.");
                }
                const e1 = this.get("declaration");
                if (this.isExportDefaultDeclaration()) {
                    const t = e1.isFunctionDeclaration() || e1.isClassDeclaration();
                    const r = e1.isFunctionExpression() || e1.isClassExpression();
                    const n = e1.isScope() ? e1.scope.parent : e1.scope;
                    let s = e1.node.id;
                    let i = false;
                    if (!s) {
                        i = true;
                        s = n.generateUidIdentifier("default");
                        if (t || r) {
                            e1.node.id = F(s);
                        }
                    } else if (r && n.hasBinding(s.name)) {
                        i = true;
                        s = n.generateUidIdentifier(s.name);
                    }
                    const a = t ? e1.node : B("var", [
                        R(F(s), e1.node)
                    ]);
                    const o = U(null, [
                        K(F(s), h("default"))
                    ]);
                    this.insertAfter(o);
                    this.replaceWith(a);
                    if (i) {
                        n.registerDeclaration(this);
                    }
                    return this;
                } else if (this.get("specifiers").length > 0) {
                    throw new Error("It doesn't make sense to split exported specifiers.");
                }
                const t = e1.getOuterBindingIdentifiers();
                const r = Object.keys(t).map((e1)=>K(h(e1), h(e1)));
                const n = U(null, r);
                this.insertAfter(n);
                this.replaceWith(e1.node);
                return this;
            }
            const H = {
                "ReferencedIdentifier|BindingIdentifier" (e1, t) {
                    if (e1.node.name !== t.name) return;
                    t.needsRename = true;
                    e1.stop();
                },
                Scope (e1, t) {
                    if (e1.scope.hasOwnBinding(t.name)) {
                        e1.skip();
                    }
                }
            };
            function ensureFunctionName(e1) {
                if (this.node.id) return this;
                const t = j(this.node, this.parent);
                if (t == null) return this;
                let { name: r } = t;
                if (!e1 && /[\uD800-\uDFFF]/.test(r)) {
                    return null;
                }
                if (r.startsWith("get ") || r.startsWith("set ")) {
                    return null;
                }
                r = _(r.replace(/[/ ]/g, "_"));
                const n = h(r);
                V(n, t.originalNode);
                const i = {
                    needsRename: false,
                    name: r
                };
                const { scope: a } = this;
                const o = a.getOwnBinding(r);
                if (o) {
                    if (o.kind === "param") {
                        i.needsRename = true;
                    } else {}
                } else if (a.parent.hasBinding(r) || a.hasGlobal(r)) {
                    this.traverse(H, i);
                }
                if (!i.needsRename) {
                    this.node.id = n;
                    a.getProgramParent().references[n.name] = true;
                    return this;
                }
                if (a.hasBinding(n.name) && !a.hasGlobal(n.name)) {
                    a.rename(n.name);
                    this.node.id = n;
                    a.getProgramParent().references[n.name] = true;
                    return this;
                }
                if (!D(this.node)) return null;
                const l = a.generateUidIdentifier(n.name);
                const c = [];
                for(let e1 = 0, t = getFunctionArity(this.node); e1 < t; e1++){
                    c.push(a.generateUidIdentifier("x"));
                }
                const p = s.default.expression.ast(_templateObject71(), l, n, c, F(l), F(n), F(l), F(n), N(this.node));
                return this.replaceWith(p)[0].get("arguments.0");
            }
            function getFunctionArity(e1) {
                const t = e1.params.findIndex((e1)=>M(e1) || L(e1));
                return t === -1 ? e1.params.length : t;
            }
        },
        9119: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.evaluate = evaluate;
            t.evaluateTruthy = evaluateTruthy;
            const r = [
                "Number",
                "String",
                "Math"
            ];
            const n = [
                "isFinite",
                "isNaN",
                "parseFloat",
                "parseInt",
                "decodeURI",
                "decodeURIComponent",
                "encodeURI",
                "encodeURIComponent",
                null,
                null
            ];
            const s = [
                "random"
            ];
            function isValidObjectCallee(e1) {
                return r.includes(e1);
            }
            function isValidIdentifierCallee(e1) {
                return n.includes(e1);
            }
            function isInvalidMethod(e1) {
                return s.includes(e1);
            }
            function evaluateTruthy() {
                const e1 = this.evaluate();
                if (e1.confident) return !!e1.value;
            }
            function deopt(e1, t) {
                if (!t.confident) return;
                t.deoptPath = e1;
                t.confident = false;
            }
            const i = new Map([
                [
                    "undefined",
                    undefined
                ],
                [
                    "Infinity",
                    Infinity
                ],
                [
                    "NaN",
                    NaN
                ]
            ]);
            function evaluateCached(e1, t) {
                const { node: r } = e1;
                const { seen: n } = t;
                if (n.has(r)) {
                    const s = n.get(r);
                    if (s.resolved) {
                        return s.value;
                    } else {
                        deopt(e1, t);
                        return;
                    }
                } else {
                    const s = {
                        resolved: false
                    };
                    n.set(r, s);
                    const i = _evaluate(e1, t);
                    if (t.confident) {
                        s.resolved = true;
                        s.value = i;
                    }
                    return i;
                }
            }
            function _evaluate(e1, t) {
                if (!t.confident) return;
                if (e1.isSequenceExpression()) {
                    const r = e1.get("expressions");
                    return evaluateCached(r[r.length - 1], t);
                }
                if (e1.isStringLiteral() || e1.isNumericLiteral() || e1.isBooleanLiteral()) {
                    return e1.node.value;
                }
                if (e1.isNullLiteral()) {
                    return null;
                }
                if (e1.isTemplateLiteral()) {
                    return evaluateQuasis(e1, e1.node.quasis, t);
                }
                if (e1.isTaggedTemplateExpression() && e1.get("tag").isMemberExpression()) {
                    const r = e1.get("tag.object");
                    const { node: { name: n } } = r;
                    const s = e1.get("tag.property");
                    if (r.isIdentifier() && n === "String" && !e1.scope.getBinding(n) && s.isIdentifier() && s.node.name === "raw") {
                        return evaluateQuasis(e1, e1.node.quasi.quasis, t, true);
                    }
                }
                if (e1.isConditionalExpression()) {
                    const r = evaluateCached(e1.get("test"), t);
                    if (!t.confident) return;
                    if (r) {
                        return evaluateCached(e1.get("consequent"), t);
                    } else {
                        return evaluateCached(e1.get("alternate"), t);
                    }
                }
                if (e1.isExpressionWrapper()) {
                    return evaluateCached(e1.get("expression"), t);
                }
                if (e1.isMemberExpression() && !e1.parentPath.isCallExpression({
                    callee: e1.node
                })) {
                    const r = e1.get("property");
                    const n = e1.get("object");
                    if (n.isLiteral()) {
                        const s = n.node.value;
                        const i = typeof s;
                        let a = null;
                        if (e1.node.computed) {
                            a = evaluateCached(r, t);
                            if (!t.confident) return;
                        } else if (r.isIdentifier()) {
                            a = r.node.name;
                        }
                        if ((i === "number" || i === "string") && a != null && (typeof a === "number" || typeof a === "string")) {
                            return s[a];
                        }
                    }
                }
                if (e1.isReferencedIdentifier()) {
                    const n = e1.scope.getBinding(e1.node.name);
                    if (n) {
                        if (n.constantViolations.length > 0 || e1.node.start < n.path.node.end) {
                            deopt(n.path, t);
                            return;
                        }
                        const s = n.path.scope;
                        if (n.kind === "var" && s !== n.scope) {
                            let i = !s.path.parentPath.isBlockStatement();
                            for(let a = s.parent; a; a = a.parent){
                                var r;
                                if (a === e1.scope) {
                                    if (i) {
                                        deopt(n.path, t);
                                        return;
                                    }
                                    break;
                                }
                                if ((r = a.path.parentPath) != null && r.isBlockStatement()) {
                                    i = true;
                                }
                            }
                        }
                        if (n.hasValue) {
                            return n.value;
                        }
                    }
                    const s = e1.node.name;
                    if (i.has(s)) {
                        if (!n) {
                            return i.get(s);
                        }
                        deopt(n.path, t);
                        return;
                    }
                    const a = e1.resolve();
                    if (a === e1) {
                        deopt(e1, t);
                        return;
                    } else {
                        return evaluateCached(a, t);
                    }
                }
                if (e1.isUnaryExpression({
                    prefix: true
                })) {
                    if (e1.node.operator === "void") {
                        return undefined;
                    }
                    const r = e1.get("argument");
                    if (e1.node.operator === "typeof" && (r.isFunction() || r.isClass())) {
                        return "function";
                    }
                    const n = evaluateCached(r, t);
                    if (!t.confident) return;
                    switch(e1.node.operator){
                        case "!":
                            return !n;
                        case "+":
                            return +n;
                        case "-":
                            return -n;
                        case "~":
                            return ~n;
                        case "typeof":
                            return typeof n;
                    }
                }
                if (e1.isArrayExpression()) {
                    const r = [];
                    const n = e1.get("elements");
                    for (const e1 of n){
                        const n = e1.evaluate();
                        if (n.confident) {
                            r.push(n.value);
                        } else {
                            deopt(n.deopt, t);
                            return;
                        }
                    }
                    return r;
                }
                if (e1.isObjectExpression()) {
                    const r = {};
                    const n = e1.get("properties");
                    for (const e1 of n){
                        if (e1.isObjectMethod() || e1.isSpreadElement()) {
                            deopt(e1, t);
                            return;
                        }
                        const n = e1.get("key");
                        let s;
                        if (e1.node.computed) {
                            s = n.evaluate();
                            if (!s.confident) {
                                deopt(s.deopt, t);
                                return;
                            }
                            s = s.value;
                        } else if (n.isIdentifier()) {
                            s = n.node.name;
                        } else {
                            s = n.node.value;
                        }
                        const i = e1.get("value");
                        let a = i.evaluate();
                        if (!a.confident) {
                            deopt(a.deopt, t);
                            return;
                        }
                        a = a.value;
                        r[s] = a;
                    }
                    return r;
                }
                if (e1.isLogicalExpression()) {
                    const r = t.confident;
                    const n = evaluateCached(e1.get("left"), t);
                    const s = t.confident;
                    t.confident = r;
                    const i = evaluateCached(e1.get("right"), t);
                    const a = t.confident;
                    switch(e1.node.operator){
                        case "||":
                            t.confident = s && (!!n || a);
                            if (!t.confident) return;
                            return n || i;
                        case "&&":
                            t.confident = s && (!n || a);
                            if (!t.confident) return;
                            return n && i;
                        case "??":
                            t.confident = s && (n != null || a);
                            if (!t.confident) return;
                            return n != null ? n : i;
                    }
                }
                if (e1.isBinaryExpression()) {
                    const r = evaluateCached(e1.get("left"), t);
                    if (!t.confident) return;
                    const n = evaluateCached(e1.get("right"), t);
                    if (!t.confident) return;
                    switch(e1.node.operator){
                        case "-":
                            return r - n;
                        case "+":
                            return r + n;
                        case "/":
                            return r / n;
                        case "*":
                            return r * n;
                        case "%":
                            return r % n;
                        case "**":
                            return Math.pow(r, n);
                        case "<":
                            return r < n;
                        case ">":
                            return r > n;
                        case "<=":
                            return r <= n;
                        case ">=":
                            return r >= n;
                        case "==":
                            return r == n;
                        case "!=":
                            return r != n;
                        case "===":
                            return r === n;
                        case "!==":
                            return r !== n;
                        case "|":
                            return r | n;
                        case "&":
                            return r & n;
                        case "^":
                            return r ^ n;
                        case "<<":
                            return r << n;
                        case ">>":
                            return r >> n;
                        case ">>>":
                            return r >>> n;
                    }
                }
                if (e1.isCallExpression()) {
                    const r = e1.get("callee");
                    let n;
                    let s;
                    if (r.isIdentifier() && !e1.scope.getBinding(r.node.name) && (isValidObjectCallee(r.node.name) || isValidIdentifierCallee(r.node.name))) {
                        s = /*TURBOPACK member replacement*/ __turbopack_context__.g[r.node.name];
                    }
                    if (r.isMemberExpression()) {
                        const e1 = r.get("object");
                        const t = r.get("property");
                        if (e1.isIdentifier() && t.isIdentifier() && isValidObjectCallee(e1.node.name) && !isInvalidMethod(t.node.name)) {
                            n = /*TURBOPACK member replacement*/ __turbopack_context__.g[e1.node.name];
                            const r = t.node.name;
                            if (hasOwnProperty.call(n, r)) {
                                s = n[r];
                            }
                        }
                        if (e1.isLiteral() && t.isIdentifier()) {
                            const r = typeof e1.node.value;
                            if (r === "string" || r === "number") {
                                n = e1.node.value;
                                s = n[t.node.name];
                            }
                        }
                    }
                    if (s) {
                        const r = e1.get("arguments").map((e1)=>evaluateCached(e1, t));
                        if (!t.confident) return;
                        return s.apply(n, r);
                    }
                }
                deopt(e1, t);
            }
            function evaluateQuasis(e1, t, r) {
                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                let s = "";
                let i = 0;
                const a = e1.isTemplateLiteral() ? e1.get("expressions") : e1.get("quasi.expressions");
                for (const e1 of t){
                    if (!r.confident) break;
                    s += n ? e1.value.raw : e1.value.cooked;
                    const t = a[i++];
                    if (t) s += String(evaluateCached(t, r));
                }
                if (!r.confident) return;
                return s;
            }
            function evaluate() {
                const e1 = {
                    confident: true,
                    deoptPath: null,
                    seen: new Map
                };
                let t = evaluateCached(this, e1);
                if (!e1.confident) t = undefined;
                return {
                    confident: e1.confident,
                    deopt: e1.deoptPath,
                    value: t
                };
            }
        },
        4126: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._getKey = _getKey;
            t._getPattern = _getPattern;
            t.get = get;
            t.getAllNextSiblings = getAllNextSiblings;
            t.getAllPrevSiblings = getAllPrevSiblings;
            t.getAssignmentIdentifiers = getAssignmentIdentifiers;
            t.getBindingIdentifierPaths = getBindingIdentifierPaths;
            t.getBindingIdentifiers = getBindingIdentifiers;
            t.getCompletionRecords = getCompletionRecords;
            t.getNextSibling = getNextSibling;
            t.getOpposite = getOpposite;
            t.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
            t.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
            t.getPrevSibling = getPrevSibling;
            t.getSibling = getSibling;
            var n = r(9111);
            var s = r(3061);
            const { getAssignmentIdentifiers: i, getBindingIdentifiers: a, getOuterBindingIdentifiers: o, numericLiteral: l, unaryExpression: c } = s;
            const p = 0;
            const u = 1;
            function NormalCompletion(e1) {
                return {
                    type: p,
                    path: e1
                };
            }
            function BreakCompletion(e1) {
                return {
                    type: u,
                    path: e1
                };
            }
            function getOpposite() {
                if (this.key === "left") {
                    return this.getSibling("right");
                } else if (this.key === "right") {
                    return this.getSibling("left");
                }
                return null;
            }
            function addCompletionRecords(e1, t, r) {
                if (e1) {
                    t.push(..._getCompletionRecords(e1, r));
                }
                return t;
            }
            function completionRecordForSwitch(e1, t, r) {
                let n = [];
                for(let s = 0; s < e1.length; s++){
                    const i = e1[s];
                    const a = _getCompletionRecords(i, r);
                    const o = [];
                    const l = [];
                    for (const e1 of a){
                        if (e1.type === p) {
                            o.push(e1);
                        }
                        if (e1.type === u) {
                            l.push(e1);
                        }
                    }
                    if (o.length) {
                        n = o;
                    }
                    t.push(...l);
                }
                t.push(...n);
                return t;
            }
            function normalCompletionToBreak(e1) {
                e1.forEach((e1)=>{
                    e1.type = u;
                });
            }
            function replaceBreakStatementInBreakCompletion(e1, t) {
                e1.forEach((e1)=>{
                    if (e1.path.isBreakStatement({
                        label: null
                    })) {
                        if (t) {
                            e1.path.replaceWith(c("void", l(0)));
                        } else {
                            e1.path.remove();
                        }
                    }
                });
            }
            function getStatementListCompletion(e1, t) {
                const r = [];
                if (t.canHaveBreak) {
                    let n = [];
                    for(let s = 0; s < e1.length; s++){
                        const i = e1[s];
                        const a = Object.assign({}, t, {
                            inCaseClause: false
                        });
                        if (i.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak)) {
                            a.shouldPopulateBreak = true;
                        } else {
                            a.shouldPopulateBreak = false;
                        }
                        const o = _getCompletionRecords(i, a);
                        if (o.length > 0 && o.every((e1)=>e1.type === u)) {
                            if (n.length > 0 && o.every((e1)=>e1.path.isBreakStatement({
                                    label: null
                                }))) {
                                normalCompletionToBreak(n);
                                r.push(...n);
                                if (n.some((e1)=>e1.path.isDeclaration())) {
                                    r.push(...o);
                                    replaceBreakStatementInBreakCompletion(o, true);
                                }
                                replaceBreakStatementInBreakCompletion(o, false);
                            } else {
                                r.push(...o);
                                if (!t.shouldPopulateBreak) {
                                    replaceBreakStatementInBreakCompletion(o, true);
                                }
                            }
                            break;
                        }
                        if (s === e1.length - 1) {
                            r.push(...o);
                        } else {
                            n = [];
                            for(let e1 = 0; e1 < o.length; e1++){
                                const t = o[e1];
                                if (t.type === u) {
                                    r.push(t);
                                }
                                if (t.type === p) {
                                    n.push(t);
                                }
                            }
                        }
                    }
                } else if (e1.length) {
                    for(let n = e1.length - 1; n >= 0; n--){
                        const s = _getCompletionRecords(e1[n], t);
                        if (s.length > 1 || s.length === 1 && !s[0].path.isVariableDeclaration()) {
                            r.push(...s);
                            break;
                        }
                    }
                }
                return r;
            }
            function _getCompletionRecords(e1, t) {
                let r = [];
                if (e1.isIfStatement()) {
                    r = addCompletionRecords(e1.get("consequent"), r, t);
                    r = addCompletionRecords(e1.get("alternate"), r, t);
                } else if (e1.isDoExpression() || e1.isFor() || e1.isWhile() || e1.isLabeledStatement()) {
                    return addCompletionRecords(e1.get("body"), r, t);
                } else if (e1.isProgram() || e1.isBlockStatement()) {
                    return getStatementListCompletion(e1.get("body"), t);
                } else if (e1.isFunction()) {
                    return _getCompletionRecords(e1.get("body"), t);
                } else if (e1.isTryStatement()) {
                    r = addCompletionRecords(e1.get("block"), r, t);
                    r = addCompletionRecords(e1.get("handler"), r, t);
                } else if (e1.isCatchClause()) {
                    return addCompletionRecords(e1.get("body"), r, t);
                } else if (e1.isSwitchStatement()) {
                    return completionRecordForSwitch(e1.get("cases"), r, t);
                } else if (e1.isSwitchCase()) {
                    return getStatementListCompletion(e1.get("consequent"), {
                        canHaveBreak: true,
                        shouldPopulateBreak: false,
                        inCaseClause: true
                    });
                } else if (e1.isBreakStatement()) {
                    r.push(BreakCompletion(e1));
                } else {
                    r.push(NormalCompletion(e1));
                }
                return r;
            }
            function getCompletionRecords() {
                const e1 = _getCompletionRecords(this, {
                    canHaveBreak: false,
                    shouldPopulateBreak: false,
                    inCaseClause: false
                });
                return e1.map((e1)=>e1.path);
            }
            function getSibling(e1) {
                return n.default.get({
                    parentPath: this.parentPath,
                    parent: this.parent,
                    container: this.container,
                    listKey: this.listKey,
                    key: e1
                }).setContext(this.context);
            }
            function getPrevSibling() {
                return this.getSibling(this.key - 1);
            }
            function getNextSibling() {
                return this.getSibling(this.key + 1);
            }
            function getAllNextSiblings() {
                let e1 = this.key;
                let t = this.getSibling(++e1);
                const r = [];
                while(t.node){
                    r.push(t);
                    t = this.getSibling(++e1);
                }
                return r;
            }
            function getAllPrevSiblings() {
                let e1 = this.key;
                let t = this.getSibling(--e1);
                const r = [];
                while(t.node){
                    r.push(t);
                    t = this.getSibling(--e1);
                }
                return r;
            }
            function get(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                if (t === true) t = this.context;
                const r = e1.split(".");
                if (r.length === 1) {
                    return _getKey.call(this, e1, t);
                } else {
                    return _getPattern.call(this, r, t);
                }
            }
            function _getKey(e1, t) {
                const r = this.node;
                const s = r[e1];
                if (Array.isArray(s)) {
                    return s.map((i, a)=>n.default.get({
                            listKey: e1,
                            parentPath: this,
                            parent: r,
                            container: s,
                            key: a
                        }).setContext(t));
                } else {
                    return n.default.get({
                        parentPath: this,
                        parent: r,
                        container: r,
                        key: e1
                    }).setContext(t);
                }
            }
            function _getPattern(e1, t) {
                let r = this;
                for (const n of e1){
                    if (n === ".") {
                        r = r.parentPath;
                    } else {
                        if (Array.isArray(r)) {
                            r = r[n];
                        } else {
                            r = r.get(n, t);
                        }
                    }
                }
                return r;
            }
            function getAssignmentIdentifiers() {
                return i(this.node);
            }
            function getBindingIdentifiers(e1) {
                return a(this.node, e1);
            }
            function getOuterBindingIdentifiers(e1) {
                return o(this.node, e1);
            }
            function getBindingIdentifierPaths() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                const r = this;
                const n = [
                    r
                ];
                const s = Object.create(null);
                while(n.length){
                    const r = n.shift();
                    if (!r) continue;
                    if (!r.node) continue;
                    const i = a.keys[r.node.type];
                    if (r.isIdentifier()) {
                        if (e1) {
                            const e1 = s[r.node.name] = s[r.node.name] || [];
                            e1.push(r);
                        } else {
                            s[r.node.name] = r;
                        }
                        continue;
                    }
                    if (r.isExportDeclaration()) {
                        const e1 = r.get("declaration");
                        if (e1.isDeclaration()) {
                            n.push(e1);
                        }
                        continue;
                    }
                    if (t) {
                        if (r.isFunctionDeclaration()) {
                            n.push(r.get("id"));
                            continue;
                        }
                        if (r.isFunctionExpression()) {
                            continue;
                        }
                    }
                    if (i) {
                        for(let e1 = 0; e1 < i.length; e1++){
                            const t = i[e1];
                            const s = r.get(t);
                            if (Array.isArray(s)) {
                                n.push(...s);
                            } else if (s.node) {
                                n.push(s);
                            }
                        }
                    }
                }
                return s;
            }
            function getOuterBindingIdentifierPaths() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                return this.getBindingIdentifierPaths(e1, true);
            }
        },
        9111: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = t.SHOULD_STOP = t.SHOULD_SKIP = t.REMOVED = void 0;
            var n = r(2490);
            var s = r(6937);
            var i = r(8026);
            var a = r(9877);
            var o = r(3061);
            var l = o;
            var c = r(8099);
            var p = r(1605);
            var u = r(8073);
            var d = r(1086);
            var f = r(3419);
            var h = r(9119);
            var m = r(2919);
            var y = r(7171);
            var g = r(4144);
            var b = g;
            var T = r(6035);
            var S = r(7116);
            var x = r(4126);
            var E = r(3162);
            var P = r(3053);
            const { validate: v } = o;
            const A = s("babel");
            const w = t.REMOVED = 1 << 0;
            const I = t.SHOULD_STOP = 1 << 1;
            const C = t.SHOULD_SKIP = 1 << 2;
            const O = t["default"] = class NodePath {
                get removed() {
                    return (this._traverseFlags & 1) > 0;
                }
                set removed(e1) {
                    if (e1) this._traverseFlags |= 1;
                    else this._traverseFlags &= -2;
                }
                get shouldStop() {
                    return (this._traverseFlags & 2) > 0;
                }
                set shouldStop(e1) {
                    if (e1) this._traverseFlags |= 2;
                    else this._traverseFlags &= -3;
                }
                get shouldSkip() {
                    return (this._traverseFlags & 4) > 0;
                }
                set shouldSkip(e1) {
                    if (e1) this._traverseFlags |= 4;
                    else this._traverseFlags &= -5;
                }
                static get(param) {
                    let { hub: e1, parentPath: t, parent: r, container: n, listKey: s, key: i } = param;
                    if (!e1 && t) {
                        e1 = t.hub;
                    }
                    if (!r) {
                        throw new Error("To get a node path the parent needs to exist");
                    }
                    const a = n[i];
                    const o = c.getOrCreateCachedPaths(e1, r);
                    let l = o.get(a);
                    if (!l) {
                        l = new NodePath(e1, r);
                        if (a) o.set(a, l);
                    }
                    g.setup.call(l, t, n, s, i);
                    return l;
                }
                getScope(e1) {
                    return this.isScope() ? new a.default(this) : e1;
                }
                setData(e1, t) {
                    if (this.data == null) {
                        this.data = Object.create(null);
                    }
                    return this.data[e1] = t;
                }
                getData(e1, t) {
                    if (this.data == null) {
                        this.data = Object.create(null);
                    }
                    let r = this.data[e1];
                    if (r === undefined && t !== undefined) r = this.data[e1] = t;
                    return r;
                }
                hasNode() {
                    return this.node != null;
                }
                buildCodeFrameError(e1) {
                    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SyntaxError;
                    return this.hub.buildError(this.node, e1, t);
                }
                traverse(e1, t) {
                    (0, i.default)(this.node, e1, this.scope, t, this);
                }
                set(e1, t) {
                    v(this.node, e1, t);
                    this.node[e1] = t;
                }
                getPathLocation() {
                    const e1 = [];
                    let t = this;
                    do {
                        let r = t.key;
                        if (t.inList) r = "".concat(t.listKey, "[").concat(r, "]");
                        e1.unshift(r);
                    }while (t = t.parentPath)
                    return e1.join(".");
                }
                debug(e1) {
                    if (!A.enabled) return;
                    A("".concat(this.getPathLocation(), " ").concat(this.type, ": ").concat(e1));
                }
                toString() {
                    return (0, p.default)(this.node).code;
                }
                get inList() {
                    return !!this.listKey;
                }
                set inList(e1) {
                    if (!e1) {
                        this.listKey = null;
                    }
                }
                get parentKey() {
                    return this.listKey || this.key;
                }
                constructor(e1, t){
                    this.contexts = [];
                    this.state = null;
                    this.opts = null;
                    this._traverseFlags = 0;
                    this.skipKeys = null;
                    this.parentPath = null;
                    this.container = null;
                    this.listKey = null;
                    this.key = null;
                    this.node = null;
                    this.type = null;
                    this.parent = t;
                    this.hub = e1;
                    this.data = null;
                    this.context = null;
                    this.scope = null;
                }
            };
            const N = {
                findParent: u.findParent,
                find: u.find,
                getFunctionParent: u.getFunctionParent,
                getStatementParent: u.getStatementParent,
                getEarliestCommonAncestorFrom: u.getEarliestCommonAncestorFrom,
                getDeepestCommonAncestorFrom: u.getDeepestCommonAncestorFrom,
                getAncestry: u.getAncestry,
                isAncestor: u.isAncestor,
                isDescendant: u.isDescendant,
                inType: u.inType,
                getTypeAnnotation: d.getTypeAnnotation,
                isBaseType: d.isBaseType,
                couldBeBaseType: d.couldBeBaseType,
                baseTypeStrictlyMatches: d.baseTypeStrictlyMatches,
                isGenericType: d.isGenericType,
                replaceWithMultiple: f.replaceWithMultiple,
                replaceWithSourceString: f.replaceWithSourceString,
                replaceWith: f.replaceWith,
                replaceExpressionWithStatements: f.replaceExpressionWithStatements,
                replaceInline: f.replaceInline,
                evaluateTruthy: h.evaluateTruthy,
                evaluate: h.evaluate,
                toComputedKey: m.toComputedKey,
                ensureBlock: m.ensureBlock,
                unwrapFunctionEnvironment: m.unwrapFunctionEnvironment,
                arrowFunctionToExpression: m.arrowFunctionToExpression,
                splitExportDeclaration: m.splitExportDeclaration,
                ensureFunctionName: m.ensureFunctionName,
                matchesPattern: y.matchesPattern,
                isStatic: y.isStatic,
                isNodeType: y.isNodeType,
                canHaveVariableDeclarationOrExpression: y.canHaveVariableDeclarationOrExpression,
                canSwapBetweenExpressionAndStatement: y.canSwapBetweenExpressionAndStatement,
                isCompletionRecord: y.isCompletionRecord,
                isStatementOrBlock: y.isStatementOrBlock,
                referencesImport: y.referencesImport,
                getSource: y.getSource,
                willIMaybeExecuteBefore: y.willIMaybeExecuteBefore,
                _guessExecutionStatusRelativeTo: y._guessExecutionStatusRelativeTo,
                resolve: y.resolve,
                isConstantExpression: y.isConstantExpression,
                isInStrictMode: y.isInStrictMode,
                isDenylisted: b.isDenylisted,
                visit: b.visit,
                skip: b.skip,
                skipKey: b.skipKey,
                stop: b.stop,
                setContext: b.setContext,
                requeue: b.requeue,
                requeueComputedKeyAndDecorators: b.requeueComputedKeyAndDecorators,
                remove: T.remove,
                insertBefore: S.insertBefore,
                insertAfter: S.insertAfter,
                unshiftContainer: S.unshiftContainer,
                pushContainer: S.pushContainer,
                getOpposite: x.getOpposite,
                getCompletionRecords: x.getCompletionRecords,
                getSibling: x.getSibling,
                getPrevSibling: x.getPrevSibling,
                getNextSibling: x.getNextSibling,
                getAllNextSiblings: x.getAllNextSiblings,
                getAllPrevSiblings: x.getAllPrevSiblings,
                get: x.get,
                getAssignmentIdentifiers: x.getAssignmentIdentifiers,
                getBindingIdentifiers: x.getBindingIdentifiers,
                getOuterBindingIdentifiers: x.getOuterBindingIdentifiers,
                getBindingIdentifierPaths: x.getBindingIdentifierPaths,
                getOuterBindingIdentifierPaths: x.getOuterBindingIdentifierPaths,
                shareCommentsWithSiblings: E.shareCommentsWithSiblings,
                addComment: E.addComment,
                addComments: E.addComments
            };
            Object.assign(O.prototype, N);
            {
                O.prototype.arrowFunctionToShadowed = m[String("arrowFunctionToShadowed")];
                Object.assign(O.prototype, {
                    has: y[String("has")],
                    is: y[String("is")],
                    isnt: y[String("isnt")],
                    equals: y[String("equals")],
                    hoist: S[String("hoist")],
                    updateSiblingKeys: S.updateSiblingKeys,
                    call: b.call,
                    isBlacklisted: b[String("isBlacklisted")],
                    setScope: b.setScope,
                    resync: b.resync,
                    popContext: b.popContext,
                    pushContext: b.pushContext,
                    setup: b.setup,
                    setKey: b.setKey
                });
            }
            {
                O.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo;
                O.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo;
                Object.assign(O.prototype, {
                    _getTypeAnnotation: d._getTypeAnnotation,
                    _replaceWith: f._replaceWith,
                    _resolve: y._resolve,
                    _call: b._call,
                    _resyncParent: b._resyncParent,
                    _resyncKey: b._resyncKey,
                    _resyncList: b._resyncList,
                    _resyncRemoved: b._resyncRemoved,
                    _getQueueContexts: b._getQueueContexts,
                    _removeFromScope: T._removeFromScope,
                    _callRemovalHooks: T._callRemovalHooks,
                    _remove: T._remove,
                    _markRemoved: T._markRemoved,
                    _assertUnremoved: T._assertUnremoved,
                    _containerInsert: S._containerInsert,
                    _containerInsertBefore: S._containerInsertBefore,
                    _containerInsertAfter: S._containerInsertAfter,
                    _verifyNodeList: S._verifyNodeList,
                    _getKey: x._getKey,
                    _getPattern: x._getPattern
                });
            }
            for (const e1 of l.TYPES){
                const t = "is".concat(e1);
                const r = l[t];
                O.prototype[t] = function(e1) {
                    return r(this.node, e1);
                };
                O.prototype["assert".concat(e1)] = function(t) {
                    if (!r(this.node, t)) {
                        throw new TypeError("Expected node path of type ".concat(e1));
                    }
                };
            }
            Object.assign(O.prototype, P);
            for (const e1 of Object.keys(n)){
                if (e1[0] === "_") continue;
                if (!l.TYPES.includes(e1)) l.TYPES.push(e1);
            }
        },
        1086: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._getTypeAnnotation = _getTypeAnnotation;
            t.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
            t.couldBeBaseType = couldBeBaseType;
            t.getTypeAnnotation = getTypeAnnotation;
            t.isBaseType = isBaseType;
            t.isGenericType = isGenericType;
            var n = r(6157);
            var s = r(3061);
            const { anyTypeAnnotation: i, isAnyTypeAnnotation: a, isArrayTypeAnnotation: o, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: c, isFlowBaseAnnotation: p, isGenericTypeAnnotation: u, isIdentifier: d, isMixedTypeAnnotation: f, isNumberTypeAnnotation: h, isStringTypeAnnotation: m, isTSArrayType: y, isTSTypeAnnotation: g, isTSTypeReference: b, isTupleTypeAnnotation: T, isTypeAnnotation: S, isUnionTypeAnnotation: x, isVoidTypeAnnotation: E, stringTypeAnnotation: P, voidTypeAnnotation: v } = s;
            function getTypeAnnotation() {
                let e1 = this.getData("typeAnnotation");
                if (e1 != null) {
                    return e1;
                }
                e1 = _getTypeAnnotation.call(this) || i();
                if (S(e1) || g(e1)) {
                    e1 = e1.typeAnnotation;
                }
                this.setData("typeAnnotation", e1);
                return e1;
            }
            const A = new WeakSet;
            function _getTypeAnnotation() {
                const e1 = this.node;
                if (!e1) {
                    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
                        const e1 = this.parentPath.parentPath;
                        const t = e1.parentPath;
                        if (e1.key === "left" && t.isForInStatement()) {
                            return P();
                        }
                        if (e1.key === "left" && t.isForOfStatement()) {
                            return i();
                        }
                        return v();
                    } else {
                        return;
                    }
                }
                if (e1.typeAnnotation) {
                    return e1.typeAnnotation;
                }
                if (A.has(e1)) {
                    return;
                }
                A.add(e1);
                try {
                    var t;
                    let r = n[e1.type];
                    if (r) {
                        return r.call(this, e1);
                    }
                    r = n[this.parentPath.type];
                    if ((t = r) != null && t.validParent) {
                        return this.parentPath.getTypeAnnotation();
                    }
                } finally{
                    A.delete(e1);
                }
            }
            function isBaseType(e1, t) {
                return _isBaseType(e1, this.getTypeAnnotation(), t);
            }
            function _isBaseType(e1, t, r) {
                if (e1 === "string") {
                    return m(t);
                } else if (e1 === "number") {
                    return h(t);
                } else if (e1 === "boolean") {
                    return l(t);
                } else if (e1 === "any") {
                    return a(t);
                } else if (e1 === "mixed") {
                    return f(t);
                } else if (e1 === "empty") {
                    return c(t);
                } else if (e1 === "void") {
                    return E(t);
                } else {
                    if (r) {
                        return false;
                    } else {
                        throw new Error("Unknown base type ".concat(e1));
                    }
                }
            }
            function couldBeBaseType(e1) {
                const t = this.getTypeAnnotation();
                if (a(t)) return true;
                if (x(t)) {
                    for (const r of t.types){
                        if (a(r) || _isBaseType(e1, r, true)) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    return _isBaseType(e1, t, true);
                }
            }
            function baseTypeStrictlyMatches(e1) {
                const t = this.getTypeAnnotation();
                const r = e1.getTypeAnnotation();
                if (!a(t) && p(t)) {
                    return r.type === t.type;
                }
                return false;
            }
            function isGenericType(e1) {
                const t = this.getTypeAnnotation();
                if (e1 === "Array") {
                    if (y(t) || o(t) || T(t)) {
                        return true;
                    }
                }
                return u(t) && d(t.id, {
                    name: e1
                }) || b(t) && d(t.typeName, {
                    name: e1
                });
            }
        },
        9919: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            var n = r(3061);
            var s = r(550);
            const { BOOLEAN_NUMBER_BINARY_OPERATORS: i, createTypeAnnotationBasedOnTypeof: a, numberTypeAnnotation: o, voidTypeAnnotation: l } = n;
            function _default(e1) {
                if (!this.isReferenced()) return;
                const t = this.scope.getBinding(e1.name);
                if (t) {
                    if (t.identifier.typeAnnotation) {
                        return t.identifier.typeAnnotation;
                    } else {
                        return getTypeAnnotationBindingConstantViolations(t, this, e1.name);
                    }
                }
                if (e1.name === "undefined") {
                    return l();
                } else if (e1.name === "NaN" || e1.name === "Infinity") {
                    return o();
                } else if (e1.name === "arguments") {}
            }
            function getTypeAnnotationBindingConstantViolations(e1, t, r) {
                const n = [];
                const i = [];
                let a = getConstantViolationsBefore(e1, t, i);
                const o = getConditionalAnnotation(e1, t, r);
                if (o) {
                    const t = getConstantViolationsBefore(e1, o.ifStatement);
                    a = a.filter((e1)=>!t.includes(e1));
                    n.push(o.typeAnnotation);
                }
                if (a.length) {
                    a.push(...i);
                    for (const e1 of a){
                        n.push(e1.getTypeAnnotation());
                    }
                }
                if (!n.length) {
                    return;
                }
                return (0, s.createUnionType)(n);
            }
            function getConstantViolationsBefore(e1, t, r) {
                const n = e1.constantViolations.slice();
                n.unshift(e1.path);
                return n.filter((e1)=>{
                    e1 = e1.resolve();
                    const n = e1._guessExecutionStatusRelativeTo(t);
                    if (r && n === "unknown") r.push(e1);
                    return n === "before";
                });
            }
            function inferAnnotationFromBinaryExpression(e1, t) {
                const r = t.node.operator;
                const n = t.get("right").resolve();
                const s = t.get("left").resolve();
                let l;
                if (s.isIdentifier({
                    name: e1
                })) {
                    l = n;
                } else if (n.isIdentifier({
                    name: e1
                })) {
                    l = s;
                }
                if (l) {
                    if (r === "===") {
                        return l.getTypeAnnotation();
                    }
                    if (i.includes(r)) {
                        return o();
                    }
                    return;
                }
                if (r !== "===" && r !== "==") return;
                let c;
                let p;
                if (s.isUnaryExpression({
                    operator: "typeof"
                })) {
                    c = s;
                    p = n;
                } else if (n.isUnaryExpression({
                    operator: "typeof"
                })) {
                    c = n;
                    p = s;
                }
                if (!c) return;
                if (!c.get("argument").isIdentifier({
                    name: e1
                })) return;
                p = p.resolve();
                if (!p.isLiteral()) return;
                const u = p.node.value;
                if (typeof u !== "string") return;
                return a(u);
            }
            function getParentConditionalPath(e1, t, r) {
                let n;
                while(n = t.parentPath){
                    if (n.isIfStatement() || n.isConditionalExpression()) {
                        if (t.key === "test") {
                            return;
                        }
                        return n;
                    }
                    if (n.isFunction()) {
                        if (n.parentPath.scope.getBinding(r) !== e1) return;
                    }
                    t = n;
                }
            }
            function getConditionalAnnotation(e1, t, r) {
                const n = getParentConditionalPath(e1, t, r);
                if (!n) return;
                const i = n.get("test");
                const a = [
                    i
                ];
                const o = [];
                for(let e1 = 0; e1 < a.length; e1++){
                    const t = a[e1];
                    if (t.isLogicalExpression()) {
                        if (t.node.operator === "&&") {
                            a.push(t.get("left"));
                            a.push(t.get("right"));
                        }
                    } else if (t.isBinaryExpression()) {
                        const e1 = inferAnnotationFromBinaryExpression(r, t);
                        if (e1) o.push(e1);
                    }
                }
                if (o.length) {
                    return {
                        typeAnnotation: (0, s.createUnionType)(o),
                        ifStatement: n
                    };
                }
                return getConditionalAnnotation(e1, n, r);
            }
        },
        6157: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArrayExpression = ArrayExpression;
            t.AssignmentExpression = AssignmentExpression;
            t.BinaryExpression = BinaryExpression;
            t.BooleanLiteral = BooleanLiteral;
            t.CallExpression = CallExpression;
            t.ConditionalExpression = ConditionalExpression;
            t.ClassDeclaration = t.ClassExpression = t.FunctionDeclaration = t.ArrowFunctionExpression = t.FunctionExpression = Func;
            Object.defineProperty(t, "Identifier", {
                enumerable: true,
                get: function() {
                    return s.default;
                }
            });
            t.LogicalExpression = LogicalExpression;
            t.NewExpression = NewExpression;
            t.NullLiteral = NullLiteral;
            t.NumericLiteral = NumericLiteral;
            t.ObjectExpression = ObjectExpression;
            t.ParenthesizedExpression = ParenthesizedExpression;
            t.RegExpLiteral = RegExpLiteral;
            t.RestElement = RestElement;
            t.SequenceExpression = SequenceExpression;
            t.StringLiteral = StringLiteral;
            t.TSAsExpression = TSAsExpression;
            t.TSNonNullExpression = TSNonNullExpression;
            t.TaggedTemplateExpression = TaggedTemplateExpression;
            t.TemplateLiteral = TemplateLiteral;
            t.TypeCastExpression = TypeCastExpression;
            t.UnaryExpression = UnaryExpression;
            t.UpdateExpression = UpdateExpression;
            t.VariableDeclarator = VariableDeclarator;
            var n = r(3061);
            var s = r(9919);
            var i = r(550);
            const { BOOLEAN_BINARY_OPERATORS: a, BOOLEAN_UNARY_OPERATORS: o, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: c, STRING_UNARY_OPERATORS: p, anyTypeAnnotation: u, arrayTypeAnnotation: d, booleanTypeAnnotation: f, buildMatchMemberExpression: h, genericTypeAnnotation: m, identifier: y, nullLiteralTypeAnnotation: g, numberTypeAnnotation: b, stringTypeAnnotation: T, tupleTypeAnnotation: S, unionTypeAnnotation: x, voidTypeAnnotation: E, isIdentifier: P } = n;
            function VariableDeclarator() {
                if (!this.get("id").isIdentifier()) return;
                return this.get("init").getTypeAnnotation();
            }
            function TypeCastExpression(e1) {
                return e1.typeAnnotation;
            }
            TypeCastExpression.validParent = true;
            function TSAsExpression(e1) {
                return e1.typeAnnotation;
            }
            TSAsExpression.validParent = true;
            function TSNonNullExpression() {
                return this.get("expression").getTypeAnnotation();
            }
            function NewExpression(e1) {
                if (e1.callee.type === "Identifier") {
                    return m(e1.callee);
                }
            }
            function TemplateLiteral() {
                return T();
            }
            function UnaryExpression(e1) {
                const t = e1.operator;
                if (t === "void") {
                    return E();
                } else if (c.includes(t)) {
                    return b();
                } else if (p.includes(t)) {
                    return T();
                } else if (o.includes(t)) {
                    return f();
                }
            }
            function BinaryExpression(e1) {
                const t = e1.operator;
                if (l.includes(t)) {
                    return b();
                } else if (a.includes(t)) {
                    return f();
                } else if (t === "+") {
                    const e1 = this.get("right");
                    const t = this.get("left");
                    if (t.isBaseType("number") && e1.isBaseType("number")) {
                        return b();
                    } else if (t.isBaseType("string") || e1.isBaseType("string")) {
                        return T();
                    }
                    return x([
                        T(),
                        b()
                    ]);
                }
            }
            function LogicalExpression() {
                const e1 = [
                    this.get("left").getTypeAnnotation(),
                    this.get("right").getTypeAnnotation()
                ];
                return (0, i.createUnionType)(e1);
            }
            function ConditionalExpression() {
                const e1 = [
                    this.get("consequent").getTypeAnnotation(),
                    this.get("alternate").getTypeAnnotation()
                ];
                return (0, i.createUnionType)(e1);
            }
            function SequenceExpression() {
                return this.get("expressions").pop().getTypeAnnotation();
            }
            function ParenthesizedExpression() {
                return this.get("expression").getTypeAnnotation();
            }
            function AssignmentExpression() {
                return this.get("right").getTypeAnnotation();
            }
            function UpdateExpression(e1) {
                const t = e1.operator;
                if (t === "++" || t === "--") {
                    return b();
                }
            }
            function StringLiteral() {
                return T();
            }
            function NumericLiteral() {
                return b();
            }
            function BooleanLiteral() {
                return f();
            }
            function NullLiteral() {
                return g();
            }
            function RegExpLiteral() {
                return m(y("RegExp"));
            }
            function ObjectExpression() {
                return m(y("Object"));
            }
            function ArrayExpression() {
                return m(y("Array"));
            }
            function RestElement() {
                return ArrayExpression();
            }
            RestElement.validParent = true;
            function Func() {
                return m(y("Function"));
            }
            const v = h("Array.from");
            const A = h("Object.keys");
            const w = h("Object.values");
            const I = h("Object.entries");
            function CallExpression() {
                const { callee: e1 } = this.node;
                if (A(e1)) {
                    return d(T());
                } else if (v(e1) || w(e1) || P(e1, {
                    name: "Array"
                })) {
                    return d(u());
                } else if (I(e1)) {
                    return d(S([
                        T(),
                        u()
                    ]));
                }
                return resolveCall(this.get("callee"));
            }
            function TaggedTemplateExpression() {
                return resolveCall(this.get("tag"));
            }
            function resolveCall(e1) {
                e1 = e1.resolve();
                if (e1.isFunction()) {
                    const { node: t } = e1;
                    if (t.async) {
                        if (t.generator) {
                            return m(y("AsyncIterator"));
                        } else {
                            return m(y("Promise"));
                        }
                    } else {
                        if (t.generator) {
                            return m(y("Iterator"));
                        } else if (e1.node.returnType) {
                            return e1.node.returnType;
                        } else {}
                    }
                }
            }
        },
        550: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createUnionType = createUnionType;
            var n = r(3061);
            const { createFlowUnionType: s, createTSUnionType: i, createUnionTypeAnnotation: a, isFlowType: o, isTSType: l } = n;
            function createUnionType(e1) {
                {
                    if (e1.every((e1)=>o(e1))) {
                        if (s) {
                            return s(e1);
                        }
                        return a(e1);
                    } else if (e1.every((e1)=>l(e1))) {
                        if (i) {
                            return i(e1);
                        }
                    }
                }
            }
        },
        7171: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
            t._resolve = _resolve;
            t.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
            t.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
            t.getSource = getSource;
            t.isCompletionRecord = isCompletionRecord;
            t.isConstantExpression = isConstantExpression;
            t.isInStrictMode = isInStrictMode;
            t.isNodeType = isNodeType;
            t.isStatementOrBlock = isStatementOrBlock;
            t.isStatic = isStatic;
            t.matchesPattern = matchesPattern;
            t.referencesImport = referencesImport;
            t.resolve = resolve;
            t.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
            var n = r(3061);
            const { STATEMENT_OR_BLOCK_KEYS: s, VISITOR_KEYS: i, isBlockStatement: a, isExpression: o, isIdentifier: l, isLiteral: c, isStringLiteral: p, isType: u, matchesPattern: d } = n;
            function matchesPattern(e1, t) {
                return d(this.node, e1, t);
            }
            {
                t.has = function has(e1) {
                    var t;
                    const r = (t = this.node) == null ? void 0 : t[e1];
                    if (r && Array.isArray(r)) {
                        return !!r.length;
                    } else {
                        return !!r;
                    }
                };
            }
            function isStatic() {
                return this.scope.isStatic(this.node);
            }
            {
                t.is = t.has;
                t.isnt = function isnt(e1) {
                    return !this.has(e1);
                };
                t.equals = function equals(e1, t) {
                    return this.node[e1] === t;
                };
            }
            function isNodeType(e1) {
                return u(this.type, e1);
            }
            function canHaveVariableDeclarationOrExpression() {
                return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
            }
            function canSwapBetweenExpressionAndStatement(e1) {
                if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
                    return false;
                }
                if (this.isExpression()) {
                    return a(e1);
                } else if (this.isBlockStatement()) {
                    return o(e1);
                }
                return false;
            }
            function isCompletionRecord(e1) {
                let t = this;
                let r = true;
                do {
                    const { type: n, container: s } = t;
                    if (!r && (t.isFunction() || n === "StaticBlock")) {
                        return !!e1;
                    }
                    r = false;
                    if (Array.isArray(s) && t.key !== s.length - 1) {
                        return false;
                    }
                }while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression())
                return true;
            }
            function isStatementOrBlock() {
                if (this.parentPath.isLabeledStatement() || a(this.container)) {
                    return false;
                } else {
                    return s.includes(this.key);
                }
            }
            function referencesImport(e1, t) {
                if (!this.isReferencedIdentifier()) {
                    if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? p(this.node.property, {
                        value: t
                    }) : this.node.property.name === t)) {
                        const t = this.get("object");
                        return t.isReferencedIdentifier() && t.referencesImport(e1, "*");
                    }
                    return false;
                }
                const r = this.scope.getBinding(this.node.name);
                if (!r || r.kind !== "module") return false;
                const n = r.path;
                const s = n.parentPath;
                if (!s.isImportDeclaration()) return false;
                if (s.node.source.value === e1) {
                    if (!t) return true;
                } else {
                    return false;
                }
                if (n.isImportDefaultSpecifier() && t === "default") {
                    return true;
                }
                if (n.isImportNamespaceSpecifier() && t === "*") {
                    return true;
                }
                if (n.isImportSpecifier() && l(n.node.imported, {
                    name: t
                })) {
                    return true;
                }
                return false;
            }
            function getSource() {
                const e1 = this.node;
                if (e1.end) {
                    const t = this.hub.getCode();
                    if (t) return t.slice(e1.start, e1.end);
                }
                return "";
            }
            function willIMaybeExecuteBefore(e1) {
                return this._guessExecutionStatusRelativeTo(e1) !== "after";
            }
            function getOuterFunction(e1) {
                return e1.isProgram() ? e1 : (e1.parentPath.scope.getFunctionParent() || e1.parentPath.scope.getProgramParent()).path;
            }
            function isExecutionUncertain(e1, t) {
                switch(e1){
                    case "LogicalExpression":
                        return t === "right";
                    case "ConditionalExpression":
                    case "IfStatement":
                        return t === "consequent" || t === "alternate";
                    case "WhileStatement":
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForOfStatement":
                        return t === "body";
                    case "ForStatement":
                        return t === "body" || t === "update";
                    case "SwitchStatement":
                        return t === "cases";
                    case "TryStatement":
                        return t === "handler";
                    case "AssignmentPattern":
                        return t === "right";
                    case "OptionalMemberExpression":
                        return t === "property";
                    case "OptionalCallExpression":
                        return t === "arguments";
                    default:
                        return false;
                }
            }
            function isExecutionUncertainInList(e1, t) {
                for(let r = 0; r < t; r++){
                    const t = e1[r];
                    if (isExecutionUncertain(t.parent.type, t.parentKey)) {
                        return true;
                    }
                }
                return false;
            }
            const f = Symbol();
            function _guessExecutionStatusRelativeTo(e1) {
                return _guessExecutionStatusRelativeToCached(this, e1, new Map);
            }
            function _guessExecutionStatusRelativeToCached(e1, t, r) {
                const n = {
                    this: getOuterFunction(e1),
                    target: getOuterFunction(t)
                };
                if (n.target.node !== n.this.node) {
                    return _guessExecutionStatusRelativeToDifferentFunctionsCached(e1, n.target, r);
                }
                const s = {
                    target: t.getAncestry(),
                    this: e1.getAncestry()
                };
                if (s.target.includes(e1)) return "after";
                if (s.this.includes(t)) return "before";
                let a;
                const o = {
                    target: 0,
                    this: 0
                };
                while(!a && o.this < s.this.length){
                    const e1 = s.this[o.this];
                    o.target = s.target.indexOf(e1);
                    if (o.target >= 0) {
                        a = e1;
                    } else {
                        o.this++;
                    }
                }
                if (!a) {
                    throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
                }
                if (isExecutionUncertainInList(s.this, o.this - 1) || isExecutionUncertainInList(s.target, o.target - 1)) {
                    return "unknown";
                }
                const l = {
                    this: s.this[o.this - 1],
                    target: s.target[o.target - 1]
                };
                if (l.target.listKey && l.this.listKey && l.target.container === l.this.container) {
                    return l.target.key > l.this.key ? "before" : "after";
                }
                const c = i[a.type];
                const p = {
                    this: c.indexOf(l.this.parentKey),
                    target: c.indexOf(l.target.parentKey)
                };
                return p.target > p.this ? "before" : "after";
            }
            function _guessExecutionStatusRelativeToDifferentFunctionsInternal(e1, t, r) {
                if (!t.isFunctionDeclaration()) {
                    if (_guessExecutionStatusRelativeToCached(e1, t, r) === "before") {
                        return "before";
                    }
                    return "unknown";
                } else if (t.parentPath.isExportDeclaration()) {
                    return "unknown";
                }
                const n = t.scope.getBinding(t.node.id.name);
                if (!n.references) return "before";
                const s = n.referencePaths;
                let i;
                for (const n of s){
                    const s = !!n.find((e1)=>e1.node === t.node);
                    if (s) continue;
                    if (n.key !== "callee" || !n.parentPath.isCallExpression()) {
                        return "unknown";
                    }
                    const a = _guessExecutionStatusRelativeToCached(e1, n, r);
                    if (i && i !== a) {
                        return "unknown";
                    } else {
                        i = a;
                    }
                }
                return i;
            }
            function _guessExecutionStatusRelativeToDifferentFunctionsCached(e1, t, r) {
                let n = r.get(e1.node);
                let s;
                if (!n) {
                    r.set(e1.node, n = new Map);
                } else if (s = n.get(t.node)) {
                    if (s === f) {
                        return "unknown";
                    }
                    return s;
                }
                n.set(t.node, f);
                const i = _guessExecutionStatusRelativeToDifferentFunctionsInternal(e1, t, r);
                n.set(t.node, i);
                return i;
            }
            function resolve(e1, t) {
                return _resolve.call(this, e1, t) || this;
            }
            function _resolve(e1, t) {
                var r;
                if ((r = t) != null && r.includes(this)) return;
                t = t || [];
                t.push(this);
                if (this.isVariableDeclarator()) {
                    if (this.get("id").isIdentifier()) {
                        return this.get("init").resolve(e1, t);
                    } else {}
                } else if (this.isReferencedIdentifier()) {
                    const r = this.scope.getBinding(this.node.name);
                    if (!r) return;
                    if (!r.constant) return;
                    if (r.kind === "module") return;
                    if (r.path !== this) {
                        const n = r.path.resolve(e1, t);
                        if (this.find((e1)=>e1.node === n.node)) return;
                        return n;
                    }
                } else if (this.isTypeCastExpression()) {
                    return this.get("expression").resolve(e1, t);
                } else if (e1 && this.isMemberExpression()) {
                    const r = this.toComputedKey();
                    if (!c(r)) return;
                    const n = r.value;
                    const s = this.get("object").resolve(e1, t);
                    if (s.isObjectExpression()) {
                        const r = s.get("properties");
                        for (const s of r){
                            if (!s.isProperty()) continue;
                            const r = s.get("key");
                            let i = s.isnt("computed") && r.isIdentifier({
                                name: n
                            });
                            i = i || r.isLiteral({
                                value: n
                            });
                            if (i) return s.get("value").resolve(e1, t);
                        }
                    } else if (s.isArrayExpression() && !isNaN(+n)) {
                        const r = s.get("elements");
                        const i = r[n];
                        if (i) return i.resolve(e1, t);
                    }
                }
            }
            function isConstantExpression() {
                if (this.isIdentifier()) {
                    const e1 = this.scope.getBinding(this.node.name);
                    if (!e1) return false;
                    return e1.constant;
                }
                if (this.isLiteral()) {
                    if (this.isRegExpLiteral()) {
                        return false;
                    }
                    if (this.isTemplateLiteral()) {
                        return this.get("expressions").every((e1)=>e1.isConstantExpression());
                    }
                    return true;
                }
                if (this.isUnaryExpression()) {
                    if (this.node.operator !== "void") {
                        return false;
                    }
                    return this.get("argument").isConstantExpression();
                }
                if (this.isBinaryExpression()) {
                    const { operator: e1 } = this.node;
                    return e1 !== "in" && e1 !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
                }
                if (this.isMemberExpression()) {
                    return !this.node.computed && this.get("object").isIdentifier({
                        name: "Symbol"
                    }) && !this.scope.hasBinding("Symbol", {
                        noGlobals: true
                    });
                }
                if (this.isCallExpression()) {
                    return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
                        noGlobals: true
                    }) && this.get("arguments")[0].isStringLiteral();
                }
                return false;
            }
            function isInStrictMode() {
                const e1 = this.isProgram() ? this : this.parentPath;
                const t = e1.find((e1)=>{
                    if (e1.isProgram({
                        sourceType: "module"
                    })) return true;
                    if (e1.isClass()) return true;
                    if (e1.isArrowFunctionExpression() && !e1.get("body").isBlockStatement()) {
                        return false;
                    }
                    let t;
                    if (e1.isFunction()) {
                        t = e1.node.body;
                    } else if (e1.isProgram()) {
                        t = e1.node;
                    } else {
                        return false;
                    }
                    for (const e1 of t.directives){
                        if (e1.value.value === "use strict") {
                            return true;
                        }
                    }
                });
                return !!t;
            }
        },
        6378: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(3061);
            var s = n;
            const { react: i } = n;
            const { cloneNode: a, jsxExpressionContainer: o, variableDeclaration: l, variableDeclarator: c } = s;
            const p = {
                ReferencedIdentifier (e1, t) {
                    if (e1.isJSXIdentifier() && i.isCompatTag(e1.node.name) && !e1.parentPath.isJSXMemberExpression()) {
                        return;
                    }
                    if (e1.node.name === "this") {
                        let r = e1.scope;
                        do {
                            if (r.path.isFunction() && !r.path.isArrowFunctionExpression()) {
                                break;
                            }
                        }while (r = r.parent)
                        if (r) t.breakOnScopePaths.push(r.path);
                    }
                    const r = e1.scope.getBinding(e1.node.name);
                    if (!r) return;
                    for (const n of r.constantViolations){
                        if (n.scope !== r.path.scope) {
                            t.mutableBinding = true;
                            e1.stop();
                            return;
                        }
                    }
                    if (r !== t.scope.getBinding(e1.node.name)) return;
                    t.bindings[e1.node.name] = r;
                }
            };
            class PathHoister {
                isCompatibleScope(e1) {
                    for (const t of Object.keys(this.bindings)){
                        const r = this.bindings[t];
                        if (!e1.bindingIdentifierEquals(t, r.identifier)) {
                            return false;
                        }
                    }
                    return true;
                }
                getCompatibleScopes() {
                    let e1 = this.path.scope;
                    do {
                        if (this.isCompatibleScope(e1)) {
                            this.scopes.push(e1);
                        } else {
                            break;
                        }
                        if (this.breakOnScopePaths.includes(e1.path)) {
                            break;
                        }
                    }while (e1 = e1.parent)
                }
                getAttachmentPath() {
                    let e1 = this._getAttachmentPath();
                    if (!e1) return;
                    let t = e1.scope;
                    if (t.path === e1) {
                        t = e1.scope.parent;
                    }
                    if (t.path.isProgram() || t.path.isFunction()) {
                        for (const r of Object.keys(this.bindings)){
                            if (!t.hasOwnBinding(r)) continue;
                            const n = this.bindings[r];
                            if (n.kind === "param" || n.path.parentKey === "params") {
                                continue;
                            }
                            const s = this.getAttachmentParentForPath(n.path);
                            if (s.key >= e1.key) {
                                this.attachAfter = true;
                                e1 = n.path;
                                for (const t of n.constantViolations){
                                    if (this.getAttachmentParentForPath(t).key > e1.key) {
                                        e1 = t;
                                    }
                                }
                            }
                        }
                    }
                    return e1;
                }
                _getAttachmentPath() {
                    const e1 = this.scopes;
                    const t = e1.pop();
                    if (!t) return;
                    if (t.path.isFunction()) {
                        if (this.hasOwnParamBindings(t)) {
                            if (this.scope === t) return;
                            const e1 = t.path.get("body").get("body");
                            for(let t = 0; t < e1.length; t++){
                                if (e1[t].node._blockHoist) continue;
                                return e1[t];
                            }
                        } else {
                            return this.getNextScopeAttachmentParent();
                        }
                    } else if (t.path.isProgram()) {
                        return this.getNextScopeAttachmentParent();
                    }
                }
                getNextScopeAttachmentParent() {
                    const e1 = this.scopes.pop();
                    if (e1) return this.getAttachmentParentForPath(e1.path);
                }
                getAttachmentParentForPath(e1) {
                    do {
                        if (!e1.parentPath || Array.isArray(e1.container) && e1.isStatement()) {
                            return e1;
                        }
                    }while (e1 = e1.parentPath)
                }
                hasOwnParamBindings(e1) {
                    for (const t of Object.keys(this.bindings)){
                        if (!e1.hasOwnBinding(t)) continue;
                        const r = this.bindings[t];
                        if (r.kind === "param" && r.constant) return true;
                    }
                    return false;
                }
                run() {
                    this.path.traverse(p, this);
                    if (this.mutableBinding) return;
                    this.getCompatibleScopes();
                    const e1 = this.getAttachmentPath();
                    if (!e1) return;
                    if (e1.getFunctionParent() === this.path.getFunctionParent()) return;
                    let t = e1.scope.generateUidIdentifier("ref");
                    const r = c(t, this.path.node);
                    const n = this.attachAfter ? "insertAfter" : "insertBefore";
                    const [s] = e1[n]([
                        e1.isVariableDeclarator() ? r : l("var", [
                            r
                        ])
                    ]);
                    const i = this.path.parentPath;
                    if (i.isJSXElement() && this.path.container === i.node.children) {
                        t = o(t);
                    }
                    this.path.replaceWith(a(t));
                    return e1.isVariableDeclarator() ? s.get("init") : s.get("declarations.0.init");
                }
                constructor(e1, t){
                    this.breakOnScopePaths = void 0;
                    this.bindings = void 0;
                    this.mutableBinding = void 0;
                    this.scopes = void 0;
                    this.scope = void 0;
                    this.path = void 0;
                    this.attachAfter = void 0;
                    this.breakOnScopePaths = [];
                    this.bindings = {};
                    this.mutableBinding = false;
                    this.scopes = [];
                    this.scope = t;
                    this.path = e1;
                    this.attachAfter = false;
                }
            }
            t["default"] = PathHoister;
        },
        7978: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.hooks = void 0;
            const r = t.hooks = [
                function(e1, t) {
                    const r = e1.key === "test" && (t.isWhile() || t.isSwitchCase()) || e1.key === "declaration" && t.isExportDeclaration() || e1.key === "body" && t.isLabeledStatement() || e1.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e1.key === "expression" && t.isExpressionStatement();
                    if (r) {
                        t.remove();
                        return true;
                    }
                },
                function(e1, t) {
                    if (t.isSequenceExpression() && t.node.expressions.length === 1) {
                        t.replaceWith(t.node.expressions[0]);
                        return true;
                    }
                },
                function(e1, t) {
                    if (t.isBinary()) {
                        if (e1.key === "left") {
                            t.replaceWith(t.node.right);
                        } else {
                            t.replaceWith(t.node.left);
                        }
                        return true;
                    }
                },
                function(e1, t) {
                    if (t.isIfStatement() && e1.key === "consequent" || e1.key === "body" && (t.isLoop() || t.isArrowFunctionExpression())) {
                        e1.replaceWith({
                            type: "BlockStatement",
                            body: []
                        });
                        return true;
                    }
                }
            ];
        },
        3053: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isBindingIdentifier = isBindingIdentifier;
            t.isBlockScoped = isBlockScoped;
            t.isExpression = isExpression;
            t.isFlow = isFlow;
            t.isForAwaitStatement = isForAwaitStatement;
            t.isGenerated = isGenerated;
            t.isPure = isPure;
            t.isReferenced = isReferenced;
            t.isReferencedIdentifier = isReferencedIdentifier;
            t.isReferencedMemberExpression = isReferencedMemberExpression;
            t.isRestProperty = isRestProperty;
            t.isScope = isScope;
            t.isSpreadProperty = isSpreadProperty;
            t.isStatement = isStatement;
            t.isUser = isUser;
            t.isVar = isVar;
            var n = r(3061);
            const { isBinding: s, isBlockScoped: i, isExportDeclaration: a, isExpression: o, isFlow: l, isForStatement: c, isForXStatement: p, isIdentifier: u, isImportDeclaration: d, isImportSpecifier: f, isJSXIdentifier: h, isJSXMemberExpression: m, isMemberExpression: y, isRestElement: g, isReferenced: b, isScope: T, isStatement: S, isVar: x, isVariableDeclaration: E, react: P, isForOfStatement: v } = n;
            const { isCompatTag: A } = P;
            function isReferencedIdentifier(e1) {
                const { node: t, parent: r } = this;
                if (!u(t, e1) && !m(r, e1)) {
                    if (h(t, e1)) {
                        if (A(t.name)) return false;
                    } else {
                        return false;
                    }
                }
                return b(t, r, this.parentPath.parent);
            }
            function isReferencedMemberExpression() {
                const { node: e1, parent: t } = this;
                return y(e1) && b(e1, t);
            }
            function isBindingIdentifier() {
                const { node: e1, parent: t } = this;
                const r = this.parentPath.parent;
                return u(e1) && s(e1, t, r);
            }
            function isStatement() {
                const { node: e1, parent: t } = this;
                if (S(e1)) {
                    if (E(e1)) {
                        if (p(t, {
                            left: e1
                        })) return false;
                        if (c(t, {
                            init: e1
                        })) return false;
                    }
                    return true;
                } else {
                    return false;
                }
            }
            function isExpression() {
                if (this.isIdentifier()) {
                    return this.isReferencedIdentifier();
                } else {
                    return o(this.node);
                }
            }
            function isScope() {
                return T(this.node, this.parent);
            }
            function isReferenced() {
                return b(this.node, this.parent);
            }
            function isBlockScoped() {
                return i(this.node);
            }
            function isVar() {
                return x(this.node);
            }
            function isUser() {
                return this.node && !!this.node.loc;
            }
            function isGenerated() {
                return !this.isUser();
            }
            function isPure(e1) {
                return this.scope.isPure(this.node, e1);
            }
            function isFlow() {
                const { node: e1 } = this;
                if (l(e1)) {
                    return true;
                } else if (d(e1)) {
                    return e1.importKind === "type" || e1.importKind === "typeof";
                } else if (a(e1)) {
                    return e1.exportKind === "type";
                } else if (f(e1)) {
                    return e1.importKind === "type" || e1.importKind === "typeof";
                } else {
                    return false;
                }
            }
            function isRestProperty() {
                var e1;
                return g(this.node) && ((e1 = this.parentPath) == null ? void 0 : e1.isObjectPattern());
            }
            function isSpreadProperty() {
                var e1;
                return g(this.node) && ((e1 = this.parentPath) == null ? void 0 : e1.isObjectExpression());
            }
            function isForAwaitStatement() {
                return v(this.node, {
                    await: true
                });
            }
            {
                t.isExistentialTypeParam = function isExistentialTypeParam() {
                    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
                };
                t.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
                    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
                };
            }
        },
        2490: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Var = t.User = t.Statement = t.SpreadProperty = t.Scope = t.RestProperty = t.ReferencedMemberExpression = t.ReferencedIdentifier = t.Referenced = t.Pure = t.NumericLiteralTypeAnnotation = t.Generated = t.ForAwaitStatement = t.Flow = t.Expression = t.ExistentialTypeParam = t.BlockScoped = t.BindingIdentifier = void 0;
            const r = t.ReferencedIdentifier = [
                "Identifier",
                "JSXIdentifier"
            ];
            const n = t.ReferencedMemberExpression = [
                "MemberExpression"
            ];
            const s = t.BindingIdentifier = [
                "Identifier"
            ];
            const i = t.Statement = [
                "Statement"
            ];
            const a = t.Expression = [
                "Expression"
            ];
            const o = t.Scope = [
                "Scopable",
                "Pattern"
            ];
            const l = t.Referenced = null;
            const c = t.BlockScoped = null;
            const p = t.Var = [
                "VariableDeclaration"
            ];
            const u = t.User = null;
            const d = t.Generated = null;
            const f = t.Pure = null;
            const h = t.Flow = [
                "Flow",
                "ImportDeclaration",
                "ExportDeclaration",
                "ImportSpecifier"
            ];
            const m = t.RestProperty = [
                "RestElement"
            ];
            const y = t.SpreadProperty = [
                "RestElement"
            ];
            const g = t.ExistentialTypeParam = [
                "ExistsTypeAnnotation"
            ];
            const b = t.NumericLiteralTypeAnnotation = [
                "NumberLiteralTypeAnnotation"
            ];
            const T = t.ForAwaitStatement = [
                "ForOfStatement"
            ];
        },
        7116: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._containerInsert = _containerInsert;
            t._containerInsertAfter = _containerInsertAfter;
            t._containerInsertBefore = _containerInsertBefore;
            t._verifyNodeList = _verifyNodeList;
            t.insertAfter = insertAfter;
            t.insertBefore = insertBefore;
            t.pushContainer = pushContainer;
            t.unshiftContainer = unshiftContainer;
            t.updateSiblingKeys = updateSiblingKeys;
            var n = r(8099);
            var s = r(9111);
            var i = r(4144);
            var a = r(6035);
            var o = r(3061);
            var l = r(6378);
            const { arrowFunctionExpression: c, assertExpression: p, assignmentExpression: u, blockStatement: d, callExpression: f, cloneNode: h, expressionStatement: m, isAssignmentExpression: y, isCallExpression: g, isExportNamedDeclaration: b, isExpression: T, isIdentifier: S, isSequenceExpression: x, isSuper: E, thisExpression: P } = o;
            function insertBefore(e1) {
                a._assertUnremoved.call(this);
                const t = _verifyNodeList.call(this, e1);
                const { parentPath: r, parent: n } = this;
                if (r.isExpressionStatement() || r.isLabeledStatement() || b(n) || r.isExportDefaultDeclaration() && this.isDeclaration()) {
                    return r.insertBefore(t);
                } else if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init") {
                    if (this.node) t.push(this.node);
                    return this.replaceExpressionWithStatements(t);
                } else if (Array.isArray(this.container)) {
                    return _containerInsertBefore.call(this, t);
                } else if (this.isStatementOrBlock()) {
                    const e1 = this.node;
                    const r = e1 && (!this.isExpressionStatement() || e1.expression != null);
                    this.replaceWith(d(r ? [
                        e1
                    ] : []));
                    return this.unshiftContainer("body", t);
                } else {
                    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
                }
            }
            function _containerInsert(e1, t) {
                updateSiblingKeys.call(this, e1, t.length);
                const r = [];
                this.container.splice(e1, 0, ...t);
                for(let s = 0; s < t.length; s++){
                    var n;
                    const t = e1 + s;
                    const a = this.getSibling(t);
                    r.push(a);
                    if ((n = this.context) != null && n.queue) {
                        i.pushContext.call(a, this.context);
                    }
                }
                const s = i._getQueueContexts.call(this);
                for (const e1 of r){
                    i.setScope.call(e1);
                    e1.debug("Inserted.");
                    for (const t of s){
                        t.maybeQueue(e1, true);
                    }
                }
                return r;
            }
            function _containerInsertBefore(e1) {
                return _containerInsert.call(this, this.key, e1);
            }
            function _containerInsertAfter(e1) {
                return _containerInsert.call(this, this.key + 1, e1);
            }
            const last = (e1)=>e1[e1.length - 1];
            function isHiddenInSequenceExpression(e1) {
                return x(e1.parent) && (last(e1.parent.expressions) !== e1.node || isHiddenInSequenceExpression(e1.parentPath));
            }
            function isAlmostConstantAssignment(e1, t) {
                if (!y(e1) || !S(e1.left)) {
                    return false;
                }
                const r = t.getBlockParent();
                return r.hasOwnBinding(e1.left.name) && r.getOwnBinding(e1.left.name).constantViolations.length <= 1;
            }
            function insertAfter(e1) {
                a._assertUnremoved.call(this);
                if (this.isSequenceExpression()) {
                    return last(this.get("expressions")).insertAfter(e1);
                }
                const t = _verifyNodeList.call(this, e1);
                const { parentPath: r, parent: n } = this;
                if (r.isExpressionStatement() || r.isLabeledStatement() || b(n) || r.isExportDefaultDeclaration() && this.isDeclaration()) {
                    return r.insertAfter(t.map((e1)=>T(e1) ? m(e1) : e1));
                } else if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
                    const e1 = this;
                    if (e1.node) {
                        const n = e1.node;
                        let { scope: s } = this;
                        if (s.path.isPattern()) {
                            p(n);
                            e1.replaceWith(f(c([], n), []));
                            e1.get("callee.body").insertAfter(t);
                            return [
                                e1
                            ];
                        }
                        if (isHiddenInSequenceExpression(e1)) {
                            t.unshift(n);
                        } else if (g(n) && E(n.callee)) {
                            t.unshift(n);
                            t.push(P());
                        } else if (isAlmostConstantAssignment(n, s)) {
                            t.unshift(n);
                            t.push(h(n.left));
                        } else if (s.isPure(n, true)) {
                            t.push(n);
                        } else {
                            if (r.isMethod({
                                computed: true,
                                key: n
                            })) {
                                s = s.parent;
                            }
                            const e1 = s.generateDeclaredUidIdentifier();
                            t.unshift(m(u("=", h(e1), n)));
                            t.push(m(h(e1)));
                        }
                    }
                    return this.replaceExpressionWithStatements(t);
                } else if (Array.isArray(this.container)) {
                    return _containerInsertAfter.call(this, t);
                } else if (this.isStatementOrBlock()) {
                    const e1 = this.node;
                    const r = e1 && (!this.isExpressionStatement() || e1.expression != null);
                    this.replaceWith(d(r ? [
                        e1
                    ] : []));
                    return this.pushContainer("body", t);
                } else {
                    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
                }
            }
            function updateSiblingKeys(e1, t) {
                if (!this.parent) return;
                const r = (0, n.getCachedPaths)(this.hub, this.parent) || [];
                for (const [, n] of r){
                    if (typeof n.key === "number" && n.container === this.container && n.key >= e1) {
                        n.key += t;
                    }
                }
            }
            function _verifyNodeList(e1) {
                if (!e1) {
                    return [];
                }
                if (!Array.isArray(e1)) {
                    e1 = [
                        e1
                    ];
                }
                for(let t = 0; t < e1.length; t++){
                    const r = e1[t];
                    let n;
                    if (!r) {
                        n = "has falsy node";
                    } else if (typeof r !== "object") {
                        n = "contains a non-object node";
                    } else if (!r.type) {
                        n = "without a type";
                    } else if (r instanceof s.default) {
                        n = "has a NodePath when it expected a raw object";
                    }
                    if (n) {
                        const e1 = Array.isArray(r) ? "array" : typeof r;
                        throw new Error("Node list ".concat(n, " with the index of ").concat(t, " and type of ").concat(e1));
                    }
                }
                return e1;
            }
            function unshiftContainer(e1, t) {
                a._assertUnremoved.call(this);
                t = _verifyNodeList.call(this, t);
                const r = s.default.get({
                    parentPath: this,
                    parent: this.node,
                    container: this.node[e1],
                    listKey: e1,
                    key: 0
                }).setContext(this.context);
                return _containerInsertBefore.call(r, t);
            }
            function pushContainer(e1, t) {
                a._assertUnremoved.call(this);
                const r = _verifyNodeList.call(this, t);
                const n = this.node[e1];
                const i = s.default.get({
                    parentPath: this,
                    parent: this.node,
                    container: n,
                    listKey: e1,
                    key: n.length
                }).setContext(this.context);
                return i.replaceWithMultiple(r);
            }
            {
                t.hoist = function hoist() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.scope;
                    const t = new l.default(this, e1);
                    return t.run();
                };
            }
        },
        6035: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._assertUnremoved = _assertUnremoved;
            t._callRemovalHooks = _callRemovalHooks;
            t._markRemoved = _markRemoved;
            t._remove = _remove;
            t._removeFromScope = _removeFromScope;
            t.remove = remove;
            var n = r(7978);
            var s = r(8099);
            var i = r(3419);
            var a = r(9111);
            var o = r(3061);
            var l = r(7116);
            var c = r(4144);
            const { getBindingIdentifiers: p } = o;
            function remove() {
                var e1;
                _assertUnremoved.call(this);
                c.resync.call(this);
                if (_callRemovalHooks.call(this)) {
                    _markRemoved.call(this);
                    return;
                }
                if (!((e1 = this.opts) != null && e1.noScope)) {
                    _removeFromScope.call(this);
                }
                this.shareCommentsWithSiblings();
                _remove.call(this);
                _markRemoved.call(this);
            }
            function _removeFromScope() {
                const e1 = p(this.node, false, false, true);
                Object.keys(e1).forEach((e1)=>this.scope.removeBinding(e1));
            }
            function _callRemovalHooks() {
                if (this.parentPath) {
                    for (const e1 of n.hooks){
                        if (e1(this, this.parentPath)) return true;
                    }
                }
            }
            function _remove() {
                if (Array.isArray(this.container)) {
                    this.container.splice(this.key, 1);
                    l.updateSiblingKeys.call(this, this.key, -1);
                } else {
                    i._replaceWith.call(this, null);
                }
            }
            function _markRemoved() {
                this._traverseFlags |= a.SHOULD_SKIP | a.REMOVED;
                if (this.parent) {
                    (0, s.getCachedPaths)(this.hub, this.parent).delete(this.node);
                }
                this.node = null;
            }
            function _assertUnremoved() {
                if (this.removed) {
                    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
                }
            }
        },
        3419: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._replaceWith = _replaceWith;
            t.replaceExpressionWithStatements = replaceExpressionWithStatements;
            t.replaceInline = replaceInline;
            t.replaceWith = replaceWith;
            t.replaceWithMultiple = replaceWithMultiple;
            t.replaceWithSourceString = replaceWithSourceString;
            var n = r(3554);
            var s = r(8026);
            var i = r(9111);
            var a = r(8099);
            var o = r(7116);
            var l = r(9849);
            var c = r(3061);
            var p = r(4144);
            const { FUNCTION_TYPES: u, arrowFunctionExpression: d, assignmentExpression: f, awaitExpression: h, blockStatement: m, buildUndefinedNode: y, callExpression: g, cloneNode: b, conditionalExpression: T, expressionStatement: S, getBindingIdentifiers: x, identifier: E, inheritLeadingComments: P, inheritTrailingComments: v, inheritsComments: A, isBlockStatement: w, isEmptyStatement: I, isExpression: C, isExpressionStatement: O, isIfStatement: N, isProgram: k, isStatement: _, isVariableDeclaration: D, removeComments: M, returnStatement: L, sequenceExpression: j, validate: F, yieldExpression: B } = c;
            function replaceWithMultiple(e1) {
                var t;
                p.resync.call(this);
                e1 = o._verifyNodeList.call(this, e1);
                P(e1[0], this.node);
                v(e1[e1.length - 1], this.node);
                (t = (0, a.getCachedPaths)(this.hub, this.parent)) == null || t.delete(this.node);
                this.node = this.container[this.key] = null;
                const r = this.insertAfter(e1);
                if (this.node) {
                    this.requeue();
                } else {
                    this.remove();
                }
                return r;
            }
            function replaceWithSourceString(e1) {
                p.resync.call(this);
                let t;
                try {
                    e1 = "(".concat(e1, ")");
                    t = (0, l.parse)(e1);
                } catch (t) {
                    const r = t.loc;
                    if (r) {
                        t.message += " - make sure this is an expression.\n" + (0, n.codeFrameColumns)(e1, {
                            start: {
                                line: r.line,
                                column: r.column + 1
                            }
                        });
                        t.code = "BABEL_REPLACE_SOURCE_ERROR";
                    }
                    throw t;
                }
                const r = t.program.body[0].expression;
                s.default.removeProperties(r);
                return this.replaceWith(r);
            }
            function replaceWith(e1) {
                p.resync.call(this);
                if (this.removed) {
                    throw new Error("You can't replace this node, we've already removed it");
                }
                let t = e1 instanceof i.default ? e1.node : e1;
                if (!t) {
                    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
                }
                if (this.node === t) {
                    return [
                        this
                    ];
                }
                if (this.isProgram() && !k(t)) {
                    throw new Error("You can only replace a Program root node with another Program node");
                }
                if (Array.isArray(t)) {
                    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
                }
                if (typeof t === "string") {
                    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
                }
                let r = "";
                if (this.isNodeType("Statement") && C(t)) {
                    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t) && !this.parentPath.isExportDefaultDeclaration()) {
                        t = S(t);
                        r = "expression";
                    }
                }
                if (this.isNodeType("Expression") && _(t)) {
                    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t)) {
                        return this.replaceExpressionWithStatements([
                            t
                        ]);
                    }
                }
                const n = this.node;
                if (n) {
                    A(t, n);
                    M(n);
                }
                _replaceWith.call(this, t);
                this.type = t.type;
                p.setScope.call(this);
                this.requeue();
                return [
                    r ? this.get(r) : this
                ];
            }
            function _replaceWith(e1) {
                var t;
                if (!this.container) {
                    throw new ReferenceError("Container is falsy");
                }
                if (this.inList) {
                    F(this.parent, this.key, [
                        e1
                    ]);
                } else {
                    F(this.parent, this.key, e1);
                }
                this.debug("Replace with ".concat(e1 == null ? void 0 : e1.type));
                (t = (0, a.getCachedPaths)(this.hub, this.parent)) == null || t.set(e1, this).delete(this.node);
                this.node = this.container[this.key] = e1;
            }
            function replaceExpressionWithStatements(e1) {
                p.resync.call(this);
                const t = [];
                const r = gatherSequenceExpressions(e1, t);
                if (r) {
                    for (const e1 of t)this.scope.push({
                        id: e1
                    });
                    return this.replaceWith(r)[0].get("expressions");
                }
                const n = this.getFunctionParent();
                const i = n == null ? void 0 : n.node.async;
                const a = n == null ? void 0 : n.node.generator;
                const o = d([], m(e1));
                this.replaceWith(g(o, []));
                const l = this.get("callee");
                l.get("body").scope.hoistVariables((e1)=>this.scope.push({
                        id: e1
                    }));
                const c = l.getCompletionRecords();
                for (const e1 of c){
                    if (!e1.isExpressionStatement()) continue;
                    const t = e1.findParent((e1)=>e1.isLoop());
                    if (t) {
                        let r = t.getData("expressionReplacementReturnUid");
                        if (!r) {
                            r = l.scope.generateDeclaredUidIdentifier("ret");
                            l.get("body").pushContainer("body", L(b(r)));
                            t.setData("expressionReplacementReturnUid", r);
                        } else {
                            r = E(r.name);
                        }
                        e1.get("expression").replaceWith(f("=", b(r), e1.node.expression));
                    } else {
                        e1.replaceWith(L(e1.node.expression));
                    }
                }
                l.arrowFunctionToExpression();
                const y = l;
                const T = i && s.default.hasType(this.get("callee.body").node, "AwaitExpression", u);
                const S = a && s.default.hasType(this.get("callee.body").node, "YieldExpression", u);
                if (T) {
                    y.set("async", true);
                    if (!S) {
                        this.replaceWith(h(this.node));
                    }
                }
                if (S) {
                    y.set("generator", true);
                    this.replaceWith(B(this.node, true));
                }
                return y.get("body.body");
            }
            function gatherSequenceExpressions(e1, t) {
                const r = [];
                let n = true;
                for (const s of e1){
                    if (!I(s)) {
                        n = false;
                    }
                    if (C(s)) {
                        r.push(s);
                    } else if (O(s)) {
                        r.push(s.expression);
                    } else if (D(s)) {
                        if (s.kind !== "var") return;
                        for (const e1 of s.declarations){
                            const n = x(e1);
                            for (const e1 of Object.keys(n)){
                                t.push(b(n[e1]));
                            }
                            if (e1.init) {
                                r.push(f("=", e1.id, e1.init));
                            }
                        }
                        n = true;
                    } else if (N(s)) {
                        const e1 = s.consequent ? gatherSequenceExpressions([
                            s.consequent
                        ], t) : y();
                        const n = s.alternate ? gatherSequenceExpressions([
                            s.alternate
                        ], t) : y();
                        if (!e1 || !n) return;
                        r.push(T(s.test, e1, n));
                    } else if (w(s)) {
                        const e1 = gatherSequenceExpressions(s.body, t);
                        if (!e1) return;
                        r.push(e1);
                    } else if (I(s)) {
                        if (e1.indexOf(s) === 0) {
                            n = true;
                        }
                    } else {
                        return;
                    }
                }
                if (n) r.push(y());
                if (r.length === 1) {
                    return r[0];
                } else {
                    return j(r);
                }
            }
            function replaceInline(e1) {
                p.resync.call(this);
                if (Array.isArray(e1)) {
                    if (Array.isArray(this.container)) {
                        e1 = o._verifyNodeList.call(this, e1);
                        const t = o._containerInsertAfter.call(this, e1);
                        this.remove();
                        return t;
                    } else {
                        return this.replaceWithMultiple(e1);
                    }
                } else {
                    return this.replaceWith(e1);
                }
            }
        },
        7033: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class Binding {
                deoptValue() {
                    this.clearValue();
                    this.hasDeoptedValue = true;
                }
                setValue(e1) {
                    if (this.hasDeoptedValue) return;
                    this.hasValue = true;
                    this.value = e1;
                }
                clearValue() {
                    this.hasDeoptedValue = false;
                    this.hasValue = false;
                    this.value = null;
                }
                reassign(e1) {
                    this.constant = false;
                    if (this.constantViolations.includes(e1)) {
                        return;
                    }
                    this.constantViolations.push(e1);
                }
                reference(e1) {
                    if (this.referencePaths.includes(e1)) {
                        return;
                    }
                    this.referenced = true;
                    this.references++;
                    this.referencePaths.push(e1);
                }
                dereference() {
                    this.references--;
                    this.referenced = !!this.references;
                }
                constructor({ identifier: e1, scope: t, path: r, kind: n }){
                    this.identifier = void 0;
                    this.scope = void 0;
                    this.path = void 0;
                    this.kind = void 0;
                    this.constantViolations = [];
                    this.constant = true;
                    this.referencePaths = [];
                    this.referenced = false;
                    this.references = 0;
                    this.identifier = e1;
                    this.scope = t;
                    this.path = r;
                    this.kind = n;
                    if ((n === "var" || n === "hoisted") && isInitInLoop(r)) {
                        this.reassign(r);
                    }
                    this.clearValue();
                }
            }
            t["default"] = Binding;
            function isInitInLoop(e1) {
                const t = !e1.isVariableDeclarator() || e1.node.init;
                for(let { parentPath: r, key: n } = e1; r; { parentPath: r, key: n } = r){
                    if (r.isFunctionParent()) return false;
                    if (n === "left" && r.isForXStatement() || t && n === "body" && r.isLoop()) {
                        return true;
                    }
                }
                return false;
            }
        },
        9877: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(3855);
            var s = r(8026);
            var i = r(7033);
            var a = r(6929);
            var o = r(3061);
            var l = o;
            var c = r(8099);
            const { assignmentExpression: p, callExpression: u, cloneNode: d, getBindingIdentifiers: f, identifier: h, isArrayExpression: m, isBinary: y, isCallExpression: g, isClass: b, isClassBody: T, isClassDeclaration: S, isExportAllDeclaration: x, isExportDefaultDeclaration: E, isExportNamedDeclaration: P, isFunctionDeclaration: v, isIdentifier: A, isImportDeclaration: w, isLiteral: I, isMemberExpression: C, isMethod: O, isModuleSpecifier: N, isNullLiteral: k, isObjectExpression: _, isProperty: D, isPureish: M, isRegExpLiteral: L, isSuper: j, isTaggedTemplateExpression: F, isTemplateLiteral: B, isThisExpression: R, isUnaryExpression: U, isVariableDeclaration: K, expressionStatement: V, matchesPattern: W, memberExpression: $, numericLiteral: q, toIdentifier: H, variableDeclaration: G, variableDeclarator: J, isRecordExpression: z, isTupleExpression: X, isObjectProperty: Y, isTopicReference: Q, isMetaProperty: Z, isPrivateName: ee, isExportDeclaration: te, buildUndefinedNode: re, sequenceExpression: ne } = o;
            function gatherNodeParts(e1, t) {
                switch(e1 == null ? void 0 : e1.type){
                    default:
                        if (w(e1) || te(e1)) {
                            var r;
                            if ((x(e1) || P(e1) || w(e1)) && e1.source) {
                                gatherNodeParts(e1.source, t);
                            } else if ((P(e1) || w(e1)) && (r = e1.specifiers) != null && r.length) {
                                for (const r of e1.specifiers)gatherNodeParts(r, t);
                            } else if ((E(e1) || P(e1)) && e1.declaration) {
                                gatherNodeParts(e1.declaration, t);
                            }
                        } else if (N(e1)) {
                            gatherNodeParts(e1.local, t);
                        } else if (I(e1) && !k(e1) && !L(e1) && !B(e1)) {
                            t.push(e1.value);
                        }
                        break;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "JSXMemberExpression":
                        gatherNodeParts(e1.object, t);
                        gatherNodeParts(e1.property, t);
                        break;
                    case "Identifier":
                    case "JSXIdentifier":
                        t.push(e1.name);
                        break;
                    case "CallExpression":
                    case "OptionalCallExpression":
                    case "NewExpression":
                        gatherNodeParts(e1.callee, t);
                        break;
                    case "ObjectExpression":
                    case "ObjectPattern":
                        for (const r of e1.properties){
                            gatherNodeParts(r, t);
                        }
                        break;
                    case "SpreadElement":
                    case "RestElement":
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "ObjectProperty":
                    case "ObjectMethod":
                    case "ClassProperty":
                    case "ClassMethod":
                    case "ClassPrivateProperty":
                    case "ClassPrivateMethod":
                        gatherNodeParts(e1.key, t);
                        break;
                    case "ThisExpression":
                        t.push("this");
                        break;
                    case "Super":
                        t.push("super");
                        break;
                    case "Import":
                        t.push("import");
                        break;
                    case "DoExpression":
                        t.push("do");
                        break;
                    case "YieldExpression":
                        t.push("yield");
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "AwaitExpression":
                        t.push("await");
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "AssignmentExpression":
                        gatherNodeParts(e1.left, t);
                        break;
                    case "VariableDeclarator":
                        gatherNodeParts(e1.id, t);
                        break;
                    case "FunctionExpression":
                    case "FunctionDeclaration":
                    case "ClassExpression":
                    case "ClassDeclaration":
                        gatherNodeParts(e1.id, t);
                        break;
                    case "PrivateName":
                        gatherNodeParts(e1.id, t);
                        break;
                    case "ParenthesizedExpression":
                        gatherNodeParts(e1.expression, t);
                        break;
                    case "UnaryExpression":
                    case "UpdateExpression":
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "MetaProperty":
                        gatherNodeParts(e1.meta, t);
                        gatherNodeParts(e1.property, t);
                        break;
                    case "JSXElement":
                        gatherNodeParts(e1.openingElement, t);
                        break;
                    case "JSXOpeningElement":
                        gatherNodeParts(e1.name, t);
                        break;
                    case "JSXFragment":
                        gatherNodeParts(e1.openingFragment, t);
                        break;
                    case "JSXOpeningFragment":
                        t.push("Fragment");
                        break;
                    case "JSXNamespacedName":
                        gatherNodeParts(e1.namespace, t);
                        gatherNodeParts(e1.name, t);
                        break;
                }
            }
            function resetScope(e1) {
                e1.references = Object.create(null);
                e1.bindings = Object.create(null);
                e1.globals = Object.create(null);
                e1.uids = Object.create(null);
            }
            {
                var se = Symbol.for("should not be considered a local binding");
            }
            const ie = {
                ForStatement (e1) {
                    const t = e1.get("init");
                    if (t.isVar()) {
                        const { scope: r } = e1;
                        const n = r.getFunctionParent() || r.getProgramParent();
                        n.registerBinding("var", t);
                    }
                },
                Declaration (e1) {
                    if (e1.isBlockScoped()) return;
                    if (e1.isImportDeclaration()) return;
                    if (e1.isExportDeclaration()) return;
                    const t = e1.scope.getFunctionParent() || e1.scope.getProgramParent();
                    t.registerDeclaration(e1);
                },
                ImportDeclaration (e1) {
                    const t = e1.scope.getBlockParent();
                    t.registerDeclaration(e1);
                },
                TSImportEqualsDeclaration (e1) {
                    const t = e1.scope.getBlockParent();
                    t.registerDeclaration(e1);
                },
                ReferencedIdentifier (e1, t) {
                    if (l.isTSQualifiedName(e1.parent) && e1.parent.right === e1.node) {
                        return;
                    }
                    if (e1.parentPath.isTSImportEqualsDeclaration()) return;
                    t.references.push(e1);
                },
                ForXStatement (e1, t) {
                    const r = e1.get("left");
                    if (r.isPattern() || r.isIdentifier()) {
                        t.constantViolations.push(e1);
                    } else if (r.isVar()) {
                        const { scope: t } = e1;
                        const n = t.getFunctionParent() || t.getProgramParent();
                        n.registerBinding("var", r);
                    }
                },
                ExportDeclaration: {
                    exit (e1) {
                        const { node: t, scope: r } = e1;
                        if (x(t)) return;
                        const n = t.declaration;
                        if (S(n) || v(n)) {
                            const t = n.id;
                            if (!t) return;
                            const s = r.getBinding(t.name);
                            s == null || s.reference(e1);
                        } else if (K(n)) {
                            for (const t of n.declarations){
                                for (const n of Object.keys(f(t))){
                                    const t = r.getBinding(n);
                                    t == null || t.reference(e1);
                                }
                            }
                        }
                    }
                },
                LabeledStatement (e1) {
                    e1.scope.getBlockParent().registerDeclaration(e1);
                },
                AssignmentExpression (e1, t) {
                    t.assignments.push(e1);
                },
                UpdateExpression (e1, t) {
                    t.constantViolations.push(e1);
                },
                UnaryExpression (e1, t) {
                    if (e1.node.operator === "delete") {
                        t.constantViolations.push(e1);
                    }
                },
                BlockScoped (e1) {
                    let t = e1.scope;
                    if (t.path === e1) t = t.parent;
                    const r = t.getBlockParent();
                    r.registerDeclaration(e1);
                    if (e1.isClassDeclaration() && e1.node.id) {
                        const t = e1.node.id;
                        const r = t.name;
                        e1.scope.bindings[r] = e1.scope.parent.getBinding(r);
                    }
                },
                CatchClause (e1) {
                    e1.scope.registerBinding("let", e1);
                },
                Function (e1) {
                    const t = e1.get("params");
                    for (const r of t){
                        e1.scope.registerBinding("param", r);
                    }
                    if (e1.isFunctionExpression() && e1.node.id && !e1.node.id[se]) {
                        e1.scope.registerBinding("local", e1.get("id"), e1);
                    }
                },
                ClassExpression (e1) {
                    if (e1.node.id && !e1.node.id[se]) {
                        e1.scope.registerBinding("local", e1.get("id"), e1);
                    }
                },
                TSTypeAnnotation (e1) {
                    e1.skip();
                }
            };
            let ae;
            let oe = 0;
            class Scope {
                get parent() {
                    var e1;
                    let t, r = this.path;
                    do {
                        var n;
                        const e1 = r.key === "key" || r.listKey === "decorators";
                        r = r.parentPath;
                        if (e1 && r.isMethod()) r = r.parentPath;
                        if ((n = r) != null && n.isScope()) t = r;
                    }while (r && !t)
                    return (e1 = t) == null ? void 0 : e1.scope;
                }
                generateDeclaredUidIdentifier(e1) {
                    const t = this.generateUidIdentifier(e1);
                    this.push({
                        id: t
                    });
                    return d(t);
                }
                generateUidIdentifier(e1) {
                    return h(this.generateUid(e1));
                }
                generateUid() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "temp";
                    e1 = H(e1).replace(/^_+/, "").replace(/\d+$/g, "");
                    let t;
                    let r = 1;
                    do {
                        t = "_".concat(e1);
                        if (r > 1) t += r;
                        r++;
                    }while (this.hasLabel(t) || this.hasBinding(t) || this.hasGlobal(t) || this.hasReference(t))
                    const n = this.getProgramParent();
                    n.references[t] = true;
                    n.uids[t] = true;
                    return t;
                }
                generateUidBasedOnNode(e1, t) {
                    const r = [];
                    gatherNodeParts(e1, r);
                    let n = r.join("$");
                    n = n.replace(/^_/, "") || t || "ref";
                    return this.generateUid(n.slice(0, 20));
                }
                generateUidIdentifierBasedOnNode(e1, t) {
                    return h(this.generateUidBasedOnNode(e1, t));
                }
                isStatic(e1) {
                    if (R(e1) || j(e1) || Q(e1)) {
                        return true;
                    }
                    if (A(e1)) {
                        const t = this.getBinding(e1.name);
                        if (t) {
                            return t.constant;
                        } else {
                            return this.hasBinding(e1.name);
                        }
                    }
                    return false;
                }
                maybeGenerateMemoised(e1, t) {
                    if (this.isStatic(e1)) {
                        return null;
                    } else {
                        const r = this.generateUidIdentifierBasedOnNode(e1);
                        if (!t) {
                            this.push({
                                id: r
                            });
                            return d(r);
                        }
                        return r;
                    }
                }
                checkBlockScopedCollisions(e1, t, r, n) {
                    if (t === "param") return;
                    if (e1.kind === "local") return;
                    const s = t === "let" || e1.kind === "let" || e1.kind === "const" || e1.kind === "module" || e1.kind === "param" && t === "const";
                    if (s) {
                        throw this.path.hub.buildError(n, 'Duplicate declaration "'.concat(r, '"'), TypeError);
                    }
                }
                rename(e1, t) {
                    const r = this.getBinding(e1);
                    if (r) {
                        t || (t = this.generateUidIdentifier(e1).name);
                        const s = new n.default(r, e1, t);
                        {
                            s.rename(arguments[2]);
                        }
                    }
                }
                dump() {
                    const e1 = "-".repeat(60);
                    console.log(e1);
                    let t = this;
                    do {
                        console.log("#", t.block.type);
                        for (const e1 of Object.keys(t.bindings)){
                            const r = t.bindings[e1];
                            console.log(" -", e1, {
                                constant: r.constant,
                                references: r.references,
                                violations: r.constantViolations.length,
                                kind: r.kind
                            });
                        }
                    }while (t = t.parent)
                    console.log(e1);
                }
                hasLabel(e1) {
                    return !!this.getLabel(e1);
                }
                getLabel(e1) {
                    return this.labels.get(e1);
                }
                registerLabel(e1) {
                    this.labels.set(e1.node.label.name, e1);
                }
                registerDeclaration(e1) {
                    if (e1.isLabeledStatement()) {
                        this.registerLabel(e1);
                    } else if (e1.isFunctionDeclaration()) {
                        this.registerBinding("hoisted", e1.get("id"), e1);
                    } else if (e1.isVariableDeclaration()) {
                        const t = e1.get("declarations");
                        const { kind: r } = e1.node;
                        for (const e1 of t){
                            this.registerBinding(r === "using" || r === "await using" ? "const" : r, e1);
                        }
                    } else if (e1.isClassDeclaration()) {
                        if (e1.node.declare) return;
                        this.registerBinding("let", e1);
                    } else if (e1.isImportDeclaration()) {
                        const t = e1.node.importKind === "type" || e1.node.importKind === "typeof";
                        const r = e1.get("specifiers");
                        for (const e1 of r){
                            const r = t || e1.isImportSpecifier() && (e1.node.importKind === "type" || e1.node.importKind === "typeof");
                            this.registerBinding(r ? "unknown" : "module", e1);
                        }
                    } else if (e1.isExportDeclaration()) {
                        const t = e1.get("declaration");
                        if (t.isClassDeclaration() || t.isFunctionDeclaration() || t.isVariableDeclaration()) {
                            this.registerDeclaration(t);
                        }
                    } else {
                        this.registerBinding("unknown", e1);
                    }
                }
                buildUndefinedNode() {
                    return re();
                }
                registerConstantViolation(e1) {
                    const t = e1.getAssignmentIdentifiers();
                    for (const n of Object.keys(t)){
                        var r;
                        (r = this.getBinding(n)) == null || r.reassign(e1);
                    }
                }
                registerBinding(e1, t) {
                    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t;
                    if (!e1) throw new ReferenceError("no `kind`");
                    if (t.isVariableDeclaration()) {
                        const r = t.get("declarations");
                        for (const t of r){
                            this.registerBinding(e1, t);
                        }
                        return;
                    }
                    const n = this.getProgramParent();
                    const s = t.getOuterBindingIdentifiers(true);
                    for (const t of Object.keys(s)){
                        n.references[t] = true;
                        for (const n of s[t]){
                            const s = this.getOwnBinding(t);
                            if (s) {
                                if (s.identifier === n) continue;
                                this.checkBlockScopedCollisions(s, e1, t, n);
                            }
                            if (s) {
                                s.reassign(r);
                            } else {
                                this.bindings[t] = new i.default({
                                    identifier: n,
                                    scope: this,
                                    path: r,
                                    kind: e1
                                });
                            }
                        }
                    }
                }
                addGlobal(e1) {
                    this.globals[e1.name] = e1;
                }
                hasUid(e1) {
                    let t = this;
                    do {
                        if (t.uids[e1]) return true;
                    }while (t = t.parent)
                    return false;
                }
                hasGlobal(e1) {
                    let t = this;
                    do {
                        if (t.globals[e1]) return true;
                    }while (t = t.parent)
                    return false;
                }
                hasReference(e1) {
                    return !!this.getProgramParent().references[e1];
                }
                isPure(e1, t) {
                    if (A(e1)) {
                        const r = this.getBinding(e1.name);
                        if (!r) return false;
                        if (t) return r.constant;
                        return true;
                    } else if (R(e1) || Z(e1) || Q(e1) || ee(e1)) {
                        return true;
                    } else if (b(e1)) {
                        var r;
                        if (e1.superClass && !this.isPure(e1.superClass, t)) {
                            return false;
                        }
                        if (((r = e1.decorators) == null ? void 0 : r.length) > 0) {
                            return false;
                        }
                        return this.isPure(e1.body, t);
                    } else if (T(e1)) {
                        for (const r of e1.body){
                            if (!this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (y(e1)) {
                        return this.isPure(e1.left, t) && this.isPure(e1.right, t);
                    } else if (m(e1) || X(e1)) {
                        for (const r of e1.elements){
                            if (r !== null && !this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (_(e1) || z(e1)) {
                        for (const r of e1.properties){
                            if (!this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (O(e1)) {
                        var n;
                        if (e1.computed && !this.isPure(e1.key, t)) return false;
                        if (((n = e1.decorators) == null ? void 0 : n.length) > 0) {
                            return false;
                        }
                        return true;
                    } else if (D(e1)) {
                        var s;
                        if (e1.computed && !this.isPure(e1.key, t)) return false;
                        if (((s = e1.decorators) == null ? void 0 : s.length) > 0) {
                            return false;
                        }
                        if (Y(e1) || e1.static) {
                            if (e1.value !== null && !this.isPure(e1.value, t)) {
                                return false;
                            }
                        }
                        return true;
                    } else if (U(e1)) {
                        return this.isPure(e1.argument, t);
                    } else if (B(e1)) {
                        for (const r of e1.expressions){
                            if (!this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (F(e1)) {
                        return W(e1.tag, "String.raw") && !this.hasBinding("String", {
                            noGlobals: true
                        }) && this.isPure(e1.quasi, t);
                    } else if (C(e1)) {
                        return !e1.computed && A(e1.object) && e1.object.name === "Symbol" && A(e1.property) && e1.property.name !== "for" && !this.hasBinding("Symbol", {
                            noGlobals: true
                        });
                    } else if (g(e1)) {
                        return W(e1.callee, "Symbol.for") && !this.hasBinding("Symbol", {
                            noGlobals: true
                        }) && e1.arguments.length === 1 && l.isStringLiteral(e1.arguments[0]);
                    } else {
                        return M(e1);
                    }
                }
                setData(e1, t) {
                    return this.data[e1] = t;
                }
                getData(e1) {
                    let t = this;
                    do {
                        const r = t.data[e1];
                        if (r != null) return r;
                    }while (t = t.parent)
                }
                removeData(e1) {
                    let t = this;
                    do {
                        const r = t.data[e1];
                        if (r != null) t.data[e1] = null;
                    }while (t = t.parent)
                }
                init() {
                    if (!this.inited) {
                        this.inited = true;
                        this.crawl();
                    }
                }
                crawl() {
                    const e1 = this.path;
                    resetScope(this);
                    this.data = Object.create(null);
                    let t = this;
                    do {
                        if (t.crawling) return;
                        if (t.path.isProgram()) {
                            break;
                        }
                    }while (t = t.parent)
                    const r = t;
                    const n = {
                        references: [],
                        constantViolations: [],
                        assignments: []
                    };
                    this.crawling = true;
                    ae || (ae = s.default.visitors.merge([
                        {
                            Scope (e1) {
                                resetScope(e1.scope);
                            }
                        },
                        ie
                    ]));
                    if (e1.type !== "Program") {
                        for (const t of ae.enter){
                            t.call(n, e1, n);
                        }
                        const t = ae[e1.type];
                        if (t) {
                            for (const r of t.enter){
                                r.call(n, e1, n);
                            }
                        }
                    }
                    e1.traverse(ae, n);
                    this.crawling = false;
                    for (const e1 of n.assignments){
                        const t = e1.getAssignmentIdentifiers();
                        for (const n of Object.keys(t)){
                            if (e1.scope.getBinding(n)) continue;
                            r.addGlobal(t[n]);
                        }
                        e1.scope.registerConstantViolation(e1);
                    }
                    for (const e1 of n.references){
                        const t = e1.scope.getBinding(e1.node.name);
                        if (t) {
                            t.reference(e1);
                        } else {
                            r.addGlobal(e1.node);
                        }
                    }
                    for (const e1 of n.constantViolations){
                        e1.scope.registerConstantViolation(e1);
                    }
                }
                push(e1) {
                    let t = this.path;
                    if (t.isPattern()) {
                        t = this.getPatternParent().path;
                    } else if (!t.isBlockStatement() && !t.isProgram()) {
                        t = this.getBlockParent().path;
                    }
                    if (t.isSwitchStatement()) {
                        t = (this.getFunctionParent() || this.getProgramParent()).path;
                    }
                    const { init: r, unique: n, kind: s = "var", id: i } = e1;
                    if (!r && !n && (s === "var" || s === "let") && t.isFunction() && !t.node.name && g(t.parent, {
                        callee: t.node
                    }) && t.parent.arguments.length <= t.node.params.length && A(i)) {
                        t.pushContainer("params", i);
                        t.scope.registerBinding("param", t.get("params")[t.node.params.length - 1]);
                        return;
                    }
                    if (t.isLoop() || t.isCatchClause() || t.isFunction()) {
                        t.ensureBlock();
                        t = t.get("body");
                    }
                    const a = e1._blockHoist == null ? 2 : e1._blockHoist;
                    const o = "declaration:".concat(s, ":").concat(a);
                    let l = !n && t.getData(o);
                    if (!l) {
                        const e1 = G(s, []);
                        e1._blockHoist = a;
                        [l] = t.unshiftContainer("body", [
                            e1
                        ]);
                        if (!n) t.setData(o, l);
                    }
                    const c = J(i, r);
                    const p = l.node.declarations.push(c);
                    t.scope.registerBinding(s, l.get("declarations")[p - 1]);
                }
                getProgramParent() {
                    let e1 = this;
                    do {
                        if (e1.path.isProgram()) {
                            return e1;
                        }
                    }while (e1 = e1.parent)
                    throw new Error("Couldn't find a Program");
                }
                getFunctionParent() {
                    let e1 = this;
                    do {
                        if (e1.path.isFunctionParent()) {
                            return e1;
                        }
                    }while (e1 = e1.parent)
                    return null;
                }
                getBlockParent() {
                    let e1 = this;
                    do {
                        if (e1.path.isBlockParent()) {
                            return e1;
                        }
                    }while (e1 = e1.parent)
                    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
                }
                getPatternParent() {
                    let e1 = this;
                    do {
                        if (!e1.path.isPattern()) {
                            return e1.getBlockParent();
                        }
                    }while (e1 = e1.parent.parent)
                    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
                }
                getAllBindings() {
                    const e1 = Object.create(null);
                    let t = this;
                    do {
                        for (const r of Object.keys(t.bindings)){
                            if (r in e1 === false) {
                                e1[r] = t.bindings[r];
                            }
                        }
                        t = t.parent;
                    }while (t)
                    return e1;
                }
                bindingIdentifierEquals(e1, t) {
                    return this.getBindingIdentifier(e1) === t;
                }
                getBinding(e1) {
                    let t = this;
                    let r;
                    do {
                        const s = t.getOwnBinding(e1);
                        if (s) {
                            var n;
                            if ((n = r) != null && n.isPattern() && s.kind !== "param" && s.kind !== "local") {} else {
                                return s;
                            }
                        } else if (!s && e1 === "arguments" && t.path.isFunction() && !t.path.isArrowFunctionExpression()) {
                            break;
                        }
                        r = t.path;
                    }while (t = t.parent)
                }
                getOwnBinding(e1) {
                    return this.bindings[e1];
                }
                getBindingIdentifier(e1) {
                    var t;
                    return (t = this.getBinding(e1)) == null ? void 0 : t.identifier;
                }
                getOwnBindingIdentifier(e1) {
                    const t = this.bindings[e1];
                    return t == null ? void 0 : t.identifier;
                }
                hasOwnBinding(e1) {
                    return !!this.getOwnBinding(e1);
                }
                hasBinding(e1, t) {
                    if (!e1) return false;
                    let r;
                    let n;
                    let s;
                    if (typeof t === "object") {
                        r = t.noGlobals;
                        n = t.noUids;
                        s = t.upToScope;
                    } else if (typeof t === "boolean") {
                        r = t;
                    }
                    let i = this;
                    do {
                        if (s === i) {
                            break;
                        }
                        if (i.hasOwnBinding(e1)) {
                            return true;
                        }
                    }while (i = i.parent)
                    if (!n && this.hasUid(e1)) return true;
                    if (!r && Scope.globals.includes(e1)) return true;
                    if (!r && Scope.contextVariables.includes(e1)) return true;
                    return false;
                }
                parentHasBinding(e1, t) {
                    var r;
                    return (r = this.parent) == null ? void 0 : r.hasBinding(e1, t);
                }
                moveBindingTo(e1, t) {
                    const r = this.getBinding(e1);
                    if (r) {
                        r.scope.removeOwnBinding(e1);
                        r.scope = t;
                        t.bindings[e1] = r;
                    }
                }
                removeOwnBinding(e1) {
                    delete this.bindings[e1];
                }
                removeBinding(e1) {
                    var t;
                    (t = this.getBinding(e1)) == null || t.scope.removeOwnBinding(e1);
                    let r = this;
                    do {
                        if (r.uids[e1]) {
                            r.uids[e1] = false;
                        }
                    }while (r = r.parent)
                }
                hoistVariables() {
                    let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (e1)=>this.push({
                            id: e1
                        });
                    this.crawl();
                    const t = new Set;
                    for (const r of Object.keys(this.bindings)){
                        const n = this.bindings[r];
                        if (!n) continue;
                        const { path: s } = n;
                        if (!s.isVariableDeclarator()) continue;
                        const { parent: i, parentPath: a } = s;
                        if (i.kind !== "var" || t.has(i)) continue;
                        t.add(s.parent);
                        let o;
                        const l = [];
                        for (const t of i.declarations){
                            o != null ? o : o = t.id;
                            if (t.init) {
                                l.push(p("=", t.id, t.init));
                            }
                            const r = Object.keys(f(t, false, true, true));
                            for (const n of r){
                                e1(h(n), t.init != null);
                            }
                        }
                        if (a.parentPath.isFor({
                            left: i
                        })) {
                            a.replaceWith(o);
                        } else if (l.length === 0) {
                            a.remove();
                        } else {
                            const e1 = l.length === 1 ? l[0] : ne(l);
                            if (a.parentPath.isForStatement({
                                init: i
                            })) {
                                a.replaceWith(e1);
                            } else {
                                a.replaceWith(V(e1));
                            }
                        }
                    }
                }
                constructor(e1){
                    this.uid = void 0;
                    this.path = void 0;
                    this.block = void 0;
                    this.inited = void 0;
                    this.labels = void 0;
                    this.bindings = void 0;
                    this.references = void 0;
                    this.globals = void 0;
                    this.uids = void 0;
                    this.data = void 0;
                    this.crawling = void 0;
                    const { node: t } = e1;
                    const r = c.scope.get(t);
                    if ((r == null ? void 0 : r.path) === e1) {
                        return r;
                    }
                    c.scope.set(t, this);
                    this.uid = oe++;
                    this.block = t;
                    this.path = e1;
                    this.labels = new Map;
                    this.inited = false;
                }
            }
            t["default"] = Scope;
            Scope.globals = Object.keys(a.builtin);
            Scope.contextVariables = [
                "arguments",
                "undefined",
                "Infinity",
                "NaN"
            ];
            {
                Scope.prototype._renameFromMap = function _renameFromMap(e1, t, r, n) {
                    if (e1[t]) {
                        e1[r] = n;
                        e1[t] = null;
                    }
                };
                Scope.prototype.traverse = function(e1, t, r) {
                    (0, s.default)(e1, t, this, r, this.path);
                };
                Scope.prototype._generateUid = function _generateUid(e1, t) {
                    let r = e1;
                    if (t > 1) r += t;
                    return "_".concat(r);
                };
                Scope.prototype.toArray = function toArray(e1, t, r) {
                    if (A(e1)) {
                        const t = this.getBinding(e1.name);
                        if (t != null && t.constant && t.path.isGenericType("Array")) {
                            return e1;
                        }
                    }
                    if (m(e1)) {
                        return e1;
                    }
                    if (A(e1, {
                        name: "arguments"
                    })) {
                        return u($($($(h("Array"), h("prototype")), h("slice")), h("call")), [
                            e1
                        ]);
                    }
                    let n;
                    const s = [
                        e1
                    ];
                    if (t === true) {
                        n = "toConsumableArray";
                    } else if (typeof t === "number") {
                        s.push(q(t));
                        n = "slicedToArray";
                    } else {
                        n = "toArray";
                    }
                    if (r) {
                        s.unshift(this.path.hub.addHelper(n));
                        n = "maybeArrayLike";
                    }
                    return u(this.path.hub.addHelper(n), s);
                };
                Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
                    for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                        e1[_key] = arguments[_key];
                    }
                    const t = Object.create(null);
                    for (const r of e1){
                        let e1 = this;
                        do {
                            for (const n of Object.keys(e1.bindings)){
                                const s = e1.bindings[n];
                                if (s.kind === r) t[n] = s;
                            }
                            e1 = e1.parent;
                        }while (e1)
                    }
                    return t;
                };
                Object.defineProperties(Scope.prototype, {
                    parentBlock: {
                        configurable: true,
                        enumerable: true,
                        get () {
                            return this.path.parent;
                        }
                    },
                    hub: {
                        configurable: true,
                        enumerable: true,
                        get () {
                            return this.path.hub;
                        }
                    }
                });
            }
        },
        3855: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(3061);
            var s = n;
            var i = r(6265);
            var a = r(5621);
            var o = r(4144);
            const { getAssignmentIdentifiers: l } = s;
            const c = {
                ReferencedIdentifier (param, t) {
                    let { node: e1 } = param;
                    if (e1.name === t.oldName) {
                        e1.name = t.newName;
                    }
                },
                Scope (e1, t) {
                    if (!e1.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier)) {
                        e1.skip();
                        if (e1.isMethod()) {
                            if (!e1.requeueComputedKeyAndDecorators) {
                                o.requeueComputedKeyAndDecorators.call(e1);
                            } else {
                                e1.requeueComputedKeyAndDecorators();
                            }
                        }
                    }
                },
                ObjectProperty (param, r) {
                    let { node: e1, scope: t } = param;
                    const { name: n } = e1.key;
                    if (e1.shorthand && (n === r.oldName || n === r.newName) && t.getBindingIdentifier(n) === r.binding.identifier) {
                        e1.shorthand = false;
                        {
                            var s;
                            if ((s = e1.extra) != null && s.shorthand) e1.extra.shorthand = false;
                        }
                    }
                },
                "AssignmentExpression|Declaration|VariableDeclarator" (e1, t) {
                    if (e1.isVariableDeclaration()) return;
                    const r = e1.isAssignmentExpression() ? l(e1.node) : e1.getOuterBindingIdentifiers();
                    for(const e1 in r){
                        if (e1 === t.oldName) r[e1].name = t.newName;
                    }
                }
            };
            class Renamer {
                maybeConvertFromExportDeclaration(e1) {
                    const t = e1.parentPath;
                    if (!t.isExportDeclaration()) {
                        return;
                    }
                    if (t.isExportDefaultDeclaration()) {
                        const { declaration: e1 } = t.node;
                        if (n.isDeclaration(e1) && !e1.id) {
                            return;
                        }
                    }
                    if (t.isExportAllDeclaration()) {
                        return;
                    }
                    t.splitExportDeclaration();
                }
                maybeConvertFromClassFunctionDeclaration(e1) {
                    return e1;
                }
                maybeConvertFromClassFunctionExpression(e1) {
                    return e1;
                }
                rename() {
                    const { binding: e1, oldName: t, newName: r } = this;
                    const { scope: s, path: o } = e1;
                    const l = o.find((e1)=>e1.isDeclaration() || e1.isFunctionExpression() || e1.isClassExpression());
                    if (l) {
                        const r = l.getOuterBindingIdentifiers();
                        if (r[t] === e1.identifier) {
                            this.maybeConvertFromExportDeclaration(l);
                        }
                    }
                    const p = arguments[0] || s.block;
                    const u = {
                        discriminant: true
                    };
                    if (n.isMethod(p)) {
                        if (p.computed) {
                            u.key = true;
                        }
                        if (!n.isObjectMethod(p)) {
                            u.decorators = true;
                        }
                    }
                    (0, i.traverseNode)(p, (0, a.explode)(c), s, this, s.path, u);
                    if (!arguments[0]) {
                        s.removeOwnBinding(t);
                        s.bindings[r] = e1;
                        this.binding.identifier.name = r;
                    }
                    if (l) {
                        this.maybeConvertFromClassFunctionDeclaration(o);
                        this.maybeConvertFromClassFunctionExpression(o);
                    }
                }
                constructor(e1, t, r){
                    this.newName = r;
                    this.oldName = t;
                    this.binding = e1;
                }
            }
            t["default"] = Renamer;
        },
        6265: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.traverseNode = traverseNode;
            var n = r(5530);
            var s = r(3061);
            const { VISITOR_KEYS: i } = s;
            function traverseNode(e1, t, r, s, a, o, l) {
                const c = i[e1.type];
                if (!c) return false;
                const p = new n.default(r, t, s, a);
                if (l) {
                    if (o != null && o[a.parentKey]) return false;
                    return p.visitQueue([
                        a
                    ]);
                }
                for (const t of c){
                    if (o != null && o[t]) continue;
                    if (p.visit(e1, t)) {
                        return true;
                    }
                }
                return false;
            }
        },
        5621: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.environmentVisitor = environmentVisitor;
            t.explode = explode$1;
            t.isExplodedVisitor = isExplodedVisitor;
            t.merge = merge;
            t.verify = verify$1;
            var n = r(2490);
            var s = r(3053);
            var i = r(3061);
            var a = r(4144);
            const { DEPRECATED_KEYS: o, DEPRECATED_ALIASES: l, FLIPPED_ALIAS_KEYS: c, TYPES: p, __internal__deprecationWarning: u } = i;
            function isVirtualType(e1) {
                return e1 in n;
            }
            function isExplodedVisitor(e1) {
                return e1 == null ? void 0 : e1._exploded;
            }
            function explode$1(e1) {
                if (isExplodedVisitor(e1)) return e1;
                e1._exploded = true;
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    const r = t.split("|");
                    if (r.length === 1) continue;
                    const n = e1[t];
                    delete e1[t];
                    for (const t of r){
                        e1[t] = n;
                    }
                }
                verify$1(e1);
                delete e1.__esModule;
                ensureEntranceObjects(e1);
                ensureCallbackArrays(e1);
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    if (!isVirtualType(t)) continue;
                    const r = e1[t];
                    for (const e1 of Object.keys(r)){
                        r[e1] = wrapCheck(t, r[e1]);
                    }
                    delete e1[t];
                    const s = n[t];
                    if (s !== null) {
                        for (const t of s){
                            if (e1[t]) {
                                mergePair(e1[t], r);
                            } else {
                                e1[t] = r;
                            }
                        }
                    } else {
                        mergePair(e1, r);
                    }
                }
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    let r = c[t];
                    if (t in o) {
                        const e1 = o[t];
                        u(t, e1, "Visitor ");
                        r = [
                            e1
                        ];
                    } else if (t in l) {
                        const e1 = l[t];
                        u(t, e1, "Visitor ");
                        r = c[e1];
                    }
                    if (!r) continue;
                    const n = e1[t];
                    delete e1[t];
                    for (const t of r){
                        const r = e1[t];
                        if (r) {
                            mergePair(r, n);
                        } else {
                            e1[t] = Object.assign({}, n);
                        }
                    }
                }
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    ensureCallbackArrays(e1[t]);
                }
                return e1;
            }
            function verify$1(e1) {
                if (e1._verified) return;
                if (typeof e1 === "function") {
                    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
                }
                for (const t of Object.keys(e1)){
                    if (t === "enter" || t === "exit") {
                        validateVisitorMethods(t, e1[t]);
                    }
                    if (shouldIgnoreKey(t)) continue;
                    if (!p.includes(t)) {
                        throw new Error("You gave us a visitor for the node type ".concat(t, " but it's not a valid type in @babel/traverse ", "7.27.0"));
                    }
                    const r = e1[t];
                    if (typeof r === "object") {
                        for (const e1 of Object.keys(r)){
                            if (e1 === "enter" || e1 === "exit") {
                                validateVisitorMethods("".concat(t, ".").concat(e1), r[e1]);
                            } else {
                                throw new Error("You passed `traverse()` a visitor object with the property " + "".concat(t, " that has the invalid property ").concat(e1));
                            }
                        }
                    }
                }
                e1._verified = true;
            }
            function validateVisitorMethods(e1, t) {
                const r = [].concat(t);
                for (const t of r){
                    if (typeof t !== "function") {
                        throw new TypeError("Non-function found defined in ".concat(e1, " with type ").concat(typeof t));
                    }
                }
            }
            function merge(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 ? arguments[2] : void 0;
                const n = {
                    _verified: true,
                    _exploded: true
                };
                {
                    Object.defineProperty(n, "_exploded", {
                        enumerable: false
                    });
                    Object.defineProperty(n, "_verified", {
                        enumerable: false
                    });
                }
                for(let s = 0; s < e1.length; s++){
                    const i = explode$1(e1[s]);
                    const a = t[s];
                    let o = i;
                    if (a || r) {
                        o = wrapWithStateOrWrapper(o, a, r);
                    }
                    mergePair(n, o);
                    for (const e1 of Object.keys(i)){
                        if (shouldIgnoreKey(e1)) continue;
                        let t = i[e1];
                        if (a || r) {
                            t = wrapWithStateOrWrapper(t, a, r);
                        }
                        const s = n[e1] || (n[e1] = {});
                        mergePair(s, t);
                    }
                }
                return n;
            }
            function wrapWithStateOrWrapper(e1, t, r) {
                const n = {};
                for (const s of [
                    "enter",
                    "exit"
                ]){
                    let i = e1[s];
                    if (!Array.isArray(i)) continue;
                    i = i.map(function(e1) {
                        let n = e1;
                        if (t) {
                            n = function(r) {
                                e1.call(t, r, t);
                            };
                        }
                        if (r) {
                            n = r(t == null ? void 0 : t.key, s, n);
                        }
                        if (n !== e1) {
                            n.toString = ()=>e1.toString();
                        }
                        return n;
                    });
                    n[s] = i;
                }
                return n;
            }
            function ensureEntranceObjects(e1) {
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    const r = e1[t];
                    if (typeof r === "function") {
                        e1[t] = {
                            enter: r
                        };
                    }
                }
            }
            function ensureCallbackArrays(e1) {
                if (e1.enter && !Array.isArray(e1.enter)) e1.enter = [
                    e1.enter
                ];
                if (e1.exit && !Array.isArray(e1.exit)) e1.exit = [
                    e1.exit
                ];
            }
            function wrapCheck(e1, t) {
                const r = "is".concat(e1);
                const n = s[r];
                const newFn = function(e1) {
                    if (n.call(e1)) {
                        return t.apply(this, arguments);
                    }
                };
                newFn.toString = ()=>t.toString();
                return newFn;
            }
            function shouldIgnoreKey(e1) {
                if (e1[0] === "_") return true;
                if (e1 === "enter" || e1 === "exit" || e1 === "shouldSkip") return true;
                if (e1 === "denylist" || e1 === "noScope" || e1 === "skipKeys") {
                    return true;
                }
                {
                    if (e1 === "blacklist") {
                        return true;
                    }
                }
                return false;
            }
            function mergePair(e1, t) {
                for (const r of [
                    "enter",
                    "exit"
                ]){
                    if (!t[r]) continue;
                    e1[r] = [].concat(e1[r] || [], t[r]);
                }
            }
            const d = {
                FunctionParent (e1) {
                    if (e1.isArrowFunctionExpression()) return;
                    e1.skip();
                    if (e1.isMethod()) {
                        if (!e1.requeueComputedKeyAndDecorators) {
                            a.requeueComputedKeyAndDecorators.call(e1);
                        } else {
                            e1.requeueComputedKeyAndDecorators();
                        }
                    }
                },
                Property (e1) {
                    if (e1.isObjectProperty()) return;
                    e1.skip();
                    if (!e1.requeueComputedKeyAndDecorators) {
                        a.requeueComputedKeyAndDecorators.call(e1);
                    } else {
                        e1.requeueComputedKeyAndDecorators();
                    }
                }
            };
            function environmentVisitor(e1) {
                return merge([
                    d,
                    e1
                ]);
            }
        },
        2856: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = assertNode;
            var n = r(6087);
            function assertNode(e1) {
                if (!(0, n.default)(e1)) {
                    var t;
                    const r = (t = e1 == null ? void 0 : e1.type) != null ? t : JSON.stringify(e1);
                    throw new TypeError('Not a valid node of type "'.concat(r, '"'));
                }
            }
        },
        1501: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assertAccessor = assertAccessor;
            t.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
            t.assertArgumentPlaceholder = assertArgumentPlaceholder;
            t.assertArrayExpression = assertArrayExpression;
            t.assertArrayPattern = assertArrayPattern;
            t.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
            t.assertArrowFunctionExpression = assertArrowFunctionExpression;
            t.assertAssignmentExpression = assertAssignmentExpression;
            t.assertAssignmentPattern = assertAssignmentPattern;
            t.assertAwaitExpression = assertAwaitExpression;
            t.assertBigIntLiteral = assertBigIntLiteral;
            t.assertBinary = assertBinary;
            t.assertBinaryExpression = assertBinaryExpression;
            t.assertBindExpression = assertBindExpression;
            t.assertBlock = assertBlock;
            t.assertBlockParent = assertBlockParent;
            t.assertBlockStatement = assertBlockStatement;
            t.assertBooleanLiteral = assertBooleanLiteral;
            t.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
            t.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
            t.assertBreakStatement = assertBreakStatement;
            t.assertCallExpression = assertCallExpression;
            t.assertCatchClause = assertCatchClause;
            t.assertClass = assertClass;
            t.assertClassAccessorProperty = assertClassAccessorProperty;
            t.assertClassBody = assertClassBody;
            t.assertClassDeclaration = assertClassDeclaration;
            t.assertClassExpression = assertClassExpression;
            t.assertClassImplements = assertClassImplements;
            t.assertClassMethod = assertClassMethod;
            t.assertClassPrivateMethod = assertClassPrivateMethod;
            t.assertClassPrivateProperty = assertClassPrivateProperty;
            t.assertClassProperty = assertClassProperty;
            t.assertCompletionStatement = assertCompletionStatement;
            t.assertConditional = assertConditional;
            t.assertConditionalExpression = assertConditionalExpression;
            t.assertContinueStatement = assertContinueStatement;
            t.assertDebuggerStatement = assertDebuggerStatement;
            t.assertDecimalLiteral = assertDecimalLiteral;
            t.assertDeclaration = assertDeclaration;
            t.assertDeclareClass = assertDeclareClass;
            t.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
            t.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
            t.assertDeclareFunction = assertDeclareFunction;
            t.assertDeclareInterface = assertDeclareInterface;
            t.assertDeclareModule = assertDeclareModule;
            t.assertDeclareModuleExports = assertDeclareModuleExports;
            t.assertDeclareOpaqueType = assertDeclareOpaqueType;
            t.assertDeclareTypeAlias = assertDeclareTypeAlias;
            t.assertDeclareVariable = assertDeclareVariable;
            t.assertDeclaredPredicate = assertDeclaredPredicate;
            t.assertDecorator = assertDecorator;
            t.assertDirective = assertDirective;
            t.assertDirectiveLiteral = assertDirectiveLiteral;
            t.assertDoExpression = assertDoExpression;
            t.assertDoWhileStatement = assertDoWhileStatement;
            t.assertEmptyStatement = assertEmptyStatement;
            t.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
            t.assertEnumBody = assertEnumBody;
            t.assertEnumBooleanBody = assertEnumBooleanBody;
            t.assertEnumBooleanMember = assertEnumBooleanMember;
            t.assertEnumDeclaration = assertEnumDeclaration;
            t.assertEnumDefaultedMember = assertEnumDefaultedMember;
            t.assertEnumMember = assertEnumMember;
            t.assertEnumNumberBody = assertEnumNumberBody;
            t.assertEnumNumberMember = assertEnumNumberMember;
            t.assertEnumStringBody = assertEnumStringBody;
            t.assertEnumStringMember = assertEnumStringMember;
            t.assertEnumSymbolBody = assertEnumSymbolBody;
            t.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
            t.assertExportAllDeclaration = assertExportAllDeclaration;
            t.assertExportDeclaration = assertExportDeclaration;
            t.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
            t.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
            t.assertExportNamedDeclaration = assertExportNamedDeclaration;
            t.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
            t.assertExportSpecifier = assertExportSpecifier;
            t.assertExpression = assertExpression;
            t.assertExpressionStatement = assertExpressionStatement;
            t.assertExpressionWrapper = assertExpressionWrapper;
            t.assertFile = assertFile;
            t.assertFlow = assertFlow;
            t.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
            t.assertFlowDeclaration = assertFlowDeclaration;
            t.assertFlowPredicate = assertFlowPredicate;
            t.assertFlowType = assertFlowType;
            t.assertFor = assertFor;
            t.assertForInStatement = assertForInStatement;
            t.assertForOfStatement = assertForOfStatement;
            t.assertForStatement = assertForStatement;
            t.assertForXStatement = assertForXStatement;
            t.assertFunction = assertFunction;
            t.assertFunctionDeclaration = assertFunctionDeclaration;
            t.assertFunctionExpression = assertFunctionExpression;
            t.assertFunctionParent = assertFunctionParent;
            t.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
            t.assertFunctionTypeParam = assertFunctionTypeParam;
            t.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
            t.assertIdentifier = assertIdentifier;
            t.assertIfStatement = assertIfStatement;
            t.assertImmutable = assertImmutable;
            t.assertImport = assertImport;
            t.assertImportAttribute = assertImportAttribute;
            t.assertImportDeclaration = assertImportDeclaration;
            t.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
            t.assertImportExpression = assertImportExpression;
            t.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
            t.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
            t.assertImportSpecifier = assertImportSpecifier;
            t.assertIndexedAccessType = assertIndexedAccessType;
            t.assertInferredPredicate = assertInferredPredicate;
            t.assertInterfaceDeclaration = assertInterfaceDeclaration;
            t.assertInterfaceExtends = assertInterfaceExtends;
            t.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
            t.assertInterpreterDirective = assertInterpreterDirective;
            t.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
            t.assertJSX = assertJSX;
            t.assertJSXAttribute = assertJSXAttribute;
            t.assertJSXClosingElement = assertJSXClosingElement;
            t.assertJSXClosingFragment = assertJSXClosingFragment;
            t.assertJSXElement = assertJSXElement;
            t.assertJSXEmptyExpression = assertJSXEmptyExpression;
            t.assertJSXExpressionContainer = assertJSXExpressionContainer;
            t.assertJSXFragment = assertJSXFragment;
            t.assertJSXIdentifier = assertJSXIdentifier;
            t.assertJSXMemberExpression = assertJSXMemberExpression;
            t.assertJSXNamespacedName = assertJSXNamespacedName;
            t.assertJSXOpeningElement = assertJSXOpeningElement;
            t.assertJSXOpeningFragment = assertJSXOpeningFragment;
            t.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
            t.assertJSXSpreadChild = assertJSXSpreadChild;
            t.assertJSXText = assertJSXText;
            t.assertLVal = assertLVal;
            t.assertLabeledStatement = assertLabeledStatement;
            t.assertLiteral = assertLiteral;
            t.assertLogicalExpression = assertLogicalExpression;
            t.assertLoop = assertLoop;
            t.assertMemberExpression = assertMemberExpression;
            t.assertMetaProperty = assertMetaProperty;
            t.assertMethod = assertMethod;
            t.assertMiscellaneous = assertMiscellaneous;
            t.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
            t.assertModuleDeclaration = assertModuleDeclaration;
            t.assertModuleExpression = assertModuleExpression;
            t.assertModuleSpecifier = assertModuleSpecifier;
            t.assertNewExpression = assertNewExpression;
            t.assertNoop = assertNoop;
            t.assertNullLiteral = assertNullLiteral;
            t.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
            t.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
            t.assertNumberLiteral = assertNumberLiteral;
            t.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
            t.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
            t.assertNumericLiteral = assertNumericLiteral;
            t.assertObjectExpression = assertObjectExpression;
            t.assertObjectMember = assertObjectMember;
            t.assertObjectMethod = assertObjectMethod;
            t.assertObjectPattern = assertObjectPattern;
            t.assertObjectProperty = assertObjectProperty;
            t.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
            t.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
            t.assertObjectTypeIndexer = assertObjectTypeIndexer;
            t.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
            t.assertObjectTypeProperty = assertObjectTypeProperty;
            t.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
            t.assertOpaqueType = assertOpaqueType;
            t.assertOptionalCallExpression = assertOptionalCallExpression;
            t.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
            t.assertOptionalMemberExpression = assertOptionalMemberExpression;
            t.assertParenthesizedExpression = assertParenthesizedExpression;
            t.assertPattern = assertPattern;
            t.assertPatternLike = assertPatternLike;
            t.assertPipelineBareFunction = assertPipelineBareFunction;
            t.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
            t.assertPipelineTopicExpression = assertPipelineTopicExpression;
            t.assertPlaceholder = assertPlaceholder;
            t.assertPrivate = assertPrivate;
            t.assertPrivateName = assertPrivateName;
            t.assertProgram = assertProgram;
            t.assertProperty = assertProperty;
            t.assertPureish = assertPureish;
            t.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
            t.assertRecordExpression = assertRecordExpression;
            t.assertRegExpLiteral = assertRegExpLiteral;
            t.assertRegexLiteral = assertRegexLiteral;
            t.assertRestElement = assertRestElement;
            t.assertRestProperty = assertRestProperty;
            t.assertReturnStatement = assertReturnStatement;
            t.assertScopable = assertScopable;
            t.assertSequenceExpression = assertSequenceExpression;
            t.assertSpreadElement = assertSpreadElement;
            t.assertSpreadProperty = assertSpreadProperty;
            t.assertStandardized = assertStandardized;
            t.assertStatement = assertStatement;
            t.assertStaticBlock = assertStaticBlock;
            t.assertStringLiteral = assertStringLiteral;
            t.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
            t.assertStringTypeAnnotation = assertStringTypeAnnotation;
            t.assertSuper = assertSuper;
            t.assertSwitchCase = assertSwitchCase;
            t.assertSwitchStatement = assertSwitchStatement;
            t.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
            t.assertTSAnyKeyword = assertTSAnyKeyword;
            t.assertTSArrayType = assertTSArrayType;
            t.assertTSAsExpression = assertTSAsExpression;
            t.assertTSBaseType = assertTSBaseType;
            t.assertTSBigIntKeyword = assertTSBigIntKeyword;
            t.assertTSBooleanKeyword = assertTSBooleanKeyword;
            t.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
            t.assertTSConditionalType = assertTSConditionalType;
            t.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
            t.assertTSConstructorType = assertTSConstructorType;
            t.assertTSDeclareFunction = assertTSDeclareFunction;
            t.assertTSDeclareMethod = assertTSDeclareMethod;
            t.assertTSEntityName = assertTSEntityName;
            t.assertTSEnumBody = assertTSEnumBody;
            t.assertTSEnumDeclaration = assertTSEnumDeclaration;
            t.assertTSEnumMember = assertTSEnumMember;
            t.assertTSExportAssignment = assertTSExportAssignment;
            t.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
            t.assertTSExternalModuleReference = assertTSExternalModuleReference;
            t.assertTSFunctionType = assertTSFunctionType;
            t.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
            t.assertTSImportType = assertTSImportType;
            t.assertTSIndexSignature = assertTSIndexSignature;
            t.assertTSIndexedAccessType = assertTSIndexedAccessType;
            t.assertTSInferType = assertTSInferType;
            t.assertTSInstantiationExpression = assertTSInstantiationExpression;
            t.assertTSInterfaceBody = assertTSInterfaceBody;
            t.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
            t.assertTSIntersectionType = assertTSIntersectionType;
            t.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
            t.assertTSLiteralType = assertTSLiteralType;
            t.assertTSMappedType = assertTSMappedType;
            t.assertTSMethodSignature = assertTSMethodSignature;
            t.assertTSModuleBlock = assertTSModuleBlock;
            t.assertTSModuleDeclaration = assertTSModuleDeclaration;
            t.assertTSNamedTupleMember = assertTSNamedTupleMember;
            t.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
            t.assertTSNeverKeyword = assertTSNeverKeyword;
            t.assertTSNonNullExpression = assertTSNonNullExpression;
            t.assertTSNullKeyword = assertTSNullKeyword;
            t.assertTSNumberKeyword = assertTSNumberKeyword;
            t.assertTSObjectKeyword = assertTSObjectKeyword;
            t.assertTSOptionalType = assertTSOptionalType;
            t.assertTSParameterProperty = assertTSParameterProperty;
            t.assertTSParenthesizedType = assertTSParenthesizedType;
            t.assertTSPropertySignature = assertTSPropertySignature;
            t.assertTSQualifiedName = assertTSQualifiedName;
            t.assertTSRestType = assertTSRestType;
            t.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
            t.assertTSStringKeyword = assertTSStringKeyword;
            t.assertTSSymbolKeyword = assertTSSymbolKeyword;
            t.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
            t.assertTSThisType = assertTSThisType;
            t.assertTSTupleType = assertTSTupleType;
            t.assertTSType = assertTSType;
            t.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
            t.assertTSTypeAnnotation = assertTSTypeAnnotation;
            t.assertTSTypeAssertion = assertTSTypeAssertion;
            t.assertTSTypeElement = assertTSTypeElement;
            t.assertTSTypeLiteral = assertTSTypeLiteral;
            t.assertTSTypeOperator = assertTSTypeOperator;
            t.assertTSTypeParameter = assertTSTypeParameter;
            t.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
            t.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
            t.assertTSTypePredicate = assertTSTypePredicate;
            t.assertTSTypeQuery = assertTSTypeQuery;
            t.assertTSTypeReference = assertTSTypeReference;
            t.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
            t.assertTSUnionType = assertTSUnionType;
            t.assertTSUnknownKeyword = assertTSUnknownKeyword;
            t.assertTSVoidKeyword = assertTSVoidKeyword;
            t.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
            t.assertTemplateElement = assertTemplateElement;
            t.assertTemplateLiteral = assertTemplateLiteral;
            t.assertTerminatorless = assertTerminatorless;
            t.assertThisExpression = assertThisExpression;
            t.assertThisTypeAnnotation = assertThisTypeAnnotation;
            t.assertThrowStatement = assertThrowStatement;
            t.assertTopicReference = assertTopicReference;
            t.assertTryStatement = assertTryStatement;
            t.assertTupleExpression = assertTupleExpression;
            t.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
            t.assertTypeAlias = assertTypeAlias;
            t.assertTypeAnnotation = assertTypeAnnotation;
            t.assertTypeCastExpression = assertTypeCastExpression;
            t.assertTypeParameter = assertTypeParameter;
            t.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
            t.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
            t.assertTypeScript = assertTypeScript;
            t.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
            t.assertUnaryExpression = assertUnaryExpression;
            t.assertUnaryLike = assertUnaryLike;
            t.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
            t.assertUpdateExpression = assertUpdateExpression;
            t.assertUserWhitespacable = assertUserWhitespacable;
            t.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
            t.assertVariableDeclaration = assertVariableDeclaration;
            t.assertVariableDeclarator = assertVariableDeclarator;
            t.assertVariance = assertVariance;
            t.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
            t.assertWhile = assertWhile;
            t.assertWhileStatement = assertWhileStatement;
            t.assertWithStatement = assertWithStatement;
            t.assertYieldExpression = assertYieldExpression;
            var n = r(7670);
            var s = r(8760);
            function assert(e1, t, r) {
                if (!(0, n.default)(e1, t, r)) {
                    throw new Error('Expected type "'.concat(e1, '" with option ').concat(JSON.stringify(r), ", ") + 'but instead got "'.concat(t.type, '".'));
                }
            }
            function assertArrayExpression(e1, t) {
                assert("ArrayExpression", e1, t);
            }
            function assertAssignmentExpression(e1, t) {
                assert("AssignmentExpression", e1, t);
            }
            function assertBinaryExpression(e1, t) {
                assert("BinaryExpression", e1, t);
            }
            function assertInterpreterDirective(e1, t) {
                assert("InterpreterDirective", e1, t);
            }
            function assertDirective(e1, t) {
                assert("Directive", e1, t);
            }
            function assertDirectiveLiteral(e1, t) {
                assert("DirectiveLiteral", e1, t);
            }
            function assertBlockStatement(e1, t) {
                assert("BlockStatement", e1, t);
            }
            function assertBreakStatement(e1, t) {
                assert("BreakStatement", e1, t);
            }
            function assertCallExpression(e1, t) {
                assert("CallExpression", e1, t);
            }
            function assertCatchClause(e1, t) {
                assert("CatchClause", e1, t);
            }
            function assertConditionalExpression(e1, t) {
                assert("ConditionalExpression", e1, t);
            }
            function assertContinueStatement(e1, t) {
                assert("ContinueStatement", e1, t);
            }
            function assertDebuggerStatement(e1, t) {
                assert("DebuggerStatement", e1, t);
            }
            function assertDoWhileStatement(e1, t) {
                assert("DoWhileStatement", e1, t);
            }
            function assertEmptyStatement(e1, t) {
                assert("EmptyStatement", e1, t);
            }
            function assertExpressionStatement(e1, t) {
                assert("ExpressionStatement", e1, t);
            }
            function assertFile(e1, t) {
                assert("File", e1, t);
            }
            function assertForInStatement(e1, t) {
                assert("ForInStatement", e1, t);
            }
            function assertForStatement(e1, t) {
                assert("ForStatement", e1, t);
            }
            function assertFunctionDeclaration(e1, t) {
                assert("FunctionDeclaration", e1, t);
            }
            function assertFunctionExpression(e1, t) {
                assert("FunctionExpression", e1, t);
            }
            function assertIdentifier(e1, t) {
                assert("Identifier", e1, t);
            }
            function assertIfStatement(e1, t) {
                assert("IfStatement", e1, t);
            }
            function assertLabeledStatement(e1, t) {
                assert("LabeledStatement", e1, t);
            }
            function assertStringLiteral(e1, t) {
                assert("StringLiteral", e1, t);
            }
            function assertNumericLiteral(e1, t) {
                assert("NumericLiteral", e1, t);
            }
            function assertNullLiteral(e1, t) {
                assert("NullLiteral", e1, t);
            }
            function assertBooleanLiteral(e1, t) {
                assert("BooleanLiteral", e1, t);
            }
            function assertRegExpLiteral(e1, t) {
                assert("RegExpLiteral", e1, t);
            }
            function assertLogicalExpression(e1, t) {
                assert("LogicalExpression", e1, t);
            }
            function assertMemberExpression(e1, t) {
                assert("MemberExpression", e1, t);
            }
            function assertNewExpression(e1, t) {
                assert("NewExpression", e1, t);
            }
            function assertProgram(e1, t) {
                assert("Program", e1, t);
            }
            function assertObjectExpression(e1, t) {
                assert("ObjectExpression", e1, t);
            }
            function assertObjectMethod(e1, t) {
                assert("ObjectMethod", e1, t);
            }
            function assertObjectProperty(e1, t) {
                assert("ObjectProperty", e1, t);
            }
            function assertRestElement(e1, t) {
                assert("RestElement", e1, t);
            }
            function assertReturnStatement(e1, t) {
                assert("ReturnStatement", e1, t);
            }
            function assertSequenceExpression(e1, t) {
                assert("SequenceExpression", e1, t);
            }
            function assertParenthesizedExpression(e1, t) {
                assert("ParenthesizedExpression", e1, t);
            }
            function assertSwitchCase(e1, t) {
                assert("SwitchCase", e1, t);
            }
            function assertSwitchStatement(e1, t) {
                assert("SwitchStatement", e1, t);
            }
            function assertThisExpression(e1, t) {
                assert("ThisExpression", e1, t);
            }
            function assertThrowStatement(e1, t) {
                assert("ThrowStatement", e1, t);
            }
            function assertTryStatement(e1, t) {
                assert("TryStatement", e1, t);
            }
            function assertUnaryExpression(e1, t) {
                assert("UnaryExpression", e1, t);
            }
            function assertUpdateExpression(e1, t) {
                assert("UpdateExpression", e1, t);
            }
            function assertVariableDeclaration(e1, t) {
                assert("VariableDeclaration", e1, t);
            }
            function assertVariableDeclarator(e1, t) {
                assert("VariableDeclarator", e1, t);
            }
            function assertWhileStatement(e1, t) {
                assert("WhileStatement", e1, t);
            }
            function assertWithStatement(e1, t) {
                assert("WithStatement", e1, t);
            }
            function assertAssignmentPattern(e1, t) {
                assert("AssignmentPattern", e1, t);
            }
            function assertArrayPattern(e1, t) {
                assert("ArrayPattern", e1, t);
            }
            function assertArrowFunctionExpression(e1, t) {
                assert("ArrowFunctionExpression", e1, t);
            }
            function assertClassBody(e1, t) {
                assert("ClassBody", e1, t);
            }
            function assertClassExpression(e1, t) {
                assert("ClassExpression", e1, t);
            }
            function assertClassDeclaration(e1, t) {
                assert("ClassDeclaration", e1, t);
            }
            function assertExportAllDeclaration(e1, t) {
                assert("ExportAllDeclaration", e1, t);
            }
            function assertExportDefaultDeclaration(e1, t) {
                assert("ExportDefaultDeclaration", e1, t);
            }
            function assertExportNamedDeclaration(e1, t) {
                assert("ExportNamedDeclaration", e1, t);
            }
            function assertExportSpecifier(e1, t) {
                assert("ExportSpecifier", e1, t);
            }
            function assertForOfStatement(e1, t) {
                assert("ForOfStatement", e1, t);
            }
            function assertImportDeclaration(e1, t) {
                assert("ImportDeclaration", e1, t);
            }
            function assertImportDefaultSpecifier(e1, t) {
                assert("ImportDefaultSpecifier", e1, t);
            }
            function assertImportNamespaceSpecifier(e1, t) {
                assert("ImportNamespaceSpecifier", e1, t);
            }
            function assertImportSpecifier(e1, t) {
                assert("ImportSpecifier", e1, t);
            }
            function assertImportExpression(e1, t) {
                assert("ImportExpression", e1, t);
            }
            function assertMetaProperty(e1, t) {
                assert("MetaProperty", e1, t);
            }
            function assertClassMethod(e1, t) {
                assert("ClassMethod", e1, t);
            }
            function assertObjectPattern(e1, t) {
                assert("ObjectPattern", e1, t);
            }
            function assertSpreadElement(e1, t) {
                assert("SpreadElement", e1, t);
            }
            function assertSuper(e1, t) {
                assert("Super", e1, t);
            }
            function assertTaggedTemplateExpression(e1, t) {
                assert("TaggedTemplateExpression", e1, t);
            }
            function assertTemplateElement(e1, t) {
                assert("TemplateElement", e1, t);
            }
            function assertTemplateLiteral(e1, t) {
                assert("TemplateLiteral", e1, t);
            }
            function assertYieldExpression(e1, t) {
                assert("YieldExpression", e1, t);
            }
            function assertAwaitExpression(e1, t) {
                assert("AwaitExpression", e1, t);
            }
            function assertImport(e1, t) {
                assert("Import", e1, t);
            }
            function assertBigIntLiteral(e1, t) {
                assert("BigIntLiteral", e1, t);
            }
            function assertExportNamespaceSpecifier(e1, t) {
                assert("ExportNamespaceSpecifier", e1, t);
            }
            function assertOptionalMemberExpression(e1, t) {
                assert("OptionalMemberExpression", e1, t);
            }
            function assertOptionalCallExpression(e1, t) {
                assert("OptionalCallExpression", e1, t);
            }
            function assertClassProperty(e1, t) {
                assert("ClassProperty", e1, t);
            }
            function assertClassAccessorProperty(e1, t) {
                assert("ClassAccessorProperty", e1, t);
            }
            function assertClassPrivateProperty(e1, t) {
                assert("ClassPrivateProperty", e1, t);
            }
            function assertClassPrivateMethod(e1, t) {
                assert("ClassPrivateMethod", e1, t);
            }
            function assertPrivateName(e1, t) {
                assert("PrivateName", e1, t);
            }
            function assertStaticBlock(e1, t) {
                assert("StaticBlock", e1, t);
            }
            function assertImportAttribute(e1, t) {
                assert("ImportAttribute", e1, t);
            }
            function assertAnyTypeAnnotation(e1, t) {
                assert("AnyTypeAnnotation", e1, t);
            }
            function assertArrayTypeAnnotation(e1, t) {
                assert("ArrayTypeAnnotation", e1, t);
            }
            function assertBooleanTypeAnnotation(e1, t) {
                assert("BooleanTypeAnnotation", e1, t);
            }
            function assertBooleanLiteralTypeAnnotation(e1, t) {
                assert("BooleanLiteralTypeAnnotation", e1, t);
            }
            function assertNullLiteralTypeAnnotation(e1, t) {
                assert("NullLiteralTypeAnnotation", e1, t);
            }
            function assertClassImplements(e1, t) {
                assert("ClassImplements", e1, t);
            }
            function assertDeclareClass(e1, t) {
                assert("DeclareClass", e1, t);
            }
            function assertDeclareFunction(e1, t) {
                assert("DeclareFunction", e1, t);
            }
            function assertDeclareInterface(e1, t) {
                assert("DeclareInterface", e1, t);
            }
            function assertDeclareModule(e1, t) {
                assert("DeclareModule", e1, t);
            }
            function assertDeclareModuleExports(e1, t) {
                assert("DeclareModuleExports", e1, t);
            }
            function assertDeclareTypeAlias(e1, t) {
                assert("DeclareTypeAlias", e1, t);
            }
            function assertDeclareOpaqueType(e1, t) {
                assert("DeclareOpaqueType", e1, t);
            }
            function assertDeclareVariable(e1, t) {
                assert("DeclareVariable", e1, t);
            }
            function assertDeclareExportDeclaration(e1, t) {
                assert("DeclareExportDeclaration", e1, t);
            }
            function assertDeclareExportAllDeclaration(e1, t) {
                assert("DeclareExportAllDeclaration", e1, t);
            }
            function assertDeclaredPredicate(e1, t) {
                assert("DeclaredPredicate", e1, t);
            }
            function assertExistsTypeAnnotation(e1, t) {
                assert("ExistsTypeAnnotation", e1, t);
            }
            function assertFunctionTypeAnnotation(e1, t) {
                assert("FunctionTypeAnnotation", e1, t);
            }
            function assertFunctionTypeParam(e1, t) {
                assert("FunctionTypeParam", e1, t);
            }
            function assertGenericTypeAnnotation(e1, t) {
                assert("GenericTypeAnnotation", e1, t);
            }
            function assertInferredPredicate(e1, t) {
                assert("InferredPredicate", e1, t);
            }
            function assertInterfaceExtends(e1, t) {
                assert("InterfaceExtends", e1, t);
            }
            function assertInterfaceDeclaration(e1, t) {
                assert("InterfaceDeclaration", e1, t);
            }
            function assertInterfaceTypeAnnotation(e1, t) {
                assert("InterfaceTypeAnnotation", e1, t);
            }
            function assertIntersectionTypeAnnotation(e1, t) {
                assert("IntersectionTypeAnnotation", e1, t);
            }
            function assertMixedTypeAnnotation(e1, t) {
                assert("MixedTypeAnnotation", e1, t);
            }
            function assertEmptyTypeAnnotation(e1, t) {
                assert("EmptyTypeAnnotation", e1, t);
            }
            function assertNullableTypeAnnotation(e1, t) {
                assert("NullableTypeAnnotation", e1, t);
            }
            function assertNumberLiteralTypeAnnotation(e1, t) {
                assert("NumberLiteralTypeAnnotation", e1, t);
            }
            function assertNumberTypeAnnotation(e1, t) {
                assert("NumberTypeAnnotation", e1, t);
            }
            function assertObjectTypeAnnotation(e1, t) {
                assert("ObjectTypeAnnotation", e1, t);
            }
            function assertObjectTypeInternalSlot(e1, t) {
                assert("ObjectTypeInternalSlot", e1, t);
            }
            function assertObjectTypeCallProperty(e1, t) {
                assert("ObjectTypeCallProperty", e1, t);
            }
            function assertObjectTypeIndexer(e1, t) {
                assert("ObjectTypeIndexer", e1, t);
            }
            function assertObjectTypeProperty(e1, t) {
                assert("ObjectTypeProperty", e1, t);
            }
            function assertObjectTypeSpreadProperty(e1, t) {
                assert("ObjectTypeSpreadProperty", e1, t);
            }
            function assertOpaqueType(e1, t) {
                assert("OpaqueType", e1, t);
            }
            function assertQualifiedTypeIdentifier(e1, t) {
                assert("QualifiedTypeIdentifier", e1, t);
            }
            function assertStringLiteralTypeAnnotation(e1, t) {
                assert("StringLiteralTypeAnnotation", e1, t);
            }
            function assertStringTypeAnnotation(e1, t) {
                assert("StringTypeAnnotation", e1, t);
            }
            function assertSymbolTypeAnnotation(e1, t) {
                assert("SymbolTypeAnnotation", e1, t);
            }
            function assertThisTypeAnnotation(e1, t) {
                assert("ThisTypeAnnotation", e1, t);
            }
            function assertTupleTypeAnnotation(e1, t) {
                assert("TupleTypeAnnotation", e1, t);
            }
            function assertTypeofTypeAnnotation(e1, t) {
                assert("TypeofTypeAnnotation", e1, t);
            }
            function assertTypeAlias(e1, t) {
                assert("TypeAlias", e1, t);
            }
            function assertTypeAnnotation(e1, t) {
                assert("TypeAnnotation", e1, t);
            }
            function assertTypeCastExpression(e1, t) {
                assert("TypeCastExpression", e1, t);
            }
            function assertTypeParameter(e1, t) {
                assert("TypeParameter", e1, t);
            }
            function assertTypeParameterDeclaration(e1, t) {
                assert("TypeParameterDeclaration", e1, t);
            }
            function assertTypeParameterInstantiation(e1, t) {
                assert("TypeParameterInstantiation", e1, t);
            }
            function assertUnionTypeAnnotation(e1, t) {
                assert("UnionTypeAnnotation", e1, t);
            }
            function assertVariance(e1, t) {
                assert("Variance", e1, t);
            }
            function assertVoidTypeAnnotation(e1, t) {
                assert("VoidTypeAnnotation", e1, t);
            }
            function assertEnumDeclaration(e1, t) {
                assert("EnumDeclaration", e1, t);
            }
            function assertEnumBooleanBody(e1, t) {
                assert("EnumBooleanBody", e1, t);
            }
            function assertEnumNumberBody(e1, t) {
                assert("EnumNumberBody", e1, t);
            }
            function assertEnumStringBody(e1, t) {
                assert("EnumStringBody", e1, t);
            }
            function assertEnumSymbolBody(e1, t) {
                assert("EnumSymbolBody", e1, t);
            }
            function assertEnumBooleanMember(e1, t) {
                assert("EnumBooleanMember", e1, t);
            }
            function assertEnumNumberMember(e1, t) {
                assert("EnumNumberMember", e1, t);
            }
            function assertEnumStringMember(e1, t) {
                assert("EnumStringMember", e1, t);
            }
            function assertEnumDefaultedMember(e1, t) {
                assert("EnumDefaultedMember", e1, t);
            }
            function assertIndexedAccessType(e1, t) {
                assert("IndexedAccessType", e1, t);
            }
            function assertOptionalIndexedAccessType(e1, t) {
                assert("OptionalIndexedAccessType", e1, t);
            }
            function assertJSXAttribute(e1, t) {
                assert("JSXAttribute", e1, t);
            }
            function assertJSXClosingElement(e1, t) {
                assert("JSXClosingElement", e1, t);
            }
            function assertJSXElement(e1, t) {
                assert("JSXElement", e1, t);
            }
            function assertJSXEmptyExpression(e1, t) {
                assert("JSXEmptyExpression", e1, t);
            }
            function assertJSXExpressionContainer(e1, t) {
                assert("JSXExpressionContainer", e1, t);
            }
            function assertJSXSpreadChild(e1, t) {
                assert("JSXSpreadChild", e1, t);
            }
            function assertJSXIdentifier(e1, t) {
                assert("JSXIdentifier", e1, t);
            }
            function assertJSXMemberExpression(e1, t) {
                assert("JSXMemberExpression", e1, t);
            }
            function assertJSXNamespacedName(e1, t) {
                assert("JSXNamespacedName", e1, t);
            }
            function assertJSXOpeningElement(e1, t) {
                assert("JSXOpeningElement", e1, t);
            }
            function assertJSXSpreadAttribute(e1, t) {
                assert("JSXSpreadAttribute", e1, t);
            }
            function assertJSXText(e1, t) {
                assert("JSXText", e1, t);
            }
            function assertJSXFragment(e1, t) {
                assert("JSXFragment", e1, t);
            }
            function assertJSXOpeningFragment(e1, t) {
                assert("JSXOpeningFragment", e1, t);
            }
            function assertJSXClosingFragment(e1, t) {
                assert("JSXClosingFragment", e1, t);
            }
            function assertNoop(e1, t) {
                assert("Noop", e1, t);
            }
            function assertPlaceholder(e1, t) {
                assert("Placeholder", e1, t);
            }
            function assertV8IntrinsicIdentifier(e1, t) {
                assert("V8IntrinsicIdentifier", e1, t);
            }
            function assertArgumentPlaceholder(e1, t) {
                assert("ArgumentPlaceholder", e1, t);
            }
            function assertBindExpression(e1, t) {
                assert("BindExpression", e1, t);
            }
            function assertDecorator(e1, t) {
                assert("Decorator", e1, t);
            }
            function assertDoExpression(e1, t) {
                assert("DoExpression", e1, t);
            }
            function assertExportDefaultSpecifier(e1, t) {
                assert("ExportDefaultSpecifier", e1, t);
            }
            function assertRecordExpression(e1, t) {
                assert("RecordExpression", e1, t);
            }
            function assertTupleExpression(e1, t) {
                assert("TupleExpression", e1, t);
            }
            function assertDecimalLiteral(e1, t) {
                assert("DecimalLiteral", e1, t);
            }
            function assertModuleExpression(e1, t) {
                assert("ModuleExpression", e1, t);
            }
            function assertTopicReference(e1, t) {
                assert("TopicReference", e1, t);
            }
            function assertPipelineTopicExpression(e1, t) {
                assert("PipelineTopicExpression", e1, t);
            }
            function assertPipelineBareFunction(e1, t) {
                assert("PipelineBareFunction", e1, t);
            }
            function assertPipelinePrimaryTopicReference(e1, t) {
                assert("PipelinePrimaryTopicReference", e1, t);
            }
            function assertTSParameterProperty(e1, t) {
                assert("TSParameterProperty", e1, t);
            }
            function assertTSDeclareFunction(e1, t) {
                assert("TSDeclareFunction", e1, t);
            }
            function assertTSDeclareMethod(e1, t) {
                assert("TSDeclareMethod", e1, t);
            }
            function assertTSQualifiedName(e1, t) {
                assert("TSQualifiedName", e1, t);
            }
            function assertTSCallSignatureDeclaration(e1, t) {
                assert("TSCallSignatureDeclaration", e1, t);
            }
            function assertTSConstructSignatureDeclaration(e1, t) {
                assert("TSConstructSignatureDeclaration", e1, t);
            }
            function assertTSPropertySignature(e1, t) {
                assert("TSPropertySignature", e1, t);
            }
            function assertTSMethodSignature(e1, t) {
                assert("TSMethodSignature", e1, t);
            }
            function assertTSIndexSignature(e1, t) {
                assert("TSIndexSignature", e1, t);
            }
            function assertTSAnyKeyword(e1, t) {
                assert("TSAnyKeyword", e1, t);
            }
            function assertTSBooleanKeyword(e1, t) {
                assert("TSBooleanKeyword", e1, t);
            }
            function assertTSBigIntKeyword(e1, t) {
                assert("TSBigIntKeyword", e1, t);
            }
            function assertTSIntrinsicKeyword(e1, t) {
                assert("TSIntrinsicKeyword", e1, t);
            }
            function assertTSNeverKeyword(e1, t) {
                assert("TSNeverKeyword", e1, t);
            }
            function assertTSNullKeyword(e1, t) {
                assert("TSNullKeyword", e1, t);
            }
            function assertTSNumberKeyword(e1, t) {
                assert("TSNumberKeyword", e1, t);
            }
            function assertTSObjectKeyword(e1, t) {
                assert("TSObjectKeyword", e1, t);
            }
            function assertTSStringKeyword(e1, t) {
                assert("TSStringKeyword", e1, t);
            }
            function assertTSSymbolKeyword(e1, t) {
                assert("TSSymbolKeyword", e1, t);
            }
            function assertTSUndefinedKeyword(e1, t) {
                assert("TSUndefinedKeyword", e1, t);
            }
            function assertTSUnknownKeyword(e1, t) {
                assert("TSUnknownKeyword", e1, t);
            }
            function assertTSVoidKeyword(e1, t) {
                assert("TSVoidKeyword", e1, t);
            }
            function assertTSThisType(e1, t) {
                assert("TSThisType", e1, t);
            }
            function assertTSFunctionType(e1, t) {
                assert("TSFunctionType", e1, t);
            }
            function assertTSConstructorType(e1, t) {
                assert("TSConstructorType", e1, t);
            }
            function assertTSTypeReference(e1, t) {
                assert("TSTypeReference", e1, t);
            }
            function assertTSTypePredicate(e1, t) {
                assert("TSTypePredicate", e1, t);
            }
            function assertTSTypeQuery(e1, t) {
                assert("TSTypeQuery", e1, t);
            }
            function assertTSTypeLiteral(e1, t) {
                assert("TSTypeLiteral", e1, t);
            }
            function assertTSArrayType(e1, t) {
                assert("TSArrayType", e1, t);
            }
            function assertTSTupleType(e1, t) {
                assert("TSTupleType", e1, t);
            }
            function assertTSOptionalType(e1, t) {
                assert("TSOptionalType", e1, t);
            }
            function assertTSRestType(e1, t) {
                assert("TSRestType", e1, t);
            }
            function assertTSNamedTupleMember(e1, t) {
                assert("TSNamedTupleMember", e1, t);
            }
            function assertTSUnionType(e1, t) {
                assert("TSUnionType", e1, t);
            }
            function assertTSIntersectionType(e1, t) {
                assert("TSIntersectionType", e1, t);
            }
            function assertTSConditionalType(e1, t) {
                assert("TSConditionalType", e1, t);
            }
            function assertTSInferType(e1, t) {
                assert("TSInferType", e1, t);
            }
            function assertTSParenthesizedType(e1, t) {
                assert("TSParenthesizedType", e1, t);
            }
            function assertTSTypeOperator(e1, t) {
                assert("TSTypeOperator", e1, t);
            }
            function assertTSIndexedAccessType(e1, t) {
                assert("TSIndexedAccessType", e1, t);
            }
            function assertTSMappedType(e1, t) {
                assert("TSMappedType", e1, t);
            }
            function assertTSTemplateLiteralType(e1, t) {
                assert("TSTemplateLiteralType", e1, t);
            }
            function assertTSLiteralType(e1, t) {
                assert("TSLiteralType", e1, t);
            }
            function assertTSExpressionWithTypeArguments(e1, t) {
                assert("TSExpressionWithTypeArguments", e1, t);
            }
            function assertTSInterfaceDeclaration(e1, t) {
                assert("TSInterfaceDeclaration", e1, t);
            }
            function assertTSInterfaceBody(e1, t) {
                assert("TSInterfaceBody", e1, t);
            }
            function assertTSTypeAliasDeclaration(e1, t) {
                assert("TSTypeAliasDeclaration", e1, t);
            }
            function assertTSInstantiationExpression(e1, t) {
                assert("TSInstantiationExpression", e1, t);
            }
            function assertTSAsExpression(e1, t) {
                assert("TSAsExpression", e1, t);
            }
            function assertTSSatisfiesExpression(e1, t) {
                assert("TSSatisfiesExpression", e1, t);
            }
            function assertTSTypeAssertion(e1, t) {
                assert("TSTypeAssertion", e1, t);
            }
            function assertTSEnumBody(e1, t) {
                assert("TSEnumBody", e1, t);
            }
            function assertTSEnumDeclaration(e1, t) {
                assert("TSEnumDeclaration", e1, t);
            }
            function assertTSEnumMember(e1, t) {
                assert("TSEnumMember", e1, t);
            }
            function assertTSModuleDeclaration(e1, t) {
                assert("TSModuleDeclaration", e1, t);
            }
            function assertTSModuleBlock(e1, t) {
                assert("TSModuleBlock", e1, t);
            }
            function assertTSImportType(e1, t) {
                assert("TSImportType", e1, t);
            }
            function assertTSImportEqualsDeclaration(e1, t) {
                assert("TSImportEqualsDeclaration", e1, t);
            }
            function assertTSExternalModuleReference(e1, t) {
                assert("TSExternalModuleReference", e1, t);
            }
            function assertTSNonNullExpression(e1, t) {
                assert("TSNonNullExpression", e1, t);
            }
            function assertTSExportAssignment(e1, t) {
                assert("TSExportAssignment", e1, t);
            }
            function assertTSNamespaceExportDeclaration(e1, t) {
                assert("TSNamespaceExportDeclaration", e1, t);
            }
            function assertTSTypeAnnotation(e1, t) {
                assert("TSTypeAnnotation", e1, t);
            }
            function assertTSTypeParameterInstantiation(e1, t) {
                assert("TSTypeParameterInstantiation", e1, t);
            }
            function assertTSTypeParameterDeclaration(e1, t) {
                assert("TSTypeParameterDeclaration", e1, t);
            }
            function assertTSTypeParameter(e1, t) {
                assert("TSTypeParameter", e1, t);
            }
            function assertStandardized(e1, t) {
                assert("Standardized", e1, t);
            }
            function assertExpression(e1, t) {
                assert("Expression", e1, t);
            }
            function assertBinary(e1, t) {
                assert("Binary", e1, t);
            }
            function assertScopable(e1, t) {
                assert("Scopable", e1, t);
            }
            function assertBlockParent(e1, t) {
                assert("BlockParent", e1, t);
            }
            function assertBlock(e1, t) {
                assert("Block", e1, t);
            }
            function assertStatement(e1, t) {
                assert("Statement", e1, t);
            }
            function assertTerminatorless(e1, t) {
                assert("Terminatorless", e1, t);
            }
            function assertCompletionStatement(e1, t) {
                assert("CompletionStatement", e1, t);
            }
            function assertConditional(e1, t) {
                assert("Conditional", e1, t);
            }
            function assertLoop(e1, t) {
                assert("Loop", e1, t);
            }
            function assertWhile(e1, t) {
                assert("While", e1, t);
            }
            function assertExpressionWrapper(e1, t) {
                assert("ExpressionWrapper", e1, t);
            }
            function assertFor(e1, t) {
                assert("For", e1, t);
            }
            function assertForXStatement(e1, t) {
                assert("ForXStatement", e1, t);
            }
            function assertFunction(e1, t) {
                assert("Function", e1, t);
            }
            function assertFunctionParent(e1, t) {
                assert("FunctionParent", e1, t);
            }
            function assertPureish(e1, t) {
                assert("Pureish", e1, t);
            }
            function assertDeclaration(e1, t) {
                assert("Declaration", e1, t);
            }
            function assertPatternLike(e1, t) {
                assert("PatternLike", e1, t);
            }
            function assertLVal(e1, t) {
                assert("LVal", e1, t);
            }
            function assertTSEntityName(e1, t) {
                assert("TSEntityName", e1, t);
            }
            function assertLiteral(e1, t) {
                assert("Literal", e1, t);
            }
            function assertImmutable(e1, t) {
                assert("Immutable", e1, t);
            }
            function assertUserWhitespacable(e1, t) {
                assert("UserWhitespacable", e1, t);
            }
            function assertMethod(e1, t) {
                assert("Method", e1, t);
            }
            function assertObjectMember(e1, t) {
                assert("ObjectMember", e1, t);
            }
            function assertProperty(e1, t) {
                assert("Property", e1, t);
            }
            function assertUnaryLike(e1, t) {
                assert("UnaryLike", e1, t);
            }
            function assertPattern(e1, t) {
                assert("Pattern", e1, t);
            }
            function assertClass(e1, t) {
                assert("Class", e1, t);
            }
            function assertImportOrExportDeclaration(e1, t) {
                assert("ImportOrExportDeclaration", e1, t);
            }
            function assertExportDeclaration(e1, t) {
                assert("ExportDeclaration", e1, t);
            }
            function assertModuleSpecifier(e1, t) {
                assert("ModuleSpecifier", e1, t);
            }
            function assertAccessor(e1, t) {
                assert("Accessor", e1, t);
            }
            function assertPrivate(e1, t) {
                assert("Private", e1, t);
            }
            function assertFlow(e1, t) {
                assert("Flow", e1, t);
            }
            function assertFlowType(e1, t) {
                assert("FlowType", e1, t);
            }
            function assertFlowBaseAnnotation(e1, t) {
                assert("FlowBaseAnnotation", e1, t);
            }
            function assertFlowDeclaration(e1, t) {
                assert("FlowDeclaration", e1, t);
            }
            function assertFlowPredicate(e1, t) {
                assert("FlowPredicate", e1, t);
            }
            function assertEnumBody(e1, t) {
                assert("EnumBody", e1, t);
            }
            function assertEnumMember(e1, t) {
                assert("EnumMember", e1, t);
            }
            function assertJSX(e1, t) {
                assert("JSX", e1, t);
            }
            function assertMiscellaneous(e1, t) {
                assert("Miscellaneous", e1, t);
            }
            function assertTypeScript(e1, t) {
                assert("TypeScript", e1, t);
            }
            function assertTSTypeElement(e1, t) {
                assert("TSTypeElement", e1, t);
            }
            function assertTSType(e1, t) {
                assert("TSType", e1, t);
            }
            function assertTSBaseType(e1, t) {
                assert("TSBaseType", e1, t);
            }
            function assertNumberLiteral(e1, t) {
                (0, s.default)("assertNumberLiteral", "assertNumericLiteral");
                assert("NumberLiteral", e1, t);
            }
            function assertRegexLiteral(e1, t) {
                (0, s.default)("assertRegexLiteral", "assertRegExpLiteral");
                assert("RegexLiteral", e1, t);
            }
            function assertRestProperty(e1, t) {
                (0, s.default)("assertRestProperty", "assertRestElement");
                assert("RestProperty", e1, t);
            }
            function assertSpreadProperty(e1, t) {
                (0, s.default)("assertSpreadProperty", "assertSpreadElement");
                assert("SpreadProperty", e1, t);
            }
            function assertModuleDeclaration(e1, t) {
                (0, s.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
                assert("ModuleDeclaration", e1, t);
            }
        },
        5164: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createFlowUnionType;
            var n = r(4755);
            var s = r(1078);
            function createFlowUnionType(e1) {
                const t = (0, s.default)(e1);
                if (t.length === 1) {
                    return t[0];
                } else {
                    return (0, n.unionTypeAnnotation)(t);
                }
            }
        },
        1655: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(4755);
            var s = t["default"] = createTypeAnnotationBasedOnTypeof;
            function createTypeAnnotationBasedOnTypeof(e1) {
                switch(e1){
                    case "string":
                        return (0, n.stringTypeAnnotation)();
                    case "number":
                        return (0, n.numberTypeAnnotation)();
                    case "undefined":
                        return (0, n.voidTypeAnnotation)();
                    case "boolean":
                        return (0, n.booleanTypeAnnotation)();
                    case "function":
                        return (0, n.genericTypeAnnotation)((0, n.identifier)("Function"));
                    case "object":
                        return (0, n.genericTypeAnnotation)((0, n.identifier)("Object"));
                    case "symbol":
                        return (0, n.genericTypeAnnotation)((0, n.identifier)("Symbol"));
                    case "bigint":
                        return (0, n.anyTypeAnnotation)();
                }
                throw new Error("Invalid typeof value: " + e1);
            }
        },
        4755: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(3259);
            Object.keys(n).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === n[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return n[e1];
                    }
                });
            });
            var s = r(7903);
            Object.keys(s).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === s[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return s[e1];
                    }
                });
            });
        },
        3259: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.anyTypeAnnotation = anyTypeAnnotation;
            t.argumentPlaceholder = argumentPlaceholder;
            t.arrayExpression = arrayExpression;
            t.arrayPattern = arrayPattern;
            t.arrayTypeAnnotation = arrayTypeAnnotation;
            t.arrowFunctionExpression = arrowFunctionExpression;
            t.assignmentExpression = assignmentExpression;
            t.assignmentPattern = assignmentPattern;
            t.awaitExpression = awaitExpression;
            t.bigIntLiteral = bigIntLiteral;
            t.binaryExpression = binaryExpression;
            t.bindExpression = bindExpression;
            t.blockStatement = blockStatement;
            t.booleanLiteral = booleanLiteral;
            t.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
            t.booleanTypeAnnotation = booleanTypeAnnotation;
            t.breakStatement = breakStatement;
            t.callExpression = callExpression;
            t.catchClause = catchClause;
            t.classAccessorProperty = classAccessorProperty;
            t.classBody = classBody;
            t.classDeclaration = classDeclaration;
            t.classExpression = classExpression;
            t.classImplements = classImplements;
            t.classMethod = classMethod;
            t.classPrivateMethod = classPrivateMethod;
            t.classPrivateProperty = classPrivateProperty;
            t.classProperty = classProperty;
            t.conditionalExpression = conditionalExpression;
            t.continueStatement = continueStatement;
            t.debuggerStatement = debuggerStatement;
            t.decimalLiteral = decimalLiteral;
            t.declareClass = declareClass;
            t.declareExportAllDeclaration = declareExportAllDeclaration;
            t.declareExportDeclaration = declareExportDeclaration;
            t.declareFunction = declareFunction;
            t.declareInterface = declareInterface;
            t.declareModule = declareModule;
            t.declareModuleExports = declareModuleExports;
            t.declareOpaqueType = declareOpaqueType;
            t.declareTypeAlias = declareTypeAlias;
            t.declareVariable = declareVariable;
            t.declaredPredicate = declaredPredicate;
            t.decorator = decorator;
            t.directive = directive;
            t.directiveLiteral = directiveLiteral;
            t.doExpression = doExpression;
            t.doWhileStatement = doWhileStatement;
            t.emptyStatement = emptyStatement;
            t.emptyTypeAnnotation = emptyTypeAnnotation;
            t.enumBooleanBody = enumBooleanBody;
            t.enumBooleanMember = enumBooleanMember;
            t.enumDeclaration = enumDeclaration;
            t.enumDefaultedMember = enumDefaultedMember;
            t.enumNumberBody = enumNumberBody;
            t.enumNumberMember = enumNumberMember;
            t.enumStringBody = enumStringBody;
            t.enumStringMember = enumStringMember;
            t.enumSymbolBody = enumSymbolBody;
            t.existsTypeAnnotation = existsTypeAnnotation;
            t.exportAllDeclaration = exportAllDeclaration;
            t.exportDefaultDeclaration = exportDefaultDeclaration;
            t.exportDefaultSpecifier = exportDefaultSpecifier;
            t.exportNamedDeclaration = exportNamedDeclaration;
            t.exportNamespaceSpecifier = exportNamespaceSpecifier;
            t.exportSpecifier = exportSpecifier;
            t.expressionStatement = expressionStatement;
            t.file = file;
            t.forInStatement = forInStatement;
            t.forOfStatement = forOfStatement;
            t.forStatement = forStatement;
            t.functionDeclaration = functionDeclaration;
            t.functionExpression = functionExpression;
            t.functionTypeAnnotation = functionTypeAnnotation;
            t.functionTypeParam = functionTypeParam;
            t.genericTypeAnnotation = genericTypeAnnotation;
            t.identifier = identifier;
            t.ifStatement = ifStatement;
            t["import"] = _import;
            t.importAttribute = importAttribute;
            t.importDeclaration = importDeclaration;
            t.importDefaultSpecifier = importDefaultSpecifier;
            t.importExpression = importExpression;
            t.importNamespaceSpecifier = importNamespaceSpecifier;
            t.importSpecifier = importSpecifier;
            t.indexedAccessType = indexedAccessType;
            t.inferredPredicate = inferredPredicate;
            t.interfaceDeclaration = interfaceDeclaration;
            t.interfaceExtends = interfaceExtends;
            t.interfaceTypeAnnotation = interfaceTypeAnnotation;
            t.interpreterDirective = interpreterDirective;
            t.intersectionTypeAnnotation = intersectionTypeAnnotation;
            t.jSXAttribute = t.jsxAttribute = jsxAttribute;
            t.jSXClosingElement = t.jsxClosingElement = jsxClosingElement;
            t.jSXClosingFragment = t.jsxClosingFragment = jsxClosingFragment;
            t.jSXElement = t.jsxElement = jsxElement;
            t.jSXEmptyExpression = t.jsxEmptyExpression = jsxEmptyExpression;
            t.jSXExpressionContainer = t.jsxExpressionContainer = jsxExpressionContainer;
            t.jSXFragment = t.jsxFragment = jsxFragment;
            t.jSXIdentifier = t.jsxIdentifier = jsxIdentifier;
            t.jSXMemberExpression = t.jsxMemberExpression = jsxMemberExpression;
            t.jSXNamespacedName = t.jsxNamespacedName = jsxNamespacedName;
            t.jSXOpeningElement = t.jsxOpeningElement = jsxOpeningElement;
            t.jSXOpeningFragment = t.jsxOpeningFragment = jsxOpeningFragment;
            t.jSXSpreadAttribute = t.jsxSpreadAttribute = jsxSpreadAttribute;
            t.jSXSpreadChild = t.jsxSpreadChild = jsxSpreadChild;
            t.jSXText = t.jsxText = jsxText;
            t.labeledStatement = labeledStatement;
            t.logicalExpression = logicalExpression;
            t.memberExpression = memberExpression;
            t.metaProperty = metaProperty;
            t.mixedTypeAnnotation = mixedTypeAnnotation;
            t.moduleExpression = moduleExpression;
            t.newExpression = newExpression;
            t.noop = noop;
            t.nullLiteral = nullLiteral;
            t.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
            t.nullableTypeAnnotation = nullableTypeAnnotation;
            t.numberLiteral = NumberLiteral;
            t.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
            t.numberTypeAnnotation = numberTypeAnnotation;
            t.numericLiteral = numericLiteral;
            t.objectExpression = objectExpression;
            t.objectMethod = objectMethod;
            t.objectPattern = objectPattern;
            t.objectProperty = objectProperty;
            t.objectTypeAnnotation = objectTypeAnnotation;
            t.objectTypeCallProperty = objectTypeCallProperty;
            t.objectTypeIndexer = objectTypeIndexer;
            t.objectTypeInternalSlot = objectTypeInternalSlot;
            t.objectTypeProperty = objectTypeProperty;
            t.objectTypeSpreadProperty = objectTypeSpreadProperty;
            t.opaqueType = opaqueType;
            t.optionalCallExpression = optionalCallExpression;
            t.optionalIndexedAccessType = optionalIndexedAccessType;
            t.optionalMemberExpression = optionalMemberExpression;
            t.parenthesizedExpression = parenthesizedExpression;
            t.pipelineBareFunction = pipelineBareFunction;
            t.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
            t.pipelineTopicExpression = pipelineTopicExpression;
            t.placeholder = placeholder;
            t.privateName = privateName;
            t.program = program;
            t.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
            t.recordExpression = recordExpression;
            t.regExpLiteral = regExpLiteral;
            t.regexLiteral = RegexLiteral;
            t.restElement = restElement;
            t.restProperty = RestProperty;
            t.returnStatement = returnStatement;
            t.sequenceExpression = sequenceExpression;
            t.spreadElement = spreadElement;
            t.spreadProperty = SpreadProperty;
            t.staticBlock = staticBlock;
            t.stringLiteral = stringLiteral;
            t.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
            t.stringTypeAnnotation = stringTypeAnnotation;
            t["super"] = _super;
            t.switchCase = switchCase;
            t.switchStatement = switchStatement;
            t.symbolTypeAnnotation = symbolTypeAnnotation;
            t.taggedTemplateExpression = taggedTemplateExpression;
            t.templateElement = templateElement;
            t.templateLiteral = templateLiteral;
            t.thisExpression = thisExpression;
            t.thisTypeAnnotation = thisTypeAnnotation;
            t.throwStatement = throwStatement;
            t.topicReference = topicReference;
            t.tryStatement = tryStatement;
            t.tSAnyKeyword = t.tsAnyKeyword = tsAnyKeyword;
            t.tSArrayType = t.tsArrayType = tsArrayType;
            t.tSAsExpression = t.tsAsExpression = tsAsExpression;
            t.tSBigIntKeyword = t.tsBigIntKeyword = tsBigIntKeyword;
            t.tSBooleanKeyword = t.tsBooleanKeyword = tsBooleanKeyword;
            t.tSCallSignatureDeclaration = t.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
            t.tSConditionalType = t.tsConditionalType = tsConditionalType;
            t.tSConstructSignatureDeclaration = t.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
            t.tSConstructorType = t.tsConstructorType = tsConstructorType;
            t.tSDeclareFunction = t.tsDeclareFunction = tsDeclareFunction;
            t.tSDeclareMethod = t.tsDeclareMethod = tsDeclareMethod;
            t.tSEnumBody = t.tsEnumBody = tsEnumBody;
            t.tSEnumDeclaration = t.tsEnumDeclaration = tsEnumDeclaration;
            t.tSEnumMember = t.tsEnumMember = tsEnumMember;
            t.tSExportAssignment = t.tsExportAssignment = tsExportAssignment;
            t.tSExpressionWithTypeArguments = t.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
            t.tSExternalModuleReference = t.tsExternalModuleReference = tsExternalModuleReference;
            t.tSFunctionType = t.tsFunctionType = tsFunctionType;
            t.tSImportEqualsDeclaration = t.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
            t.tSImportType = t.tsImportType = tsImportType;
            t.tSIndexSignature = t.tsIndexSignature = tsIndexSignature;
            t.tSIndexedAccessType = t.tsIndexedAccessType = tsIndexedAccessType;
            t.tSInferType = t.tsInferType = tsInferType;
            t.tSInstantiationExpression = t.tsInstantiationExpression = tsInstantiationExpression;
            t.tSInterfaceBody = t.tsInterfaceBody = tsInterfaceBody;
            t.tSInterfaceDeclaration = t.tsInterfaceDeclaration = tsInterfaceDeclaration;
            t.tSIntersectionType = t.tsIntersectionType = tsIntersectionType;
            t.tSIntrinsicKeyword = t.tsIntrinsicKeyword = tsIntrinsicKeyword;
            t.tSLiteralType = t.tsLiteralType = tsLiteralType;
            t.tSMappedType = t.tsMappedType = tsMappedType;
            t.tSMethodSignature = t.tsMethodSignature = tsMethodSignature;
            t.tSModuleBlock = t.tsModuleBlock = tsModuleBlock;
            t.tSModuleDeclaration = t.tsModuleDeclaration = tsModuleDeclaration;
            t.tSNamedTupleMember = t.tsNamedTupleMember = tsNamedTupleMember;
            t.tSNamespaceExportDeclaration = t.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
            t.tSNeverKeyword = t.tsNeverKeyword = tsNeverKeyword;
            t.tSNonNullExpression = t.tsNonNullExpression = tsNonNullExpression;
            t.tSNullKeyword = t.tsNullKeyword = tsNullKeyword;
            t.tSNumberKeyword = t.tsNumberKeyword = tsNumberKeyword;
            t.tSObjectKeyword = t.tsObjectKeyword = tsObjectKeyword;
            t.tSOptionalType = t.tsOptionalType = tsOptionalType;
            t.tSParameterProperty = t.tsParameterProperty = tsParameterProperty;
            t.tSParenthesizedType = t.tsParenthesizedType = tsParenthesizedType;
            t.tSPropertySignature = t.tsPropertySignature = tsPropertySignature;
            t.tSQualifiedName = t.tsQualifiedName = tsQualifiedName;
            t.tSRestType = t.tsRestType = tsRestType;
            t.tSSatisfiesExpression = t.tsSatisfiesExpression = tsSatisfiesExpression;
            t.tSStringKeyword = t.tsStringKeyword = tsStringKeyword;
            t.tSSymbolKeyword = t.tsSymbolKeyword = tsSymbolKeyword;
            t.tSTemplateLiteralType = t.tsTemplateLiteralType = tsTemplateLiteralType;
            t.tSThisType = t.tsThisType = tsThisType;
            t.tSTupleType = t.tsTupleType = tsTupleType;
            t.tSTypeAliasDeclaration = t.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
            t.tSTypeAnnotation = t.tsTypeAnnotation = tsTypeAnnotation;
            t.tSTypeAssertion = t.tsTypeAssertion = tsTypeAssertion;
            t.tSTypeLiteral = t.tsTypeLiteral = tsTypeLiteral;
            t.tSTypeOperator = t.tsTypeOperator = tsTypeOperator;
            t.tSTypeParameter = t.tsTypeParameter = tsTypeParameter;
            t.tSTypeParameterDeclaration = t.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
            t.tSTypeParameterInstantiation = t.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
            t.tSTypePredicate = t.tsTypePredicate = tsTypePredicate;
            t.tSTypeQuery = t.tsTypeQuery = tsTypeQuery;
            t.tSTypeReference = t.tsTypeReference = tsTypeReference;
            t.tSUndefinedKeyword = t.tsUndefinedKeyword = tsUndefinedKeyword;
            t.tSUnionType = t.tsUnionType = tsUnionType;
            t.tSUnknownKeyword = t.tsUnknownKeyword = tsUnknownKeyword;
            t.tSVoidKeyword = t.tsVoidKeyword = tsVoidKeyword;
            t.tupleExpression = tupleExpression;
            t.tupleTypeAnnotation = tupleTypeAnnotation;
            t.typeAlias = typeAlias;
            t.typeAnnotation = typeAnnotation;
            t.typeCastExpression = typeCastExpression;
            t.typeParameter = typeParameter;
            t.typeParameterDeclaration = typeParameterDeclaration;
            t.typeParameterInstantiation = typeParameterInstantiation;
            t.typeofTypeAnnotation = typeofTypeAnnotation;
            t.unaryExpression = unaryExpression;
            t.unionTypeAnnotation = unionTypeAnnotation;
            t.updateExpression = updateExpression;
            t.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
            t.variableDeclaration = variableDeclaration;
            t.variableDeclarator = variableDeclarator;
            t.variance = variance;
            t.voidTypeAnnotation = voidTypeAnnotation;
            t.whileStatement = whileStatement;
            t.withStatement = withStatement;
            t.yieldExpression = yieldExpression;
            var n = r(8966);
            var s = r(8760);
            var i = r(6624);
            const { validateInternal: a } = n;
            const { NODE_FIELDS: o } = i;
            function arrayExpression() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                const t = {
                    type: "ArrayExpression",
                    elements: e1
                };
                const r = o.ArrayExpression;
                a(r.elements, t, "elements", e1, 1);
                return t;
            }
            function assignmentExpression(e1, t, r) {
                const n = {
                    type: "AssignmentExpression",
                    operator: e1,
                    left: t,
                    right: r
                };
                const s = o.AssignmentExpression;
                a(s.operator, n, "operator", e1);
                a(s.left, n, "left", t, 1);
                a(s.right, n, "right", r, 1);
                return n;
            }
            function binaryExpression(e1, t, r) {
                const n = {
                    type: "BinaryExpression",
                    operator: e1,
                    left: t,
                    right: r
                };
                const s = o.BinaryExpression;
                a(s.operator, n, "operator", e1);
                a(s.left, n, "left", t, 1);
                a(s.right, n, "right", r, 1);
                return n;
            }
            function interpreterDirective(e1) {
                const t = {
                    type: "InterpreterDirective",
                    value: e1
                };
                const r = o.InterpreterDirective;
                a(r.value, t, "value", e1);
                return t;
            }
            function directive(e1) {
                const t = {
                    type: "Directive",
                    value: e1
                };
                const r = o.Directive;
                a(r.value, t, "value", e1, 1);
                return t;
            }
            function directiveLiteral(e1) {
                const t = {
                    type: "DirectiveLiteral",
                    value: e1
                };
                const r = o.DirectiveLiteral;
                a(r.value, t, "value", e1);
                return t;
            }
            function blockStatement(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                const r = {
                    type: "BlockStatement",
                    body: e1,
                    directives: t
                };
                const n = o.BlockStatement;
                a(n.body, r, "body", e1, 1);
                a(n.directives, r, "directives", t, 1);
                return r;
            }
            function breakStatement() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                const t = {
                    type: "BreakStatement",
                    label: e1
                };
                const r = o.BreakStatement;
                a(r.label, t, "label", e1, 1);
                return t;
            }
            function callExpression(e1, t) {
                const r = {
                    type: "CallExpression",
                    callee: e1,
                    arguments: t
                };
                const n = o.CallExpression;
                a(n.callee, r, "callee", e1, 1);
                a(n.arguments, r, "arguments", t, 1);
                return r;
            }
            function catchClause() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
                const r = {
                    type: "CatchClause",
                    param: e1,
                    body: t
                };
                const n = o.CatchClause;
                a(n.param, r, "param", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function conditionalExpression(e1, t, r) {
                const n = {
                    type: "ConditionalExpression",
                    test: e1,
                    consequent: t,
                    alternate: r
                };
                const s = o.ConditionalExpression;
                a(s.test, n, "test", e1, 1);
                a(s.consequent, n, "consequent", t, 1);
                a(s.alternate, n, "alternate", r, 1);
                return n;
            }
            function continueStatement() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                const t = {
                    type: "ContinueStatement",
                    label: e1
                };
                const r = o.ContinueStatement;
                a(r.label, t, "label", e1, 1);
                return t;
            }
            function debuggerStatement() {
                return {
                    type: "DebuggerStatement"
                };
            }
            function doWhileStatement(e1, t) {
                const r = {
                    type: "DoWhileStatement",
                    test: e1,
                    body: t
                };
                const n = o.DoWhileStatement;
                a(n.test, r, "test", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function emptyStatement() {
                return {
                    type: "EmptyStatement"
                };
            }
            function expressionStatement(e1) {
                const t = {
                    type: "ExpressionStatement",
                    expression: e1
                };
                const r = o.ExpressionStatement;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function file(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "File",
                    program: e1,
                    comments: t,
                    tokens: r
                };
                const s = o.File;
                a(s.program, n, "program", e1, 1);
                a(s.comments, n, "comments", t, 1);
                a(s.tokens, n, "tokens", r);
                return n;
            }
            function forInStatement(e1, t, r) {
                const n = {
                    type: "ForInStatement",
                    left: e1,
                    right: t,
                    body: r
                };
                const s = o.ForInStatement;
                a(s.left, n, "left", e1, 1);
                a(s.right, n, "right", t, 1);
                a(s.body, n, "body", r, 1);
                return n;
            }
            function forStatement() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "ForStatement",
                    init: e1,
                    test: t,
                    update: r,
                    body: n
                };
                const i = o.ForStatement;
                a(i.init, s, "init", e1, 1);
                a(i.test, s, "test", t, 1);
                a(i.update, s, "update", r, 1);
                a(i.body, s, "body", n, 1);
                return s;
            }
            function functionDeclaration() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                const i = {
                    type: "FunctionDeclaration",
                    id: e1,
                    params: t,
                    body: r,
                    generator: n,
                    async: s
                };
                const l = o.FunctionDeclaration;
                a(l.id, i, "id", e1, 1);
                a(l.params, i, "params", t, 1);
                a(l.body, i, "body", r, 1);
                a(l.generator, i, "generator", n);
                a(l.async, i, "async", s);
                return i;
            }
            function functionExpression() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                const i = {
                    type: "FunctionExpression",
                    id: e1,
                    params: t,
                    body: r,
                    generator: n,
                    async: s
                };
                const l = o.FunctionExpression;
                a(l.id, i, "id", e1, 1);
                a(l.params, i, "params", t, 1);
                a(l.body, i, "body", r, 1);
                a(l.generator, i, "generator", n);
                a(l.async, i, "async", s);
                return i;
            }
            function identifier(e1) {
                const t = {
                    type: "Identifier",
                    name: e1
                };
                const r = o.Identifier;
                a(r.name, t, "name", e1);
                return t;
            }
            function ifStatement(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "IfStatement",
                    test: e1,
                    consequent: t,
                    alternate: r
                };
                const s = o.IfStatement;
                a(s.test, n, "test", e1, 1);
                a(s.consequent, n, "consequent", t, 1);
                a(s.alternate, n, "alternate", r, 1);
                return n;
            }
            function labeledStatement(e1, t) {
                const r = {
                    type: "LabeledStatement",
                    label: e1,
                    body: t
                };
                const n = o.LabeledStatement;
                a(n.label, r, "label", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function stringLiteral(e1) {
                const t = {
                    type: "StringLiteral",
                    value: e1
                };
                const r = o.StringLiteral;
                a(r.value, t, "value", e1);
                return t;
            }
            function numericLiteral(e1) {
                const t = {
                    type: "NumericLiteral",
                    value: e1
                };
                const r = o.NumericLiteral;
                a(r.value, t, "value", e1);
                return t;
            }
            function nullLiteral() {
                return {
                    type: "NullLiteral"
                };
            }
            function booleanLiteral(e1) {
                const t = {
                    type: "BooleanLiteral",
                    value: e1
                };
                const r = o.BooleanLiteral;
                a(r.value, t, "value", e1);
                return t;
            }
            function regExpLiteral(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                const r = {
                    type: "RegExpLiteral",
                    pattern: e1,
                    flags: t
                };
                const n = o.RegExpLiteral;
                a(n.pattern, r, "pattern", e1);
                a(n.flags, r, "flags", t);
                return r;
            }
            function logicalExpression(e1, t, r) {
                const n = {
                    type: "LogicalExpression",
                    operator: e1,
                    left: t,
                    right: r
                };
                const s = o.LogicalExpression;
                a(s.operator, n, "operator", e1);
                a(s.left, n, "left", t, 1);
                a(s.right, n, "right", r, 1);
                return n;
            }
            function memberExpression(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "MemberExpression",
                    object: e1,
                    property: t,
                    computed: r,
                    optional: n
                };
                const i = o.MemberExpression;
                a(i.object, s, "object", e1, 1);
                a(i.property, s, "property", t, 1);
                a(i.computed, s, "computed", r);
                a(i.optional, s, "optional", n);
                return s;
            }
            function newExpression(e1, t) {
                const r = {
                    type: "NewExpression",
                    callee: e1,
                    arguments: t
                };
                const n = o.NewExpression;
                a(n.callee, r, "callee", e1, 1);
                a(n.arguments, r, "arguments", t, 1);
                return r;
            }
            function program(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "script", n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "Program",
                    body: e1,
                    directives: t,
                    sourceType: r,
                    interpreter: n
                };
                const i = o.Program;
                a(i.body, s, "body", e1, 1);
                a(i.directives, s, "directives", t, 1);
                a(i.sourceType, s, "sourceType", r);
                a(i.interpreter, s, "interpreter", n, 1);
                return s;
            }
            function objectExpression(e1) {
                const t = {
                    type: "ObjectExpression",
                    properties: e1
                };
                const r = o.ObjectExpression;
                a(r.properties, t, "properties", e1, 1);
                return t;
            }
            function objectMethod() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method", t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                const c = {
                    type: "ObjectMethod",
                    kind: e1,
                    key: t,
                    params: r,
                    body: n,
                    computed: s,
                    generator: i,
                    async: l
                };
                const p = o.ObjectMethod;
                a(p.kind, c, "kind", e1);
                a(p.key, c, "key", t, 1);
                a(p.params, c, "params", r, 1);
                a(p.body, c, "body", n, 1);
                a(p.computed, c, "computed", s);
                a(p.generator, c, "generator", i);
                a(p.async, c, "async", l);
                return c;
            }
            function objectProperty(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                const i = {
                    type: "ObjectProperty",
                    key: e1,
                    value: t,
                    computed: r,
                    shorthand: n,
                    decorators: s
                };
                const l = o.ObjectProperty;
                a(l.key, i, "key", e1, 1);
                a(l.value, i, "value", t, 1);
                a(l.computed, i, "computed", r);
                a(l.shorthand, i, "shorthand", n);
                a(l.decorators, i, "decorators", s, 1);
                return i;
            }
            function restElement(e1) {
                const t = {
                    type: "RestElement",
                    argument: e1
                };
                const r = o.RestElement;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function returnStatement() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                const t = {
                    type: "ReturnStatement",
                    argument: e1
                };
                const r = o.ReturnStatement;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function sequenceExpression(e1) {
                const t = {
                    type: "SequenceExpression",
                    expressions: e1
                };
                const r = o.SequenceExpression;
                a(r.expressions, t, "expressions", e1, 1);
                return t;
            }
            function parenthesizedExpression(e1) {
                const t = {
                    type: "ParenthesizedExpression",
                    expression: e1
                };
                const r = o.ParenthesizedExpression;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function switchCase() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
                const r = {
                    type: "SwitchCase",
                    test: e1,
                    consequent: t
                };
                const n = o.SwitchCase;
                a(n.test, r, "test", e1, 1);
                a(n.consequent, r, "consequent", t, 1);
                return r;
            }
            function switchStatement(e1, t) {
                const r = {
                    type: "SwitchStatement",
                    discriminant: e1,
                    cases: t
                };
                const n = o.SwitchStatement;
                a(n.discriminant, r, "discriminant", e1, 1);
                a(n.cases, r, "cases", t, 1);
                return r;
            }
            function thisExpression() {
                return {
                    type: "ThisExpression"
                };
            }
            function throwStatement(e1) {
                const t = {
                    type: "ThrowStatement",
                    argument: e1
                };
                const r = o.ThrowStatement;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function tryStatement(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TryStatement",
                    block: e1,
                    handler: t,
                    finalizer: r
                };
                const s = o.TryStatement;
                a(s.block, n, "block", e1, 1);
                a(s.handler, n, "handler", t, 1);
                a(s.finalizer, n, "finalizer", r, 1);
                return n;
            }
            function unaryExpression(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                const n = {
                    type: "UnaryExpression",
                    operator: e1,
                    argument: t,
                    prefix: r
                };
                const s = o.UnaryExpression;
                a(s.operator, n, "operator", e1);
                a(s.argument, n, "argument", t, 1);
                a(s.prefix, n, "prefix", r);
                return n;
            }
            function updateExpression(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                const n = {
                    type: "UpdateExpression",
                    operator: e1,
                    argument: t,
                    prefix: r
                };
                const s = o.UpdateExpression;
                a(s.operator, n, "operator", e1);
                a(s.argument, n, "argument", t, 1);
                a(s.prefix, n, "prefix", r);
                return n;
            }
            function variableDeclaration(e1, t) {
                const r = {
                    type: "VariableDeclaration",
                    kind: e1,
                    declarations: t
                };
                const n = o.VariableDeclaration;
                a(n.kind, r, "kind", e1);
                a(n.declarations, r, "declarations", t, 1);
                return r;
            }
            function variableDeclarator(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "VariableDeclarator",
                    id: e1,
                    init: t
                };
                const n = o.VariableDeclarator;
                a(n.id, r, "id", e1, 1);
                a(n.init, r, "init", t, 1);
                return r;
            }
            function whileStatement(e1, t) {
                const r = {
                    type: "WhileStatement",
                    test: e1,
                    body: t
                };
                const n = o.WhileStatement;
                a(n.test, r, "test", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function withStatement(e1, t) {
                const r = {
                    type: "WithStatement",
                    object: e1,
                    body: t
                };
                const n = o.WithStatement;
                a(n.object, r, "object", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function assignmentPattern(e1, t) {
                const r = {
                    type: "AssignmentPattern",
                    left: e1,
                    right: t
                };
                const n = o.AssignmentPattern;
                a(n.left, r, "left", e1, 1);
                a(n.right, r, "right", t, 1);
                return r;
            }
            function arrayPattern(e1) {
                const t = {
                    type: "ArrayPattern",
                    elements: e1
                };
                const r = o.ArrayPattern;
                a(r.elements, t, "elements", e1, 1);
                return t;
            }
            function arrowFunctionExpression(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                const n = {
                    type: "ArrowFunctionExpression",
                    params: e1,
                    body: t,
                    async: r,
                    expression: null
                };
                const s = o.ArrowFunctionExpression;
                a(s.params, n, "params", e1, 1);
                a(s.body, n, "body", t, 1);
                a(s.async, n, "async", r);
                return n;
            }
            function classBody(e1) {
                const t = {
                    type: "ClassBody",
                    body: e1
                };
                const r = o.ClassBody;
                a(r.body, t, "body", e1, 1);
                return t;
            }
            function classExpression() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "ClassExpression",
                    id: e1,
                    superClass: t,
                    body: r,
                    decorators: n
                };
                const i = o.ClassExpression;
                a(i.id, s, "id", e1, 1);
                a(i.superClass, s, "superClass", t, 1);
                a(i.body, s, "body", r, 1);
                a(i.decorators, s, "decorators", n, 1);
                return s;
            }
            function classDeclaration() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "ClassDeclaration",
                    id: e1,
                    superClass: t,
                    body: r,
                    decorators: n
                };
                const i = o.ClassDeclaration;
                a(i.id, s, "id", e1, 1);
                a(i.superClass, s, "superClass", t, 1);
                a(i.body, s, "body", r, 1);
                a(i.decorators, s, "decorators", n, 1);
                return s;
            }
            function exportAllDeclaration(e1) {
                const t = {
                    type: "ExportAllDeclaration",
                    source: e1
                };
                const r = o.ExportAllDeclaration;
                a(r.source, t, "source", e1, 1);
                return t;
            }
            function exportDefaultDeclaration(e1) {
                const t = {
                    type: "ExportDefaultDeclaration",
                    declaration: e1
                };
                const r = o.ExportDefaultDeclaration;
                a(r.declaration, t, "declaration", e1, 1);
                return t;
            }
            function exportNamedDeclaration() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "ExportNamedDeclaration",
                    declaration: e1,
                    specifiers: t,
                    source: r
                };
                const s = o.ExportNamedDeclaration;
                a(s.declaration, n, "declaration", e1, 1);
                a(s.specifiers, n, "specifiers", t, 1);
                a(s.source, n, "source", r, 1);
                return n;
            }
            function exportSpecifier(e1, t) {
                const r = {
                    type: "ExportSpecifier",
                    local: e1,
                    exported: t
                };
                const n = o.ExportSpecifier;
                a(n.local, r, "local", e1, 1);
                a(n.exported, r, "exported", t, 1);
                return r;
            }
            function forOfStatement(e1, t, r) {
                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                const s = {
                    type: "ForOfStatement",
                    left: e1,
                    right: t,
                    body: r,
                    await: n
                };
                const i = o.ForOfStatement;
                a(i.left, s, "left", e1, 1);
                a(i.right, s, "right", t, 1);
                a(i.body, s, "body", r, 1);
                a(i.await, s, "await", n);
                return s;
            }
            function importDeclaration(e1, t) {
                const r = {
                    type: "ImportDeclaration",
                    specifiers: e1,
                    source: t
                };
                const n = o.ImportDeclaration;
                a(n.specifiers, r, "specifiers", e1, 1);
                a(n.source, r, "source", t, 1);
                return r;
            }
            function importDefaultSpecifier(e1) {
                const t = {
                    type: "ImportDefaultSpecifier",
                    local: e1
                };
                const r = o.ImportDefaultSpecifier;
                a(r.local, t, "local", e1, 1);
                return t;
            }
            function importNamespaceSpecifier(e1) {
                const t = {
                    type: "ImportNamespaceSpecifier",
                    local: e1
                };
                const r = o.ImportNamespaceSpecifier;
                a(r.local, t, "local", e1, 1);
                return t;
            }
            function importSpecifier(e1, t) {
                const r = {
                    type: "ImportSpecifier",
                    local: e1,
                    imported: t
                };
                const n = o.ImportSpecifier;
                a(n.local, r, "local", e1, 1);
                a(n.imported, r, "imported", t, 1);
                return r;
            }
            function importExpression(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "ImportExpression",
                    source: e1,
                    options: t
                };
                const n = o.ImportExpression;
                a(n.source, r, "source", e1, 1);
                a(n.options, r, "options", t, 1);
                return r;
            }
            function metaProperty(e1, t) {
                const r = {
                    type: "MetaProperty",
                    meta: e1,
                    property: t
                };
                const n = o.MetaProperty;
                a(n.meta, r, "meta", e1, 1);
                a(n.property, r, "property", t, 1);
                return r;
            }
            function classMethod() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method", t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, c = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
                const p = {
                    type: "ClassMethod",
                    kind: e1,
                    key: t,
                    params: r,
                    body: n,
                    computed: s,
                    static: i,
                    generator: l,
                    async: c
                };
                const u = o.ClassMethod;
                a(u.kind, p, "kind", e1);
                a(u.key, p, "key", t, 1);
                a(u.params, p, "params", r, 1);
                a(u.body, p, "body", n, 1);
                a(u.computed, p, "computed", s);
                a(u.static, p, "static", i);
                a(u.generator, p, "generator", l);
                a(u.async, p, "async", c);
                return p;
            }
            function objectPattern(e1) {
                const t = {
                    type: "ObjectPattern",
                    properties: e1
                };
                const r = o.ObjectPattern;
                a(r.properties, t, "properties", e1, 1);
                return t;
            }
            function spreadElement(e1) {
                const t = {
                    type: "SpreadElement",
                    argument: e1
                };
                const r = o.SpreadElement;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function _super() {
                return {
                    type: "Super"
                };
            }
            function taggedTemplateExpression(e1, t) {
                const r = {
                    type: "TaggedTemplateExpression",
                    tag: e1,
                    quasi: t
                };
                const n = o.TaggedTemplateExpression;
                a(n.tag, r, "tag", e1, 1);
                a(n.quasi, r, "quasi", t, 1);
                return r;
            }
            function templateElement(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                const r = {
                    type: "TemplateElement",
                    value: e1,
                    tail: t
                };
                const n = o.TemplateElement;
                a(n.value, r, "value", e1);
                a(n.tail, r, "tail", t);
                return r;
            }
            function templateLiteral(e1, t) {
                const r = {
                    type: "TemplateLiteral",
                    quasis: e1,
                    expressions: t
                };
                const n = o.TemplateLiteral;
                a(n.quasis, r, "quasis", e1, 1);
                a(n.expressions, r, "expressions", t, 1);
                return r;
            }
            function yieldExpression() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                const r = {
                    type: "YieldExpression",
                    argument: e1,
                    delegate: t
                };
                const n = o.YieldExpression;
                a(n.argument, r, "argument", e1, 1);
                a(n.delegate, r, "delegate", t);
                return r;
            }
            function awaitExpression(e1) {
                const t = {
                    type: "AwaitExpression",
                    argument: e1
                };
                const r = o.AwaitExpression;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function _import() {
                return {
                    type: "Import"
                };
            }
            function bigIntLiteral(e1) {
                const t = {
                    type: "BigIntLiteral",
                    value: e1
                };
                const r = o.BigIntLiteral;
                a(r.value, t, "value", e1);
                return t;
            }
            function exportNamespaceSpecifier(e1) {
                const t = {
                    type: "ExportNamespaceSpecifier",
                    exported: e1
                };
                const r = o.ExportNamespaceSpecifier;
                a(r.exported, t, "exported", e1, 1);
                return t;
            }
            function optionalMemberExpression(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "OptionalMemberExpression",
                    object: e1,
                    property: t,
                    computed: r,
                    optional: n
                };
                const i = o.OptionalMemberExpression;
                a(i.object, s, "object", e1, 1);
                a(i.property, s, "property", t, 1);
                a(i.computed, s, "computed", r);
                a(i.optional, s, "optional", n);
                return s;
            }
            function optionalCallExpression(e1, t, r) {
                const n = {
                    type: "OptionalCallExpression",
                    callee: e1,
                    arguments: t,
                    optional: r
                };
                const s = o.OptionalCallExpression;
                a(s.callee, n, "callee", e1, 1);
                a(s.arguments, n, "arguments", t, 1);
                a(s.optional, n, "optional", r);
                return n;
            }
            function classProperty(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                const l = {
                    type: "ClassProperty",
                    key: e1,
                    value: t,
                    typeAnnotation: r,
                    decorators: n,
                    computed: s,
                    static: i
                };
                const c = o.ClassProperty;
                a(c.key, l, "key", e1, 1);
                a(c.value, l, "value", t, 1);
                a(c.typeAnnotation, l, "typeAnnotation", r, 1);
                a(c.decorators, l, "decorators", n, 1);
                a(c.computed, l, "computed", s);
                a(c.static, l, "static", i);
                return l;
            }
            function classAccessorProperty(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                const l = {
                    type: "ClassAccessorProperty",
                    key: e1,
                    value: t,
                    typeAnnotation: r,
                    decorators: n,
                    computed: s,
                    static: i
                };
                const c = o.ClassAccessorProperty;
                a(c.key, l, "key", e1, 1);
                a(c.value, l, "value", t, 1);
                a(c.typeAnnotation, l, "typeAnnotation", r, 1);
                a(c.decorators, l, "decorators", n, 1);
                a(c.computed, l, "computed", s);
                a(c.static, l, "static", i);
                return l;
            }
            function classPrivateProperty(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                const s = {
                    type: "ClassPrivateProperty",
                    key: e1,
                    value: t,
                    decorators: r,
                    static: n
                };
                const i = o.ClassPrivateProperty;
                a(i.key, s, "key", e1, 1);
                a(i.value, s, "value", t, 1);
                a(i.decorators, s, "decorators", r, 1);
                a(i.static, s, "static", n);
                return s;
            }
            function classPrivateMethod() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "method", t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                const i = {
                    type: "ClassPrivateMethod",
                    kind: e1,
                    key: t,
                    params: r,
                    body: n,
                    static: s
                };
                const l = o.ClassPrivateMethod;
                a(l.kind, i, "kind", e1);
                a(l.key, i, "key", t, 1);
                a(l.params, i, "params", r, 1);
                a(l.body, i, "body", n, 1);
                a(l.static, i, "static", s);
                return i;
            }
            function privateName(e1) {
                const t = {
                    type: "PrivateName",
                    id: e1
                };
                const r = o.PrivateName;
                a(r.id, t, "id", e1, 1);
                return t;
            }
            function staticBlock(e1) {
                const t = {
                    type: "StaticBlock",
                    body: e1
                };
                const r = o.StaticBlock;
                a(r.body, t, "body", e1, 1);
                return t;
            }
            function importAttribute(e1, t) {
                const r = {
                    type: "ImportAttribute",
                    key: e1,
                    value: t
                };
                const n = o.ImportAttribute;
                a(n.key, r, "key", e1, 1);
                a(n.value, r, "value", t, 1);
                return r;
            }
            function anyTypeAnnotation() {
                return {
                    type: "AnyTypeAnnotation"
                };
            }
            function arrayTypeAnnotation(e1) {
                const t = {
                    type: "ArrayTypeAnnotation",
                    elementType: e1
                };
                const r = o.ArrayTypeAnnotation;
                a(r.elementType, t, "elementType", e1, 1);
                return t;
            }
            function booleanTypeAnnotation() {
                return {
                    type: "BooleanTypeAnnotation"
                };
            }
            function booleanLiteralTypeAnnotation(e1) {
                const t = {
                    type: "BooleanLiteralTypeAnnotation",
                    value: e1
                };
                const r = o.BooleanLiteralTypeAnnotation;
                a(r.value, t, "value", e1);
                return t;
            }
            function nullLiteralTypeAnnotation() {
                return {
                    type: "NullLiteralTypeAnnotation"
                };
            }
            function classImplements(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "ClassImplements",
                    id: e1,
                    typeParameters: t
                };
                const n = o.ClassImplements;
                a(n.id, r, "id", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function declareClass(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "DeclareClass",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: n
                };
                const i = o.DeclareClass;
                a(i.id, s, "id", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.extends, s, "extends", r, 1);
                a(i.body, s, "body", n, 1);
                return s;
            }
            function declareFunction(e1) {
                const t = {
                    type: "DeclareFunction",
                    id: e1
                };
                const r = o.DeclareFunction;
                a(r.id, t, "id", e1, 1);
                return t;
            }
            function declareInterface(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "DeclareInterface",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: n
                };
                const i = o.DeclareInterface;
                a(i.id, s, "id", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.extends, s, "extends", r, 1);
                a(i.body, s, "body", n, 1);
                return s;
            }
            function declareModule(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "DeclareModule",
                    id: e1,
                    body: t,
                    kind: r
                };
                const s = o.DeclareModule;
                a(s.id, n, "id", e1, 1);
                a(s.body, n, "body", t, 1);
                a(s.kind, n, "kind", r);
                return n;
            }
            function declareModuleExports(e1) {
                const t = {
                    type: "DeclareModuleExports",
                    typeAnnotation: e1
                };
                const r = o.DeclareModuleExports;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function declareTypeAlias(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0;
                const n = {
                    type: "DeclareTypeAlias",
                    id: e1,
                    typeParameters: t,
                    right: r
                };
                const s = o.DeclareTypeAlias;
                a(s.id, n, "id", e1, 1);
                a(s.typeParameters, n, "typeParameters", t, 1);
                a(s.right, n, "right", r, 1);
                return n;
            }
            function declareOpaqueType(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "DeclareOpaqueType",
                    id: e1,
                    typeParameters: t,
                    supertype: r
                };
                const s = o.DeclareOpaqueType;
                a(s.id, n, "id", e1, 1);
                a(s.typeParameters, n, "typeParameters", t, 1);
                a(s.supertype, n, "supertype", r, 1);
                return n;
            }
            function declareVariable(e1) {
                const t = {
                    type: "DeclareVariable",
                    id: e1
                };
                const r = o.DeclareVariable;
                a(r.id, t, "id", e1, 1);
                return t;
            }
            function declareExportDeclaration() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "DeclareExportDeclaration",
                    declaration: e1,
                    specifiers: t,
                    source: r,
                    attributes: n
                };
                const i = o.DeclareExportDeclaration;
                a(i.declaration, s, "declaration", e1, 1);
                a(i.specifiers, s, "specifiers", t, 1);
                a(i.source, s, "source", r, 1);
                a(i.attributes, s, "attributes", n, 1);
                return s;
            }
            function declareExportAllDeclaration(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "DeclareExportAllDeclaration",
                    source: e1,
                    attributes: t
                };
                const n = o.DeclareExportAllDeclaration;
                a(n.source, r, "source", e1, 1);
                a(n.attributes, r, "attributes", t, 1);
                return r;
            }
            function declaredPredicate(e1) {
                const t = {
                    type: "DeclaredPredicate",
                    value: e1
                };
                const r = o.DeclaredPredicate;
                a(r.value, t, "value", e1, 1);
                return t;
            }
            function existsTypeAnnotation() {
                return {
                    type: "ExistsTypeAnnotation"
                };
            }
            function functionTypeAnnotation() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "FunctionTypeAnnotation",
                    typeParameters: e1,
                    params: t,
                    rest: r,
                    returnType: n
                };
                const i = o.FunctionTypeAnnotation;
                a(i.typeParameters, s, "typeParameters", e1, 1);
                a(i.params, s, "params", t, 1);
                a(i.rest, s, "rest", r, 1);
                a(i.returnType, s, "returnType", n, 1);
                return s;
            }
            function functionTypeParam() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
                const r = {
                    type: "FunctionTypeParam",
                    name: e1,
                    typeAnnotation: t
                };
                const n = o.FunctionTypeParam;
                a(n.name, r, "name", e1, 1);
                a(n.typeAnnotation, r, "typeAnnotation", t, 1);
                return r;
            }
            function genericTypeAnnotation(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "GenericTypeAnnotation",
                    id: e1,
                    typeParameters: t
                };
                const n = o.GenericTypeAnnotation;
                a(n.id, r, "id", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function inferredPredicate() {
                return {
                    type: "InferredPredicate"
                };
            }
            function interfaceExtends(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "InterfaceExtends",
                    id: e1,
                    typeParameters: t
                };
                const n = o.InterfaceExtends;
                a(n.id, r, "id", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function interfaceDeclaration(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "InterfaceDeclaration",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: n
                };
                const i = o.InterfaceDeclaration;
                a(i.id, s, "id", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.extends, s, "extends", r, 1);
                a(i.body, s, "body", n, 1);
                return s;
            }
            function interfaceTypeAnnotation() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
                const r = {
                    type: "InterfaceTypeAnnotation",
                    extends: e1,
                    body: t
                };
                const n = o.InterfaceTypeAnnotation;
                a(n.extends, r, "extends", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function intersectionTypeAnnotation(e1) {
                const t = {
                    type: "IntersectionTypeAnnotation",
                    types: e1
                };
                const r = o.IntersectionTypeAnnotation;
                a(r.types, t, "types", e1, 1);
                return t;
            }
            function mixedTypeAnnotation() {
                return {
                    type: "MixedTypeAnnotation"
                };
            }
            function emptyTypeAnnotation() {
                return {
                    type: "EmptyTypeAnnotation"
                };
            }
            function nullableTypeAnnotation(e1) {
                const t = {
                    type: "NullableTypeAnnotation",
                    typeAnnotation: e1
                };
                const r = o.NullableTypeAnnotation;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function numberLiteralTypeAnnotation(e1) {
                const t = {
                    type: "NumberLiteralTypeAnnotation",
                    value: e1
                };
                const r = o.NumberLiteralTypeAnnotation;
                a(r.value, t, "value", e1);
                return t;
            }
            function numberTypeAnnotation() {
                return {
                    type: "NumberTypeAnnotation"
                };
            }
            function objectTypeAnnotation(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                const i = {
                    type: "ObjectTypeAnnotation",
                    properties: e1,
                    indexers: t,
                    callProperties: r,
                    internalSlots: n,
                    exact: s
                };
                const l = o.ObjectTypeAnnotation;
                a(l.properties, i, "properties", e1, 1);
                a(l.indexers, i, "indexers", t, 1);
                a(l.callProperties, i, "callProperties", r, 1);
                a(l.internalSlots, i, "internalSlots", n, 1);
                a(l.exact, i, "exact", s);
                return i;
            }
            function objectTypeInternalSlot(e1, t, r, n, s) {
                const i = {
                    type: "ObjectTypeInternalSlot",
                    id: e1,
                    value: t,
                    optional: r,
                    static: n,
                    method: s
                };
                const l = o.ObjectTypeInternalSlot;
                a(l.id, i, "id", e1, 1);
                a(l.value, i, "value", t, 1);
                a(l.optional, i, "optional", r);
                a(l.static, i, "static", n);
                a(l.method, i, "method", s);
                return i;
            }
            function objectTypeCallProperty(e1) {
                const t = {
                    type: "ObjectTypeCallProperty",
                    value: e1,
                    static: null
                };
                const r = o.ObjectTypeCallProperty;
                a(r.value, t, "value", e1, 1);
                return t;
            }
            function objectTypeIndexer() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "ObjectTypeIndexer",
                    id: e1,
                    key: t,
                    value: r,
                    variance: n,
                    static: null
                };
                const i = o.ObjectTypeIndexer;
                a(i.id, s, "id", e1, 1);
                a(i.key, s, "key", t, 1);
                a(i.value, s, "value", r, 1);
                a(i.variance, s, "variance", n, 1);
                return s;
            }
            function objectTypeProperty(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "ObjectTypeProperty",
                    key: e1,
                    value: t,
                    variance: r,
                    kind: null,
                    method: null,
                    optional: null,
                    proto: null,
                    static: null
                };
                const s = o.ObjectTypeProperty;
                a(s.key, n, "key", e1, 1);
                a(s.value, n, "value", t, 1);
                a(s.variance, n, "variance", r, 1);
                return n;
            }
            function objectTypeSpreadProperty(e1) {
                const t = {
                    type: "ObjectTypeSpreadProperty",
                    argument: e1
                };
                const r = o.ObjectTypeSpreadProperty;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function opaqueType(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "OpaqueType",
                    id: e1,
                    typeParameters: t,
                    supertype: r,
                    impltype: n
                };
                const i = o.OpaqueType;
                a(i.id, s, "id", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.supertype, s, "supertype", r, 1);
                a(i.impltype, s, "impltype", n, 1);
                return s;
            }
            function qualifiedTypeIdentifier(e1, t) {
                const r = {
                    type: "QualifiedTypeIdentifier",
                    id: e1,
                    qualification: t
                };
                const n = o.QualifiedTypeIdentifier;
                a(n.id, r, "id", e1, 1);
                a(n.qualification, r, "qualification", t, 1);
                return r;
            }
            function stringLiteralTypeAnnotation(e1) {
                const t = {
                    type: "StringLiteralTypeAnnotation",
                    value: e1
                };
                const r = o.StringLiteralTypeAnnotation;
                a(r.value, t, "value", e1);
                return t;
            }
            function stringTypeAnnotation() {
                return {
                    type: "StringTypeAnnotation"
                };
            }
            function symbolTypeAnnotation() {
                return {
                    type: "SymbolTypeAnnotation"
                };
            }
            function thisTypeAnnotation() {
                return {
                    type: "ThisTypeAnnotation"
                };
            }
            function tupleTypeAnnotation(e1) {
                const t = {
                    type: "TupleTypeAnnotation",
                    types: e1
                };
                const r = o.TupleTypeAnnotation;
                a(r.types, t, "types", e1, 1);
                return t;
            }
            function typeofTypeAnnotation(e1) {
                const t = {
                    type: "TypeofTypeAnnotation",
                    argument: e1
                };
                const r = o.TypeofTypeAnnotation;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function typeAlias(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0;
                const n = {
                    type: "TypeAlias",
                    id: e1,
                    typeParameters: t,
                    right: r
                };
                const s = o.TypeAlias;
                a(s.id, n, "id", e1, 1);
                a(s.typeParameters, n, "typeParameters", t, 1);
                a(s.right, n, "right", r, 1);
                return n;
            }
            function typeAnnotation(e1) {
                const t = {
                    type: "TypeAnnotation",
                    typeAnnotation: e1
                };
                const r = o.TypeAnnotation;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function typeCastExpression(e1, t) {
                const r = {
                    type: "TypeCastExpression",
                    expression: e1,
                    typeAnnotation: t
                };
                const n = o.TypeCastExpression;
                a(n.expression, r, "expression", e1, 1);
                a(n.typeAnnotation, r, "typeAnnotation", t, 1);
                return r;
            }
            function typeParameter() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TypeParameter",
                    bound: e1,
                    default: t,
                    variance: r,
                    name: null
                };
                const s = o.TypeParameter;
                a(s.bound, n, "bound", e1, 1);
                a(s.default, n, "default", t, 1);
                a(s.variance, n, "variance", r, 1);
                return n;
            }
            function typeParameterDeclaration(e1) {
                const t = {
                    type: "TypeParameterDeclaration",
                    params: e1
                };
                const r = o.TypeParameterDeclaration;
                a(r.params, t, "params", e1, 1);
                return t;
            }
            function typeParameterInstantiation(e1) {
                const t = {
                    type: "TypeParameterInstantiation",
                    params: e1
                };
                const r = o.TypeParameterInstantiation;
                a(r.params, t, "params", e1, 1);
                return t;
            }
            function unionTypeAnnotation(e1) {
                const t = {
                    type: "UnionTypeAnnotation",
                    types: e1
                };
                const r = o.UnionTypeAnnotation;
                a(r.types, t, "types", e1, 1);
                return t;
            }
            function variance(e1) {
                const t = {
                    type: "Variance",
                    kind: e1
                };
                const r = o.Variance;
                a(r.kind, t, "kind", e1);
                return t;
            }
            function voidTypeAnnotation() {
                return {
                    type: "VoidTypeAnnotation"
                };
            }
            function enumDeclaration(e1, t) {
                const r = {
                    type: "EnumDeclaration",
                    id: e1,
                    body: t
                };
                const n = o.EnumDeclaration;
                a(n.id, r, "id", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function enumBooleanBody(e1) {
                const t = {
                    type: "EnumBooleanBody",
                    members: e1,
                    explicitType: null,
                    hasUnknownMembers: null
                };
                const r = o.EnumBooleanBody;
                a(r.members, t, "members", e1, 1);
                return t;
            }
            function enumNumberBody(e1) {
                const t = {
                    type: "EnumNumberBody",
                    members: e1,
                    explicitType: null,
                    hasUnknownMembers: null
                };
                const r = o.EnumNumberBody;
                a(r.members, t, "members", e1, 1);
                return t;
            }
            function enumStringBody(e1) {
                const t = {
                    type: "EnumStringBody",
                    members: e1,
                    explicitType: null,
                    hasUnknownMembers: null
                };
                const r = o.EnumStringBody;
                a(r.members, t, "members", e1, 1);
                return t;
            }
            function enumSymbolBody(e1) {
                const t = {
                    type: "EnumSymbolBody",
                    members: e1,
                    hasUnknownMembers: null
                };
                const r = o.EnumSymbolBody;
                a(r.members, t, "members", e1, 1);
                return t;
            }
            function enumBooleanMember(e1) {
                const t = {
                    type: "EnumBooleanMember",
                    id: e1,
                    init: null
                };
                const r = o.EnumBooleanMember;
                a(r.id, t, "id", e1, 1);
                return t;
            }
            function enumNumberMember(e1, t) {
                const r = {
                    type: "EnumNumberMember",
                    id: e1,
                    init: t
                };
                const n = o.EnumNumberMember;
                a(n.id, r, "id", e1, 1);
                a(n.init, r, "init", t, 1);
                return r;
            }
            function enumStringMember(e1, t) {
                const r = {
                    type: "EnumStringMember",
                    id: e1,
                    init: t
                };
                const n = o.EnumStringMember;
                a(n.id, r, "id", e1, 1);
                a(n.init, r, "init", t, 1);
                return r;
            }
            function enumDefaultedMember(e1) {
                const t = {
                    type: "EnumDefaultedMember",
                    id: e1
                };
                const r = o.EnumDefaultedMember;
                a(r.id, t, "id", e1, 1);
                return t;
            }
            function indexedAccessType(e1, t) {
                const r = {
                    type: "IndexedAccessType",
                    objectType: e1,
                    indexType: t
                };
                const n = o.IndexedAccessType;
                a(n.objectType, r, "objectType", e1, 1);
                a(n.indexType, r, "indexType", t, 1);
                return r;
            }
            function optionalIndexedAccessType(e1, t) {
                const r = {
                    type: "OptionalIndexedAccessType",
                    objectType: e1,
                    indexType: t,
                    optional: null
                };
                const n = o.OptionalIndexedAccessType;
                a(n.objectType, r, "objectType", e1, 1);
                a(n.indexType, r, "indexType", t, 1);
                return r;
            }
            function jsxAttribute(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "JSXAttribute",
                    name: e1,
                    value: t
                };
                const n = o.JSXAttribute;
                a(n.name, r, "name", e1, 1);
                a(n.value, r, "value", t, 1);
                return r;
            }
            function jsxClosingElement(e1) {
                const t = {
                    type: "JSXClosingElement",
                    name: e1
                };
                const r = o.JSXClosingElement;
                a(r.name, t, "name", e1, 1);
                return t;
            }
            function jsxElement(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "JSXElement",
                    openingElement: e1,
                    closingElement: t,
                    children: r,
                    selfClosing: n
                };
                const i = o.JSXElement;
                a(i.openingElement, s, "openingElement", e1, 1);
                a(i.closingElement, s, "closingElement", t, 1);
                a(i.children, s, "children", r, 1);
                a(i.selfClosing, s, "selfClosing", n);
                return s;
            }
            function jsxEmptyExpression() {
                return {
                    type: "JSXEmptyExpression"
                };
            }
            function jsxExpressionContainer(e1) {
                const t = {
                    type: "JSXExpressionContainer",
                    expression: e1
                };
                const r = o.JSXExpressionContainer;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function jsxSpreadChild(e1) {
                const t = {
                    type: "JSXSpreadChild",
                    expression: e1
                };
                const r = o.JSXSpreadChild;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function jsxIdentifier(e1) {
                const t = {
                    type: "JSXIdentifier",
                    name: e1
                };
                const r = o.JSXIdentifier;
                a(r.name, t, "name", e1);
                return t;
            }
            function jsxMemberExpression(e1, t) {
                const r = {
                    type: "JSXMemberExpression",
                    object: e1,
                    property: t
                };
                const n = o.JSXMemberExpression;
                a(n.object, r, "object", e1, 1);
                a(n.property, r, "property", t, 1);
                return r;
            }
            function jsxNamespacedName(e1, t) {
                const r = {
                    type: "JSXNamespacedName",
                    namespace: e1,
                    name: t
                };
                const n = o.JSXNamespacedName;
                a(n.namespace, r, "namespace", e1, 1);
                a(n.name, r, "name", t, 1);
                return r;
            }
            function jsxOpeningElement(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                const n = {
                    type: "JSXOpeningElement",
                    name: e1,
                    attributes: t,
                    selfClosing: r
                };
                const s = o.JSXOpeningElement;
                a(s.name, n, "name", e1, 1);
                a(s.attributes, n, "attributes", t, 1);
                a(s.selfClosing, n, "selfClosing", r);
                return n;
            }
            function jsxSpreadAttribute(e1) {
                const t = {
                    type: "JSXSpreadAttribute",
                    argument: e1
                };
                const r = o.JSXSpreadAttribute;
                a(r.argument, t, "argument", e1, 1);
                return t;
            }
            function jsxText(e1) {
                const t = {
                    type: "JSXText",
                    value: e1
                };
                const r = o.JSXText;
                a(r.value, t, "value", e1);
                return t;
            }
            function jsxFragment(e1, t, r) {
                const n = {
                    type: "JSXFragment",
                    openingFragment: e1,
                    closingFragment: t,
                    children: r
                };
                const s = o.JSXFragment;
                a(s.openingFragment, n, "openingFragment", e1, 1);
                a(s.closingFragment, n, "closingFragment", t, 1);
                a(s.children, n, "children", r, 1);
                return n;
            }
            function jsxOpeningFragment() {
                return {
                    type: "JSXOpeningFragment"
                };
            }
            function jsxClosingFragment() {
                return {
                    type: "JSXClosingFragment"
                };
            }
            function noop() {
                return {
                    type: "Noop"
                };
            }
            function placeholder(e1, t) {
                const r = {
                    type: "Placeholder",
                    expectedNode: e1,
                    name: t
                };
                const n = o.Placeholder;
                a(n.expectedNode, r, "expectedNode", e1);
                a(n.name, r, "name", t, 1);
                return r;
            }
            function v8IntrinsicIdentifier(e1) {
                const t = {
                    type: "V8IntrinsicIdentifier",
                    name: e1
                };
                const r = o.V8IntrinsicIdentifier;
                a(r.name, t, "name", e1);
                return t;
            }
            function argumentPlaceholder() {
                return {
                    type: "ArgumentPlaceholder"
                };
            }
            function bindExpression(e1, t) {
                const r = {
                    type: "BindExpression",
                    object: e1,
                    callee: t
                };
                const n = o.BindExpression;
                a(n.object, r, "object", e1, 1);
                a(n.callee, r, "callee", t, 1);
                return r;
            }
            function decorator(e1) {
                const t = {
                    type: "Decorator",
                    expression: e1
                };
                const r = o.Decorator;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function doExpression(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                const r = {
                    type: "DoExpression",
                    body: e1,
                    async: t
                };
                const n = o.DoExpression;
                a(n.body, r, "body", e1, 1);
                a(n.async, r, "async", t);
                return r;
            }
            function exportDefaultSpecifier(e1) {
                const t = {
                    type: "ExportDefaultSpecifier",
                    exported: e1
                };
                const r = o.ExportDefaultSpecifier;
                a(r.exported, t, "exported", e1, 1);
                return t;
            }
            function recordExpression(e1) {
                const t = {
                    type: "RecordExpression",
                    properties: e1
                };
                const r = o.RecordExpression;
                a(r.properties, t, "properties", e1, 1);
                return t;
            }
            function tupleExpression() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                const t = {
                    type: "TupleExpression",
                    elements: e1
                };
                const r = o.TupleExpression;
                a(r.elements, t, "elements", e1, 1);
                return t;
            }
            function decimalLiteral(e1) {
                const t = {
                    type: "DecimalLiteral",
                    value: e1
                };
                const r = o.DecimalLiteral;
                a(r.value, t, "value", e1);
                return t;
            }
            function moduleExpression(e1) {
                const t = {
                    type: "ModuleExpression",
                    body: e1
                };
                const r = o.ModuleExpression;
                a(r.body, t, "body", e1, 1);
                return t;
            }
            function topicReference() {
                return {
                    type: "TopicReference"
                };
            }
            function pipelineTopicExpression(e1) {
                const t = {
                    type: "PipelineTopicExpression",
                    expression: e1
                };
                const r = o.PipelineTopicExpression;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function pipelineBareFunction(e1) {
                const t = {
                    type: "PipelineBareFunction",
                    callee: e1
                };
                const r = o.PipelineBareFunction;
                a(r.callee, t, "callee", e1, 1);
                return t;
            }
            function pipelinePrimaryTopicReference() {
                return {
                    type: "PipelinePrimaryTopicReference"
                };
            }
            function tsParameterProperty(e1) {
                const t = {
                    type: "TSParameterProperty",
                    parameter: e1
                };
                const r = o.TSParameterProperty;
                a(r.parameter, t, "parameter", e1, 1);
                return t;
            }
            function tsDeclareFunction() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "TSDeclareFunction",
                    id: e1,
                    typeParameters: t,
                    params: r,
                    returnType: n
                };
                const i = o.TSDeclareFunction;
                a(i.id, s, "id", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.params, s, "params", r, 1);
                a(i.returnType, s, "returnType", n, 1);
                return s;
            }
            function tsDeclareMethod() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                const i = {
                    type: "TSDeclareMethod",
                    decorators: e1,
                    key: t,
                    typeParameters: r,
                    params: n,
                    returnType: s
                };
                const l = o.TSDeclareMethod;
                a(l.decorators, i, "decorators", e1, 1);
                a(l.key, i, "key", t, 1);
                a(l.typeParameters, i, "typeParameters", r, 1);
                a(l.params, i, "params", n, 1);
                a(l.returnType, i, "returnType", s, 1);
                return i;
            }
            function tsQualifiedName(e1, t) {
                const r = {
                    type: "TSQualifiedName",
                    left: e1,
                    right: t
                };
                const n = o.TSQualifiedName;
                a(n.left, r, "left", e1, 1);
                a(n.right, r, "right", t, 1);
                return r;
            }
            function tsCallSignatureDeclaration() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSCallSignatureDeclaration",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                };
                const s = o.TSCallSignatureDeclaration;
                a(s.typeParameters, n, "typeParameters", e1, 1);
                a(s.parameters, n, "parameters", t, 1);
                a(s.typeAnnotation, n, "typeAnnotation", r, 1);
                return n;
            }
            function tsConstructSignatureDeclaration() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSConstructSignatureDeclaration",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                };
                const s = o.TSConstructSignatureDeclaration;
                a(s.typeParameters, n, "typeParameters", e1, 1);
                a(s.parameters, n, "parameters", t, 1);
                a(s.typeAnnotation, n, "typeAnnotation", r, 1);
                return n;
            }
            function tsPropertySignature(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSPropertySignature",
                    key: e1,
                    typeAnnotation: t
                };
                const n = o.TSPropertySignature;
                a(n.key, r, "key", e1, 1);
                a(n.typeAnnotation, r, "typeAnnotation", t, 1);
                return r;
            }
            function tsMethodSignature(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                const s = {
                    type: "TSMethodSignature",
                    key: e1,
                    typeParameters: t,
                    parameters: r,
                    typeAnnotation: n,
                    kind: null
                };
                const i = o.TSMethodSignature;
                a(i.key, s, "key", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.parameters, s, "parameters", r, 1);
                a(i.typeAnnotation, s, "typeAnnotation", n, 1);
                return s;
            }
            function tsIndexSignature(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSIndexSignature",
                    parameters: e1,
                    typeAnnotation: t
                };
                const n = o.TSIndexSignature;
                a(n.parameters, r, "parameters", e1, 1);
                a(n.typeAnnotation, r, "typeAnnotation", t, 1);
                return r;
            }
            function tsAnyKeyword() {
                return {
                    type: "TSAnyKeyword"
                };
            }
            function tsBooleanKeyword() {
                return {
                    type: "TSBooleanKeyword"
                };
            }
            function tsBigIntKeyword() {
                return {
                    type: "TSBigIntKeyword"
                };
            }
            function tsIntrinsicKeyword() {
                return {
                    type: "TSIntrinsicKeyword"
                };
            }
            function tsNeverKeyword() {
                return {
                    type: "TSNeverKeyword"
                };
            }
            function tsNullKeyword() {
                return {
                    type: "TSNullKeyword"
                };
            }
            function tsNumberKeyword() {
                return {
                    type: "TSNumberKeyword"
                };
            }
            function tsObjectKeyword() {
                return {
                    type: "TSObjectKeyword"
                };
            }
            function tsStringKeyword() {
                return {
                    type: "TSStringKeyword"
                };
            }
            function tsSymbolKeyword() {
                return {
                    type: "TSSymbolKeyword"
                };
            }
            function tsUndefinedKeyword() {
                return {
                    type: "TSUndefinedKeyword"
                };
            }
            function tsUnknownKeyword() {
                return {
                    type: "TSUnknownKeyword"
                };
            }
            function tsVoidKeyword() {
                return {
                    type: "TSVoidKeyword"
                };
            }
            function tsThisType() {
                return {
                    type: "TSThisType"
                };
            }
            function tsFunctionType() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSFunctionType",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                };
                const s = o.TSFunctionType;
                a(s.typeParameters, n, "typeParameters", e1, 1);
                a(s.parameters, n, "parameters", t, 1);
                a(s.typeAnnotation, n, "typeAnnotation", r, 1);
                return n;
            }
            function tsConstructorType() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSConstructorType",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                };
                const s = o.TSConstructorType;
                a(s.typeParameters, n, "typeParameters", e1, 1);
                a(s.parameters, n, "parameters", t, 1);
                a(s.typeAnnotation, n, "typeAnnotation", r, 1);
                return n;
            }
            function tsTypeReference(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSTypeReference",
                    typeName: e1,
                    typeParameters: t
                };
                const n = o.TSTypeReference;
                a(n.typeName, r, "typeName", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function tsTypePredicate(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSTypePredicate",
                    parameterName: e1,
                    typeAnnotation: t,
                    asserts: r
                };
                const s = o.TSTypePredicate;
                a(s.parameterName, n, "parameterName", e1, 1);
                a(s.typeAnnotation, n, "typeAnnotation", t, 1);
                a(s.asserts, n, "asserts", r);
                return n;
            }
            function tsTypeQuery(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSTypeQuery",
                    exprName: e1,
                    typeParameters: t
                };
                const n = o.TSTypeQuery;
                a(n.exprName, r, "exprName", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function tsTypeLiteral(e1) {
                const t = {
                    type: "TSTypeLiteral",
                    members: e1
                };
                const r = o.TSTypeLiteral;
                a(r.members, t, "members", e1, 1);
                return t;
            }
            function tsArrayType(e1) {
                const t = {
                    type: "TSArrayType",
                    elementType: e1
                };
                const r = o.TSArrayType;
                a(r.elementType, t, "elementType", e1, 1);
                return t;
            }
            function tsTupleType(e1) {
                const t = {
                    type: "TSTupleType",
                    elementTypes: e1
                };
                const r = o.TSTupleType;
                a(r.elementTypes, t, "elementTypes", e1, 1);
                return t;
            }
            function tsOptionalType(e1) {
                const t = {
                    type: "TSOptionalType",
                    typeAnnotation: e1
                };
                const r = o.TSOptionalType;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function tsRestType(e1) {
                const t = {
                    type: "TSRestType",
                    typeAnnotation: e1
                };
                const r = o.TSRestType;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function tsNamedTupleMember(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                const n = {
                    type: "TSNamedTupleMember",
                    label: e1,
                    elementType: t,
                    optional: r
                };
                const s = o.TSNamedTupleMember;
                a(s.label, n, "label", e1, 1);
                a(s.elementType, n, "elementType", t, 1);
                a(s.optional, n, "optional", r);
                return n;
            }
            function tsUnionType(e1) {
                const t = {
                    type: "TSUnionType",
                    types: e1
                };
                const r = o.TSUnionType;
                a(r.types, t, "types", e1, 1);
                return t;
            }
            function tsIntersectionType(e1) {
                const t = {
                    type: "TSIntersectionType",
                    types: e1
                };
                const r = o.TSIntersectionType;
                a(r.types, t, "types", e1, 1);
                return t;
            }
            function tsConditionalType(e1, t, r, n) {
                const s = {
                    type: "TSConditionalType",
                    checkType: e1,
                    extendsType: t,
                    trueType: r,
                    falseType: n
                };
                const i = o.TSConditionalType;
                a(i.checkType, s, "checkType", e1, 1);
                a(i.extendsType, s, "extendsType", t, 1);
                a(i.trueType, s, "trueType", r, 1);
                a(i.falseType, s, "falseType", n, 1);
                return s;
            }
            function tsInferType(e1) {
                const t = {
                    type: "TSInferType",
                    typeParameter: e1
                };
                const r = o.TSInferType;
                a(r.typeParameter, t, "typeParameter", e1, 1);
                return t;
            }
            function tsParenthesizedType(e1) {
                const t = {
                    type: "TSParenthesizedType",
                    typeAnnotation: e1
                };
                const r = o.TSParenthesizedType;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function tsTypeOperator(e1) {
                const t = {
                    type: "TSTypeOperator",
                    typeAnnotation: e1,
                    operator: null
                };
                const r = o.TSTypeOperator;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function tsIndexedAccessType(e1, t) {
                const r = {
                    type: "TSIndexedAccessType",
                    objectType: e1,
                    indexType: t
                };
                const n = o.TSIndexedAccessType;
                a(n.objectType, r, "objectType", e1, 1);
                a(n.indexType, r, "indexType", t, 1);
                return r;
            }
            function tsMappedType(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSMappedType",
                    typeParameter: e1,
                    typeAnnotation: t,
                    nameType: r
                };
                const s = o.TSMappedType;
                a(s.typeParameter, n, "typeParameter", e1, 1);
                a(s.typeAnnotation, n, "typeAnnotation", t, 1);
                a(s.nameType, n, "nameType", r, 1);
                return n;
            }
            function tsTemplateLiteralType(e1, t) {
                const r = {
                    type: "TSTemplateLiteralType",
                    quasis: e1,
                    types: t
                };
                const n = o.TSTemplateLiteralType;
                a(n.quasis, r, "quasis", e1, 1);
                a(n.types, r, "types", t, 1);
                return r;
            }
            function tsLiteralType(e1) {
                const t = {
                    type: "TSLiteralType",
                    literal: e1
                };
                const r = o.TSLiteralType;
                a(r.literal, t, "literal", e1, 1);
                return t;
            }
            function tsExpressionWithTypeArguments(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSExpressionWithTypeArguments",
                    expression: e1,
                    typeParameters: t
                };
                const n = o.TSExpressionWithTypeArguments;
                a(n.expression, r, "expression", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function tsInterfaceDeclaration(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 ? arguments[3] : void 0;
                const s = {
                    type: "TSInterfaceDeclaration",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: n
                };
                const i = o.TSInterfaceDeclaration;
                a(i.id, s, "id", e1, 1);
                a(i.typeParameters, s, "typeParameters", t, 1);
                a(i.extends, s, "extends", r, 1);
                a(i.body, s, "body", n, 1);
                return s;
            }
            function tsInterfaceBody(e1) {
                const t = {
                    type: "TSInterfaceBody",
                    body: e1
                };
                const r = o.TSInterfaceBody;
                a(r.body, t, "body", e1, 1);
                return t;
            }
            function tsTypeAliasDeclaration(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0;
                const n = {
                    type: "TSTypeAliasDeclaration",
                    id: e1,
                    typeParameters: t,
                    typeAnnotation: r
                };
                const s = o.TSTypeAliasDeclaration;
                a(s.id, n, "id", e1, 1);
                a(s.typeParameters, n, "typeParameters", t, 1);
                a(s.typeAnnotation, n, "typeAnnotation", r, 1);
                return n;
            }
            function tsInstantiationExpression(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSInstantiationExpression",
                    expression: e1,
                    typeParameters: t
                };
                const n = o.TSInstantiationExpression;
                a(n.expression, r, "expression", e1, 1);
                a(n.typeParameters, r, "typeParameters", t, 1);
                return r;
            }
            function tsAsExpression(e1, t) {
                const r = {
                    type: "TSAsExpression",
                    expression: e1,
                    typeAnnotation: t
                };
                const n = o.TSAsExpression;
                a(n.expression, r, "expression", e1, 1);
                a(n.typeAnnotation, r, "typeAnnotation", t, 1);
                return r;
            }
            function tsSatisfiesExpression(e1, t) {
                const r = {
                    type: "TSSatisfiesExpression",
                    expression: e1,
                    typeAnnotation: t
                };
                const n = o.TSSatisfiesExpression;
                a(n.expression, r, "expression", e1, 1);
                a(n.typeAnnotation, r, "typeAnnotation", t, 1);
                return r;
            }
            function tsTypeAssertion(e1, t) {
                const r = {
                    type: "TSTypeAssertion",
                    typeAnnotation: e1,
                    expression: t
                };
                const n = o.TSTypeAssertion;
                a(n.typeAnnotation, r, "typeAnnotation", e1, 1);
                a(n.expression, r, "expression", t, 1);
                return r;
            }
            function tsEnumBody(e1) {
                const t = {
                    type: "TSEnumBody",
                    members: e1
                };
                const r = o.TSEnumBody;
                a(r.members, t, "members", e1, 1);
                return t;
            }
            function tsEnumDeclaration(e1, t) {
                const r = {
                    type: "TSEnumDeclaration",
                    id: e1,
                    members: t
                };
                const n = o.TSEnumDeclaration;
                a(n.id, r, "id", e1, 1);
                a(n.members, r, "members", t, 1);
                return r;
            }
            function tsEnumMember(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                const r = {
                    type: "TSEnumMember",
                    id: e1,
                    initializer: t
                };
                const n = o.TSEnumMember;
                a(n.id, r, "id", e1, 1);
                a(n.initializer, r, "initializer", t, 1);
                return r;
            }
            function tsModuleDeclaration(e1, t) {
                const r = {
                    type: "TSModuleDeclaration",
                    id: e1,
                    body: t,
                    kind: null
                };
                const n = o.TSModuleDeclaration;
                a(n.id, r, "id", e1, 1);
                a(n.body, r, "body", t, 1);
                return r;
            }
            function tsModuleBlock(e1) {
                const t = {
                    type: "TSModuleBlock",
                    body: e1
                };
                const r = o.TSModuleBlock;
                a(r.body, t, "body", e1, 1);
                return t;
            }
            function tsImportType(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                const n = {
                    type: "TSImportType",
                    argument: e1,
                    qualifier: t,
                    typeParameters: r
                };
                const s = o.TSImportType;
                a(s.argument, n, "argument", e1, 1);
                a(s.qualifier, n, "qualifier", t, 1);
                a(s.typeParameters, n, "typeParameters", r, 1);
                return n;
            }
            function tsImportEqualsDeclaration(e1, t) {
                const r = {
                    type: "TSImportEqualsDeclaration",
                    id: e1,
                    moduleReference: t,
                    isExport: null
                };
                const n = o.TSImportEqualsDeclaration;
                a(n.id, r, "id", e1, 1);
                a(n.moduleReference, r, "moduleReference", t, 1);
                return r;
            }
            function tsExternalModuleReference(e1) {
                const t = {
                    type: "TSExternalModuleReference",
                    expression: e1
                };
                const r = o.TSExternalModuleReference;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function tsNonNullExpression(e1) {
                const t = {
                    type: "TSNonNullExpression",
                    expression: e1
                };
                const r = o.TSNonNullExpression;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function tsExportAssignment(e1) {
                const t = {
                    type: "TSExportAssignment",
                    expression: e1
                };
                const r = o.TSExportAssignment;
                a(r.expression, t, "expression", e1, 1);
                return t;
            }
            function tsNamespaceExportDeclaration(e1) {
                const t = {
                    type: "TSNamespaceExportDeclaration",
                    id: e1
                };
                const r = o.TSNamespaceExportDeclaration;
                a(r.id, t, "id", e1, 1);
                return t;
            }
            function tsTypeAnnotation(e1) {
                const t = {
                    type: "TSTypeAnnotation",
                    typeAnnotation: e1
                };
                const r = o.TSTypeAnnotation;
                a(r.typeAnnotation, t, "typeAnnotation", e1, 1);
                return t;
            }
            function tsTypeParameterInstantiation(e1) {
                const t = {
                    type: "TSTypeParameterInstantiation",
                    params: e1
                };
                const r = o.TSTypeParameterInstantiation;
                a(r.params, t, "params", e1, 1);
                return t;
            }
            function tsTypeParameterDeclaration(e1) {
                const t = {
                    type: "TSTypeParameterDeclaration",
                    params: e1
                };
                const r = o.TSTypeParameterDeclaration;
                a(r.params, t, "params", e1, 1);
                return t;
            }
            function tsTypeParameter() {
                let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, r = arguments.length > 2 ? arguments[2] : void 0;
                const n = {
                    type: "TSTypeParameter",
                    constraint: e1,
                    default: t,
                    name: r
                };
                const s = o.TSTypeParameter;
                a(s.constraint, n, "constraint", e1, 1);
                a(s.default, n, "default", t, 1);
                a(s.name, n, "name", r);
                return n;
            }
            function NumberLiteral(e1) {
                (0, s.default)("NumberLiteral", "NumericLiteral", "The node type ");
                return numericLiteral(e1);
            }
            function RegexLiteral(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                (0, s.default)("RegexLiteral", "RegExpLiteral", "The node type ");
                return regExpLiteral(e1, t);
            }
            function RestProperty(e1) {
                (0, s.default)("RestProperty", "RestElement", "The node type ");
                return restElement(e1);
            }
            function SpreadProperty(e1) {
                (0, s.default)("SpreadProperty", "SpreadElement", "The node type ");
                return spreadElement(e1);
            }
        },
        7903: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "AnyTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.anyTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ArgumentPlaceholder", {
                enumerable: true,
                get: function() {
                    return n.argumentPlaceholder;
                }
            });
            Object.defineProperty(t, "ArrayExpression", {
                enumerable: true,
                get: function() {
                    return n.arrayExpression;
                }
            });
            Object.defineProperty(t, "ArrayPattern", {
                enumerable: true,
                get: function() {
                    return n.arrayPattern;
                }
            });
            Object.defineProperty(t, "ArrayTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.arrayTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ArrowFunctionExpression", {
                enumerable: true,
                get: function() {
                    return n.arrowFunctionExpression;
                }
            });
            Object.defineProperty(t, "AssignmentExpression", {
                enumerable: true,
                get: function() {
                    return n.assignmentExpression;
                }
            });
            Object.defineProperty(t, "AssignmentPattern", {
                enumerable: true,
                get: function() {
                    return n.assignmentPattern;
                }
            });
            Object.defineProperty(t, "AwaitExpression", {
                enumerable: true,
                get: function() {
                    return n.awaitExpression;
                }
            });
            Object.defineProperty(t, "BigIntLiteral", {
                enumerable: true,
                get: function() {
                    return n.bigIntLiteral;
                }
            });
            Object.defineProperty(t, "BinaryExpression", {
                enumerable: true,
                get: function() {
                    return n.binaryExpression;
                }
            });
            Object.defineProperty(t, "BindExpression", {
                enumerable: true,
                get: function() {
                    return n.bindExpression;
                }
            });
            Object.defineProperty(t, "BlockStatement", {
                enumerable: true,
                get: function() {
                    return n.blockStatement;
                }
            });
            Object.defineProperty(t, "BooleanLiteral", {
                enumerable: true,
                get: function() {
                    return n.booleanLiteral;
                }
            });
            Object.defineProperty(t, "BooleanLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.booleanLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "BooleanTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.booleanTypeAnnotation;
                }
            });
            Object.defineProperty(t, "BreakStatement", {
                enumerable: true,
                get: function() {
                    return n.breakStatement;
                }
            });
            Object.defineProperty(t, "CallExpression", {
                enumerable: true,
                get: function() {
                    return n.callExpression;
                }
            });
            Object.defineProperty(t, "CatchClause", {
                enumerable: true,
                get: function() {
                    return n.catchClause;
                }
            });
            Object.defineProperty(t, "ClassAccessorProperty", {
                enumerable: true,
                get: function() {
                    return n.classAccessorProperty;
                }
            });
            Object.defineProperty(t, "ClassBody", {
                enumerable: true,
                get: function() {
                    return n.classBody;
                }
            });
            Object.defineProperty(t, "ClassDeclaration", {
                enumerable: true,
                get: function() {
                    return n.classDeclaration;
                }
            });
            Object.defineProperty(t, "ClassExpression", {
                enumerable: true,
                get: function() {
                    return n.classExpression;
                }
            });
            Object.defineProperty(t, "ClassImplements", {
                enumerable: true,
                get: function() {
                    return n.classImplements;
                }
            });
            Object.defineProperty(t, "ClassMethod", {
                enumerable: true,
                get: function() {
                    return n.classMethod;
                }
            });
            Object.defineProperty(t, "ClassPrivateMethod", {
                enumerable: true,
                get: function() {
                    return n.classPrivateMethod;
                }
            });
            Object.defineProperty(t, "ClassPrivateProperty", {
                enumerable: true,
                get: function() {
                    return n.classPrivateProperty;
                }
            });
            Object.defineProperty(t, "ClassProperty", {
                enumerable: true,
                get: function() {
                    return n.classProperty;
                }
            });
            Object.defineProperty(t, "ConditionalExpression", {
                enumerable: true,
                get: function() {
                    return n.conditionalExpression;
                }
            });
            Object.defineProperty(t, "ContinueStatement", {
                enumerable: true,
                get: function() {
                    return n.continueStatement;
                }
            });
            Object.defineProperty(t, "DebuggerStatement", {
                enumerable: true,
                get: function() {
                    return n.debuggerStatement;
                }
            });
            Object.defineProperty(t, "DecimalLiteral", {
                enumerable: true,
                get: function() {
                    return n.decimalLiteral;
                }
            });
            Object.defineProperty(t, "DeclareClass", {
                enumerable: true,
                get: function() {
                    return n.declareClass;
                }
            });
            Object.defineProperty(t, "DeclareExportAllDeclaration", {
                enumerable: true,
                get: function() {
                    return n.declareExportAllDeclaration;
                }
            });
            Object.defineProperty(t, "DeclareExportDeclaration", {
                enumerable: true,
                get: function() {
                    return n.declareExportDeclaration;
                }
            });
            Object.defineProperty(t, "DeclareFunction", {
                enumerable: true,
                get: function() {
                    return n.declareFunction;
                }
            });
            Object.defineProperty(t, "DeclareInterface", {
                enumerable: true,
                get: function() {
                    return n.declareInterface;
                }
            });
            Object.defineProperty(t, "DeclareModule", {
                enumerable: true,
                get: function() {
                    return n.declareModule;
                }
            });
            Object.defineProperty(t, "DeclareModuleExports", {
                enumerable: true,
                get: function() {
                    return n.declareModuleExports;
                }
            });
            Object.defineProperty(t, "DeclareOpaqueType", {
                enumerable: true,
                get: function() {
                    return n.declareOpaqueType;
                }
            });
            Object.defineProperty(t, "DeclareTypeAlias", {
                enumerable: true,
                get: function() {
                    return n.declareTypeAlias;
                }
            });
            Object.defineProperty(t, "DeclareVariable", {
                enumerable: true,
                get: function() {
                    return n.declareVariable;
                }
            });
            Object.defineProperty(t, "DeclaredPredicate", {
                enumerable: true,
                get: function() {
                    return n.declaredPredicate;
                }
            });
            Object.defineProperty(t, "Decorator", {
                enumerable: true,
                get: function() {
                    return n.decorator;
                }
            });
            Object.defineProperty(t, "Directive", {
                enumerable: true,
                get: function() {
                    return n.directive;
                }
            });
            Object.defineProperty(t, "DirectiveLiteral", {
                enumerable: true,
                get: function() {
                    return n.directiveLiteral;
                }
            });
            Object.defineProperty(t, "DoExpression", {
                enumerable: true,
                get: function() {
                    return n.doExpression;
                }
            });
            Object.defineProperty(t, "DoWhileStatement", {
                enumerable: true,
                get: function() {
                    return n.doWhileStatement;
                }
            });
            Object.defineProperty(t, "EmptyStatement", {
                enumerable: true,
                get: function() {
                    return n.emptyStatement;
                }
            });
            Object.defineProperty(t, "EmptyTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.emptyTypeAnnotation;
                }
            });
            Object.defineProperty(t, "EnumBooleanBody", {
                enumerable: true,
                get: function() {
                    return n.enumBooleanBody;
                }
            });
            Object.defineProperty(t, "EnumBooleanMember", {
                enumerable: true,
                get: function() {
                    return n.enumBooleanMember;
                }
            });
            Object.defineProperty(t, "EnumDeclaration", {
                enumerable: true,
                get: function() {
                    return n.enumDeclaration;
                }
            });
            Object.defineProperty(t, "EnumDefaultedMember", {
                enumerable: true,
                get: function() {
                    return n.enumDefaultedMember;
                }
            });
            Object.defineProperty(t, "EnumNumberBody", {
                enumerable: true,
                get: function() {
                    return n.enumNumberBody;
                }
            });
            Object.defineProperty(t, "EnumNumberMember", {
                enumerable: true,
                get: function() {
                    return n.enumNumberMember;
                }
            });
            Object.defineProperty(t, "EnumStringBody", {
                enumerable: true,
                get: function() {
                    return n.enumStringBody;
                }
            });
            Object.defineProperty(t, "EnumStringMember", {
                enumerable: true,
                get: function() {
                    return n.enumStringMember;
                }
            });
            Object.defineProperty(t, "EnumSymbolBody", {
                enumerable: true,
                get: function() {
                    return n.enumSymbolBody;
                }
            });
            Object.defineProperty(t, "ExistsTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.existsTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ExportAllDeclaration", {
                enumerable: true,
                get: function() {
                    return n.exportAllDeclaration;
                }
            });
            Object.defineProperty(t, "ExportDefaultDeclaration", {
                enumerable: true,
                get: function() {
                    return n.exportDefaultDeclaration;
                }
            });
            Object.defineProperty(t, "ExportDefaultSpecifier", {
                enumerable: true,
                get: function() {
                    return n.exportDefaultSpecifier;
                }
            });
            Object.defineProperty(t, "ExportNamedDeclaration", {
                enumerable: true,
                get: function() {
                    return n.exportNamedDeclaration;
                }
            });
            Object.defineProperty(t, "ExportNamespaceSpecifier", {
                enumerable: true,
                get: function() {
                    return n.exportNamespaceSpecifier;
                }
            });
            Object.defineProperty(t, "ExportSpecifier", {
                enumerable: true,
                get: function() {
                    return n.exportSpecifier;
                }
            });
            Object.defineProperty(t, "ExpressionStatement", {
                enumerable: true,
                get: function() {
                    return n.expressionStatement;
                }
            });
            Object.defineProperty(t, "File", {
                enumerable: true,
                get: function() {
                    return n.file;
                }
            });
            Object.defineProperty(t, "ForInStatement", {
                enumerable: true,
                get: function() {
                    return n.forInStatement;
                }
            });
            Object.defineProperty(t, "ForOfStatement", {
                enumerable: true,
                get: function() {
                    return n.forOfStatement;
                }
            });
            Object.defineProperty(t, "ForStatement", {
                enumerable: true,
                get: function() {
                    return n.forStatement;
                }
            });
            Object.defineProperty(t, "FunctionDeclaration", {
                enumerable: true,
                get: function() {
                    return n.functionDeclaration;
                }
            });
            Object.defineProperty(t, "FunctionExpression", {
                enumerable: true,
                get: function() {
                    return n.functionExpression;
                }
            });
            Object.defineProperty(t, "FunctionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.functionTypeAnnotation;
                }
            });
            Object.defineProperty(t, "FunctionTypeParam", {
                enumerable: true,
                get: function() {
                    return n.functionTypeParam;
                }
            });
            Object.defineProperty(t, "GenericTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.genericTypeAnnotation;
                }
            });
            Object.defineProperty(t, "Identifier", {
                enumerable: true,
                get: function() {
                    return n.identifier;
                }
            });
            Object.defineProperty(t, "IfStatement", {
                enumerable: true,
                get: function() {
                    return n.ifStatement;
                }
            });
            Object.defineProperty(t, "Import", {
                enumerable: true,
                get: function() {
                    return n.import;
                }
            });
            Object.defineProperty(t, "ImportAttribute", {
                enumerable: true,
                get: function() {
                    return n.importAttribute;
                }
            });
            Object.defineProperty(t, "ImportDeclaration", {
                enumerable: true,
                get: function() {
                    return n.importDeclaration;
                }
            });
            Object.defineProperty(t, "ImportDefaultSpecifier", {
                enumerable: true,
                get: function() {
                    return n.importDefaultSpecifier;
                }
            });
            Object.defineProperty(t, "ImportExpression", {
                enumerable: true,
                get: function() {
                    return n.importExpression;
                }
            });
            Object.defineProperty(t, "ImportNamespaceSpecifier", {
                enumerable: true,
                get: function() {
                    return n.importNamespaceSpecifier;
                }
            });
            Object.defineProperty(t, "ImportSpecifier", {
                enumerable: true,
                get: function() {
                    return n.importSpecifier;
                }
            });
            Object.defineProperty(t, "IndexedAccessType", {
                enumerable: true,
                get: function() {
                    return n.indexedAccessType;
                }
            });
            Object.defineProperty(t, "InferredPredicate", {
                enumerable: true,
                get: function() {
                    return n.inferredPredicate;
                }
            });
            Object.defineProperty(t, "InterfaceDeclaration", {
                enumerable: true,
                get: function() {
                    return n.interfaceDeclaration;
                }
            });
            Object.defineProperty(t, "InterfaceExtends", {
                enumerable: true,
                get: function() {
                    return n.interfaceExtends;
                }
            });
            Object.defineProperty(t, "InterfaceTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.interfaceTypeAnnotation;
                }
            });
            Object.defineProperty(t, "InterpreterDirective", {
                enumerable: true,
                get: function() {
                    return n.interpreterDirective;
                }
            });
            Object.defineProperty(t, "IntersectionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.intersectionTypeAnnotation;
                }
            });
            Object.defineProperty(t, "JSXAttribute", {
                enumerable: true,
                get: function() {
                    return n.jsxAttribute;
                }
            });
            Object.defineProperty(t, "JSXClosingElement", {
                enumerable: true,
                get: function() {
                    return n.jsxClosingElement;
                }
            });
            Object.defineProperty(t, "JSXClosingFragment", {
                enumerable: true,
                get: function() {
                    return n.jsxClosingFragment;
                }
            });
            Object.defineProperty(t, "JSXElement", {
                enumerable: true,
                get: function() {
                    return n.jsxElement;
                }
            });
            Object.defineProperty(t, "JSXEmptyExpression", {
                enumerable: true,
                get: function() {
                    return n.jsxEmptyExpression;
                }
            });
            Object.defineProperty(t, "JSXExpressionContainer", {
                enumerable: true,
                get: function() {
                    return n.jsxExpressionContainer;
                }
            });
            Object.defineProperty(t, "JSXFragment", {
                enumerable: true,
                get: function() {
                    return n.jsxFragment;
                }
            });
            Object.defineProperty(t, "JSXIdentifier", {
                enumerable: true,
                get: function() {
                    return n.jsxIdentifier;
                }
            });
            Object.defineProperty(t, "JSXMemberExpression", {
                enumerable: true,
                get: function() {
                    return n.jsxMemberExpression;
                }
            });
            Object.defineProperty(t, "JSXNamespacedName", {
                enumerable: true,
                get: function() {
                    return n.jsxNamespacedName;
                }
            });
            Object.defineProperty(t, "JSXOpeningElement", {
                enumerable: true,
                get: function() {
                    return n.jsxOpeningElement;
                }
            });
            Object.defineProperty(t, "JSXOpeningFragment", {
                enumerable: true,
                get: function() {
                    return n.jsxOpeningFragment;
                }
            });
            Object.defineProperty(t, "JSXSpreadAttribute", {
                enumerable: true,
                get: function() {
                    return n.jsxSpreadAttribute;
                }
            });
            Object.defineProperty(t, "JSXSpreadChild", {
                enumerable: true,
                get: function() {
                    return n.jsxSpreadChild;
                }
            });
            Object.defineProperty(t, "JSXText", {
                enumerable: true,
                get: function() {
                    return n.jsxText;
                }
            });
            Object.defineProperty(t, "LabeledStatement", {
                enumerable: true,
                get: function() {
                    return n.labeledStatement;
                }
            });
            Object.defineProperty(t, "LogicalExpression", {
                enumerable: true,
                get: function() {
                    return n.logicalExpression;
                }
            });
            Object.defineProperty(t, "MemberExpression", {
                enumerable: true,
                get: function() {
                    return n.memberExpression;
                }
            });
            Object.defineProperty(t, "MetaProperty", {
                enumerable: true,
                get: function() {
                    return n.metaProperty;
                }
            });
            Object.defineProperty(t, "MixedTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.mixedTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ModuleExpression", {
                enumerable: true,
                get: function() {
                    return n.moduleExpression;
                }
            });
            Object.defineProperty(t, "NewExpression", {
                enumerable: true,
                get: function() {
                    return n.newExpression;
                }
            });
            Object.defineProperty(t, "Noop", {
                enumerable: true,
                get: function() {
                    return n.noop;
                }
            });
            Object.defineProperty(t, "NullLiteral", {
                enumerable: true,
                get: function() {
                    return n.nullLiteral;
                }
            });
            Object.defineProperty(t, "NullLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.nullLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NullableTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.nullableTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NumberLiteral", {
                enumerable: true,
                get: function() {
                    return n.numberLiteral;
                }
            });
            Object.defineProperty(t, "NumberLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.numberLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NumberTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.numberTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NumericLiteral", {
                enumerable: true,
                get: function() {
                    return n.numericLiteral;
                }
            });
            Object.defineProperty(t, "ObjectExpression", {
                enumerable: true,
                get: function() {
                    return n.objectExpression;
                }
            });
            Object.defineProperty(t, "ObjectMethod", {
                enumerable: true,
                get: function() {
                    return n.objectMethod;
                }
            });
            Object.defineProperty(t, "ObjectPattern", {
                enumerable: true,
                get: function() {
                    return n.objectPattern;
                }
            });
            Object.defineProperty(t, "ObjectProperty", {
                enumerable: true,
                get: function() {
                    return n.objectProperty;
                }
            });
            Object.defineProperty(t, "ObjectTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.objectTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ObjectTypeCallProperty", {
                enumerable: true,
                get: function() {
                    return n.objectTypeCallProperty;
                }
            });
            Object.defineProperty(t, "ObjectTypeIndexer", {
                enumerable: true,
                get: function() {
                    return n.objectTypeIndexer;
                }
            });
            Object.defineProperty(t, "ObjectTypeInternalSlot", {
                enumerable: true,
                get: function() {
                    return n.objectTypeInternalSlot;
                }
            });
            Object.defineProperty(t, "ObjectTypeProperty", {
                enumerable: true,
                get: function() {
                    return n.objectTypeProperty;
                }
            });
            Object.defineProperty(t, "ObjectTypeSpreadProperty", {
                enumerable: true,
                get: function() {
                    return n.objectTypeSpreadProperty;
                }
            });
            Object.defineProperty(t, "OpaqueType", {
                enumerable: true,
                get: function() {
                    return n.opaqueType;
                }
            });
            Object.defineProperty(t, "OptionalCallExpression", {
                enumerable: true,
                get: function() {
                    return n.optionalCallExpression;
                }
            });
            Object.defineProperty(t, "OptionalIndexedAccessType", {
                enumerable: true,
                get: function() {
                    return n.optionalIndexedAccessType;
                }
            });
            Object.defineProperty(t, "OptionalMemberExpression", {
                enumerable: true,
                get: function() {
                    return n.optionalMemberExpression;
                }
            });
            Object.defineProperty(t, "ParenthesizedExpression", {
                enumerable: true,
                get: function() {
                    return n.parenthesizedExpression;
                }
            });
            Object.defineProperty(t, "PipelineBareFunction", {
                enumerable: true,
                get: function() {
                    return n.pipelineBareFunction;
                }
            });
            Object.defineProperty(t, "PipelinePrimaryTopicReference", {
                enumerable: true,
                get: function() {
                    return n.pipelinePrimaryTopicReference;
                }
            });
            Object.defineProperty(t, "PipelineTopicExpression", {
                enumerable: true,
                get: function() {
                    return n.pipelineTopicExpression;
                }
            });
            Object.defineProperty(t, "Placeholder", {
                enumerable: true,
                get: function() {
                    return n.placeholder;
                }
            });
            Object.defineProperty(t, "PrivateName", {
                enumerable: true,
                get: function() {
                    return n.privateName;
                }
            });
            Object.defineProperty(t, "Program", {
                enumerable: true,
                get: function() {
                    return n.program;
                }
            });
            Object.defineProperty(t, "QualifiedTypeIdentifier", {
                enumerable: true,
                get: function() {
                    return n.qualifiedTypeIdentifier;
                }
            });
            Object.defineProperty(t, "RecordExpression", {
                enumerable: true,
                get: function() {
                    return n.recordExpression;
                }
            });
            Object.defineProperty(t, "RegExpLiteral", {
                enumerable: true,
                get: function() {
                    return n.regExpLiteral;
                }
            });
            Object.defineProperty(t, "RegexLiteral", {
                enumerable: true,
                get: function() {
                    return n.regexLiteral;
                }
            });
            Object.defineProperty(t, "RestElement", {
                enumerable: true,
                get: function() {
                    return n.restElement;
                }
            });
            Object.defineProperty(t, "RestProperty", {
                enumerable: true,
                get: function() {
                    return n.restProperty;
                }
            });
            Object.defineProperty(t, "ReturnStatement", {
                enumerable: true,
                get: function() {
                    return n.returnStatement;
                }
            });
            Object.defineProperty(t, "SequenceExpression", {
                enumerable: true,
                get: function() {
                    return n.sequenceExpression;
                }
            });
            Object.defineProperty(t, "SpreadElement", {
                enumerable: true,
                get: function() {
                    return n.spreadElement;
                }
            });
            Object.defineProperty(t, "SpreadProperty", {
                enumerable: true,
                get: function() {
                    return n.spreadProperty;
                }
            });
            Object.defineProperty(t, "StaticBlock", {
                enumerable: true,
                get: function() {
                    return n.staticBlock;
                }
            });
            Object.defineProperty(t, "StringLiteral", {
                enumerable: true,
                get: function() {
                    return n.stringLiteral;
                }
            });
            Object.defineProperty(t, "StringLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.stringLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "StringTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.stringTypeAnnotation;
                }
            });
            Object.defineProperty(t, "Super", {
                enumerable: true,
                get: function() {
                    return n.super;
                }
            });
            Object.defineProperty(t, "SwitchCase", {
                enumerable: true,
                get: function() {
                    return n.switchCase;
                }
            });
            Object.defineProperty(t, "SwitchStatement", {
                enumerable: true,
                get: function() {
                    return n.switchStatement;
                }
            });
            Object.defineProperty(t, "SymbolTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.symbolTypeAnnotation;
                }
            });
            Object.defineProperty(t, "TSAnyKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsAnyKeyword;
                }
            });
            Object.defineProperty(t, "TSArrayType", {
                enumerable: true,
                get: function() {
                    return n.tsArrayType;
                }
            });
            Object.defineProperty(t, "TSAsExpression", {
                enumerable: true,
                get: function() {
                    return n.tsAsExpression;
                }
            });
            Object.defineProperty(t, "TSBigIntKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsBigIntKeyword;
                }
            });
            Object.defineProperty(t, "TSBooleanKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsBooleanKeyword;
                }
            });
            Object.defineProperty(t, "TSCallSignatureDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsCallSignatureDeclaration;
                }
            });
            Object.defineProperty(t, "TSConditionalType", {
                enumerable: true,
                get: function() {
                    return n.tsConditionalType;
                }
            });
            Object.defineProperty(t, "TSConstructSignatureDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsConstructSignatureDeclaration;
                }
            });
            Object.defineProperty(t, "TSConstructorType", {
                enumerable: true,
                get: function() {
                    return n.tsConstructorType;
                }
            });
            Object.defineProperty(t, "TSDeclareFunction", {
                enumerable: true,
                get: function() {
                    return n.tsDeclareFunction;
                }
            });
            Object.defineProperty(t, "TSDeclareMethod", {
                enumerable: true,
                get: function() {
                    return n.tsDeclareMethod;
                }
            });
            Object.defineProperty(t, "TSEnumBody", {
                enumerable: true,
                get: function() {
                    return n.tsEnumBody;
                }
            });
            Object.defineProperty(t, "TSEnumDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsEnumDeclaration;
                }
            });
            Object.defineProperty(t, "TSEnumMember", {
                enumerable: true,
                get: function() {
                    return n.tsEnumMember;
                }
            });
            Object.defineProperty(t, "TSExportAssignment", {
                enumerable: true,
                get: function() {
                    return n.tsExportAssignment;
                }
            });
            Object.defineProperty(t, "TSExpressionWithTypeArguments", {
                enumerable: true,
                get: function() {
                    return n.tsExpressionWithTypeArguments;
                }
            });
            Object.defineProperty(t, "TSExternalModuleReference", {
                enumerable: true,
                get: function() {
                    return n.tsExternalModuleReference;
                }
            });
            Object.defineProperty(t, "TSFunctionType", {
                enumerable: true,
                get: function() {
                    return n.tsFunctionType;
                }
            });
            Object.defineProperty(t, "TSImportEqualsDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsImportEqualsDeclaration;
                }
            });
            Object.defineProperty(t, "TSImportType", {
                enumerable: true,
                get: function() {
                    return n.tsImportType;
                }
            });
            Object.defineProperty(t, "TSIndexSignature", {
                enumerable: true,
                get: function() {
                    return n.tsIndexSignature;
                }
            });
            Object.defineProperty(t, "TSIndexedAccessType", {
                enumerable: true,
                get: function() {
                    return n.tsIndexedAccessType;
                }
            });
            Object.defineProperty(t, "TSInferType", {
                enumerable: true,
                get: function() {
                    return n.tsInferType;
                }
            });
            Object.defineProperty(t, "TSInstantiationExpression", {
                enumerable: true,
                get: function() {
                    return n.tsInstantiationExpression;
                }
            });
            Object.defineProperty(t, "TSInterfaceBody", {
                enumerable: true,
                get: function() {
                    return n.tsInterfaceBody;
                }
            });
            Object.defineProperty(t, "TSInterfaceDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsInterfaceDeclaration;
                }
            });
            Object.defineProperty(t, "TSIntersectionType", {
                enumerable: true,
                get: function() {
                    return n.tsIntersectionType;
                }
            });
            Object.defineProperty(t, "TSIntrinsicKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsIntrinsicKeyword;
                }
            });
            Object.defineProperty(t, "TSLiteralType", {
                enumerable: true,
                get: function() {
                    return n.tsLiteralType;
                }
            });
            Object.defineProperty(t, "TSMappedType", {
                enumerable: true,
                get: function() {
                    return n.tsMappedType;
                }
            });
            Object.defineProperty(t, "TSMethodSignature", {
                enumerable: true,
                get: function() {
                    return n.tsMethodSignature;
                }
            });
            Object.defineProperty(t, "TSModuleBlock", {
                enumerable: true,
                get: function() {
                    return n.tsModuleBlock;
                }
            });
            Object.defineProperty(t, "TSModuleDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsModuleDeclaration;
                }
            });
            Object.defineProperty(t, "TSNamedTupleMember", {
                enumerable: true,
                get: function() {
                    return n.tsNamedTupleMember;
                }
            });
            Object.defineProperty(t, "TSNamespaceExportDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsNamespaceExportDeclaration;
                }
            });
            Object.defineProperty(t, "TSNeverKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsNeverKeyword;
                }
            });
            Object.defineProperty(t, "TSNonNullExpression", {
                enumerable: true,
                get: function() {
                    return n.tsNonNullExpression;
                }
            });
            Object.defineProperty(t, "TSNullKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsNullKeyword;
                }
            });
            Object.defineProperty(t, "TSNumberKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsNumberKeyword;
                }
            });
            Object.defineProperty(t, "TSObjectKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsObjectKeyword;
                }
            });
            Object.defineProperty(t, "TSOptionalType", {
                enumerable: true,
                get: function() {
                    return n.tsOptionalType;
                }
            });
            Object.defineProperty(t, "TSParameterProperty", {
                enumerable: true,
                get: function() {
                    return n.tsParameterProperty;
                }
            });
            Object.defineProperty(t, "TSParenthesizedType", {
                enumerable: true,
                get: function() {
                    return n.tsParenthesizedType;
                }
            });
            Object.defineProperty(t, "TSPropertySignature", {
                enumerable: true,
                get: function() {
                    return n.tsPropertySignature;
                }
            });
            Object.defineProperty(t, "TSQualifiedName", {
                enumerable: true,
                get: function() {
                    return n.tsQualifiedName;
                }
            });
            Object.defineProperty(t, "TSRestType", {
                enumerable: true,
                get: function() {
                    return n.tsRestType;
                }
            });
            Object.defineProperty(t, "TSSatisfiesExpression", {
                enumerable: true,
                get: function() {
                    return n.tsSatisfiesExpression;
                }
            });
            Object.defineProperty(t, "TSStringKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsStringKeyword;
                }
            });
            Object.defineProperty(t, "TSSymbolKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsSymbolKeyword;
                }
            });
            Object.defineProperty(t, "TSTemplateLiteralType", {
                enumerable: true,
                get: function() {
                    return n.tsTemplateLiteralType;
                }
            });
            Object.defineProperty(t, "TSThisType", {
                enumerable: true,
                get: function() {
                    return n.tsThisType;
                }
            });
            Object.defineProperty(t, "TSTupleType", {
                enumerable: true,
                get: function() {
                    return n.tsTupleType;
                }
            });
            Object.defineProperty(t, "TSTypeAliasDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsTypeAliasDeclaration;
                }
            });
            Object.defineProperty(t, "TSTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.tsTypeAnnotation;
                }
            });
            Object.defineProperty(t, "TSTypeAssertion", {
                enumerable: true,
                get: function() {
                    return n.tsTypeAssertion;
                }
            });
            Object.defineProperty(t, "TSTypeLiteral", {
                enumerable: true,
                get: function() {
                    return n.tsTypeLiteral;
                }
            });
            Object.defineProperty(t, "TSTypeOperator", {
                enumerable: true,
                get: function() {
                    return n.tsTypeOperator;
                }
            });
            Object.defineProperty(t, "TSTypeParameter", {
                enumerable: true,
                get: function() {
                    return n.tsTypeParameter;
                }
            });
            Object.defineProperty(t, "TSTypeParameterDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsTypeParameterDeclaration;
                }
            });
            Object.defineProperty(t, "TSTypeParameterInstantiation", {
                enumerable: true,
                get: function() {
                    return n.tsTypeParameterInstantiation;
                }
            });
            Object.defineProperty(t, "TSTypePredicate", {
                enumerable: true,
                get: function() {
                    return n.tsTypePredicate;
                }
            });
            Object.defineProperty(t, "TSTypeQuery", {
                enumerable: true,
                get: function() {
                    return n.tsTypeQuery;
                }
            });
            Object.defineProperty(t, "TSTypeReference", {
                enumerable: true,
                get: function() {
                    return n.tsTypeReference;
                }
            });
            Object.defineProperty(t, "TSUndefinedKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsUndefinedKeyword;
                }
            });
            Object.defineProperty(t, "TSUnionType", {
                enumerable: true,
                get: function() {
                    return n.tsUnionType;
                }
            });
            Object.defineProperty(t, "TSUnknownKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsUnknownKeyword;
                }
            });
            Object.defineProperty(t, "TSVoidKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsVoidKeyword;
                }
            });
            Object.defineProperty(t, "TaggedTemplateExpression", {
                enumerable: true,
                get: function() {
                    return n.taggedTemplateExpression;
                }
            });
            Object.defineProperty(t, "TemplateElement", {
                enumerable: true,
                get: function() {
                    return n.templateElement;
                }
            });
            Object.defineProperty(t, "TemplateLiteral", {
                enumerable: true,
                get: function() {
                    return n.templateLiteral;
                }
            });
            Object.defineProperty(t, "ThisExpression", {
                enumerable: true,
                get: function() {
                    return n.thisExpression;
                }
            });
            Object.defineProperty(t, "ThisTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.thisTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ThrowStatement", {
                enumerable: true,
                get: function() {
                    return n.throwStatement;
                }
            });
            Object.defineProperty(t, "TopicReference", {
                enumerable: true,
                get: function() {
                    return n.topicReference;
                }
            });
            Object.defineProperty(t, "TryStatement", {
                enumerable: true,
                get: function() {
                    return n.tryStatement;
                }
            });
            Object.defineProperty(t, "TupleExpression", {
                enumerable: true,
                get: function() {
                    return n.tupleExpression;
                }
            });
            Object.defineProperty(t, "TupleTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.tupleTypeAnnotation;
                }
            });
            Object.defineProperty(t, "TypeAlias", {
                enumerable: true,
                get: function() {
                    return n.typeAlias;
                }
            });
            Object.defineProperty(t, "TypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.typeAnnotation;
                }
            });
            Object.defineProperty(t, "TypeCastExpression", {
                enumerable: true,
                get: function() {
                    return n.typeCastExpression;
                }
            });
            Object.defineProperty(t, "TypeParameter", {
                enumerable: true,
                get: function() {
                    return n.typeParameter;
                }
            });
            Object.defineProperty(t, "TypeParameterDeclaration", {
                enumerable: true,
                get: function() {
                    return n.typeParameterDeclaration;
                }
            });
            Object.defineProperty(t, "TypeParameterInstantiation", {
                enumerable: true,
                get: function() {
                    return n.typeParameterInstantiation;
                }
            });
            Object.defineProperty(t, "TypeofTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.typeofTypeAnnotation;
                }
            });
            Object.defineProperty(t, "UnaryExpression", {
                enumerable: true,
                get: function() {
                    return n.unaryExpression;
                }
            });
            Object.defineProperty(t, "UnionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.unionTypeAnnotation;
                }
            });
            Object.defineProperty(t, "UpdateExpression", {
                enumerable: true,
                get: function() {
                    return n.updateExpression;
                }
            });
            Object.defineProperty(t, "V8IntrinsicIdentifier", {
                enumerable: true,
                get: function() {
                    return n.v8IntrinsicIdentifier;
                }
            });
            Object.defineProperty(t, "VariableDeclaration", {
                enumerable: true,
                get: function() {
                    return n.variableDeclaration;
                }
            });
            Object.defineProperty(t, "VariableDeclarator", {
                enumerable: true,
                get: function() {
                    return n.variableDeclarator;
                }
            });
            Object.defineProperty(t, "Variance", {
                enumerable: true,
                get: function() {
                    return n.variance;
                }
            });
            Object.defineProperty(t, "VoidTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.voidTypeAnnotation;
                }
            });
            Object.defineProperty(t, "WhileStatement", {
                enumerable: true,
                get: function() {
                    return n.whileStatement;
                }
            });
            Object.defineProperty(t, "WithStatement", {
                enumerable: true,
                get: function() {
                    return n.withStatement;
                }
            });
            Object.defineProperty(t, "YieldExpression", {
                enumerable: true,
                get: function() {
                    return n.yieldExpression;
                }
            });
            var n = r(3259);
        },
        3396: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildUndefinedNode = buildUndefinedNode;
            var n = r(4755);
            function buildUndefinedNode() {
                return (0, n.unaryExpression)("void", (0, n.numericLiteral)(0), true);
            }
        },
        1323: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = buildChildren;
            var n = r(46);
            var s = r(8530);
            function buildChildren(e1) {
                const t = [];
                for(let r = 0; r < e1.children.length; r++){
                    let i = e1.children[r];
                    if ((0, n.isJSXText)(i)) {
                        (0, s.default)(i, t);
                        continue;
                    }
                    if ((0, n.isJSXExpressionContainer)(i)) i = i.expression;
                    if ((0, n.isJSXEmptyExpression)(i)) continue;
                    t.push(i);
                }
                return t;
            }
        },
        1258: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createTSUnionType;
            var n = r(4755);
            var s = r(6066);
            var i = r(46);
            function createTSUnionType(e1) {
                const t = e1.map((e1)=>(0, i.isTSTypeAnnotation)(e1) ? e1.typeAnnotation : e1);
                const r = (0, s.default)(t);
                if (r.length === 1) {
                    return r[0];
                } else {
                    return (0, n.tsUnionType)(r);
                }
            }
        },
        8329: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = clone;
            var n = r(363);
            function clone(e1) {
                return (0, n.default)(e1, false);
            }
        },
        8637: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneDeep;
            var n = r(363);
            function cloneDeep(e1) {
                return (0, n.default)(e1);
            }
        },
        7684: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneDeepWithoutLoc;
            var n = r(363);
            function cloneDeepWithoutLoc(e1) {
                return (0, n.default)(e1, true, true);
            }
        },
        363: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneNode;
            var n = r(6767);
            var s = r(46);
            const { hasOwn: i } = {
                hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
            };
            function cloneIfNode(e1, t, r, n) {
                if (e1 && typeof e1.type === "string") {
                    return cloneNodeInternal(e1, t, r, n);
                }
                return e1;
            }
            function cloneIfNodeOrArray(e1, t, r, n) {
                if (Array.isArray(e1)) {
                    return e1.map((e1)=>cloneIfNode(e1, t, r, n));
                }
                return cloneIfNode(e1, t, r, n);
            }
            function cloneNode(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                return cloneNodeInternal(e1, t, r, new Map);
            }
            function cloneNodeInternal(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, a = arguments.length > 3 ? arguments[3] : void 0;
                if (!e1) return e1;
                const { type: o } = e1;
                const l = {
                    type: e1.type
                };
                if ((0, s.isIdentifier)(e1)) {
                    l.name = e1.name;
                    if (i(e1, "optional") && typeof e1.optional === "boolean") {
                        l.optional = e1.optional;
                    }
                    if (i(e1, "typeAnnotation")) {
                        l.typeAnnotation = t ? cloneIfNodeOrArray(e1.typeAnnotation, true, r, a) : e1.typeAnnotation;
                    }
                    if (i(e1, "decorators")) {
                        l.decorators = t ? cloneIfNodeOrArray(e1.decorators, true, r, a) : e1.decorators;
                    }
                } else if (!i(n.NODE_FIELDS, o)) {
                    throw new Error('Unknown node type: "'.concat(o, '"'));
                } else {
                    for (const c of Object.keys(n.NODE_FIELDS[o])){
                        if (i(e1, c)) {
                            if (t) {
                                l[c] = (0, s.isFile)(e1) && c === "comments" ? maybeCloneComments(e1.comments, t, r, a) : cloneIfNodeOrArray(e1[c], true, r, a);
                            } else {
                                l[c] = e1[c];
                            }
                        }
                    }
                }
                if (i(e1, "loc")) {
                    if (r) {
                        l.loc = null;
                    } else {
                        l.loc = e1.loc;
                    }
                }
                if (i(e1, "leadingComments")) {
                    l.leadingComments = maybeCloneComments(e1.leadingComments, t, r, a);
                }
                if (i(e1, "innerComments")) {
                    l.innerComments = maybeCloneComments(e1.innerComments, t, r, a);
                }
                if (i(e1, "trailingComments")) {
                    l.trailingComments = maybeCloneComments(e1.trailingComments, t, r, a);
                }
                if (i(e1, "extra")) {
                    l.extra = Object.assign({}, e1.extra);
                }
                return l;
            }
            function maybeCloneComments(e1, t, r, n) {
                if (!e1 || !t) {
                    return e1;
                }
                return e1.map((e1)=>{
                    const t = n.get(e1);
                    if (t) return t;
                    const { type: s, value: i, loc: a } = e1;
                    const o = {
                        type: s,
                        value: i,
                        loc: a
                    };
                    if (r) {
                        o.loc = null;
                    }
                    n.set(e1, o);
                    return o;
                });
            }
        },
        9410: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneWithoutLoc;
            var n = r(363);
            function cloneWithoutLoc(e1) {
                return (0, n.default)(e1, false, true);
            }
        },
        5185: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = addComment;
            var n = r(9039);
            function addComment(e1, t, r, s) {
                return (0, n.default)(e1, t, [
                    {
                        type: s ? "CommentLine" : "CommentBlock",
                        value: r
                    }
                ]);
            }
        },
        9039: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = addComments;
            function addComments(e1, t, r) {
                if (!r || !e1) return e1;
                const n = "".concat(t, "Comments");
                if (e1[n]) {
                    if (t === "leading") {
                        e1[n] = r.concat(e1[n]);
                    } else {
                        e1[n].push(...r);
                    }
                } else {
                    e1[n] = r;
                }
                return e1;
            }
        },
        3041: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritInnerComments;
            var n = r(2660);
            function inheritInnerComments(e1, t) {
                (0, n.default)("innerComments", e1, t);
            }
        },
        5151: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritLeadingComments;
            var n = r(2660);
            function inheritLeadingComments(e1, t) {
                (0, n.default)("leadingComments", e1, t);
            }
        },
        8538: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritTrailingComments;
            var n = r(2660);
            function inheritTrailingComments(e1, t) {
                (0, n.default)("trailingComments", e1, t);
            }
        },
        5060: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritsComments;
            var n = r(8538);
            var s = r(5151);
            var i = r(3041);
            function inheritsComments(e1, t) {
                (0, n.default)(e1, t);
                (0, s.default)(e1, t);
                (0, i.default)(e1, t);
                return e1;
            }
        },
        170: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeComments;
            var n = r(1164);
            function removeComments(e1) {
                n.COMMENT_KEYS.forEach((t)=>{
                    e1[t] = null;
                });
                return e1;
            }
        },
        4766: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.WHILE_TYPES = t.USERWHITESPACABLE_TYPES = t.UNARYLIKE_TYPES = t.TYPESCRIPT_TYPES = t.TSTYPE_TYPES = t.TSTYPEELEMENT_TYPES = t.TSENTITYNAME_TYPES = t.TSBASETYPE_TYPES = t.TERMINATORLESS_TYPES = t.STATEMENT_TYPES = t.STANDARDIZED_TYPES = t.SCOPABLE_TYPES = t.PUREISH_TYPES = t.PROPERTY_TYPES = t.PRIVATE_TYPES = t.PATTERN_TYPES = t.PATTERNLIKE_TYPES = t.OBJECTMEMBER_TYPES = t.MODULESPECIFIER_TYPES = t.MODULEDECLARATION_TYPES = t.MISCELLANEOUS_TYPES = t.METHOD_TYPES = t.LVAL_TYPES = t.LOOP_TYPES = t.LITERAL_TYPES = t.JSX_TYPES = t.IMPORTOREXPORTDECLARATION_TYPES = t.IMMUTABLE_TYPES = t.FUNCTION_TYPES = t.FUNCTIONPARENT_TYPES = t.FOR_TYPES = t.FORXSTATEMENT_TYPES = t.FLOW_TYPES = t.FLOWTYPE_TYPES = t.FLOWPREDICATE_TYPES = t.FLOWDECLARATION_TYPES = t.FLOWBASEANNOTATION_TYPES = t.EXPRESSION_TYPES = t.EXPRESSIONWRAPPER_TYPES = t.EXPORTDECLARATION_TYPES = t.ENUMMEMBER_TYPES = t.ENUMBODY_TYPES = t.DECLARATION_TYPES = t.CONDITIONAL_TYPES = t.COMPLETIONSTATEMENT_TYPES = t.CLASS_TYPES = t.BLOCK_TYPES = t.BLOCKPARENT_TYPES = t.BINARY_TYPES = t.ACCESSOR_TYPES = void 0;
            var n = r(6767);
            const s = t.STANDARDIZED_TYPES = n.FLIPPED_ALIAS_KEYS["Standardized"];
            const i = t.EXPRESSION_TYPES = n.FLIPPED_ALIAS_KEYS["Expression"];
            const a = t.BINARY_TYPES = n.FLIPPED_ALIAS_KEYS["Binary"];
            const o = t.SCOPABLE_TYPES = n.FLIPPED_ALIAS_KEYS["Scopable"];
            const l = t.BLOCKPARENT_TYPES = n.FLIPPED_ALIAS_KEYS["BlockParent"];
            const c = t.BLOCK_TYPES = n.FLIPPED_ALIAS_KEYS["Block"];
            const p = t.STATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS["Statement"];
            const u = t.TERMINATORLESS_TYPES = n.FLIPPED_ALIAS_KEYS["Terminatorless"];
            const d = t.COMPLETIONSTATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS["CompletionStatement"];
            const f = t.CONDITIONAL_TYPES = n.FLIPPED_ALIAS_KEYS["Conditional"];
            const h = t.LOOP_TYPES = n.FLIPPED_ALIAS_KEYS["Loop"];
            const m = t.WHILE_TYPES = n.FLIPPED_ALIAS_KEYS["While"];
            const y = t.EXPRESSIONWRAPPER_TYPES = n.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
            const g = t.FOR_TYPES = n.FLIPPED_ALIAS_KEYS["For"];
            const b = t.FORXSTATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS["ForXStatement"];
            const T = t.FUNCTION_TYPES = n.FLIPPED_ALIAS_KEYS["Function"];
            const S = t.FUNCTIONPARENT_TYPES = n.FLIPPED_ALIAS_KEYS["FunctionParent"];
            const x = t.PUREISH_TYPES = n.FLIPPED_ALIAS_KEYS["Pureish"];
            const E = t.DECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS["Declaration"];
            const P = t.PATTERNLIKE_TYPES = n.FLIPPED_ALIAS_KEYS["PatternLike"];
            const v = t.LVAL_TYPES = n.FLIPPED_ALIAS_KEYS["LVal"];
            const A = t.TSENTITYNAME_TYPES = n.FLIPPED_ALIAS_KEYS["TSEntityName"];
            const w = t.LITERAL_TYPES = n.FLIPPED_ALIAS_KEYS["Literal"];
            const I = t.IMMUTABLE_TYPES = n.FLIPPED_ALIAS_KEYS["Immutable"];
            const C = t.USERWHITESPACABLE_TYPES = n.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
            const O = t.METHOD_TYPES = n.FLIPPED_ALIAS_KEYS["Method"];
            const N = t.OBJECTMEMBER_TYPES = n.FLIPPED_ALIAS_KEYS["ObjectMember"];
            const k = t.PROPERTY_TYPES = n.FLIPPED_ALIAS_KEYS["Property"];
            const _ = t.UNARYLIKE_TYPES = n.FLIPPED_ALIAS_KEYS["UnaryLike"];
            const D = t.PATTERN_TYPES = n.FLIPPED_ALIAS_KEYS["Pattern"];
            const M = t.CLASS_TYPES = n.FLIPPED_ALIAS_KEYS["Class"];
            const L = t.IMPORTOREXPORTDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
            const j = t.EXPORTDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
            const F = t.MODULESPECIFIER_TYPES = n.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
            const B = t.ACCESSOR_TYPES = n.FLIPPED_ALIAS_KEYS["Accessor"];
            const R = t.PRIVATE_TYPES = n.FLIPPED_ALIAS_KEYS["Private"];
            const U = t.FLOW_TYPES = n.FLIPPED_ALIAS_KEYS["Flow"];
            const K = t.FLOWTYPE_TYPES = n.FLIPPED_ALIAS_KEYS["FlowType"];
            const V = t.FLOWBASEANNOTATION_TYPES = n.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
            const W = t.FLOWDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
            const $ = t.FLOWPREDICATE_TYPES = n.FLIPPED_ALIAS_KEYS["FlowPredicate"];
            const q = t.ENUMBODY_TYPES = n.FLIPPED_ALIAS_KEYS["EnumBody"];
            const H = t.ENUMMEMBER_TYPES = n.FLIPPED_ALIAS_KEYS["EnumMember"];
            const G = t.JSX_TYPES = n.FLIPPED_ALIAS_KEYS["JSX"];
            const J = t.MISCELLANEOUS_TYPES = n.FLIPPED_ALIAS_KEYS["Miscellaneous"];
            const z = t.TYPESCRIPT_TYPES = n.FLIPPED_ALIAS_KEYS["TypeScript"];
            const X = t.TSTYPEELEMENT_TYPES = n.FLIPPED_ALIAS_KEYS["TSTypeElement"];
            const Y = t.TSTYPE_TYPES = n.FLIPPED_ALIAS_KEYS["TSType"];
            const Q = t.TSBASETYPE_TYPES = n.FLIPPED_ALIAS_KEYS["TSBaseType"];
            const Z = t.MODULEDECLARATION_TYPES = L;
        },
        1164: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.UPDATE_OPERATORS = t.UNARY_OPERATORS = t.STRING_UNARY_OPERATORS = t.STATEMENT_OR_BLOCK_KEYS = t.NUMBER_UNARY_OPERATORS = t.NUMBER_BINARY_OPERATORS = t.LOGICAL_OPERATORS = t.INHERIT_KEYS = t.FOR_INIT_KEYS = t.FLATTENABLE_KEYS = t.EQUALITY_BINARY_OPERATORS = t.COMPARISON_BINARY_OPERATORS = t.COMMENT_KEYS = t.BOOLEAN_UNARY_OPERATORS = t.BOOLEAN_NUMBER_BINARY_OPERATORS = t.BOOLEAN_BINARY_OPERATORS = t.BINARY_OPERATORS = t.ASSIGNMENT_OPERATORS = void 0;
            const r = t.STATEMENT_OR_BLOCK_KEYS = [
                "consequent",
                "body",
                "alternate"
            ];
            const n = t.FLATTENABLE_KEYS = [
                "body",
                "expressions"
            ];
            const s = t.FOR_INIT_KEYS = [
                "left",
                "init"
            ];
            const i = t.COMMENT_KEYS = [
                "leadingComments",
                "trailingComments",
                "innerComments"
            ];
            const a = t.LOGICAL_OPERATORS = [
                "||",
                "&&",
                "??"
            ];
            const o = t.UPDATE_OPERATORS = [
                "++",
                "--"
            ];
            const l = t.BOOLEAN_NUMBER_BINARY_OPERATORS = [
                ">",
                "<",
                ">=",
                "<="
            ];
            const c = t.EQUALITY_BINARY_OPERATORS = [
                "==",
                "===",
                "!=",
                "!=="
            ];
            const p = t.COMPARISON_BINARY_OPERATORS = [
                ...c,
                "in",
                "instanceof"
            ];
            const u = t.BOOLEAN_BINARY_OPERATORS = [
                ...p,
                ...l
            ];
            const d = t.NUMBER_BINARY_OPERATORS = [
                "-",
                "/",
                "%",
                "*",
                "**",
                "&",
                "|",
                ">>",
                ">>>",
                "<<",
                "^"
            ];
            const f = t.BINARY_OPERATORS = [
                "+",
                ...d,
                ...u,
                "|>"
            ];
            const h = t.ASSIGNMENT_OPERATORS = [
                "=",
                "+=",
                ...d.map((e1)=>e1 + "="),
                ...a.map((e1)=>e1 + "=")
            ];
            const m = t.BOOLEAN_UNARY_OPERATORS = [
                "delete",
                "!"
            ];
            const y = t.NUMBER_UNARY_OPERATORS = [
                "+",
                "-",
                "~"
            ];
            const g = t.STRING_UNARY_OPERATORS = [
                "typeof"
            ];
            const b = t.UNARY_OPERATORS = [
                "void",
                "throw",
                ...m,
                ...y,
                ...g
            ];
            const T = t.INHERIT_KEYS = {
                optional: [
                    "typeAnnotation",
                    "typeParameters",
                    "returnType"
                ],
                force: [
                    "start",
                    "loc",
                    "end"
                ]
            };
            {
                t.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
                t.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
            }
        },
        7234: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = ensureBlock;
            var n = r(3670);
            function ensureBlock(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "body";
                const r = (0, n.default)(e1[t], e1);
                e1[t] = r;
                return r;
            }
        },
        6673: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = gatherSequenceExpressions;
            var n = r(6306);
            var s = r(46);
            var i = r(4755);
            var a = r(3396);
            var o = r(363);
            function gatherSequenceExpressions(e1, t) {
                const r = [];
                let l = true;
                for (const c of e1){
                    if (!(0, s.isEmptyStatement)(c)) {
                        l = false;
                    }
                    if ((0, s.isExpression)(c)) {
                        r.push(c);
                    } else if ((0, s.isExpressionStatement)(c)) {
                        r.push(c.expression);
                    } else if ((0, s.isVariableDeclaration)(c)) {
                        if (c.kind !== "var") return;
                        for (const e1 of c.declarations){
                            const s = (0, n.default)(e1);
                            for (const e1 of Object.keys(s)){
                                t.push({
                                    kind: c.kind,
                                    id: (0, o.default)(s[e1])
                                });
                            }
                            if (e1.init) {
                                r.push((0, i.assignmentExpression)("=", e1.id, e1.init));
                            }
                        }
                        l = true;
                    } else if ((0, s.isIfStatement)(c)) {
                        const e1 = c.consequent ? gatherSequenceExpressions([
                            c.consequent
                        ], t) : (0, a.buildUndefinedNode)();
                        const n = c.alternate ? gatherSequenceExpressions([
                            c.alternate
                        ], t) : (0, a.buildUndefinedNode)();
                        if (!e1 || !n) return;
                        r.push((0, i.conditionalExpression)(c.test, e1, n));
                    } else if ((0, s.isBlockStatement)(c)) {
                        const e1 = gatherSequenceExpressions(c.body, t);
                        if (!e1) return;
                        r.push(e1);
                    } else if ((0, s.isEmptyStatement)(c)) {
                        if (e1.indexOf(c) === 0) {
                            l = true;
                        }
                    } else {
                        return;
                    }
                }
                if (l) {
                    r.push((0, a.buildUndefinedNode)());
                }
                if (r.length === 1) {
                    return r[0];
                } else {
                    return (0, i.sequenceExpression)(r);
                }
            }
        },
        1350: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toBindingIdentifierName;
            var n = r(1334);
            function toBindingIdentifierName(e1) {
                e1 = (0, n.default)(e1);
                if (e1 === "eval" || e1 === "arguments") e1 = "_" + e1;
                return e1;
            }
        },
        3670: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toBlock;
            var n = r(46);
            var s = r(4755);
            function toBlock(e1, t) {
                if ((0, n.isBlockStatement)(e1)) {
                    return e1;
                }
                let r = [];
                if ((0, n.isEmptyStatement)(e1)) {
                    r = [];
                } else {
                    if (!(0, n.isStatement)(e1)) {
                        if ((0, n.isFunction)(t)) {
                            e1 = (0, s.returnStatement)(e1);
                        } else {
                            e1 = (0, s.expressionStatement)(e1);
                        }
                    }
                    r = [
                        e1
                    ];
                }
                return (0, s.blockStatement)(r);
            }
        },
        5847: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toComputedKey;
            var n = r(46);
            var s = r(4755);
            function toComputedKey(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e1.key || e1.property;
                if (!e1.computed && (0, n.isIdentifier)(t)) t = (0, s.stringLiteral)(t.name);
                return t;
            }
        },
        4811: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(46);
            var s = t["default"] = toExpression;
            function toExpression(e1) {
                if ((0, n.isExpressionStatement)(e1)) {
                    e1 = e1.expression;
                }
                if ((0, n.isExpression)(e1)) {
                    return e1;
                }
                if ((0, n.isClass)(e1)) {
                    e1.type = "ClassExpression";
                } else if ((0, n.isFunction)(e1)) {
                    e1.type = "FunctionExpression";
                }
                if (!(0, n.isExpression)(e1)) {
                    throw new Error("cannot turn ".concat(e1.type, " to an expression"));
                }
                return e1;
            }
        },
        1334: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toIdentifier;
            var n = r(2892);
            var s = r(974);
            function toIdentifier(e1) {
                e1 = e1 + "";
                let t = "";
                for (const r of e1){
                    t += (0, s.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
                }
                t = t.replace(/^[-0-9]+/, "");
                t = t.replace(/[-\s]+(.)?/g, function(e1, t) {
                    return t ? t.toUpperCase() : "";
                });
                if (!(0, n.default)(t)) {
                    t = "_".concat(t);
                }
                return t || "_";
            }
        },
        1480: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toKeyAlias;
            var n = r(46);
            var s = r(363);
            var i = r(9437);
            function toKeyAlias(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e1.key;
                let r;
                if (e1.kind === "method") {
                    return toKeyAlias.increment() + "";
                } else if ((0, n.isIdentifier)(t)) {
                    r = t.name;
                } else if ((0, n.isStringLiteral)(t)) {
                    r = JSON.stringify(t.value);
                } else {
                    r = JSON.stringify((0, i.default)((0, s.default)(t)));
                }
                if (e1.computed) {
                    r = "[".concat(r, "]");
                }
                if (e1.static) {
                    r = "static:".concat(r);
                }
                return r;
            }
            toKeyAlias.uid = 0;
            toKeyAlias.increment = function() {
                if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
                    return toKeyAlias.uid = 0;
                } else {
                    return toKeyAlias.uid++;
                }
            };
        },
        4136: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toSequenceExpression;
            var n = r(6673);
            function toSequenceExpression(e1, t) {
                if (!(e1 != null && e1.length)) return;
                const r = [];
                const s = (0, n.default)(e1, r);
                if (!s) return;
                for (const e1 of r){
                    t.push(e1);
                }
                return s;
            }
        },
        1035: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(46);
            var s = r(4755);
            var i = t["default"] = toStatement;
            function toStatement(e1, t) {
                if ((0, n.isStatement)(e1)) {
                    return e1;
                }
                let r = false;
                let i;
                if ((0, n.isClass)(e1)) {
                    r = true;
                    i = "ClassDeclaration";
                } else if ((0, n.isFunction)(e1)) {
                    r = true;
                    i = "FunctionDeclaration";
                } else if ((0, n.isAssignmentExpression)(e1)) {
                    return (0, s.expressionStatement)(e1);
                }
                if (r && !e1.id) {
                    i = false;
                }
                if (!i) {
                    if (t) {
                        return false;
                    } else {
                        throw new Error("cannot turn ".concat(e1.type, " to a statement"));
                    }
                }
                e1.type = i;
                return e1;
            }
        },
        5222: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(2892);
            var s = r(4755);
            var i = t["default"] = valueToNode;
            const a = Function.call.bind(Object.prototype.toString);
            function isRegExp(e1) {
                return a(e1) === "[object RegExp]";
            }
            function isPlainObject(e1) {
                if (typeof e1 !== "object" || e1 === null || Object.prototype.toString.call(e1) !== "[object Object]") {
                    return false;
                }
                const t = Object.getPrototypeOf(e1);
                return t === null || Object.getPrototypeOf(t) === null;
            }
            function valueToNode(e1) {
                if (e1 === undefined) {
                    return (0, s.identifier)("undefined");
                }
                if (e1 === true || e1 === false) {
                    return (0, s.booleanLiteral)(e1);
                }
                if (e1 === null) {
                    return (0, s.nullLiteral)();
                }
                if (typeof e1 === "string") {
                    return (0, s.stringLiteral)(e1);
                }
                if (typeof e1 === "number") {
                    let t;
                    if (Number.isFinite(e1)) {
                        t = (0, s.numericLiteral)(Math.abs(e1));
                    } else {
                        let r;
                        if (Number.isNaN(e1)) {
                            r = (0, s.numericLiteral)(0);
                        } else {
                            r = (0, s.numericLiteral)(1);
                        }
                        t = (0, s.binaryExpression)("/", r, (0, s.numericLiteral)(0));
                    }
                    if (e1 < 0 || Object.is(e1, -0)) {
                        t = (0, s.unaryExpression)("-", t);
                    }
                    return t;
                }
                if (typeof e1 === "bigint") {
                    return (0, s.bigIntLiteral)(e1.toString());
                }
                if (isRegExp(e1)) {
                    const t = e1.source;
                    const r = /\/([a-z]*)$/.exec(e1.toString())[1];
                    return (0, s.regExpLiteral)(t, r);
                }
                if (Array.isArray(e1)) {
                    return (0, s.arrayExpression)(e1.map(valueToNode));
                }
                if (isPlainObject(e1)) {
                    const t = [];
                    for (const r of Object.keys(e1)){
                        let i, a = false;
                        if ((0, n.default)(r)) {
                            if (r === "__proto__") {
                                a = true;
                                i = (0, s.stringLiteral)(r);
                            } else {
                                i = (0, s.identifier)(r);
                            }
                        } else {
                            i = (0, s.stringLiteral)(r);
                        }
                        t.push((0, s.objectProperty)(i, valueToNode(e1[r]), a));
                    }
                    return (0, s.objectExpression)(t);
                }
                throw new Error("don't know how to turn this value into a node");
            }
        },
        485: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.patternLikeCommon = t.importAttributes = t.functionTypeAnnotationCommon = t.functionDeclarationCommon = t.functionCommon = t.classMethodOrPropertyCommon = t.classMethodOrDeclareMethodCommon = void 0;
            var n = r(7670);
            var s = r(2892);
            var i = r(974);
            var a = r(5241);
            var o = r(1164);
            var l = r(6624);
            const c = (0, l.defineAliasedType)("Standardized");
            c("ArrayExpression", {
                fields: {
                    elements: {
                        validate: (0, l.arrayOf)((0, l.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
                        default: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? [] : undefined
                    }
                },
                visitor: [
                    "elements"
                ],
                aliases: [
                    "Expression"
                ]
            });
            c("AssignmentExpression", {
                fields: {
                    operator: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertValueType)("string") : Object.assign(function() {
                            const e1 = (0, l.assertOneOf)(...o.ASSIGNMENT_OPERATORS);
                            const t = (0, l.assertOneOf)("=");
                            return function(r, s, i) {
                                const a = (0, n.default)("Pattern", r.left) ? t : e1;
                                a(r, s, i);
                            };
                        }(), {
                            type: "string"
                        })
                    },
                    left: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("LVal", "OptionalMemberExpression") : (0, l.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                builder: [
                    "operator",
                    "left",
                    "right"
                ],
                visitor: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Expression"
                ]
            });
            c("BinaryExpression", {
                builder: [
                    "operator",
                    "left",
                    "right"
                ],
                fields: {
                    operator: {
                        validate: (0, l.assertOneOf)(...o.BINARY_OPERATORS)
                    },
                    left: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Expression");
                            const t = (0, l.assertNodeType)("Expression", "PrivateName");
                            const r = Object.assign(function(r, n, s) {
                                const i = r.operator === "in" ? t : e1;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "Expression",
                                    "PrivateName"
                                ]
                            });
                            return r;
                        }()
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                visitor: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Binary",
                    "Expression"
                ]
            });
            c("InterpreterDirective", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                }
            });
            c("Directive", {
                visitor: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertNodeType)("DirectiveLiteral")
                    }
                }
            });
            c("DirectiveLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                }
            });
            c("BlockStatement", {
                builder: [
                    "body",
                    "directives"
                ],
                visitor: [
                    "directives",
                    "body"
                ],
                fields: {
                    directives: {
                        validate: (0, l.arrayOfType)("Directive"),
                        default: []
                    },
                    body: (0, l.validateArrayOfType)("Statement")
                },
                aliases: [
                    "Scopable",
                    "BlockParent",
                    "Block",
                    "Statement"
                ]
            });
            c("BreakStatement", {
                visitor: [
                    "label"
                ],
                fields: {
                    label: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    }
                },
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ]
            });
            c("CallExpression", {
                visitor: [
                    "callee",
                    "arguments",
                    "typeParameters",
                    "typeArguments"
                ],
                builder: [
                    "callee",
                    "arguments"
                ],
                aliases: [
                    "Expression"
                ],
                fields: Object.assign({
                    callee: {
                        validate: (0, l.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
                    },
                    arguments: (0, l.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
                    typeArguments: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation"),
                        optional: true
                    }
                }, {
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: true
                    }
                }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? {} : {
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    }
                })
            });
            c("CatchClause", {
                visitor: [
                    "param",
                    "body"
                ],
                fields: {
                    param: {
                        validate: (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                },
                aliases: [
                    "Scopable",
                    "BlockParent"
                ]
            });
            c("ConditionalExpression", {
                visitor: [
                    "test",
                    "consequent",
                    "alternate"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    alternate: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Expression",
                    "Conditional"
                ]
            });
            c("ContinueStatement", {
                visitor: [
                    "label"
                ],
                fields: {
                    label: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    }
                },
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ]
            });
            c("DebuggerStatement", {
                aliases: [
                    "Statement"
                ]
            });
            c("DoWhileStatement", {
                builder: [
                    "test",
                    "body"
                ],
                visitor: [
                    "body",
                    "test"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                },
                aliases: [
                    "Statement",
                    "BlockParent",
                    "Loop",
                    "While",
                    "Scopable"
                ]
            });
            c("EmptyStatement", {
                aliases: [
                    "Statement"
                ]
            });
            c("ExpressionStatement", {
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Statement",
                    "ExpressionWrapper"
                ]
            });
            c("File", {
                builder: [
                    "program",
                    "comments",
                    "tokens"
                ],
                visitor: [
                    "program"
                ],
                fields: {
                    program: {
                        validate: (0, l.assertNodeType)("Program")
                    },
                    comments: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? Object.assign(()=>{}, {
                            each: {
                                oneOfNodeTypes: [
                                    "CommentBlock",
                                    "CommentLine"
                                ]
                            }
                        }) : (0, l.assertEach)((0, l.assertNodeType)("CommentBlock", "CommentLine")),
                        optional: true
                    },
                    tokens: {
                        validate: (0, l.assertEach)(Object.assign(()=>{}, {
                            type: "any"
                        })),
                        optional: true
                    }
                }
            });
            c("ForInStatement", {
                visitor: [
                    "left",
                    "right",
                    "body"
                ],
                aliases: [
                    "Scopable",
                    "Statement",
                    "For",
                    "BlockParent",
                    "Loop",
                    "ForXStatement"
                ],
                fields: {
                    left: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("VariableDeclaration", "LVal") : (0, l.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("ForStatement", {
                visitor: [
                    "init",
                    "test",
                    "update",
                    "body"
                ],
                aliases: [
                    "Scopable",
                    "Statement",
                    "For",
                    "BlockParent",
                    "Loop"
                ],
                fields: {
                    init: {
                        validate: (0, l.assertNodeType)("VariableDeclaration", "Expression"),
                        optional: true
                    },
                    test: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    update: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            const functionCommon = ()=>({
                    params: (0, l.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
                    generator: {
                        default: false
                    },
                    async: {
                        default: false
                    }
                });
            t.functionCommon = functionCommon;
            const functionTypeAnnotationCommon = ()=>({
                    returnType: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    }
                });
            t.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
            const functionDeclarationCommon = ()=>Object.assign({}, functionCommon(), {
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    }
                });
            t.functionDeclarationCommon = functionDeclarationCommon;
            c("FunctionDeclaration", {
                builder: [
                    "id",
                    "params",
                    "body",
                    "generator",
                    "async"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "params",
                    "predicate",
                    "returnType",
                    "body"
                ],
                fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    },
                    predicate: {
                        validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                        optional: true
                    }
                }),
                aliases: [
                    "Scopable",
                    "Function",
                    "BlockParent",
                    "FunctionParent",
                    "Statement",
                    "Pureish",
                    "Declaration"
                ],
                validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? undefined : function() {
                    const e1 = (0, l.assertNodeType)("Identifier");
                    return function(t, r, s) {
                        if (!(0, n.default)("ExportDefaultDeclaration", t)) {
                            e1(s, "id", s.id);
                        }
                    };
                }()
            });
            c("FunctionExpression", {
                inherits: "FunctionDeclaration",
                aliases: [
                    "Scopable",
                    "Function",
                    "BlockParent",
                    "FunctionParent",
                    "Expression",
                    "Pureish"
                ],
                fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    },
                    predicate: {
                        validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                        optional: true
                    }
                })
            });
            const patternLikeCommon = ()=>({
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    }
                });
            t.patternLikeCommon = patternLikeCommon;
            c("Identifier", {
                builder: [
                    "name"
                ],
                visitor: [
                    "typeAnnotation",
                    "decorators"
                ],
                aliases: [
                    "Expression",
                    "PatternLike",
                    "LVal",
                    "TSEntityName"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    name: {
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("string"), Object.assign(function(e1, t, r) {
                            if (!(0, s.default)(r, false)) {
                                throw new TypeError('"'.concat(r, '" is not a valid identifier name'));
                            }
                        }, {
                            type: "string"
                        })) : (0, l.assertValueType)("string")
                    }
                }),
                validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? function(e1, t, r) {
                    const s = /\.(\w+)$/.exec(t.toString());
                    if (!s) return;
                    const [, a] = s;
                    const o = {
                        computed: false
                    };
                    if (a === "property") {
                        if ((0, n.default)("MemberExpression", e1, o)) return;
                        if ((0, n.default)("OptionalMemberExpression", e1, o)) return;
                    } else if (a === "key") {
                        if ((0, n.default)("Property", e1, o)) return;
                        if ((0, n.default)("Method", e1, o)) return;
                    } else if (a === "exported") {
                        if ((0, n.default)("ExportSpecifier", e1)) return;
                    } else if (a === "imported") {
                        if ((0, n.default)("ImportSpecifier", e1, {
                            imported: r
                        })) return;
                    } else if (a === "meta") {
                        if ((0, n.default)("MetaProperty", e1, {
                            meta: r
                        })) return;
                    }
                    if (((0, i.isKeyword)(r.name) || (0, i.isReservedWord)(r.name, false)) && r.name !== "this") {
                        throw new TypeError('"'.concat(r.name, '" is not a valid identifier'));
                    }
                } : undefined
            });
            c("IfStatement", {
                visitor: [
                    "test",
                    "consequent",
                    "alternate"
                ],
                aliases: [
                    "Statement",
                    "Conditional"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0, l.assertNodeType)("Statement")
                    },
                    alternate: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("LabeledStatement", {
                visitor: [
                    "label",
                    "body"
                ],
                aliases: [
                    "Statement"
                ],
                fields: {
                    label: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("StringLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("NumericLiteral", {
                builder: [
                    "value"
                ],
                deprecatedAlias: "NumberLiteral",
                fields: {
                    value: {
                        validate: (0, l.chain)((0, l.assertValueType)("number"), Object.assign(function(e1, t, r) {
                            if (1 / r < 0 || !Number.isFinite(r)) {
                                const e1 = new Error("NumericLiterals must be non-negative finite numbers. " + "You can use t.valueToNode(".concat(r, ") instead."));
                                {}
                            }
                        }, {
                            type: "number"
                        }))
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("NullLiteral", {
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("BooleanLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("boolean")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("RegExpLiteral", {
                builder: [
                    "pattern",
                    "flags"
                ],
                deprecatedAlias: "RegexLiteral",
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal"
                ],
                fields: {
                    pattern: {
                        validate: (0, l.assertValueType)("string")
                    },
                    flags: {
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("string"), Object.assign(function(e1, t, r) {
                            const n = /[^gimsuy]/.exec(r);
                            if (n) {
                                throw new TypeError('"'.concat(n[0], '" is not a valid RegExp flag'));
                            }
                        }, {
                            type: "string"
                        })) : (0, l.assertValueType)("string"),
                        default: ""
                    }
                }
            });
            c("LogicalExpression", {
                builder: [
                    "operator",
                    "left",
                    "right"
                ],
                visitor: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Binary",
                    "Expression"
                ],
                fields: {
                    operator: {
                        validate: (0, l.assertOneOf)(...o.LOGICAL_OPERATORS)
                    },
                    left: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("MemberExpression", {
                builder: [
                    "object",
                    "property",
                    "computed",
                    ...!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? [
                        "optional"
                    ] : []
                ],
                visitor: [
                    "object",
                    "property"
                ],
                aliases: [
                    "Expression",
                    "LVal"
                ],
                fields: Object.assign({
                    object: {
                        validate: (0, l.assertNodeType)("Expression", "Super")
                    },
                    property: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "PrivateName");
                            const t = (0, l.assertNodeType)("Expression");
                            const validator = function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                            validator.oneOfNodeTypes = [
                                "Expression",
                                "Identifier",
                                "PrivateName"
                            ];
                            return validator;
                        }()
                    },
                    computed: {
                        default: false
                    }
                }, !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? {
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    }
                } : {})
            });
            c("NewExpression", {
                inherits: "CallExpression"
            });
            c("Program", {
                visitor: [
                    "directives",
                    "body"
                ],
                builder: [
                    "body",
                    "directives",
                    "sourceType",
                    "interpreter"
                ],
                fields: {
                    sourceType: {
                        validate: (0, l.assertOneOf)("script", "module"),
                        default: "script"
                    },
                    interpreter: {
                        validate: (0, l.assertNodeType)("InterpreterDirective"),
                        default: null,
                        optional: true
                    },
                    directives: {
                        validate: (0, l.arrayOfType)("Directive"),
                        default: []
                    },
                    body: (0, l.validateArrayOfType)("Statement")
                },
                aliases: [
                    "Scopable",
                    "BlockParent",
                    "Block"
                ]
            });
            c("ObjectExpression", {
                visitor: [
                    "properties"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    properties: (0, l.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
                }
            });
            c("ObjectMethod", {
                builder: [
                    "kind",
                    "key",
                    "params",
                    "body",
                    "computed",
                    "generator",
                    "async"
                ],
                visitor: [
                    "decorators",
                    "key",
                    "typeParameters",
                    "params",
                    "returnType",
                    "body"
                ],
                fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                    kind: Object.assign({
                        validate: (0, l.assertOneOf)("method", "get", "set")
                    }, !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? {
                        default: "method"
                    } : {}),
                    computed: {
                        default: false
                    },
                    key: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
                            const t = (0, l.assertNodeType)("Expression");
                            const validator = function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                            validator.oneOfNodeTypes = [
                                "Expression",
                                "Identifier",
                                "StringLiteral",
                                "NumericLiteral",
                                "BigIntLiteral"
                            ];
                            return validator;
                        }()
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                }),
                aliases: [
                    "UserWhitespacable",
                    "Function",
                    "Scopable",
                    "BlockParent",
                    "FunctionParent",
                    "Method",
                    "ObjectMember"
                ]
            });
            c("ObjectProperty", {
                builder: [
                    "key",
                    "value",
                    "computed",
                    "shorthand",
                    ...!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? [
                        "decorators"
                    ] : []
                ],
                fields: {
                    computed: {
                        default: false
                    },
                    key: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
                            const t = (0, l.assertNodeType)("Expression");
                            const r = Object.assign(function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "Expression",
                                    "Identifier",
                                    "StringLiteral",
                                    "NumericLiteral",
                                    "BigIntLiteral",
                                    "DecimalLiteral",
                                    "PrivateName"
                                ]
                            });
                            return r;
                        }()
                    },
                    value: {
                        validate: (0, l.assertNodeType)("Expression", "PatternLike")
                    },
                    shorthand: {
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("boolean"), Object.assign(function(e1, t, r) {
                            if (!r) return;
                            if (e1.computed) {
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
                            }
                            if (!(0, n.default)("Identifier", e1.key)) {
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
                            }
                        }, {
                            type: "boolean"
                        })) : (0, l.assertValueType)("boolean"),
                        default: false
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    }
                },
                visitor: [
                    "key",
                    "value",
                    "decorators"
                ],
                aliases: [
                    "UserWhitespacable",
                    "Property",
                    "ObjectMember"
                ],
                validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? undefined : function() {
                    const e1 = (0, l.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
                    const t = (0, l.assertNodeType)("Expression");
                    return function(r, s, i) {
                        const a = (0, n.default)("ObjectPattern", r) ? e1 : t;
                        a(i, "value", i.value);
                    };
                }()
            });
            c("RestElement", {
                visitor: [
                    "argument",
                    "typeAnnotation"
                ],
                builder: [
                    "argument"
                ],
                aliases: [
                    "LVal",
                    "PatternLike"
                ],
                deprecatedAlias: "RestProperty",
                fields: Object.assign({}, patternLikeCommon(), {
                    argument: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("LVal") : (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    }
                }),
                validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? function(e1, t) {
                    const r = /(\w+)\[(\d+)\]/.exec(t.toString());
                    if (!r) throw new Error("Internal Babel error: malformed key.");
                    const [, n, s] = r;
                    if (e1[n].length > +s + 1) {
                        throw new TypeError("RestElement must be last element of ".concat(n));
                    }
                } : undefined
            });
            c("ReturnStatement", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ],
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    }
                }
            });
            c("SequenceExpression", {
                visitor: [
                    "expressions"
                ],
                fields: {
                    expressions: (0, l.validateArrayOfType)("Expression")
                },
                aliases: [
                    "Expression"
                ]
            });
            c("ParenthesizedExpression", {
                visitor: [
                    "expression"
                ],
                aliases: [
                    "Expression",
                    "ExpressionWrapper"
                ],
                fields: {
                    expression: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("SwitchCase", {
                visitor: [
                    "test",
                    "consequent"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    consequent: (0, l.validateArrayOfType)("Statement")
                }
            });
            c("SwitchStatement", {
                visitor: [
                    "discriminant",
                    "cases"
                ],
                aliases: [
                    "Statement",
                    "BlockParent",
                    "Scopable"
                ],
                fields: {
                    discriminant: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    cases: (0, l.validateArrayOfType)("SwitchCase")
                }
            });
            c("ThisExpression", {
                aliases: [
                    "Expression"
                ]
            });
            c("ThrowStatement", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ],
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("TryStatement", {
                visitor: [
                    "block",
                    "handler",
                    "finalizer"
                ],
                aliases: [
                    "Statement"
                ],
                fields: {
                    block: {
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertNodeType)("BlockStatement"), Object.assign(function(e1) {
                            if (!e1.handler && !e1.finalizer) {
                                throw new TypeError("TryStatement expects either a handler or finalizer, or both");
                            }
                        }, {
                            oneOfNodeTypes: [
                                "BlockStatement"
                            ]
                        })) : (0, l.assertNodeType)("BlockStatement")
                    },
                    handler: {
                        optional: true,
                        validate: (0, l.assertNodeType)("CatchClause")
                    },
                    finalizer: {
                        optional: true,
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                }
            });
            c("UnaryExpression", {
                builder: [
                    "operator",
                    "argument",
                    "prefix"
                ],
                fields: {
                    prefix: {
                        default: true
                    },
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: (0, l.assertOneOf)(...o.UNARY_OPERATORS)
                    }
                },
                visitor: [
                    "argument"
                ],
                aliases: [
                    "UnaryLike",
                    "Expression"
                ]
            });
            c("UpdateExpression", {
                builder: [
                    "operator",
                    "argument",
                    "prefix"
                ],
                fields: {
                    prefix: {
                        default: false
                    },
                    argument: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("Expression") : (0, l.assertNodeType)("Identifier", "MemberExpression")
                    },
                    operator: {
                        validate: (0, l.assertOneOf)(...o.UPDATE_OPERATORS)
                    }
                },
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Expression"
                ]
            });
            c("VariableDeclaration", {
                builder: [
                    "kind",
                    "declarations"
                ],
                visitor: [
                    "declarations"
                ],
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    kind: {
                        validate: (0, l.assertOneOf)("var", "let", "const", "using", "await using")
                    },
                    declarations: (0, l.validateArrayOfType)("VariableDeclarator")
                },
                validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (()=>{
                    const e1 = (0, l.assertNodeType)("Identifier");
                    return function(t, r, s) {
                        if ((0, n.default)("ForXStatement", t, {
                            left: s
                        })) {
                            if (s.declarations.length !== 1) {
                                throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(t.type));
                            }
                        } else {
                            s.declarations.forEach((t)=>{
                                if (!t.init) e1(t, "id", t.id);
                            });
                        }
                    };
                })() : undefined
            });
            c("VariableDeclarator", {
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("LVal") : (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
                    },
                    definite: {
                        optional: true,
                        validate: (0, l.assertValueType)("boolean")
                    },
                    init: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("WhileStatement", {
                visitor: [
                    "test",
                    "body"
                ],
                aliases: [
                    "Statement",
                    "BlockParent",
                    "Loop",
                    "While",
                    "Scopable"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("WithStatement", {
                visitor: [
                    "object",
                    "body"
                ],
                aliases: [
                    "Statement"
                ],
                fields: {
                    object: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("AssignmentPattern", {
                visitor: [
                    "left",
                    "right",
                    "decorators"
                ],
                builder: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Pattern",
                    "PatternLike",
                    "LVal"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    left: {
                        validate: (0, l.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    }
                })
            });
            c("ArrayPattern", {
                visitor: [
                    "elements",
                    "typeAnnotation"
                ],
                builder: [
                    "elements"
                ],
                aliases: [
                    "Pattern",
                    "PatternLike",
                    "LVal"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    elements: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeOrValueType)("null", "PatternLike", "LVal")))
                    }
                })
            });
            c("ArrowFunctionExpression", {
                builder: [
                    "params",
                    "body",
                    "async"
                ],
                visitor: [
                    "typeParameters",
                    "params",
                    "predicate",
                    "returnType",
                    "body"
                ],
                aliases: [
                    "Scopable",
                    "Function",
                    "BlockParent",
                    "FunctionParent",
                    "Expression",
                    "Pureish"
                ],
                fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                    expression: {
                        validate: (0, l.assertValueType)("boolean")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement", "Expression")
                    },
                    predicate: {
                        validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                        optional: true
                    }
                })
            });
            c("ClassBody", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: (0, l.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
                }
            });
            c("ClassExpression", {
                builder: [
                    "id",
                    "superClass",
                    "body",
                    "decorators"
                ],
                visitor: [
                    "decorators",
                    "id",
                    "typeParameters",
                    "superClass",
                    "superTypeParameters",
                    "mixins",
                    "implements",
                    "body"
                ],
                aliases: [
                    "Scopable",
                    "Class",
                    "Expression"
                ],
                fields: {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    ["superTypeParameters"]: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    },
                    implements: {
                        validate: (0, l.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    },
                    mixins: {
                        validate: (0, l.assertNodeType)("InterfaceExtends"),
                        optional: true
                    }
                }
            });
            c("ClassDeclaration", {
                inherits: "ClassExpression",
                aliases: [
                    "Scopable",
                    "Class",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    ["superTypeParameters"]: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    },
                    implements: {
                        validate: (0, l.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    },
                    mixins: {
                        validate: (0, l.assertNodeType)("InterfaceExtends"),
                        optional: true
                    },
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    abstract: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    }
                },
                validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? undefined : function() {
                    const e1 = (0, l.assertNodeType)("Identifier");
                    return function(t, r, s) {
                        if (!(0, n.default)("ExportDefaultDeclaration", t)) {
                            e1(s, "id", s.id);
                        }
                    };
                }()
            });
            const p = t.importAttributes = {
                attributes: {
                    optional: true,
                    validate: (0, l.arrayOfType)("ImportAttribute")
                },
                assertions: {
                    deprecated: true,
                    optional: true,
                    validate: (0, l.arrayOfType)("ImportAttribute")
                }
            };
            c("ExportAllDeclaration", {
                builder: [
                    "source"
                ],
                visitor: [
                    "source",
                    "attributes",
                    "assertions"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration",
                    "ExportDeclaration"
                ],
                fields: Object.assign({
                    source: {
                        validate: (0, l.assertNodeType)("StringLiteral")
                    },
                    exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value"))
                }, p)
            });
            c("ExportDefaultDeclaration", {
                visitor: [
                    "declaration"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration",
                    "ExportDeclaration"
                ],
                fields: {
                    declaration: (0, l.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
                    exportKind: (0, l.validateOptional)((0, l.assertOneOf)("value"))
                }
            });
            c("ExportNamedDeclaration", {
                builder: [
                    "declaration",
                    "specifiers",
                    "source"
                ],
                visitor: ("TURBOPACK compile-time truthy", 1) ? [
                    "declaration",
                    "specifiers",
                    "source",
                    "attributes"
                ] : "TURBOPACK unreachable",
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration",
                    "ExportDeclaration"
                ],
                fields: Object.assign({
                    declaration: {
                        optional: true,
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertNodeType)("Declaration"), Object.assign(function(e1, t, r) {
                            if (r && e1.specifiers.length) {
                                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
                            }
                            if (r && e1.source) {
                                throw new TypeError("Cannot export a declaration from a source");
                            }
                        }, {
                            oneOfNodeTypes: [
                                "Declaration"
                            ]
                        })) : (0, l.assertNodeType)("Declaration")
                    }
                }, p, {
                    specifiers: {
                        default: [],
                        validate: (0, l.arrayOf)(function() {
                            const e1 = (0, l.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                            const t = (0, l.assertNodeType)("ExportSpecifier");
                            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING) return e1;
                            return Object.assign(function(r, n, s) {
                                const i = r.source ? e1 : t;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "ExportSpecifier",
                                    "ExportDefaultSpecifier",
                                    "ExportNamespaceSpecifier"
                                ]
                            });
                        }())
                    },
                    source: {
                        validate: (0, l.assertNodeType)("StringLiteral"),
                        optional: true
                    },
                    exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value"))
                })
            });
            c("ExportSpecifier", {
                visitor: [
                    "local",
                    "exported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    exported: {
                        validate: (0, l.assertNodeType)("Identifier", "StringLiteral")
                    },
                    exportKind: {
                        validate: (0, l.assertOneOf)("type", "value"),
                        optional: true
                    }
                }
            });
            c("ForOfStatement", {
                visitor: [
                    "left",
                    "right",
                    "body"
                ],
                builder: [
                    "left",
                    "right",
                    "body",
                    "await"
                ],
                aliases: [
                    "Scopable",
                    "Statement",
                    "For",
                    "BlockParent",
                    "Loop",
                    "ForXStatement"
                ],
                fields: {
                    left: {
                        validate: function() {
                            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING) {
                                return (0, l.assertNodeType)("VariableDeclaration", "LVal");
                            }
                            const e1 = (0, l.assertNodeType)("VariableDeclaration");
                            const t = (0, l.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
                            return Object.assign(function(r, s, i) {
                                if ((0, n.default)("VariableDeclaration", i)) {
                                    e1(r, s, i);
                                } else {
                                    t(r, s, i);
                                }
                            }, {
                                oneOfNodeTypes: [
                                    "VariableDeclaration",
                                    "Identifier",
                                    "MemberExpression",
                                    "ArrayPattern",
                                    "ObjectPattern",
                                    "TSAsExpression",
                                    "TSSatisfiesExpression",
                                    "TSTypeAssertion",
                                    "TSNonNullExpression"
                                ]
                            });
                        }()
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    },
                    await: {
                        default: false
                    }
                }
            });
            c("ImportDeclaration", {
                builder: [
                    "specifiers",
                    "source"
                ],
                visitor: [
                    "specifiers",
                    "source",
                    "attributes",
                    "assertions"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration"
                ],
                fields: Object.assign({}, p, {
                    module: {
                        optional: true,
                        validate: (0, l.assertValueType)("boolean")
                    },
                    phase: {
                        default: null,
                        validate: (0, l.assertOneOf)("source", "defer")
                    },
                    specifiers: (0, l.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
                    source: {
                        validate: (0, l.assertNodeType)("StringLiteral")
                    },
                    importKind: {
                        validate: (0, l.assertOneOf)("type", "typeof", "value"),
                        optional: true
                    }
                })
            });
            c("ImportDefaultSpecifier", {
                visitor: [
                    "local"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("ImportNamespaceSpecifier", {
                visitor: [
                    "local"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("ImportSpecifier", {
                visitor: [
                    "imported",
                    "local"
                ],
                builder: [
                    "local",
                    "imported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    imported: {
                        validate: (0, l.assertNodeType)("Identifier", "StringLiteral")
                    },
                    importKind: {
                        validate: (0, l.assertOneOf)("type", "typeof", "value"),
                        optional: true
                    }
                }
            });
            c("ImportExpression", {
                visitor: [
                    "source",
                    "options"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    phase: {
                        default: null,
                        validate: (0, l.assertOneOf)("source", "defer")
                    },
                    source: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    options: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    }
                }
            });
            c("MetaProperty", {
                visitor: [
                    "meta",
                    "property"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    meta: {
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertNodeType)("Identifier"), Object.assign(function(e1, t, r) {
                            let s;
                            switch(r.name){
                                case "function":
                                    s = "sent";
                                    break;
                                case "new":
                                    s = "target";
                                    break;
                                case "import":
                                    s = "meta";
                                    break;
                            }
                            if (!(0, n.default)("Identifier", e1.property, {
                                name: s
                            })) {
                                throw new TypeError("Unrecognised MetaProperty");
                            }
                        }, {
                            oneOfNodeTypes: [
                                "Identifier"
                            ]
                        })) : (0, l.assertNodeType)("Identifier")
                    },
                    property: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            const classMethodOrPropertyCommon = ()=>({
                    abstract: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    accessibility: {
                        validate: (0, l.assertOneOf)("public", "private", "protected"),
                        optional: true
                    },
                    static: {
                        default: false
                    },
                    override: {
                        default: false
                    },
                    computed: {
                        default: false
                    },
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    key: {
                        validate: (0, l.chain)(function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
                            const t = (0, l.assertNodeType)("Expression");
                            return function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                        }(), (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
                    }
                });
            t.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
            const classMethodOrDeclareMethodCommon = ()=>Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
                    params: (0, l.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
                    kind: {
                        validate: (0, l.assertOneOf)("get", "set", "method", "constructor"),
                        default: "method"
                    },
                    access: {
                        validate: (0, l.chain)((0, l.assertValueType)("string"), (0, l.assertOneOf)("public", "private", "protected")),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    }
                });
            t.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
            c("ClassMethod", {
                aliases: [
                    "Function",
                    "Scopable",
                    "BlockParent",
                    "FunctionParent",
                    "Method"
                ],
                builder: [
                    "kind",
                    "key",
                    "params",
                    "body",
                    "computed",
                    "static",
                    "generator",
                    "async"
                ],
                visitor: [
                    "decorators",
                    "key",
                    "typeParameters",
                    "params",
                    "returnType",
                    "body"
                ],
                fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                })
            });
            c("ObjectPattern", {
                visitor: [
                    "properties",
                    "typeAnnotation",
                    "decorators"
                ],
                builder: [
                    "properties"
                ],
                aliases: [
                    "Pattern",
                    "PatternLike",
                    "LVal"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    properties: (0, l.validateArrayOfType)("RestElement", "ObjectProperty")
                })
            });
            c("SpreadElement", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "UnaryLike"
                ],
                deprecatedAlias: "SpreadProperty",
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("Super", {
                aliases: [
                    "Expression"
                ]
            });
            c("TaggedTemplateExpression", {
                visitor: [
                    "tag",
                    "typeParameters",
                    "quasi"
                ],
                builder: [
                    "tag",
                    "quasi"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    tag: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    quasi: {
                        validate: (0, l.assertNodeType)("TemplateLiteral")
                    },
                    ["typeParameters"]: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    }
                }
            });
            c("TemplateElement", {
                builder: [
                    "value",
                    "tail"
                ],
                fields: {
                    value: {
                        validate: (0, l.chain)((0, l.assertShape)({
                            raw: {
                                validate: (0, l.assertValueType)("string")
                            },
                            cooked: {
                                validate: (0, l.assertValueType)("string"),
                                optional: true
                            }
                        }), function templateElementCookedValidator(e1) {
                            const t = e1.value.raw;
                            let r = false;
                            const error = ()=>{
                                throw new Error("Internal @babel/types error.");
                            };
                            const { str: n, firstInvalidLoc: s } = (0, a.readStringContents)("template", t, 0, 0, 0, {
                                unterminated () {
                                    r = true;
                                },
                                strictNumericEscape: error,
                                invalidEscapeSequence: error,
                                numericSeparatorInEscapeSequence: error,
                                unexpectedNumericSeparator: error,
                                invalidDigit: error,
                                invalidCodePoint: error
                            });
                            if (!r) throw new Error("Invalid raw");
                            e1.value.cooked = s ? null : n;
                        })
                    },
                    tail: {
                        default: false
                    }
                }
            });
            c("TemplateLiteral", {
                visitor: [
                    "quasis",
                    "expressions"
                ],
                aliases: [
                    "Expression",
                    "Literal"
                ],
                fields: {
                    quasis: (0, l.validateArrayOfType)("TemplateElement"),
                    expressions: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Expression", "TSType")), function(e1, t, r) {
                            if (e1.quasis.length !== r.length + 1) {
                                throw new TypeError("Number of ".concat(e1.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(r.length + 1, " quasis but got ").concat(e1.quasis.length));
                            }
                        })
                    }
                }
            });
            c("YieldExpression", {
                builder: [
                    "argument",
                    "delegate"
                ],
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Expression",
                    "Terminatorless"
                ],
                fields: {
                    delegate: {
                        validate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("boolean"), Object.assign(function(e1, t, r) {
                            if (r && !e1.argument) {
                                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
                            }
                        }, {
                            type: "boolean"
                        })) : (0, l.assertValueType)("boolean"),
                        default: false
                    },
                    argument: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("AwaitExpression", {
                builder: [
                    "argument"
                ],
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Expression",
                    "Terminatorless"
                ],
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("Import", {
                aliases: [
                    "Expression"
                ]
            });
            c("BigIntLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("ExportNamespaceSpecifier", {
                visitor: [
                    "exported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    exported: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("OptionalMemberExpression", {
                builder: [
                    "object",
                    "property",
                    "computed",
                    "optional"
                ],
                visitor: [
                    "object",
                    "property"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    object: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier");
                            const t = (0, l.assertNodeType)("Expression");
                            const r = Object.assign(function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "Expression",
                                    "Identifier"
                                ]
                            });
                            return r;
                        }()
                    },
                    computed: {
                        default: false
                    },
                    optional: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertValueType)("boolean") : (0, l.chain)((0, l.assertValueType)("boolean"), (0, l.assertOptionalChainStart)())
                    }
                }
            });
            c("OptionalCallExpression", {
                visitor: [
                    "callee",
                    "arguments",
                    "typeParameters",
                    "typeArguments"
                ],
                builder: [
                    "callee",
                    "arguments",
                    "optional"
                ],
                aliases: [
                    "Expression"
                ],
                fields: Object.assign({
                    callee: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    arguments: (0, l.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
                    optional: {
                        validate: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? (0, l.assertValueType)("boolean") : (0, l.chain)((0, l.assertValueType)("boolean"), (0, l.assertOptionalChainStart)())
                    },
                    typeArguments: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation"),
                        optional: true
                    }
                }, {
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: true
                    }
                })
            });
            c("ClassProperty", {
                visitor: [
                    "decorators",
                    "variance",
                    "key",
                    "typeAnnotation",
                    "value"
                ],
                builder: [
                    "key",
                    "value",
                    "typeAnnotation",
                    "decorators",
                    "computed",
                    "static"
                ],
                aliases: [
                    "Property"
                ],
                fields: Object.assign({}, classMethodOrPropertyCommon(), {
                    value: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    definite: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    },
                    readonly: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    variance: {
                        validate: (0, l.assertNodeType)("Variance"),
                        optional: true
                    }
                })
            });
            c("ClassAccessorProperty", {
                visitor: [
                    "decorators",
                    "key",
                    "typeAnnotation",
                    "value"
                ],
                builder: [
                    "key",
                    "value",
                    "typeAnnotation",
                    "decorators",
                    "computed",
                    "static"
                ],
                aliases: [
                    "Property",
                    "Accessor"
                ],
                fields: Object.assign({}, classMethodOrPropertyCommon(), {
                    key: {
                        validate: (0, l.chain)(function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
                            const t = (0, l.assertNodeType)("Expression");
                            return function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                        }(), (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
                    },
                    value: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    definite: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    },
                    readonly: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    variance: {
                        validate: (0, l.assertNodeType)("Variance"),
                        optional: true
                    }
                })
            });
            c("ClassPrivateProperty", {
                visitor: [
                    "decorators",
                    "variance",
                    "key",
                    "typeAnnotation",
                    "value"
                ],
                builder: [
                    "key",
                    "value",
                    "decorators",
                    "static"
                ],
                aliases: [
                    "Property",
                    "Private"
                ],
                fields: {
                    key: {
                        validate: (0, l.assertNodeType)("PrivateName")
                    },
                    value: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.arrayOfType)("Decorator"),
                        optional: true
                    },
                    static: {
                        validate: (0, l.assertValueType)("boolean"),
                        default: false
                    },
                    readonly: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    definite: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    variance: {
                        validate: (0, l.assertNodeType)("Variance"),
                        optional: true
                    }
                }
            });
            c("ClassPrivateMethod", {
                builder: [
                    "kind",
                    "key",
                    "params",
                    "body",
                    "static"
                ],
                visitor: [
                    "decorators",
                    "key",
                    "typeParameters",
                    "params",
                    "returnType",
                    "body"
                ],
                aliases: [
                    "Function",
                    "Scopable",
                    "BlockParent",
                    "FunctionParent",
                    "Method",
                    "Private"
                ],
                fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
                    kind: {
                        validate: (0, l.assertOneOf)("get", "set", "method"),
                        default: "method"
                    },
                    key: {
                        validate: (0, l.assertNodeType)("PrivateName")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                })
            });
            c("PrivateName", {
                visitor: [
                    "id"
                ],
                aliases: [
                    "Private"
                ],
                fields: {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("StaticBlock", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: (0, l.validateArrayOfType)("Statement")
                },
                aliases: [
                    "Scopable",
                    "BlockParent",
                    "FunctionParent"
                ]
            });
            c("ImportAttribute", {
                visitor: [
                    "key",
                    "value"
                ],
                fields: {
                    key: {
                        validate: (0, l.assertNodeType)("Identifier", "StringLiteral")
                    },
                    value: {
                        validate: (0, l.assertNodeType)("StringLiteral")
                    }
                }
            });
        },
        6738: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DEPRECATED_ALIASES = void 0;
            const r = t.DEPRECATED_ALIASES = {
                ModuleDeclaration: "ImportOrExportDeclaration"
            };
        },
        4414: (e1, t, r)=>{
            "use strict";
            var n = r(6624);
            (0, n.default)("ArgumentPlaceholder", {});
            (0, n.default)("BindExpression", {
                visitor: [
                    "object",
                    "callee"
                ],
                aliases: [
                    "Expression"
                ],
                fields: !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? {
                    object: {
                        validate: Object.assign(()=>{}, {
                            oneOfNodeTypes: [
                                "Expression"
                            ]
                        })
                    },
                    callee: {
                        validate: Object.assign(()=>{}, {
                            oneOfNodeTypes: [
                                "Expression"
                            ]
                        })
                    }
                } : {
                    object: {
                        validate: (0, n.assertNodeType)("Expression")
                    },
                    callee: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            (0, n.default)("Decorator", {
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            (0, n.default)("DoExpression", {
                visitor: [
                    "body"
                ],
                builder: [
                    "body",
                    "async"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    body: {
                        validate: (0, n.assertNodeType)("BlockStatement")
                    },
                    async: {
                        validate: (0, n.assertValueType)("boolean"),
                        default: false
                    }
                }
            });
            (0, n.default)("ExportDefaultSpecifier", {
                visitor: [
                    "exported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    exported: {
                        validate: (0, n.assertNodeType)("Identifier")
                    }
                }
            });
            (0, n.default)("RecordExpression", {
                visitor: [
                    "properties"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    properties: (0, n.validateArrayOfType)("ObjectProperty", "SpreadElement")
                }
            });
            (0, n.default)("TupleExpression", {
                fields: {
                    elements: {
                        validate: (0, n.arrayOfType)("Expression", "SpreadElement"),
                        default: []
                    }
                },
                visitor: [
                    "elements"
                ],
                aliases: [
                    "Expression"
                ]
            });
            {
                (0, n.default)("DecimalLiteral", {
                    builder: [
                        "value"
                    ],
                    fields: {
                        value: {
                            validate: (0, n.assertValueType)("string")
                        }
                    },
                    aliases: [
                        "Expression",
                        "Pureish",
                        "Literal",
                        "Immutable"
                    ]
                });
            }
            (0, n.default)("ModuleExpression", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: {
                        validate: (0, n.assertNodeType)("Program")
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("TopicReference", {
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("PipelineTopicExpression", {
                builder: [
                    "expression"
                ],
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("PipelineBareFunction", {
                builder: [
                    "callee"
                ],
                visitor: [
                    "callee"
                ],
                fields: {
                    callee: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("PipelinePrimaryTopicReference", {
                aliases: [
                    "Expression"
                ]
            });
        },
        6769: (e1, t, r)=>{
            "use strict";
            var n = r(485);
            var s = r(6624);
            const i = (0, s.defineAliasedType)("Flow");
            const defineInterfaceishType = (e1)=>{
                const t = e1 === "DeclareClass";
                i(e1, {
                    builder: [
                        "id",
                        "typeParameters",
                        "extends",
                        "body"
                    ],
                    visitor: [
                        "id",
                        "typeParameters",
                        "extends",
                        ...t ? [
                            "mixins",
                            "implements"
                        ] : [],
                        "body"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: Object.assign({
                        id: (0, s.validateType)("Identifier"),
                        typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
                        extends: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends"))
                    }, t ? {
                        mixins: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")),
                        implements: (0, s.validateOptional)((0, s.arrayOfType)("ClassImplements"))
                    } : {}, {
                        body: (0, s.validateType)("ObjectTypeAnnotation")
                    })
                });
            };
            i("AnyTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("ArrayTypeAnnotation", {
                visitor: [
                    "elementType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    elementType: (0, s.validateType)("FlowType")
                }
            });
            i("BooleanTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("BooleanLiteralTypeAnnotation", {
                builder: [
                    "value"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    value: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("NullLiteralTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("ClassImplements", {
                visitor: [
                    "id",
                    "typeParameters"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation")
                }
            });
            defineInterfaceishType("DeclareClass");
            i("DeclareFunction", {
                builder: [
                    "id"
                ],
                visitor: [
                    "id",
                    "predicate"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    predicate: (0, s.validateOptionalType)("DeclaredPredicate")
                }
            });
            defineInterfaceishType("DeclareInterface");
            i("DeclareModule", {
                builder: [
                    "id",
                    "body",
                    "kind"
                ],
                visitor: [
                    "id",
                    "body"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier", "StringLiteral"),
                    body: (0, s.validateType)("BlockStatement"),
                    kind: (0, s.validateOptional)((0, s.assertOneOf)("CommonJS", "ES"))
                }
            });
            i("DeclareModuleExports", {
                visitor: [
                    "typeAnnotation"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    typeAnnotation: (0, s.validateType)("TypeAnnotation")
                }
            });
            i("DeclareTypeAlias", {
                visitor: [
                    "id",
                    "typeParameters",
                    "right"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
                    right: (0, s.validateType)("FlowType")
                }
            });
            i("DeclareOpaqueType", {
                visitor: [
                    "id",
                    "typeParameters",
                    "supertype"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
                    supertype: (0, s.validateOptionalType)("FlowType"),
                    impltype: (0, s.validateOptionalType)("FlowType")
                }
            });
            i("DeclareVariable", {
                visitor: [
                    "id"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier")
                }
            });
            i("DeclareExportDeclaration", {
                visitor: [
                    "declaration",
                    "specifiers",
                    "source",
                    "attributes"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: Object.assign({
                    declaration: (0, s.validateOptionalType)("Flow"),
                    specifiers: (0, s.validateOptional)((0, s.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
                    source: (0, s.validateOptionalType)("StringLiteral"),
                    default: (0, s.validateOptional)((0, s.assertValueType)("boolean"))
                }, n.importAttributes)
            });
            i("DeclareExportAllDeclaration", {
                visitor: [
                    "source",
                    "attributes"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: Object.assign({
                    source: (0, s.validateType)("StringLiteral"),
                    exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value"))
                }, n.importAttributes)
            });
            i("DeclaredPredicate", {
                visitor: [
                    "value"
                ],
                aliases: [
                    "FlowPredicate"
                ],
                fields: {
                    value: (0, s.validateType)("Flow")
                }
            });
            i("ExistsTypeAnnotation", {
                aliases: [
                    "FlowType"
                ]
            });
            i("FunctionTypeAnnotation", {
                builder: [
                    "typeParameters",
                    "params",
                    "rest",
                    "returnType"
                ],
                visitor: [
                    "typeParameters",
                    "this",
                    "params",
                    "rest",
                    "returnType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
                    params: (0, s.validateArrayOfType)("FunctionTypeParam"),
                    rest: (0, s.validateOptionalType)("FunctionTypeParam"),
                    this: (0, s.validateOptionalType)("FunctionTypeParam"),
                    returnType: (0, s.validateType)("FlowType")
                }
            });
            i("FunctionTypeParam", {
                visitor: [
                    "name",
                    "typeAnnotation"
                ],
                fields: {
                    name: (0, s.validateOptionalType)("Identifier"),
                    typeAnnotation: (0, s.validateType)("FlowType"),
                    optional: (0, s.validateOptional)((0, s.assertValueType)("boolean"))
                }
            });
            i("GenericTypeAnnotation", {
                visitor: [
                    "id",
                    "typeParameters"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier", "QualifiedTypeIdentifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation")
                }
            });
            i("InferredPredicate", {
                aliases: [
                    "FlowPredicate"
                ]
            });
            i("InterfaceExtends", {
                visitor: [
                    "id",
                    "typeParameters"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier", "QualifiedTypeIdentifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation")
                }
            });
            defineInterfaceishType("InterfaceDeclaration");
            i("InterfaceTypeAnnotation", {
                visitor: [
                    "extends",
                    "body"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    extends: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")),
                    body: (0, s.validateType)("ObjectTypeAnnotation")
                }
            });
            i("IntersectionTypeAnnotation", {
                visitor: [
                    "types"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    types: (0, s.validate)((0, s.arrayOfType)("FlowType"))
                }
            });
            i("MixedTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("EmptyTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("NullableTypeAnnotation", {
                visitor: [
                    "typeAnnotation"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    typeAnnotation: (0, s.validateType)("FlowType")
                }
            });
            i("NumberLiteralTypeAnnotation", {
                builder: [
                    "value"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    value: (0, s.validate)((0, s.assertValueType)("number"))
                }
            });
            i("NumberTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("ObjectTypeAnnotation", {
                visitor: [
                    "properties",
                    "indexers",
                    "callProperties",
                    "internalSlots"
                ],
                aliases: [
                    "FlowType"
                ],
                builder: [
                    "properties",
                    "indexers",
                    "callProperties",
                    "internalSlots",
                    "exact"
                ],
                fields: {
                    properties: (0, s.validate)((0, s.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
                    indexers: {
                        validate: (0, s.arrayOfType)("ObjectTypeIndexer"),
                        optional: true,
                        default: []
                    },
                    callProperties: {
                        validate: (0, s.arrayOfType)("ObjectTypeCallProperty"),
                        optional: true,
                        default: []
                    },
                    internalSlots: {
                        validate: (0, s.arrayOfType)("ObjectTypeInternalSlot"),
                        optional: true,
                        default: []
                    },
                    exact: {
                        validate: (0, s.assertValueType)("boolean"),
                        default: false
                    },
                    inexact: (0, s.validateOptional)((0, s.assertValueType)("boolean"))
                }
            });
            i("ObjectTypeInternalSlot", {
                visitor: [
                    "id",
                    "value"
                ],
                builder: [
                    "id",
                    "value",
                    "optional",
                    "static",
                    "method"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    value: (0, s.validateType)("FlowType"),
                    optional: (0, s.validate)((0, s.assertValueType)("boolean")),
                    static: (0, s.validate)((0, s.assertValueType)("boolean")),
                    method: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("ObjectTypeCallProperty", {
                visitor: [
                    "value"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    value: (0, s.validateType)("FlowType"),
                    static: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("ObjectTypeIndexer", {
                visitor: [
                    "variance",
                    "id",
                    "key",
                    "value"
                ],
                builder: [
                    "id",
                    "key",
                    "value",
                    "variance"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    id: (0, s.validateOptionalType)("Identifier"),
                    key: (0, s.validateType)("FlowType"),
                    value: (0, s.validateType)("FlowType"),
                    static: (0, s.validate)((0, s.assertValueType)("boolean")),
                    variance: (0, s.validateOptionalType)("Variance")
                }
            });
            i("ObjectTypeProperty", {
                visitor: [
                    "key",
                    "value",
                    "variance"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    key: (0, s.validateType)("Identifier", "StringLiteral"),
                    value: (0, s.validateType)("FlowType"),
                    kind: (0, s.validate)((0, s.assertOneOf)("init", "get", "set")),
                    static: (0, s.validate)((0, s.assertValueType)("boolean")),
                    proto: (0, s.validate)((0, s.assertValueType)("boolean")),
                    optional: (0, s.validate)((0, s.assertValueType)("boolean")),
                    variance: (0, s.validateOptionalType)("Variance"),
                    method: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("ObjectTypeSpreadProperty", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    argument: (0, s.validateType)("FlowType")
                }
            });
            i("OpaqueType", {
                visitor: [
                    "id",
                    "typeParameters",
                    "supertype",
                    "impltype"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
                    supertype: (0, s.validateOptionalType)("FlowType"),
                    impltype: (0, s.validateType)("FlowType")
                }
            });
            i("QualifiedTypeIdentifier", {
                visitor: [
                    "qualification",
                    "id"
                ],
                builder: [
                    "id",
                    "qualification"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    qualification: (0, s.validateType)("Identifier", "QualifiedTypeIdentifier")
                }
            });
            i("StringLiteralTypeAnnotation", {
                builder: [
                    "value"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    value: (0, s.validate)((0, s.assertValueType)("string"))
                }
            });
            i("StringTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("SymbolTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("ThisTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("TupleTypeAnnotation", {
                visitor: [
                    "types"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    types: (0, s.validate)((0, s.arrayOfType)("FlowType"))
                }
            });
            i("TypeofTypeAnnotation", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    argument: (0, s.validateType)("FlowType")
                }
            });
            i("TypeAlias", {
                visitor: [
                    "id",
                    "typeParameters",
                    "right"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"),
                    right: (0, s.validateType)("FlowType")
                }
            });
            i("TypeAnnotation", {
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, s.validateType)("FlowType")
                }
            });
            i("TypeCastExpression", {
                visitor: [
                    "expression",
                    "typeAnnotation"
                ],
                aliases: [
                    "ExpressionWrapper",
                    "Expression"
                ],
                fields: {
                    expression: (0, s.validateType)("Expression"),
                    typeAnnotation: (0, s.validateType)("TypeAnnotation")
                }
            });
            i("TypeParameter", {
                visitor: [
                    "bound",
                    "default",
                    "variance"
                ],
                fields: {
                    name: (0, s.validate)((0, s.assertValueType)("string")),
                    bound: (0, s.validateOptionalType)("TypeAnnotation"),
                    default: (0, s.validateOptionalType)("FlowType"),
                    variance: (0, s.validateOptionalType)("Variance")
                }
            });
            i("TypeParameterDeclaration", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: (0, s.validate)((0, s.arrayOfType)("TypeParameter"))
                }
            });
            i("TypeParameterInstantiation", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: (0, s.validate)((0, s.arrayOfType)("FlowType"))
                }
            });
            i("UnionTypeAnnotation", {
                visitor: [
                    "types"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    types: (0, s.validate)((0, s.arrayOfType)("FlowType"))
                }
            });
            i("Variance", {
                builder: [
                    "kind"
                ],
                fields: {
                    kind: (0, s.validate)((0, s.assertOneOf)("minus", "plus"))
                }
            });
            i("VoidTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            i("EnumDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "body"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    body: (0, s.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
                }
            });
            i("EnumBooleanBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    explicitType: (0, s.validate)((0, s.assertValueType)("boolean")),
                    members: (0, s.validateArrayOfType)("EnumBooleanMember"),
                    hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("EnumNumberBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    explicitType: (0, s.validate)((0, s.assertValueType)("boolean")),
                    members: (0, s.validateArrayOfType)("EnumNumberMember"),
                    hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("EnumStringBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    explicitType: (0, s.validate)((0, s.assertValueType)("boolean")),
                    members: (0, s.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
                    hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("EnumSymbolBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    members: (0, s.validateArrayOfType)("EnumDefaultedMember"),
                    hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
            i("EnumBooleanMember", {
                aliases: [
                    "EnumMember"
                ],
                builder: [
                    "id"
                ],
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    init: (0, s.validateType)("BooleanLiteral")
                }
            });
            i("EnumNumberMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    init: (0, s.validateType)("NumericLiteral")
                }
            });
            i("EnumStringMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier"),
                    init: (0, s.validateType)("StringLiteral")
                }
            });
            i("EnumDefaultedMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id"
                ],
                fields: {
                    id: (0, s.validateType)("Identifier")
                }
            });
            i("IndexedAccessType", {
                visitor: [
                    "objectType",
                    "indexType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    objectType: (0, s.validateType)("FlowType"),
                    indexType: (0, s.validateType)("FlowType")
                }
            });
            i("OptionalIndexedAccessType", {
                visitor: [
                    "objectType",
                    "indexType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    objectType: (0, s.validateType)("FlowType"),
                    indexType: (0, s.validateType)("FlowType"),
                    optional: (0, s.validate)((0, s.assertValueType)("boolean"))
                }
            });
        },
        6767: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "ALIAS_KEYS", {
                enumerable: true,
                get: function() {
                    return n.ALIAS_KEYS;
                }
            });
            Object.defineProperty(t, "BUILDER_KEYS", {
                enumerable: true,
                get: function() {
                    return n.BUILDER_KEYS;
                }
            });
            Object.defineProperty(t, "DEPRECATED_ALIASES", {
                enumerable: true,
                get: function() {
                    return i.DEPRECATED_ALIASES;
                }
            });
            Object.defineProperty(t, "DEPRECATED_KEYS", {
                enumerable: true,
                get: function() {
                    return n.DEPRECATED_KEYS;
                }
            });
            Object.defineProperty(t, "FLIPPED_ALIAS_KEYS", {
                enumerable: true,
                get: function() {
                    return n.FLIPPED_ALIAS_KEYS;
                }
            });
            Object.defineProperty(t, "NODE_FIELDS", {
                enumerable: true,
                get: function() {
                    return n.NODE_FIELDS;
                }
            });
            Object.defineProperty(t, "NODE_PARENT_VALIDATIONS", {
                enumerable: true,
                get: function() {
                    return n.NODE_PARENT_VALIDATIONS;
                }
            });
            Object.defineProperty(t, "PLACEHOLDERS", {
                enumerable: true,
                get: function() {
                    return s.PLACEHOLDERS;
                }
            });
            Object.defineProperty(t, "PLACEHOLDERS_ALIAS", {
                enumerable: true,
                get: function() {
                    return s.PLACEHOLDERS_ALIAS;
                }
            });
            Object.defineProperty(t, "PLACEHOLDERS_FLIPPED_ALIAS", {
                enumerable: true,
                get: function() {
                    return s.PLACEHOLDERS_FLIPPED_ALIAS;
                }
            });
            t.TYPES = void 0;
            Object.defineProperty(t, "VISITOR_KEYS", {
                enumerable: true,
                get: function() {
                    return n.VISITOR_KEYS;
                }
            });
            r(485);
            r(6769);
            r(4985);
            r(3482);
            r(4414);
            r(2273);
            var n = r(6624);
            var s = r(771);
            var i = r(6738);
            Object.keys(i.DEPRECATED_ALIASES).forEach((e1)=>{
                n.FLIPPED_ALIAS_KEYS[e1] = n.FLIPPED_ALIAS_KEYS[i.DEPRECATED_ALIASES[e1]];
            });
            for (const { types: e1, set: t } of n.allExpandedTypes){
                for (const r of e1){
                    const e1 = n.FLIPPED_ALIAS_KEYS[r];
                    if (e1) {
                        e1.forEach(t.add, t);
                    } else {
                        t.add(r);
                    }
                }
            }
            const a = t.TYPES = [].concat(Object.keys(n.VISITOR_KEYS), Object.keys(n.FLIPPED_ALIAS_KEYS), Object.keys(n.DEPRECATED_KEYS));
        },
        4985: (e1, t, r)=>{
            "use strict";
            var n = r(6624);
            const s = (0, n.defineAliasedType)("JSX");
            s("JSXAttribute", {
                visitor: [
                    "name",
                    "value"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                    },
                    value: {
                        optional: true,
                        validate: (0, n.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                    }
                }
            });
            s("JSXClosingElement", {
                visitor: [
                    "name"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                    }
                }
            });
            s("JSXElement", {
                builder: [
                    "openingElement",
                    "closingElement",
                    "children",
                    "selfClosing"
                ],
                visitor: [
                    "openingElement",
                    "children",
                    "closingElement"
                ],
                aliases: [
                    "Immutable",
                    "Expression"
                ],
                fields: Object.assign({
                    openingElement: {
                        validate: (0, n.assertNodeType)("JSXOpeningElement")
                    },
                    closingElement: {
                        optional: true,
                        validate: (0, n.assertNodeType)("JSXClosingElement")
                    },
                    children: (0, n.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
                }, {
                    selfClosing: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    }
                })
            });
            s("JSXEmptyExpression", {});
            s("JSXExpressionContainer", {
                visitor: [
                    "expression"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression", "JSXEmptyExpression")
                    }
                }
            });
            s("JSXSpreadChild", {
                visitor: [
                    "expression"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            s("JSXIdentifier", {
                builder: [
                    "name"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertValueType)("string")
                    }
                }
            });
            s("JSXMemberExpression", {
                visitor: [
                    "object",
                    "property"
                ],
                fields: {
                    object: {
                        validate: (0, n.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                    },
                    property: {
                        validate: (0, n.assertNodeType)("JSXIdentifier")
                    }
                }
            });
            s("JSXNamespacedName", {
                visitor: [
                    "namespace",
                    "name"
                ],
                fields: {
                    namespace: {
                        validate: (0, n.assertNodeType)("JSXIdentifier")
                    },
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier")
                    }
                }
            });
            s("JSXOpeningElement", {
                builder: [
                    "name",
                    "attributes",
                    "selfClosing"
                ],
                visitor: [
                    "name",
                    "typeParameters",
                    "typeArguments",
                    "attributes"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: Object.assign({
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                    },
                    selfClosing: {
                        default: false
                    },
                    attributes: (0, n.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
                    typeArguments: {
                        validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
                        optional: true
                    }
                }, {
                    typeParameters: {
                        validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: true
                    }
                })
            });
            s("JSXSpreadAttribute", {
                visitor: [
                    "argument"
                ],
                fields: {
                    argument: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            s("JSXText", {
                aliases: [
                    "Immutable"
                ],
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, n.assertValueType)("string")
                    }
                }
            });
            s("JSXFragment", {
                builder: [
                    "openingFragment",
                    "closingFragment",
                    "children"
                ],
                visitor: [
                    "openingFragment",
                    "children",
                    "closingFragment"
                ],
                aliases: [
                    "Immutable",
                    "Expression"
                ],
                fields: {
                    openingFragment: {
                        validate: (0, n.assertNodeType)("JSXOpeningFragment")
                    },
                    closingFragment: {
                        validate: (0, n.assertNodeType)("JSXClosingFragment")
                    },
                    children: (0, n.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
                }
            });
            s("JSXOpeningFragment", {
                aliases: [
                    "Immutable"
                ]
            });
            s("JSXClosingFragment", {
                aliases: [
                    "Immutable"
                ]
            });
        },
        3482: (e1, t, r)=>{
            "use strict";
            var n = r(6624);
            var s = r(771);
            var i = r(485);
            const a = (0, n.defineAliasedType)("Miscellaneous");
            {
                a("Noop", {
                    visitor: []
                });
            }
            a("Placeholder", {
                visitor: [],
                builder: [
                    "expectedNode",
                    "name"
                ],
                fields: Object.assign({
                    name: {
                        validate: (0, n.assertNodeType)("Identifier")
                    },
                    expectedNode: {
                        validate: (0, n.assertOneOf)(...s.PLACEHOLDERS)
                    }
                }, (0, i.patternLikeCommon)())
            });
            a("V8IntrinsicIdentifier", {
                builder: [
                    "name"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertValueType)("string")
                    }
                }
            });
        },
        771: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PLACEHOLDERS_FLIPPED_ALIAS = t.PLACEHOLDERS_ALIAS = t.PLACEHOLDERS = void 0;
            var n = r(6624);
            const s = t.PLACEHOLDERS = [
                "Identifier",
                "StringLiteral",
                "Expression",
                "Statement",
                "Declaration",
                "BlockStatement",
                "ClassBody",
                "Pattern"
            ];
            const i = t.PLACEHOLDERS_ALIAS = {
                Declaration: [
                    "Statement"
                ],
                Pattern: [
                    "PatternLike",
                    "LVal"
                ]
            };
            for (const e1 of s){
                const t = n.ALIAS_KEYS[e1];
                if (t != null && t.length) i[e1] = t;
            }
            const a = t.PLACEHOLDERS_FLIPPED_ALIAS = {};
            Object.keys(i).forEach((e1)=>{
                i[e1].forEach((t)=>{
                    if (!hasOwnProperty.call(a, t)) {
                        a[t] = [];
                    }
                    a[t].push(e1);
                });
            });
        },
        2273: (e1, t, r)=>{
            "use strict";
            var n = r(6624);
            var s = r(485);
            var i = r(7670);
            const a = (0, n.defineAliasedType)("TypeScript");
            const o = (0, n.assertValueType)("boolean");
            const tSFunctionTypeAnnotationCommon = ()=>({
                    returnType: {
                        validate: (0, n.assertNodeType)("TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, n.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    }
                });
            a("TSParameterProperty", {
                aliases: [
                    "LVal"
                ],
                visitor: [
                    "parameter"
                ],
                fields: {
                    accessibility: {
                        validate: (0, n.assertOneOf)("public", "private", "protected"),
                        optional: true
                    },
                    readonly: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    parameter: {
                        validate: (0, n.assertNodeType)("Identifier", "AssignmentPattern")
                    },
                    override: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, n.arrayOfType)("Decorator"),
                        optional: true
                    }
                }
            });
            a("TSDeclareFunction", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "params",
                    "returnType"
                ],
                fields: Object.assign({}, (0, s.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
            });
            a("TSDeclareMethod", {
                visitor: [
                    "decorators",
                    "key",
                    "typeParameters",
                    "params",
                    "returnType"
                ],
                fields: Object.assign({}, (0, s.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
            });
            a("TSQualifiedName", {
                aliases: [
                    "TSEntityName"
                ],
                visitor: [
                    "left",
                    "right"
                ],
                fields: {
                    left: (0, n.validateType)("TSEntityName"),
                    right: (0, n.validateType)("Identifier")
                }
            });
            const signatureDeclarationCommon = ()=>({
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"),
                    ["parameters"]: (0, n.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
                    ["typeAnnotation"]: (0, n.validateOptionalType)("TSTypeAnnotation")
                });
            const l = {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "typeParameters",
                    "parameters",
                    "typeAnnotation"
                ],
                fields: signatureDeclarationCommon()
            };
            a("TSCallSignatureDeclaration", l);
            a("TSConstructSignatureDeclaration", l);
            const namedTypeElementCommon = ()=>({
                    key: (0, n.validateType)("Expression"),
                    computed: {
                        default: false
                    },
                    optional: (0, n.validateOptional)(o)
                });
            a("TSPropertySignature", {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "key",
                    "typeAnnotation"
                ],
                fields: Object.assign({}, namedTypeElementCommon(), {
                    readonly: (0, n.validateOptional)(o),
                    typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"),
                    kind: {
                        optional: true,
                        validate: (0, n.assertOneOf)("get", "set")
                    }
                })
            });
            a("TSMethodSignature", {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "key",
                    "typeParameters",
                    "parameters",
                    "typeAnnotation"
                ],
                fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
                    kind: {
                        validate: (0, n.assertOneOf)("method", "get", "set")
                    }
                })
            });
            a("TSIndexSignature", {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "parameters",
                    "typeAnnotation"
                ],
                fields: {
                    readonly: (0, n.validateOptional)(o),
                    static: (0, n.validateOptional)(o),
                    parameters: (0, n.validateArrayOfType)("Identifier"),
                    typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation")
                }
            });
            const c = [
                "TSAnyKeyword",
                "TSBooleanKeyword",
                "TSBigIntKeyword",
                "TSIntrinsicKeyword",
                "TSNeverKeyword",
                "TSNullKeyword",
                "TSNumberKeyword",
                "TSObjectKeyword",
                "TSStringKeyword",
                "TSSymbolKeyword",
                "TSUndefinedKeyword",
                "TSUnknownKeyword",
                "TSVoidKeyword"
            ];
            for (const e1 of c){
                a(e1, {
                    aliases: [
                        "TSType",
                        "TSBaseType"
                    ],
                    visitor: [],
                    fields: {}
                });
            }
            a("TSThisType", {
                aliases: [
                    "TSType",
                    "TSBaseType"
                ],
                visitor: [],
                fields: {}
            });
            const p = {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeParameters",
                    "parameters",
                    "typeAnnotation"
                ]
            };
            a("TSFunctionType", Object.assign({}, p, {
                fields: signatureDeclarationCommon()
            }));
            a("TSConstructorType", Object.assign({}, p, {
                fields: Object.assign({}, signatureDeclarationCommon(), {
                    abstract: (0, n.validateOptional)(o)
                })
            }));
            a("TSTypeReference", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeName",
                    "typeParameters"
                ],
                fields: {
                    typeName: (0, n.validateType)("TSEntityName"),
                    ["typeParameters"]: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            a("TSTypePredicate", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "parameterName",
                    "typeAnnotation"
                ],
                builder: [
                    "parameterName",
                    "typeAnnotation",
                    "asserts"
                ],
                fields: {
                    parameterName: (0, n.validateType)("Identifier", "TSThisType"),
                    typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"),
                    asserts: (0, n.validateOptional)(o)
                }
            });
            a("TSTypeQuery", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "exprName",
                    "typeParameters"
                ],
                fields: {
                    exprName: (0, n.validateType)("TSEntityName", "TSImportType"),
                    ["typeParameters"]: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            a("TSTypeLiteral", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    members: (0, n.validateArrayOfType)("TSTypeElement")
                }
            });
            a("TSArrayType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "elementType"
                ],
                fields: {
                    elementType: (0, n.validateType)("TSType")
                }
            });
            a("TSTupleType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "elementTypes"
                ],
                fields: {
                    elementTypes: (0, n.validateArrayOfType)("TSType", "TSNamedTupleMember")
                }
            });
            a("TSOptionalType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSRestType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSNamedTupleMember", {
                visitor: [
                    "label",
                    "elementType"
                ],
                builder: [
                    "label",
                    "elementType",
                    "optional"
                ],
                fields: {
                    label: (0, n.validateType)("Identifier"),
                    optional: {
                        validate: o,
                        default: false
                    },
                    elementType: (0, n.validateType)("TSType")
                }
            });
            const u = {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "types"
                ],
                fields: {
                    types: (0, n.validateArrayOfType)("TSType")
                }
            };
            a("TSUnionType", u);
            a("TSIntersectionType", u);
            a("TSConditionalType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "checkType",
                    "extendsType",
                    "trueType",
                    "falseType"
                ],
                fields: {
                    checkType: (0, n.validateType)("TSType"),
                    extendsType: (0, n.validateType)("TSType"),
                    trueType: (0, n.validateType)("TSType"),
                    falseType: (0, n.validateType)("TSType")
                }
            });
            a("TSInferType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeParameter"
                ],
                fields: {
                    typeParameter: (0, n.validateType)("TSTypeParameter")
                }
            });
            a("TSParenthesizedType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSTypeOperator", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    operator: (0, n.validate)((0, n.assertValueType)("string")),
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSIndexedAccessType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "objectType",
                    "indexType"
                ],
                fields: {
                    objectType: (0, n.validateType)("TSType"),
                    indexType: (0, n.validateType)("TSType")
                }
            });
            a("TSMappedType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeParameter",
                    "nameType",
                    "typeAnnotation"
                ],
                builder: [
                    "typeParameter",
                    "typeAnnotation",
                    "nameType"
                ],
                fields: Object.assign({}, {
                    typeParameter: (0, n.validateType)("TSTypeParameter")
                }, {
                    readonly: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")),
                    optional: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")),
                    typeAnnotation: (0, n.validateOptionalType)("TSType"),
                    nameType: (0, n.validateOptionalType)("TSType")
                })
            });
            a("TSTemplateLiteralType", {
                aliases: [
                    "TSType",
                    "TSBaseType"
                ],
                visitor: [
                    "quasis",
                    "types"
                ],
                fields: {
                    quasis: (0, n.validateArrayOfType)("TemplateElement"),
                    types: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSType")), function(e1, t, r) {
                            if (e1.quasis.length !== r.length + 1) {
                                throw new TypeError("Number of ".concat(e1.type, " quasis should be exactly one more than the number of types.\nExpected ").concat(r.length + 1, " quasis but got ").concat(e1.quasis.length));
                            }
                        })
                    }
                }
            });
            a("TSLiteralType", {
                aliases: [
                    "TSType",
                    "TSBaseType"
                ],
                visitor: [
                    "literal"
                ],
                fields: {
                    literal: {
                        validate: function() {
                            const e1 = (0, n.assertNodeType)("NumericLiteral", "BigIntLiteral");
                            const t = (0, n.assertOneOf)("-");
                            const r = (0, n.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
                            function validator(n, s, a) {
                                if ((0, i.default)("UnaryExpression", a)) {
                                    t(a, "operator", a.operator);
                                    e1(a, "argument", a.argument);
                                } else {
                                    r(n, s, a);
                                }
                            }
                            validator.oneOfNodeTypes = [
                                "NumericLiteral",
                                "StringLiteral",
                                "BooleanLiteral",
                                "BigIntLiteral",
                                "TemplateLiteral",
                                "UnaryExpression"
                            ];
                            return validator;
                        }()
                    }
                }
            });
            {
                a("TSExpressionWithTypeArguments", {
                    aliases: [
                        "TSType"
                    ],
                    visitor: [
                        "expression",
                        "typeParameters"
                    ],
                    fields: {
                        expression: (0, n.validateType)("TSEntityName"),
                        typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                    }
                });
            }
            a("TSInterfaceDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "extends",
                    "body"
                ],
                fields: {
                    declare: (0, n.validateOptional)(o),
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"),
                    extends: (0, n.validateOptional)((0, n.arrayOfType)("TSExpressionWithTypeArguments")),
                    body: (0, n.validateType)("TSInterfaceBody")
                }
            });
            a("TSInterfaceBody", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: (0, n.validateArrayOfType)("TSTypeElement")
                }
            });
            a("TSTypeAliasDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "typeAnnotation"
                ],
                fields: {
                    declare: (0, n.validateOptional)(o),
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"),
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSInstantiationExpression", {
                aliases: [
                    "Expression"
                ],
                visitor: [
                    "expression",
                    "typeParameters"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression"),
                    ["typeParameters"]: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            const d = {
                aliases: [
                    "Expression",
                    "LVal",
                    "PatternLike"
                ],
                visitor: [
                    "expression",
                    "typeAnnotation"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression"),
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            };
            a("TSAsExpression", d);
            a("TSSatisfiesExpression", d);
            a("TSTypeAssertion", {
                aliases: [
                    "Expression",
                    "LVal",
                    "PatternLike"
                ],
                visitor: [
                    "typeAnnotation",
                    "expression"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType"),
                    expression: (0, n.validateType)("Expression")
                }
            });
            a("TSEnumBody", {
                visitor: [
                    "members"
                ],
                fields: {
                    members: (0, n.validateArrayOfType)("TSEnumMember")
                }
            });
            {
                a("TSEnumDeclaration", {
                    aliases: [
                        "Statement",
                        "Declaration"
                    ],
                    visitor: [
                        "id",
                        "members"
                    ],
                    fields: {
                        declare: (0, n.validateOptional)(o),
                        const: (0, n.validateOptional)(o),
                        id: (0, n.validateType)("Identifier"),
                        members: (0, n.validateArrayOfType)("TSEnumMember"),
                        initializer: (0, n.validateOptionalType)("Expression"),
                        body: (0, n.validateOptionalType)("TSEnumBody")
                    }
                });
            }
            a("TSEnumMember", {
                visitor: [
                    "id",
                    "initializer"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier", "StringLiteral"),
                    initializer: (0, n.validateOptionalType)("Expression")
                }
            });
            a("TSModuleDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "body"
                ],
                fields: Object.assign({
                    kind: {
                        validate: (0, n.assertOneOf)("global", "module", "namespace")
                    },
                    declare: (0, n.validateOptional)(o)
                }, {
                    global: (0, n.validateOptional)(o)
                }, {
                    id: (0, n.validateType)("Identifier", "StringLiteral"),
                    body: (0, n.validateType)("TSModuleBlock", "TSModuleDeclaration")
                })
            });
            a("TSModuleBlock", {
                aliases: [
                    "Scopable",
                    "Block",
                    "BlockParent",
                    "FunctionParent"
                ],
                visitor: [
                    "body"
                ],
                fields: {
                    body: (0, n.validateArrayOfType)("Statement")
                }
            });
            a("TSImportType", {
                aliases: [
                    "TSType"
                ],
                builder: [
                    "argument",
                    "qualifier",
                    "typeParameters"
                ],
                visitor: [
                    "argument",
                    "options",
                    "qualifier",
                    "typeParameters"
                ],
                fields: {
                    argument: (0, n.validateType)("StringLiteral"),
                    qualifier: (0, n.validateOptionalType)("TSEntityName"),
                    ["typeParameters"]: (0, n.validateOptionalType)("TSTypeParameterInstantiation"),
                    options: {
                        validate: (0, n.assertNodeType)("Expression"),
                        optional: true
                    }
                }
            });
            a("TSImportEqualsDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "moduleReference"
                ],
                fields: Object.assign({}, {
                    isExport: (0, n.validate)(o)
                }, {
                    id: (0, n.validateType)("Identifier"),
                    moduleReference: (0, n.validateType)("TSEntityName", "TSExternalModuleReference"),
                    importKind: {
                        validate: (0, n.assertOneOf)("type", "value"),
                        optional: true
                    }
                })
            });
            a("TSExternalModuleReference", {
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: (0, n.validateType)("StringLiteral")
                }
            });
            a("TSNonNullExpression", {
                aliases: [
                    "Expression",
                    "LVal",
                    "PatternLike"
                ],
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression")
                }
            });
            a("TSExportAssignment", {
                aliases: [
                    "Statement"
                ],
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression")
                }
            });
            a("TSNamespaceExportDeclaration", {
                aliases: [
                    "Statement"
                ],
                visitor: [
                    "id"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier")
                }
            });
            a("TSTypeAnnotation", {
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: {
                        validate: (0, n.assertNodeType)("TSType")
                    }
                }
            });
            a("TSTypeParameterInstantiation", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: (0, n.validateArrayOfType)("TSType")
                }
            });
            a("TSTypeParameterDeclaration", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: (0, n.validateArrayOfType)("TSTypeParameter")
                }
            });
            a("TSTypeParameter", {
                builder: [
                    "constraint",
                    "default",
                    "name"
                ],
                visitor: [
                    "constraint",
                    "default"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertValueType)("string")
                    },
                    in: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    out: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    const: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    constraint: {
                        validate: (0, n.assertNodeType)("TSType"),
                        optional: true
                    },
                    default: {
                        validate: (0, n.assertNodeType)("TSType"),
                        optional: true
                    }
                }
            });
        },
        6624: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.allExpandedTypes = t.VISITOR_KEYS = t.NODE_PARENT_VALIDATIONS = t.NODE_FIELDS = t.FLIPPED_ALIAS_KEYS = t.DEPRECATED_KEYS = t.BUILDER_KEYS = t.ALIAS_KEYS = void 0;
            t.arrayOf = arrayOf;
            t.arrayOfType = arrayOfType;
            t.assertEach = assertEach;
            t.assertNodeOrValueType = assertNodeOrValueType;
            t.assertNodeType = assertNodeType;
            t.assertOneOf = assertOneOf;
            t.assertOptionalChainStart = assertOptionalChainStart;
            t.assertShape = assertShape;
            t.assertValueType = assertValueType;
            t.chain = chain;
            t["default"] = defineType;
            t.defineAliasedType = defineAliasedType;
            t.validate = validate;
            t.validateArrayOfType = validateArrayOfType;
            t.validateOptional = validateOptional;
            t.validateOptionalType = validateOptionalType;
            t.validateType = validateType;
            var n = r(7670);
            var s = r(8966);
            const i = t.VISITOR_KEYS = {};
            const a = t.ALIAS_KEYS = {};
            const o = t.FLIPPED_ALIAS_KEYS = {};
            const l = t.NODE_FIELDS = {};
            const c = t.BUILDER_KEYS = {};
            const p = t.DEPRECATED_KEYS = {};
            const u = t.NODE_PARENT_VALIDATIONS = {};
            function getType(e1) {
                if (Array.isArray(e1)) {
                    return "array";
                } else if (e1 === null) {
                    return "null";
                } else {
                    return typeof e1;
                }
            }
            function validate(e1) {
                return {
                    validate: e1
                };
            }
            function validateType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return validate(assertNodeType(...e1));
            }
            function validateOptional(e1) {
                return {
                    validate: e1,
                    optional: true
                };
            }
            function validateOptionalType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return {
                    validate: assertNodeType(...e1),
                    optional: true
                };
            }
            function arrayOf(e1) {
                return chain(assertValueType("array"), assertEach(e1));
            }
            function arrayOfType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return arrayOf(assertNodeType(...e1));
            }
            function validateArrayOfType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return validate(arrayOfType(...e1));
            }
            function assertEach(e1) {
                const t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING ? s.validateChild : ()=>{};
                function validator(r, n, s) {
                    if (!Array.isArray(s)) return;
                    let i = 0;
                    const a = {
                        toString () {
                            return "".concat(n, "[").concat(i, "]");
                        }
                    };
                    for(; i < s.length; i++){
                        const n = s[i];
                        e1(r, a, n);
                        t(r, a, n);
                    }
                }
                validator.each = e1;
                return validator;
            }
            function assertOneOf() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                function validate(t, r, n) {
                    if (!e1.includes(n)) {
                        throw new TypeError("Property ".concat(r, " expected value to be one of ").concat(JSON.stringify(e1), " but got ").concat(JSON.stringify(n)));
                    }
                }
                validate.oneOf = e1;
                return validate;
            }
            const d = t.allExpandedTypes = [];
            function assertNodeType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                const t = new Set;
                d.push({
                    types: e1,
                    set: t
                });
                function validate(r, i, a) {
                    const o = a == null ? void 0 : a.type;
                    if (o != null) {
                        if (t.has(o)) {
                            (0, s.validateChild)(r, i, a);
                            return;
                        }
                        if (o === "Placeholder") {
                            for (const t of e1){
                                if ((0, n.default)(t, a)) {
                                    (0, s.validateChild)(r, i, a);
                                    return;
                                }
                            }
                        }
                    }
                    throw new TypeError("Property ".concat(i, " of ").concat(r.type, " expected node to be of a type ").concat(JSON.stringify(e1), " but instead got ").concat(JSON.stringify(o)));
                }
                validate.oneOfNodeTypes = e1;
                return validate;
            }
            function assertNodeOrValueType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                function validate(t, r, i) {
                    const a = getType(i);
                    for (const o of e1){
                        if (a === o || (0, n.default)(o, i)) {
                            (0, s.validateChild)(t, r, i);
                            return;
                        }
                    }
                    throw new TypeError("Property ".concat(r, " of ").concat(t.type, " expected node to be of a type ").concat(JSON.stringify(e1), " but instead got ").concat(JSON.stringify(i == null ? void 0 : i.type)));
                }
                validate.oneOfNodeOrValueTypes = e1;
                return validate;
            }
            function assertValueType(e1) {
                function validate(t, r, n) {
                    if (getType(n) === e1) {
                        return;
                    }
                    throw new TypeError("Property ".concat(r, " expected type of ").concat(e1, " but got ").concat(getType(n)));
                }
                validate.type = e1;
                return validate;
            }
            function assertShape(e1) {
                const t = Object.keys(e1);
                function validate(r, n, i) {
                    const a = [];
                    for (const n of t){
                        try {
                            (0, s.validateField)(r, n, i[n], e1[n]);
                        } catch (e1) {
                            if (e1 instanceof TypeError) {
                                a.push(e1.message);
                                continue;
                            }
                            throw e1;
                        }
                    }
                    if (a.length) {
                        throw new TypeError("Property ".concat(n, " of ").concat(r.type, " expected to have the following:\n").concat(a.join("\n")));
                    }
                }
                validate.shapeOf = e1;
                return validate;
            }
            function assertOptionalChainStart() {
                function validate(e1) {
                    var t;
                    let r = e1;
                    while(e1){
                        const { type: e1 } = r;
                        if (e1 === "OptionalCallExpression") {
                            if (r.optional) return;
                            r = r.callee;
                            continue;
                        }
                        if (e1 === "OptionalMemberExpression") {
                            if (r.optional) return;
                            r = r.object;
                            continue;
                        }
                        break;
                    }
                    throw new TypeError("Non-optional ".concat(e1.type, " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ").concat((t = r) == null ? void 0 : t.type));
                }
                return validate;
            }
            function chain() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                function validate() {
                    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
                        t[_key] = arguments[_key];
                    }
                    for (const r of e1){
                        r(...t);
                    }
                }
                validate.chainOf = e1;
                if (e1.length >= 2 && "type" in e1[0] && e1[0].type === "array" && !("each" in e1[1])) {
                    throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
                }
                return validate;
            }
            const f = new Set([
                "aliases",
                "builder",
                "deprecatedAlias",
                "fields",
                "inherits",
                "visitor",
                "validate"
            ]);
            const h = new Set([
                "default",
                "optional",
                "deprecated",
                "validate"
            ]);
            const m = {};
            function defineAliasedType() {
                for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){
                    e1[_key] = arguments[_key];
                }
                return function(t) {
                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    let n = r.aliases;
                    if (!n) {
                        var s;
                        if (r.inherits) n = (s = m[r.inherits].aliases) == null ? void 0 : s.slice();
                        n != null ? n : n = [];
                        r.aliases = n;
                    }
                    const i = e1.filter((e1)=>!n.includes(e1));
                    n.unshift(...i);
                    defineType(t, r);
                };
            }
            function defineType(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const r = t.inherits && m[t.inherits] || {};
                let n = t.fields;
                if (!n) {
                    n = {};
                    if (r.fields) {
                        const e1 = Object.getOwnPropertyNames(r.fields);
                        for (const t of e1){
                            const e1 = r.fields[t];
                            const s = e1.default;
                            if (Array.isArray(s) ? s.length > 0 : s && typeof s === "object") {
                                throw new Error("field defaults can only be primitives or empty arrays currently");
                            }
                            n[t] = {
                                default: Array.isArray(s) ? [] : s,
                                optional: e1.optional,
                                deprecated: e1.deprecated,
                                validate: e1.validate
                            };
                        }
                    }
                }
                const s = t.visitor || r.visitor || [];
                const d = t.aliases || r.aliases || [];
                const y = t.builder || r.builder || t.visitor || [];
                for (const r of Object.keys(t)){
                    if (!f.has(r)) {
                        throw new Error('Unknown type option "'.concat(r, '" on ').concat(e1));
                    }
                }
                if (t.deprecatedAlias) {
                    p[t.deprecatedAlias] = e1;
                }
                for (const e1 of s.concat(y)){
                    n[e1] = n[e1] || {};
                }
                for (const t of Object.keys(n)){
                    const r = n[t];
                    if (r.default !== undefined && !y.includes(t)) {
                        r.optional = true;
                    }
                    if (r.default === undefined) {
                        r.default = null;
                    } else if (!r.validate && r.default != null) {
                        r.validate = assertValueType(getType(r.default));
                    }
                    for (const n of Object.keys(r)){
                        if (!h.has(n)) {
                            throw new Error('Unknown field key "'.concat(n, '" on ').concat(e1, ".").concat(t));
                        }
                    }
                }
                i[e1] = t.visitor = s;
                c[e1] = t.builder = y;
                l[e1] = t.fields = n;
                a[e1] = t.aliases = d;
                d.forEach((t)=>{
                    o[t] = o[t] || [];
                    o[t].push(e1);
                });
                if (t.validate) {
                    u[e1] = t.validate;
                }
                m[e1] = t;
            }
        },
        3061: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = {
                react: true,
                assertNode: true,
                createTypeAnnotationBasedOnTypeof: true,
                createUnionTypeAnnotation: true,
                createFlowUnionType: true,
                createTSUnionType: true,
                cloneNode: true,
                clone: true,
                cloneDeep: true,
                cloneDeepWithoutLoc: true,
                cloneWithoutLoc: true,
                addComment: true,
                addComments: true,
                inheritInnerComments: true,
                inheritLeadingComments: true,
                inheritsComments: true,
                inheritTrailingComments: true,
                removeComments: true,
                ensureBlock: true,
                toBindingIdentifierName: true,
                toBlock: true,
                toComputedKey: true,
                toExpression: true,
                toIdentifier: true,
                toKeyAlias: true,
                toStatement: true,
                valueToNode: true,
                appendToMemberExpression: true,
                inherits: true,
                prependToMemberExpression: true,
                removeProperties: true,
                removePropertiesDeep: true,
                removeTypeDuplicates: true,
                getAssignmentIdentifiers: true,
                getBindingIdentifiers: true,
                getOuterBindingIdentifiers: true,
                getFunctionName: true,
                traverse: true,
                traverseFast: true,
                shallowEqual: true,
                is: true,
                isBinding: true,
                isBlockScoped: true,
                isImmutable: true,
                isLet: true,
                isNode: true,
                isNodesEquivalent: true,
                isPlaceholderType: true,
                isReferenced: true,
                isScope: true,
                isSpecifierDefault: true,
                isType: true,
                isValidES3Identifier: true,
                isValidIdentifier: true,
                isVar: true,
                matchesPattern: true,
                validate: true,
                buildMatchMemberExpression: true,
                __internal__deprecationWarning: true
            };
            Object.defineProperty(t, "__internal__deprecationWarning", {
                enumerable: true,
                get: function() {
                    return ye.default;
                }
            });
            Object.defineProperty(t, "addComment", {
                enumerable: true,
                get: function() {
                    return T.default;
                }
            });
            Object.defineProperty(t, "addComments", {
                enumerable: true,
                get: function() {
                    return S.default;
                }
            });
            Object.defineProperty(t, "appendToMemberExpression", {
                enumerable: true,
                get: function() {
                    return B.default;
                }
            });
            Object.defineProperty(t, "assertNode", {
                enumerable: true,
                get: function() {
                    return o.default;
                }
            });
            Object.defineProperty(t, "buildMatchMemberExpression", {
                enumerable: true,
                get: function() {
                    return he.default;
                }
            });
            Object.defineProperty(t, "clone", {
                enumerable: true,
                get: function() {
                    return m.default;
                }
            });
            Object.defineProperty(t, "cloneDeep", {
                enumerable: true,
                get: function() {
                    return y.default;
                }
            });
            Object.defineProperty(t, "cloneDeepWithoutLoc", {
                enumerable: true,
                get: function() {
                    return g.default;
                }
            });
            Object.defineProperty(t, "cloneNode", {
                enumerable: true,
                get: function() {
                    return h.default;
                }
            });
            Object.defineProperty(t, "cloneWithoutLoc", {
                enumerable: true,
                get: function() {
                    return b.default;
                }
            });
            Object.defineProperty(t, "createFlowUnionType", {
                enumerable: true,
                get: function() {
                    return p.default;
                }
            });
            Object.defineProperty(t, "createTSUnionType", {
                enumerable: true,
                get: function() {
                    return u.default;
                }
            });
            Object.defineProperty(t, "createTypeAnnotationBasedOnTypeof", {
                enumerable: true,
                get: function() {
                    return c.default;
                }
            });
            Object.defineProperty(t, "createUnionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return p.default;
                }
            });
            Object.defineProperty(t, "ensureBlock", {
                enumerable: true,
                get: function() {
                    return C.default;
                }
            });
            Object.defineProperty(t, "getAssignmentIdentifiers", {
                enumerable: true,
                get: function() {
                    return $.default;
                }
            });
            Object.defineProperty(t, "getBindingIdentifiers", {
                enumerable: true,
                get: function() {
                    return q.default;
                }
            });
            Object.defineProperty(t, "getFunctionName", {
                enumerable: true,
                get: function() {
                    return G.default;
                }
            });
            Object.defineProperty(t, "getOuterBindingIdentifiers", {
                enumerable: true,
                get: function() {
                    return H.default;
                }
            });
            Object.defineProperty(t, "inheritInnerComments", {
                enumerable: true,
                get: function() {
                    return x.default;
                }
            });
            Object.defineProperty(t, "inheritLeadingComments", {
                enumerable: true,
                get: function() {
                    return E.default;
                }
            });
            Object.defineProperty(t, "inheritTrailingComments", {
                enumerable: true,
                get: function() {
                    return v.default;
                }
            });
            Object.defineProperty(t, "inherits", {
                enumerable: true,
                get: function() {
                    return R.default;
                }
            });
            Object.defineProperty(t, "inheritsComments", {
                enumerable: true,
                get: function() {
                    return P.default;
                }
            });
            Object.defineProperty(t, "is", {
                enumerable: true,
                get: function() {
                    return Y.default;
                }
            });
            Object.defineProperty(t, "isBinding", {
                enumerable: true,
                get: function() {
                    return Q.default;
                }
            });
            Object.defineProperty(t, "isBlockScoped", {
                enumerable: true,
                get: function() {
                    return Z.default;
                }
            });
            Object.defineProperty(t, "isImmutable", {
                enumerable: true,
                get: function() {
                    return ee.default;
                }
            });
            Object.defineProperty(t, "isLet", {
                enumerable: true,
                get: function() {
                    return te.default;
                }
            });
            Object.defineProperty(t, "isNode", {
                enumerable: true,
                get: function() {
                    return re.default;
                }
            });
            Object.defineProperty(t, "isNodesEquivalent", {
                enumerable: true,
                get: function() {
                    return ne.default;
                }
            });
            Object.defineProperty(t, "isPlaceholderType", {
                enumerable: true,
                get: function() {
                    return se.default;
                }
            });
            Object.defineProperty(t, "isReferenced", {
                enumerable: true,
                get: function() {
                    return ie.default;
                }
            });
            Object.defineProperty(t, "isScope", {
                enumerable: true,
                get: function() {
                    return ae.default;
                }
            });
            Object.defineProperty(t, "isSpecifierDefault", {
                enumerable: true,
                get: function() {
                    return oe.default;
                }
            });
            Object.defineProperty(t, "isType", {
                enumerable: true,
                get: function() {
                    return le.default;
                }
            });
            Object.defineProperty(t, "isValidES3Identifier", {
                enumerable: true,
                get: function() {
                    return ce.default;
                }
            });
            Object.defineProperty(t, "isValidIdentifier", {
                enumerable: true,
                get: function() {
                    return pe.default;
                }
            });
            Object.defineProperty(t, "isVar", {
                enumerable: true,
                get: function() {
                    return ue.default;
                }
            });
            Object.defineProperty(t, "matchesPattern", {
                enumerable: true,
                get: function() {
                    return de.default;
                }
            });
            Object.defineProperty(t, "prependToMemberExpression", {
                enumerable: true,
                get: function() {
                    return U.default;
                }
            });
            t.react = void 0;
            Object.defineProperty(t, "removeComments", {
                enumerable: true,
                get: function() {
                    return A.default;
                }
            });
            Object.defineProperty(t, "removeProperties", {
                enumerable: true,
                get: function() {
                    return K.default;
                }
            });
            Object.defineProperty(t, "removePropertiesDeep", {
                enumerable: true,
                get: function() {
                    return V.default;
                }
            });
            Object.defineProperty(t, "removeTypeDuplicates", {
                enumerable: true,
                get: function() {
                    return W.default;
                }
            });
            Object.defineProperty(t, "shallowEqual", {
                enumerable: true,
                get: function() {
                    return X.default;
                }
            });
            Object.defineProperty(t, "toBindingIdentifierName", {
                enumerable: true,
                get: function() {
                    return O.default;
                }
            });
            Object.defineProperty(t, "toBlock", {
                enumerable: true,
                get: function() {
                    return N.default;
                }
            });
            Object.defineProperty(t, "toComputedKey", {
                enumerable: true,
                get: function() {
                    return k.default;
                }
            });
            Object.defineProperty(t, "toExpression", {
                enumerable: true,
                get: function() {
                    return _.default;
                }
            });
            Object.defineProperty(t, "toIdentifier", {
                enumerable: true,
                get: function() {
                    return D.default;
                }
            });
            Object.defineProperty(t, "toKeyAlias", {
                enumerable: true,
                get: function() {
                    return M.default;
                }
            });
            Object.defineProperty(t, "toStatement", {
                enumerable: true,
                get: function() {
                    return L.default;
                }
            });
            Object.defineProperty(t, "traverse", {
                enumerable: true,
                get: function() {
                    return J.default;
                }
            });
            Object.defineProperty(t, "traverseFast", {
                enumerable: true,
                get: function() {
                    return z.default;
                }
            });
            Object.defineProperty(t, "validate", {
                enumerable: true,
                get: function() {
                    return fe.default;
                }
            });
            Object.defineProperty(t, "valueToNode", {
                enumerable: true,
                get: function() {
                    return j.default;
                }
            });
            var s = r(9651);
            var i = r(339);
            var a = r(1323);
            var o = r(2856);
            var l = r(1501);
            Object.keys(l).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === l[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return l[e1];
                    }
                });
            });
            var c = r(1655);
            var p = r(5164);
            var u = r(1258);
            var d = r(3396);
            Object.keys(d).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === d[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return d[e1];
                    }
                });
            });
            var f = r(4755);
            Object.keys(f).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === f[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return f[e1];
                    }
                });
            });
            var h = r(363);
            var m = r(8329);
            var y = r(8637);
            var g = r(7684);
            var b = r(9410);
            var T = r(5185);
            var S = r(9039);
            var x = r(3041);
            var E = r(5151);
            var P = r(5060);
            var v = r(8538);
            var A = r(170);
            var w = r(4766);
            Object.keys(w).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === w[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return w[e1];
                    }
                });
            });
            var I = r(1164);
            Object.keys(I).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === I[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return I[e1];
                    }
                });
            });
            var C = r(7234);
            var O = r(1350);
            var N = r(3670);
            var k = r(5847);
            var _ = r(4811);
            var D = r(1334);
            var M = r(1480);
            var L = r(1035);
            var j = r(5222);
            var F = r(6767);
            Object.keys(F).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === F[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return F[e1];
                    }
                });
            });
            var B = r(2246);
            var R = r(2774);
            var U = r(6254);
            var K = r(4370);
            var V = r(9437);
            var W = r(1078);
            var $ = r(3573);
            var q = r(6306);
            var H = r(6128);
            var G = r(6626);
            var J = r(6348);
            Object.keys(J).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === J[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return J[e1];
                    }
                });
            });
            var z = r(4865);
            var X = r(1119);
            var Y = r(7670);
            var Q = r(5195);
            var Z = r(3652);
            var ee = r(8597);
            var te = r(9626);
            var re = r(6087);
            var ne = r(8486);
            var se = r(8557);
            var ie = r(5028);
            var ae = r(1559);
            var oe = r(8445);
            var le = r(8388);
            var ce = r(3502);
            var pe = r(2892);
            var ue = r(7581);
            var de = r(3447);
            var fe = r(8966);
            var he = r(7723);
            var me = r(46);
            Object.keys(me).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === me[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return me[e1];
                    }
                });
            });
            var ye = r(8760);
            var ge = r(4136);
            const be = t.react = {
                isReactComponent: s.default,
                isCompatTag: i.default,
                buildChildren: a.default
            };
            {
                t.toSequenceExpression = ge.default;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.BABEL_TYPES_8_BREAKING) {
                console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
            }
        },
        2246: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = appendToMemberExpression;
            var n = r(4755);
            function appendToMemberExpression(e1, t) {
                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                e1.object = (0, n.memberExpression)(e1.object, e1.property, e1.computed);
                e1.property = t;
                e1.computed = !!r;
                return e1;
            }
        },
        1078: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeTypeDuplicates;
            var n = r(46);
            function getQualifiedName(e1) {
                return (0, n.isIdentifier)(e1) ? e1.name : "".concat(e1.id.name, ".").concat(getQualifiedName(e1.qualification));
            }
            function removeTypeDuplicates(e1) {
                const t = Array.from(e1);
                const r = new Map;
                const s = new Map;
                const i = new Set;
                const a = [];
                for(let e1 = 0; e1 < t.length; e1++){
                    const o = t[e1];
                    if (!o) continue;
                    if (a.includes(o)) {
                        continue;
                    }
                    if ((0, n.isAnyTypeAnnotation)(o)) {
                        return [
                            o
                        ];
                    }
                    if ((0, n.isFlowBaseAnnotation)(o)) {
                        s.set(o.type, o);
                        continue;
                    }
                    if ((0, n.isUnionTypeAnnotation)(o)) {
                        if (!i.has(o.types)) {
                            t.push(...o.types);
                            i.add(o.types);
                        }
                        continue;
                    }
                    if ((0, n.isGenericTypeAnnotation)(o)) {
                        const e1 = getQualifiedName(o.id);
                        if (r.has(e1)) {
                            let t = r.get(e1);
                            if (t.typeParameters) {
                                if (o.typeParameters) {
                                    t.typeParameters.params.push(...o.typeParameters.params);
                                    t.typeParameters.params = removeTypeDuplicates(t.typeParameters.params);
                                }
                            } else {
                                t = o.typeParameters;
                            }
                        } else {
                            r.set(e1, o);
                        }
                        continue;
                    }
                    a.push(o);
                }
                for (const [, e1] of s){
                    a.push(e1);
                }
                for (const [, e1] of r){
                    a.push(e1);
                }
                return a;
            }
        },
        2774: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inherits;
            var n = r(1164);
            var s = r(5060);
            function inherits(e1, t) {
                if (!e1 || !t) return e1;
                for (const r of n.INHERIT_KEYS.optional){
                    if (e1[r] == null) {
                        e1[r] = t[r];
                    }
                }
                for (const r of Object.keys(t)){
                    if (r[0] === "_" && r !== "__clone") {
                        e1[r] = t[r];
                    }
                }
                for (const r of n.INHERIT_KEYS.force){
                    e1[r] = t[r];
                }
                (0, s.default)(e1, t);
                return e1;
            }
        },
        6254: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = prependToMemberExpression;
            var n = r(4755);
            var s = r(3061);
            function prependToMemberExpression(e1, t) {
                if ((0, s.isSuper)(e1.object)) {
                    throw new Error("Cannot prepend node to super property access (`super.foo`).");
                }
                e1.object = (0, n.memberExpression)(t, e1.object);
                return e1;
            }
        },
        4370: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeProperties;
            var n = r(1164);
            const s = [
                "tokens",
                "start",
                "end",
                "loc",
                "raw",
                "rawValue"
            ];
            const i = [
                ...n.COMMENT_KEYS,
                "comments",
                ...s
            ];
            function removeProperties(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const r = t.preserveComments ? s : i;
                for (const t of r){
                    if (e1[t] != null) e1[t] = undefined;
                }
                for (const t of Object.keys(e1)){
                    if (t[0] === "_" && e1[t] != null) e1[t] = undefined;
                }
                const n = Object.getOwnPropertySymbols(e1);
                for (const t of n){
                    e1[t] = null;
                }
            }
        },
        9437: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removePropertiesDeep;
            var n = r(4865);
            var s = r(4370);
            function removePropertiesDeep(e1, t) {
                (0, n.default)(e1, s.default, t);
                return e1;
            }
        },
        6066: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeTypeDuplicates;
            var n = r(46);
            function getQualifiedName(e1) {
                return (0, n.isIdentifier)(e1) ? e1.name : (0, n.isThisExpression)(e1) ? "this" : "".concat(e1.right.name, ".").concat(getQualifiedName(e1.left));
            }
            function removeTypeDuplicates(e1) {
                const t = Array.from(e1);
                const r = new Map;
                const s = new Map;
                const i = new Set;
                const a = [];
                for(let e1 = 0; e1 < t.length; e1++){
                    const o = t[e1];
                    if (!o) continue;
                    if (a.includes(o)) {
                        continue;
                    }
                    if ((0, n.isTSAnyKeyword)(o)) {
                        return [
                            o
                        ];
                    }
                    if ((0, n.isTSBaseType)(o)) {
                        s.set(o.type, o);
                        continue;
                    }
                    if ((0, n.isTSUnionType)(o)) {
                        if (!i.has(o.types)) {
                            t.push(...o.types);
                            i.add(o.types);
                        }
                        continue;
                    }
                    const l = "typeParameters";
                    if ((0, n.isTSTypeReference)(o) && o[l]) {
                        const e1 = o[l];
                        const t = getQualifiedName(o.typeName);
                        if (r.has(t)) {
                            let n = r.get(t);
                            const s = n[l];
                            if (s) {
                                s.params.push(...e1.params);
                                s.params = removeTypeDuplicates(s.params);
                            } else {
                                n = e1;
                            }
                        } else {
                            r.set(t, o);
                        }
                        continue;
                    }
                    a.push(o);
                }
                for (const [, e1] of s){
                    a.push(e1);
                }
                for (const [, e1] of r){
                    a.push(e1);
                }
                return a;
            }
        },
        3573: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = getAssignmentIdentifiers;
            function getAssignmentIdentifiers(e1) {
                const t = [].concat(e1);
                const r = Object.create(null);
                while(t.length){
                    const e1 = t.pop();
                    if (!e1) continue;
                    switch(e1.type){
                        case "ArrayPattern":
                            t.push(...e1.elements);
                            break;
                        case "AssignmentExpression":
                        case "AssignmentPattern":
                        case "ForInStatement":
                        case "ForOfStatement":
                            t.push(e1.left);
                            break;
                        case "ObjectPattern":
                            t.push(...e1.properties);
                            break;
                        case "ObjectProperty":
                            t.push(e1.value);
                            break;
                        case "RestElement":
                        case "UpdateExpression":
                            t.push(e1.argument);
                            break;
                        case "UnaryExpression":
                            if (e1.operator === "delete") {
                                t.push(e1.argument);
                            }
                            break;
                        case "Identifier":
                            r[e1.name] = e1;
                            break;
                        default:
                            break;
                    }
                }
                return r;
            }
        },
        6306: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = getBindingIdentifiers;
            var n = r(46);
            function getBindingIdentifiers(e1, t, r, s) {
                const i = [].concat(e1);
                const a = Object.create(null);
                while(i.length){
                    const e1 = i.shift();
                    if (!e1) continue;
                    if (s && ((0, n.isAssignmentExpression)(e1) || (0, n.isUnaryExpression)(e1) || (0, n.isUpdateExpression)(e1))) {
                        continue;
                    }
                    if ((0, n.isIdentifier)(e1)) {
                        if (t) {
                            const t = a[e1.name] = a[e1.name] || [];
                            t.push(e1);
                        } else {
                            a[e1.name] = e1;
                        }
                        continue;
                    }
                    if ((0, n.isExportDeclaration)(e1) && !(0, n.isExportAllDeclaration)(e1)) {
                        if ((0, n.isDeclaration)(e1.declaration)) {
                            i.push(e1.declaration);
                        }
                        continue;
                    }
                    if (r) {
                        if ((0, n.isFunctionDeclaration)(e1)) {
                            i.push(e1.id);
                            continue;
                        }
                        if ((0, n.isFunctionExpression)(e1)) {
                            continue;
                        }
                    }
                    const o = getBindingIdentifiers.keys[e1.type];
                    if (o) {
                        for(let t = 0; t < o.length; t++){
                            const r = o[t];
                            const n = e1[r];
                            if (n) {
                                if (Array.isArray(n)) {
                                    i.push(...n);
                                } else {
                                    i.push(n);
                                }
                            }
                        }
                    }
                }
                return a;
            }
            const s = {
                DeclareClass: [
                    "id"
                ],
                DeclareFunction: [
                    "id"
                ],
                DeclareModule: [
                    "id"
                ],
                DeclareVariable: [
                    "id"
                ],
                DeclareInterface: [
                    "id"
                ],
                DeclareTypeAlias: [
                    "id"
                ],
                DeclareOpaqueType: [
                    "id"
                ],
                InterfaceDeclaration: [
                    "id"
                ],
                TypeAlias: [
                    "id"
                ],
                OpaqueType: [
                    "id"
                ],
                CatchClause: [
                    "param"
                ],
                LabeledStatement: [
                    "label"
                ],
                UnaryExpression: [
                    "argument"
                ],
                AssignmentExpression: [
                    "left"
                ],
                ImportSpecifier: [
                    "local"
                ],
                ImportNamespaceSpecifier: [
                    "local"
                ],
                ImportDefaultSpecifier: [
                    "local"
                ],
                ImportDeclaration: [
                    "specifiers"
                ],
                TSImportEqualsDeclaration: [
                    "id"
                ],
                ExportSpecifier: [
                    "exported"
                ],
                ExportNamespaceSpecifier: [
                    "exported"
                ],
                ExportDefaultSpecifier: [
                    "exported"
                ],
                FunctionDeclaration: [
                    "id",
                    "params"
                ],
                FunctionExpression: [
                    "id",
                    "params"
                ],
                ArrowFunctionExpression: [
                    "params"
                ],
                ObjectMethod: [
                    "params"
                ],
                ClassMethod: [
                    "params"
                ],
                ClassPrivateMethod: [
                    "params"
                ],
                ForInStatement: [
                    "left"
                ],
                ForOfStatement: [
                    "left"
                ],
                ClassDeclaration: [
                    "id"
                ],
                ClassExpression: [
                    "id"
                ],
                RestElement: [
                    "argument"
                ],
                UpdateExpression: [
                    "argument"
                ],
                ObjectProperty: [
                    "value"
                ],
                AssignmentPattern: [
                    "left"
                ],
                ArrayPattern: [
                    "elements"
                ],
                ObjectPattern: [
                    "properties"
                ],
                VariableDeclaration: [
                    "declarations"
                ],
                VariableDeclarator: [
                    "id"
                ]
            };
            getBindingIdentifiers.keys = s;
        },
        6626: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = getFunctionName;
            var n = r(46);
            function getNameFromLiteralId(e1) {
                if ((0, n.isNullLiteral)(e1)) {
                    return "null";
                }
                if ((0, n.isRegExpLiteral)(e1)) {
                    return "/".concat(e1.pattern, "/").concat(e1.flags);
                }
                if ((0, n.isTemplateLiteral)(e1)) {
                    return e1.quasis.map((e1)=>e1.value.raw).join("");
                }
                if (e1.value !== undefined) {
                    return String(e1.value);
                }
                return null;
            }
            function getObjectMemberKey(e1) {
                if (!e1.computed || (0, n.isLiteral)(e1.key)) {
                    return e1.key;
                }
            }
            function getFunctionName(e1, t) {
                if ("id" in e1 && e1.id) {
                    return {
                        name: e1.id.name,
                        originalNode: e1.id
                    };
                }
                let r = "";
                let s;
                if ((0, n.isObjectProperty)(t, {
                    value: e1
                })) {
                    s = getObjectMemberKey(t);
                } else if ((0, n.isObjectMethod)(e1) || (0, n.isClassMethod)(e1)) {
                    s = getObjectMemberKey(e1);
                    if (e1.kind === "get") r = "get ";
                    else if (e1.kind === "set") r = "set ";
                } else if ((0, n.isVariableDeclarator)(t, {
                    init: e1
                })) {
                    s = t.id;
                } else if ((0, n.isAssignmentExpression)(t, {
                    operator: "=",
                    right: e1
                })) {
                    s = t.left;
                }
                if (!s) return null;
                const i = (0, n.isLiteral)(s) ? getNameFromLiteralId(s) : (0, n.isIdentifier)(s) ? s.name : (0, n.isPrivateName)(s) ? s.id.name : null;
                if (i == null) return null;
                return {
                    name: r + i,
                    originalNode: s
                };
            }
        },
        6128: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(6306);
            var s = t["default"] = getOuterBindingIdentifiers;
            function getOuterBindingIdentifiers(e1, t) {
                return (0, n.default)(e1, t, true);
            }
        },
        6348: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = traverse;
            var n = r(6767);
            function traverse(e1, t, r) {
                if (typeof t === "function") {
                    t = {
                        enter: t
                    };
                }
                const { enter: n, exit: s } = t;
                traverseSimpleImpl(e1, n, s, r, []);
            }
            function traverseSimpleImpl(e1, t, r, s, i) {
                const a = n.VISITOR_KEYS[e1.type];
                if (!a) return;
                if (t) t(e1, i, s);
                for (const n of a){
                    const a = e1[n];
                    if (Array.isArray(a)) {
                        for(let o = 0; o < a.length; o++){
                            const l = a[o];
                            if (!l) continue;
                            i.push({
                                node: e1,
                                key: n,
                                index: o
                            });
                            traverseSimpleImpl(l, t, r, s, i);
                            i.pop();
                        }
                    } else if (a) {
                        i.push({
                            node: e1,
                            key: n
                        });
                        traverseSimpleImpl(a, t, r, s, i);
                        i.pop();
                    }
                }
                if (r) r(e1, i, s);
            }
        },
        4865: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = traverseFast;
            var n = r(6767);
            const s = Symbol();
            const i = Symbol();
            function traverseFast(e1, t, r) {
                if (!e1) return false;
                const a = n.VISITOR_KEYS[e1.type];
                if (!a) return false;
                r = r || {};
                const o = t(e1, r);
                if (o !== undefined) {
                    switch(o){
                        case s:
                            return false;
                        case i:
                            return true;
                    }
                }
                for (const n of a){
                    const s = e1[n];
                    if (!s) continue;
                    if (Array.isArray(s)) {
                        for (const e1 of s){
                            if (traverseFast(e1, t, r)) return true;
                        }
                    } else {
                        if (traverseFast(s, t, r)) return true;
                    }
                }
                return false;
            }
            traverseFast.skip = s;
            traverseFast.stop = i;
        },
        8760: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = deprecationWarning;
            const r = new Set;
            function deprecationWarning(e1, t) {
                let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
                if (r.has(e1)) return;
                r.add(e1);
                const { internal: s, trace: i } = captureShortStackTrace(1, 2);
                if (s) {
                    return;
                }
                console.warn("".concat(n, "`").concat(e1, "` has been deprecated, please migrate to `").concat(t, "`\n").concat(i));
            }
            function captureShortStackTrace(e1, t) {
                const { stackTraceLimit: r, prepareStackTrace: n } = Error;
                let s;
                Error.stackTraceLimit = 1 + e1 + t;
                Error.prepareStackTrace = function(e1, t) {
                    s = t;
                };
                (new Error).stack;
                Error.stackTraceLimit = r;
                Error.prepareStackTrace = n;
                if (!s) return {
                    internal: false,
                    trace: ""
                };
                const i = s.slice(1 + e1, 1 + e1 + t);
                return {
                    internal: /[\\/]@babel[\\/]/.test(i[1].getFileName()),
                    trace: i.map((e1)=>"    at ".concat(e1)).join("\n")
                };
            }
        },
        2660: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inherit;
            function inherit(e1, t, r) {
                if (t && r) {
                    t[e1] = Array.from(new Set([].concat(t[e1], r[e1]).filter(Boolean)));
                }
            }
        },
        8530: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cleanJSXElementLiteralChild;
            var n = r(4755);
            var s = r(3061);
            function cleanJSXElementLiteralChild(e1, t) {
                const r = e1.value.split(/\r\n|\n|\r/);
                let i = 0;
                for(let e1 = 0; e1 < r.length; e1++){
                    if (/[^ \t]/.exec(r[e1])) {
                        i = e1;
                    }
                }
                let a = "";
                for(let e1 = 0; e1 < r.length; e1++){
                    const t = r[e1];
                    const n = e1 === 0;
                    const s = e1 === r.length - 1;
                    const o = e1 === i;
                    let l = t.replace(/\t/g, " ");
                    if (!n) {
                        l = l.replace(/^ +/, "");
                    }
                    if (!s) {
                        l = l.replace(/ +$/, "");
                    }
                    if (l) {
                        if (!o) {
                            l += " ";
                        }
                        a += l;
                    }
                }
                if (a) t.push((0, s.inherits)((0, n.stringLiteral)(a), e1));
            }
        },
        1119: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = shallowEqual;
            function shallowEqual(e1, t) {
                const r = Object.keys(t);
                for (const n of r){
                    if (e1[n] !== t[n]) {
                        return false;
                    }
                }
                return true;
            }
        },
        7723: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = buildMatchMemberExpression;
            var n = r(3447);
            function buildMatchMemberExpression(e1, t) {
                const r = e1.split(".");
                return (e1)=>(0, n.default)(e1, r, t);
            }
        },
        46: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isAccessor = isAccessor;
            t.isAnyTypeAnnotation = isAnyTypeAnnotation;
            t.isArgumentPlaceholder = isArgumentPlaceholder;
            t.isArrayExpression = isArrayExpression;
            t.isArrayPattern = isArrayPattern;
            t.isArrayTypeAnnotation = isArrayTypeAnnotation;
            t.isArrowFunctionExpression = isArrowFunctionExpression;
            t.isAssignmentExpression = isAssignmentExpression;
            t.isAssignmentPattern = isAssignmentPattern;
            t.isAwaitExpression = isAwaitExpression;
            t.isBigIntLiteral = isBigIntLiteral;
            t.isBinary = isBinary;
            t.isBinaryExpression = isBinaryExpression;
            t.isBindExpression = isBindExpression;
            t.isBlock = isBlock;
            t.isBlockParent = isBlockParent;
            t.isBlockStatement = isBlockStatement;
            t.isBooleanLiteral = isBooleanLiteral;
            t.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
            t.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
            t.isBreakStatement = isBreakStatement;
            t.isCallExpression = isCallExpression;
            t.isCatchClause = isCatchClause;
            t.isClass = isClass;
            t.isClassAccessorProperty = isClassAccessorProperty;
            t.isClassBody = isClassBody;
            t.isClassDeclaration = isClassDeclaration;
            t.isClassExpression = isClassExpression;
            t.isClassImplements = isClassImplements;
            t.isClassMethod = isClassMethod;
            t.isClassPrivateMethod = isClassPrivateMethod;
            t.isClassPrivateProperty = isClassPrivateProperty;
            t.isClassProperty = isClassProperty;
            t.isCompletionStatement = isCompletionStatement;
            t.isConditional = isConditional;
            t.isConditionalExpression = isConditionalExpression;
            t.isContinueStatement = isContinueStatement;
            t.isDebuggerStatement = isDebuggerStatement;
            t.isDecimalLiteral = isDecimalLiteral;
            t.isDeclaration = isDeclaration;
            t.isDeclareClass = isDeclareClass;
            t.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
            t.isDeclareExportDeclaration = isDeclareExportDeclaration;
            t.isDeclareFunction = isDeclareFunction;
            t.isDeclareInterface = isDeclareInterface;
            t.isDeclareModule = isDeclareModule;
            t.isDeclareModuleExports = isDeclareModuleExports;
            t.isDeclareOpaqueType = isDeclareOpaqueType;
            t.isDeclareTypeAlias = isDeclareTypeAlias;
            t.isDeclareVariable = isDeclareVariable;
            t.isDeclaredPredicate = isDeclaredPredicate;
            t.isDecorator = isDecorator;
            t.isDirective = isDirective;
            t.isDirectiveLiteral = isDirectiveLiteral;
            t.isDoExpression = isDoExpression;
            t.isDoWhileStatement = isDoWhileStatement;
            t.isEmptyStatement = isEmptyStatement;
            t.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
            t.isEnumBody = isEnumBody;
            t.isEnumBooleanBody = isEnumBooleanBody;
            t.isEnumBooleanMember = isEnumBooleanMember;
            t.isEnumDeclaration = isEnumDeclaration;
            t.isEnumDefaultedMember = isEnumDefaultedMember;
            t.isEnumMember = isEnumMember;
            t.isEnumNumberBody = isEnumNumberBody;
            t.isEnumNumberMember = isEnumNumberMember;
            t.isEnumStringBody = isEnumStringBody;
            t.isEnumStringMember = isEnumStringMember;
            t.isEnumSymbolBody = isEnumSymbolBody;
            t.isExistsTypeAnnotation = isExistsTypeAnnotation;
            t.isExportAllDeclaration = isExportAllDeclaration;
            t.isExportDeclaration = isExportDeclaration;
            t.isExportDefaultDeclaration = isExportDefaultDeclaration;
            t.isExportDefaultSpecifier = isExportDefaultSpecifier;
            t.isExportNamedDeclaration = isExportNamedDeclaration;
            t.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
            t.isExportSpecifier = isExportSpecifier;
            t.isExpression = isExpression;
            t.isExpressionStatement = isExpressionStatement;
            t.isExpressionWrapper = isExpressionWrapper;
            t.isFile = isFile;
            t.isFlow = isFlow;
            t.isFlowBaseAnnotation = isFlowBaseAnnotation;
            t.isFlowDeclaration = isFlowDeclaration;
            t.isFlowPredicate = isFlowPredicate;
            t.isFlowType = isFlowType;
            t.isFor = isFor;
            t.isForInStatement = isForInStatement;
            t.isForOfStatement = isForOfStatement;
            t.isForStatement = isForStatement;
            t.isForXStatement = isForXStatement;
            t.isFunction = isFunction;
            t.isFunctionDeclaration = isFunctionDeclaration;
            t.isFunctionExpression = isFunctionExpression;
            t.isFunctionParent = isFunctionParent;
            t.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
            t.isFunctionTypeParam = isFunctionTypeParam;
            t.isGenericTypeAnnotation = isGenericTypeAnnotation;
            t.isIdentifier = isIdentifier;
            t.isIfStatement = isIfStatement;
            t.isImmutable = isImmutable;
            t.isImport = isImport;
            t.isImportAttribute = isImportAttribute;
            t.isImportDeclaration = isImportDeclaration;
            t.isImportDefaultSpecifier = isImportDefaultSpecifier;
            t.isImportExpression = isImportExpression;
            t.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
            t.isImportOrExportDeclaration = isImportOrExportDeclaration;
            t.isImportSpecifier = isImportSpecifier;
            t.isIndexedAccessType = isIndexedAccessType;
            t.isInferredPredicate = isInferredPredicate;
            t.isInterfaceDeclaration = isInterfaceDeclaration;
            t.isInterfaceExtends = isInterfaceExtends;
            t.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
            t.isInterpreterDirective = isInterpreterDirective;
            t.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
            t.isJSX = isJSX;
            t.isJSXAttribute = isJSXAttribute;
            t.isJSXClosingElement = isJSXClosingElement;
            t.isJSXClosingFragment = isJSXClosingFragment;
            t.isJSXElement = isJSXElement;
            t.isJSXEmptyExpression = isJSXEmptyExpression;
            t.isJSXExpressionContainer = isJSXExpressionContainer;
            t.isJSXFragment = isJSXFragment;
            t.isJSXIdentifier = isJSXIdentifier;
            t.isJSXMemberExpression = isJSXMemberExpression;
            t.isJSXNamespacedName = isJSXNamespacedName;
            t.isJSXOpeningElement = isJSXOpeningElement;
            t.isJSXOpeningFragment = isJSXOpeningFragment;
            t.isJSXSpreadAttribute = isJSXSpreadAttribute;
            t.isJSXSpreadChild = isJSXSpreadChild;
            t.isJSXText = isJSXText;
            t.isLVal = isLVal;
            t.isLabeledStatement = isLabeledStatement;
            t.isLiteral = isLiteral;
            t.isLogicalExpression = isLogicalExpression;
            t.isLoop = isLoop;
            t.isMemberExpression = isMemberExpression;
            t.isMetaProperty = isMetaProperty;
            t.isMethod = isMethod;
            t.isMiscellaneous = isMiscellaneous;
            t.isMixedTypeAnnotation = isMixedTypeAnnotation;
            t.isModuleDeclaration = isModuleDeclaration;
            t.isModuleExpression = isModuleExpression;
            t.isModuleSpecifier = isModuleSpecifier;
            t.isNewExpression = isNewExpression;
            t.isNoop = isNoop;
            t.isNullLiteral = isNullLiteral;
            t.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
            t.isNullableTypeAnnotation = isNullableTypeAnnotation;
            t.isNumberLiteral = isNumberLiteral;
            t.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
            t.isNumberTypeAnnotation = isNumberTypeAnnotation;
            t.isNumericLiteral = isNumericLiteral;
            t.isObjectExpression = isObjectExpression;
            t.isObjectMember = isObjectMember;
            t.isObjectMethod = isObjectMethod;
            t.isObjectPattern = isObjectPattern;
            t.isObjectProperty = isObjectProperty;
            t.isObjectTypeAnnotation = isObjectTypeAnnotation;
            t.isObjectTypeCallProperty = isObjectTypeCallProperty;
            t.isObjectTypeIndexer = isObjectTypeIndexer;
            t.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
            t.isObjectTypeProperty = isObjectTypeProperty;
            t.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
            t.isOpaqueType = isOpaqueType;
            t.isOptionalCallExpression = isOptionalCallExpression;
            t.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
            t.isOptionalMemberExpression = isOptionalMemberExpression;
            t.isParenthesizedExpression = isParenthesizedExpression;
            t.isPattern = isPattern;
            t.isPatternLike = isPatternLike;
            t.isPipelineBareFunction = isPipelineBareFunction;
            t.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
            t.isPipelineTopicExpression = isPipelineTopicExpression;
            t.isPlaceholder = isPlaceholder;
            t.isPrivate = isPrivate;
            t.isPrivateName = isPrivateName;
            t.isProgram = isProgram;
            t.isProperty = isProperty;
            t.isPureish = isPureish;
            t.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
            t.isRecordExpression = isRecordExpression;
            t.isRegExpLiteral = isRegExpLiteral;
            t.isRegexLiteral = isRegexLiteral;
            t.isRestElement = isRestElement;
            t.isRestProperty = isRestProperty;
            t.isReturnStatement = isReturnStatement;
            t.isScopable = isScopable;
            t.isSequenceExpression = isSequenceExpression;
            t.isSpreadElement = isSpreadElement;
            t.isSpreadProperty = isSpreadProperty;
            t.isStandardized = isStandardized;
            t.isStatement = isStatement;
            t.isStaticBlock = isStaticBlock;
            t.isStringLiteral = isStringLiteral;
            t.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
            t.isStringTypeAnnotation = isStringTypeAnnotation;
            t.isSuper = isSuper;
            t.isSwitchCase = isSwitchCase;
            t.isSwitchStatement = isSwitchStatement;
            t.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
            t.isTSAnyKeyword = isTSAnyKeyword;
            t.isTSArrayType = isTSArrayType;
            t.isTSAsExpression = isTSAsExpression;
            t.isTSBaseType = isTSBaseType;
            t.isTSBigIntKeyword = isTSBigIntKeyword;
            t.isTSBooleanKeyword = isTSBooleanKeyword;
            t.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
            t.isTSConditionalType = isTSConditionalType;
            t.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
            t.isTSConstructorType = isTSConstructorType;
            t.isTSDeclareFunction = isTSDeclareFunction;
            t.isTSDeclareMethod = isTSDeclareMethod;
            t.isTSEntityName = isTSEntityName;
            t.isTSEnumBody = isTSEnumBody;
            t.isTSEnumDeclaration = isTSEnumDeclaration;
            t.isTSEnumMember = isTSEnumMember;
            t.isTSExportAssignment = isTSExportAssignment;
            t.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
            t.isTSExternalModuleReference = isTSExternalModuleReference;
            t.isTSFunctionType = isTSFunctionType;
            t.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
            t.isTSImportType = isTSImportType;
            t.isTSIndexSignature = isTSIndexSignature;
            t.isTSIndexedAccessType = isTSIndexedAccessType;
            t.isTSInferType = isTSInferType;
            t.isTSInstantiationExpression = isTSInstantiationExpression;
            t.isTSInterfaceBody = isTSInterfaceBody;
            t.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
            t.isTSIntersectionType = isTSIntersectionType;
            t.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
            t.isTSLiteralType = isTSLiteralType;
            t.isTSMappedType = isTSMappedType;
            t.isTSMethodSignature = isTSMethodSignature;
            t.isTSModuleBlock = isTSModuleBlock;
            t.isTSModuleDeclaration = isTSModuleDeclaration;
            t.isTSNamedTupleMember = isTSNamedTupleMember;
            t.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
            t.isTSNeverKeyword = isTSNeverKeyword;
            t.isTSNonNullExpression = isTSNonNullExpression;
            t.isTSNullKeyword = isTSNullKeyword;
            t.isTSNumberKeyword = isTSNumberKeyword;
            t.isTSObjectKeyword = isTSObjectKeyword;
            t.isTSOptionalType = isTSOptionalType;
            t.isTSParameterProperty = isTSParameterProperty;
            t.isTSParenthesizedType = isTSParenthesizedType;
            t.isTSPropertySignature = isTSPropertySignature;
            t.isTSQualifiedName = isTSQualifiedName;
            t.isTSRestType = isTSRestType;
            t.isTSSatisfiesExpression = isTSSatisfiesExpression;
            t.isTSStringKeyword = isTSStringKeyword;
            t.isTSSymbolKeyword = isTSSymbolKeyword;
            t.isTSTemplateLiteralType = isTSTemplateLiteralType;
            t.isTSThisType = isTSThisType;
            t.isTSTupleType = isTSTupleType;
            t.isTSType = isTSType;
            t.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
            t.isTSTypeAnnotation = isTSTypeAnnotation;
            t.isTSTypeAssertion = isTSTypeAssertion;
            t.isTSTypeElement = isTSTypeElement;
            t.isTSTypeLiteral = isTSTypeLiteral;
            t.isTSTypeOperator = isTSTypeOperator;
            t.isTSTypeParameter = isTSTypeParameter;
            t.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
            t.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
            t.isTSTypePredicate = isTSTypePredicate;
            t.isTSTypeQuery = isTSTypeQuery;
            t.isTSTypeReference = isTSTypeReference;
            t.isTSUndefinedKeyword = isTSUndefinedKeyword;
            t.isTSUnionType = isTSUnionType;
            t.isTSUnknownKeyword = isTSUnknownKeyword;
            t.isTSVoidKeyword = isTSVoidKeyword;
            t.isTaggedTemplateExpression = isTaggedTemplateExpression;
            t.isTemplateElement = isTemplateElement;
            t.isTemplateLiteral = isTemplateLiteral;
            t.isTerminatorless = isTerminatorless;
            t.isThisExpression = isThisExpression;
            t.isThisTypeAnnotation = isThisTypeAnnotation;
            t.isThrowStatement = isThrowStatement;
            t.isTopicReference = isTopicReference;
            t.isTryStatement = isTryStatement;
            t.isTupleExpression = isTupleExpression;
            t.isTupleTypeAnnotation = isTupleTypeAnnotation;
            t.isTypeAlias = isTypeAlias;
            t.isTypeAnnotation = isTypeAnnotation;
            t.isTypeCastExpression = isTypeCastExpression;
            t.isTypeParameter = isTypeParameter;
            t.isTypeParameterDeclaration = isTypeParameterDeclaration;
            t.isTypeParameterInstantiation = isTypeParameterInstantiation;
            t.isTypeScript = isTypeScript;
            t.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
            t.isUnaryExpression = isUnaryExpression;
            t.isUnaryLike = isUnaryLike;
            t.isUnionTypeAnnotation = isUnionTypeAnnotation;
            t.isUpdateExpression = isUpdateExpression;
            t.isUserWhitespacable = isUserWhitespacable;
            t.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
            t.isVariableDeclaration = isVariableDeclaration;
            t.isVariableDeclarator = isVariableDeclarator;
            t.isVariance = isVariance;
            t.isVoidTypeAnnotation = isVoidTypeAnnotation;
            t.isWhile = isWhile;
            t.isWhileStatement = isWhileStatement;
            t.isWithStatement = isWithStatement;
            t.isYieldExpression = isYieldExpression;
            var n = r(1119);
            var s = r(8760);
            function isArrayExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrayExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAssignmentExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AssignmentExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBinaryExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BinaryExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterpreterDirective(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterpreterDirective") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDirective(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Directive") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDirectiveLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DirectiveLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBlockStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BlockStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBreakStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BreakStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isCallExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "CallExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isCatchClause(e1, t) {
                if (!e1) return false;
                if (e1.type !== "CatchClause") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isConditionalExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ConditionalExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isContinueStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ContinueStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDebuggerStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DebuggerStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDoWhileStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DoWhileStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEmptyStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EmptyStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExpressionStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExpressionStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFile(e1, t) {
                if (!e1) return false;
                if (e1.type !== "File") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isForInStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ForInStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isForStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ForStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Identifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIfStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "IfStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isLabeledStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "LabeledStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStringLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StringLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNumericLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NumericLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNullLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NullLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBooleanLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BooleanLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRegExpLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "RegExpLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isLogicalExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "LogicalExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isMemberExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "MemberExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNewExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NewExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isProgram(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Program") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRestElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "RestElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isReturnStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ReturnStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSequenceExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SequenceExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isParenthesizedExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ParenthesizedExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSwitchCase(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SwitchCase") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSwitchStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SwitchStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isThisExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ThisExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isThrowStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ThrowStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTryStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TryStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isUnaryExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "UnaryExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isUpdateExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "UpdateExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVariableDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "VariableDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVariableDeclarator(e1, t) {
                if (!e1) return false;
                if (e1.type !== "VariableDeclarator") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isWhileStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "WhileStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isWithStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "WithStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAssignmentPattern(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AssignmentPattern") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArrayPattern(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrayPattern") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArrowFunctionExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrowFunctionExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportAllDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportAllDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportDefaultDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportDefaultDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportNamedDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportNamedDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isForOfStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ForOfStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportDefaultSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportDefaultSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportNamespaceSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportNamespaceSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isMetaProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "MetaProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectPattern(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectPattern") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSpreadElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SpreadElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSuper(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Super") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTaggedTemplateExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TaggedTemplateExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTemplateElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TemplateElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTemplateLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TemplateLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isYieldExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "YieldExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAwaitExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AwaitExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImport(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Import") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBigIntLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BigIntLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportNamespaceSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportNamespaceSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOptionalMemberExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OptionalMemberExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOptionalCallExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OptionalCallExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassAccessorProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassAccessorProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassPrivateProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassPrivateProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassPrivateMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassPrivateMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPrivateName(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PrivateName") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStaticBlock(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StaticBlock") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportAttribute(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportAttribute") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAnyTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AnyTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArrayTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrayTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBooleanTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BooleanTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBooleanLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BooleanLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNullLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NullLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassImplements(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassImplements") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareClass(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareClass") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareFunction(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareFunction") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareInterface(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareInterface") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareModule(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareModule") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareModuleExports(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareModuleExports") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareTypeAlias(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareTypeAlias") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareOpaqueType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareOpaqueType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareVariable(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareVariable") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareExportDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareExportDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareExportAllDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareExportAllDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclaredPredicate(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclaredPredicate") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExistsTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExistsTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionTypeParam(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionTypeParam") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isGenericTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "GenericTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInferredPredicate(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InferredPredicate") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterfaceExtends(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterfaceExtends") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterfaceDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterfaceDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterfaceTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterfaceTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIntersectionTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "IntersectionTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isMixedTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "MixedTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEmptyTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EmptyTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNullableTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NullableTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNumberLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NumberLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNumberTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NumberTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeInternalSlot(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeInternalSlot") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeCallProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeCallProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeIndexer(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeIndexer") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeSpreadProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeSpreadProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOpaqueType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OpaqueType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isQualifiedTypeIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "QualifiedTypeIdentifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStringLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StringLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStringTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StringTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSymbolTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SymbolTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isThisTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ThisTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTupleTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TupleTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeofTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeofTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeAlias(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeAlias") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeCastExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeCastExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeParameter(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeParameter") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeParameterDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeParameterDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeParameterInstantiation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeParameterInstantiation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isUnionTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "UnionTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVariance(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Variance") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVoidTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "VoidTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumBooleanBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumBooleanBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumNumberBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumNumberBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumStringBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumStringBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumSymbolBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumSymbolBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumBooleanMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumBooleanMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumNumberMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumNumberMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumStringMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumStringMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumDefaultedMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumDefaultedMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIndexedAccessType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "IndexedAccessType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOptionalIndexedAccessType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OptionalIndexedAccessType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXAttribute(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXAttribute") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXClosingElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXClosingElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXEmptyExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXEmptyExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXExpressionContainer(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXExpressionContainer") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXSpreadChild(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXSpreadChild") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXIdentifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXMemberExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXMemberExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXNamespacedName(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXNamespacedName") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXOpeningElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXOpeningElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXSpreadAttribute(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXSpreadAttribute") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXText(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXText") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXFragment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXFragment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXOpeningFragment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXOpeningFragment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXClosingFragment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXClosingFragment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNoop(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Noop") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPlaceholder(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Placeholder") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isV8IntrinsicIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "V8IntrinsicIdentifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArgumentPlaceholder(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArgumentPlaceholder") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBindExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BindExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDecorator(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Decorator") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDoExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DoExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportDefaultSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportDefaultSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRecordExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "RecordExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTupleExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TupleExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDecimalLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DecimalLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isModuleExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ModuleExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTopicReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TopicReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPipelineTopicExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PipelineTopicExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPipelineBareFunction(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PipelineBareFunction") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPipelinePrimaryTopicReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PipelinePrimaryTopicReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSParameterProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSParameterProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSDeclareFunction(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSDeclareFunction") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSDeclareMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSDeclareMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSQualifiedName(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSQualifiedName") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSCallSignatureDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSCallSignatureDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSConstructSignatureDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSConstructSignatureDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSPropertySignature(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSPropertySignature") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSMethodSignature(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSMethodSignature") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIndexSignature(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIndexSignature") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSAnyKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSAnyKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSBooleanKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSBooleanKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSBigIntKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSBigIntKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIntrinsicKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIntrinsicKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNeverKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNeverKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNullKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNullKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNumberKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNumberKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSObjectKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSObjectKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSStringKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSStringKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSSymbolKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSSymbolKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSUndefinedKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSUndefinedKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSUnknownKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSUnknownKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSVoidKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSVoidKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSThisType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSThisType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSFunctionType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSFunctionType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSConstructorType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSConstructorType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypePredicate(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypePredicate") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeQuery(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeQuery") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSArrayType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSArrayType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTupleType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTupleType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSOptionalType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSOptionalType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSRestType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSRestType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNamedTupleMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNamedTupleMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSUnionType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSUnionType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIntersectionType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIntersectionType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSConditionalType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSConditionalType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInferType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInferType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSParenthesizedType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSParenthesizedType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeOperator(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeOperator") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIndexedAccessType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIndexedAccessType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSMappedType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSMappedType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTemplateLiteralType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTemplateLiteralType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSLiteralType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSLiteralType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSExpressionWithTypeArguments(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSExpressionWithTypeArguments") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInterfaceDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInterfaceDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInterfaceBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInterfaceBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeAliasDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeAliasDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInstantiationExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInstantiationExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSAsExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSAsExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSSatisfiesExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSSatisfiesExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeAssertion(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeAssertion") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEnumBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSEnumBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEnumDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSEnumDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEnumMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSEnumMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSModuleDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSModuleDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSModuleBlock(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSModuleBlock") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSImportType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSImportType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSImportEqualsDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSImportEqualsDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSExternalModuleReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSExternalModuleReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNonNullExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNonNullExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSExportAssignment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSExportAssignment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNamespaceExportDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNamespaceExportDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeParameterInstantiation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeParameterInstantiation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeParameterDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeParameterDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeParameter(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeParameter") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStandardized(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "InterpreterDirective":
                    case "Directive":
                    case "DirectiveLiteral":
                    case "BlockStatement":
                    case "BreakStatement":
                    case "CallExpression":
                    case "CatchClause":
                    case "ConditionalExpression":
                    case "ContinueStatement":
                    case "DebuggerStatement":
                    case "DoWhileStatement":
                    case "EmptyStatement":
                    case "ExpressionStatement":
                    case "File":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "Identifier":
                    case "IfStatement":
                    case "LabeledStatement":
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "Program":
                    case "ObjectExpression":
                    case "ObjectMethod":
                    case "ObjectProperty":
                    case "RestElement":
                    case "ReturnStatement":
                    case "SequenceExpression":
                    case "ParenthesizedExpression":
                    case "SwitchCase":
                    case "SwitchStatement":
                    case "ThisExpression":
                    case "ThrowStatement":
                    case "TryStatement":
                    case "UnaryExpression":
                    case "UpdateExpression":
                    case "VariableDeclaration":
                    case "VariableDeclarator":
                    case "WhileStatement":
                    case "WithStatement":
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ArrowFunctionExpression":
                    case "ClassBody":
                    case "ClassExpression":
                    case "ClassDeclaration":
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ExportSpecifier":
                    case "ForOfStatement":
                    case "ImportDeclaration":
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                    case "ImportExpression":
                    case "MetaProperty":
                    case "ClassMethod":
                    case "ObjectPattern":
                    case "SpreadElement":
                    case "Super":
                    case "TaggedTemplateExpression":
                    case "TemplateElement":
                    case "TemplateLiteral":
                    case "YieldExpression":
                    case "AwaitExpression":
                    case "Import":
                    case "BigIntLiteral":
                    case "ExportNamespaceSpecifier":
                    case "OptionalMemberExpression":
                    case "OptionalCallExpression":
                    case "ClassProperty":
                    case "ClassAccessorProperty":
                    case "ClassPrivateProperty":
                    case "ClassPrivateMethod":
                    case "PrivateName":
                    case "StaticBlock":
                    case "ImportAttribute":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Identifier":
                            case "StringLiteral":
                            case "BlockStatement":
                            case "ClassBody":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isExpression(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ParenthesizedExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                    case "ArrowFunctionExpression":
                    case "ClassExpression":
                    case "ImportExpression":
                    case "MetaProperty":
                    case "Super":
                    case "TaggedTemplateExpression":
                    case "TemplateLiteral":
                    case "YieldExpression":
                    case "AwaitExpression":
                    case "Import":
                    case "BigIntLiteral":
                    case "OptionalMemberExpression":
                    case "OptionalCallExpression":
                    case "TypeCastExpression":
                    case "JSXElement":
                    case "JSXFragment":
                    case "BindExpression":
                    case "DoExpression":
                    case "RecordExpression":
                    case "TupleExpression":
                    case "DecimalLiteral":
                    case "ModuleExpression":
                    case "TopicReference":
                    case "PipelineTopicExpression":
                    case "PipelineBareFunction":
                    case "PipelinePrimaryTopicReference":
                    case "TSInstantiationExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSNonNullExpression":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Expression":
                            case "Identifier":
                            case "StringLiteral":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isBinary(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BinaryExpression":
                    case "LogicalExpression":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isScopable(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "CatchClause":
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "Program":
                    case "ObjectMethod":
                    case "SwitchStatement":
                    case "WhileStatement":
                    case "ArrowFunctionExpression":
                    case "ClassExpression":
                    case "ClassDeclaration":
                    case "ForOfStatement":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "StaticBlock":
                    case "TSModuleBlock":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "BlockStatement") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isBlockParent(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "CatchClause":
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "Program":
                    case "ObjectMethod":
                    case "SwitchStatement":
                    case "WhileStatement":
                    case "ArrowFunctionExpression":
                    case "ForOfStatement":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "StaticBlock":
                    case "TSModuleBlock":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "BlockStatement") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isBlock(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "Program":
                    case "TSModuleBlock":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "BlockStatement") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isStatement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "BreakStatement":
                    case "ContinueStatement":
                    case "DebuggerStatement":
                    case "DoWhileStatement":
                    case "EmptyStatement":
                    case "ExpressionStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "IfStatement":
                    case "LabeledStatement":
                    case "ReturnStatement":
                    case "SwitchStatement":
                    case "ThrowStatement":
                    case "TryStatement":
                    case "VariableDeclaration":
                    case "WhileStatement":
                    case "WithStatement":
                    case "ClassDeclaration":
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ForOfStatement":
                    case "ImportDeclaration":
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "InterfaceDeclaration":
                    case "OpaqueType":
                    case "TypeAlias":
                    case "EnumDeclaration":
                    case "TSDeclareFunction":
                    case "TSInterfaceDeclaration":
                    case "TSTypeAliasDeclaration":
                    case "TSEnumDeclaration":
                    case "TSModuleDeclaration":
                    case "TSImportEqualsDeclaration":
                    case "TSExportAssignment":
                    case "TSNamespaceExportDeclaration":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Statement":
                            case "Declaration":
                            case "BlockStatement":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTerminatorless(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BreakStatement":
                    case "ContinueStatement":
                    case "ReturnStatement":
                    case "ThrowStatement":
                    case "YieldExpression":
                    case "AwaitExpression":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isCompletionStatement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BreakStatement":
                    case "ContinueStatement":
                    case "ReturnStatement":
                    case "ThrowStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isConditional(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ConditionalExpression":
                    case "IfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isLoop(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                    case "ForOfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isWhile(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DoWhileStatement":
                    case "WhileStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isExpressionWrapper(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExpressionStatement":
                    case "ParenthesizedExpression":
                    case "TypeCastExpression":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFor(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ForInStatement":
                    case "ForStatement":
                    case "ForOfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isForXStatement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ForInStatement":
                    case "ForOfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFunction(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ObjectMethod":
                    case "ArrowFunctionExpression":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionParent(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ObjectMethod":
                    case "ArrowFunctionExpression":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "StaticBlock":
                    case "TSModuleBlock":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPureish(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "ArrowFunctionExpression":
                    case "BigIntLiteral":
                    case "DecimalLiteral":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "StringLiteral") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "VariableDeclaration":
                    case "ClassDeclaration":
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "InterfaceDeclaration":
                    case "OpaqueType":
                    case "TypeAlias":
                    case "EnumDeclaration":
                    case "TSDeclareFunction":
                    case "TSInterfaceDeclaration":
                    case "TSTypeAliasDeclaration":
                    case "TSEnumDeclaration":
                    case "TSModuleDeclaration":
                    case "TSImportEqualsDeclaration":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "Declaration") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPatternLike(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Identifier":
                    case "RestElement":
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ObjectPattern":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSNonNullExpression":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Pattern":
                            case "Identifier":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isLVal(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Identifier":
                    case "MemberExpression":
                    case "RestElement":
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ObjectPattern":
                    case "TSParameterProperty":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSNonNullExpression":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Pattern":
                            case "Identifier":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEntityName(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Identifier":
                    case "TSQualifiedName":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "Identifier") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isLiteral(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "TemplateLiteral":
                    case "BigIntLiteral":
                    case "DecimalLiteral":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "StringLiteral") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isImmutable(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "BigIntLiteral":
                    case "JSXAttribute":
                    case "JSXClosingElement":
                    case "JSXElement":
                    case "JSXExpressionContainer":
                    case "JSXSpreadChild":
                    case "JSXOpeningElement":
                    case "JSXText":
                    case "JSXFragment":
                    case "JSXOpeningFragment":
                    case "JSXClosingFragment":
                    case "DecimalLiteral":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "StringLiteral") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isUserWhitespacable(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectMethod":
                    case "ObjectProperty":
                    case "ObjectTypeInternalSlot":
                    case "ObjectTypeCallProperty":
                    case "ObjectTypeIndexer":
                    case "ObjectTypeProperty":
                    case "ObjectTypeSpreadProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isMethod(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectMethod":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectMember(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectMethod":
                    case "ObjectProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isProperty(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectProperty":
                    case "ClassProperty":
                    case "ClassAccessorProperty":
                    case "ClassPrivateProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isUnaryLike(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "UnaryExpression":
                    case "SpreadElement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPattern(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ObjectPattern":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "Pattern") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isClass(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ClassExpression":
                    case "ClassDeclaration":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isImportOrExportDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isExportDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isModuleSpecifier(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExportSpecifier":
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                    case "ExportNamespaceSpecifier":
                    case "ExportDefaultSpecifier":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isAccessor(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ClassAccessorProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPrivate(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ClassPrivateProperty":
                    case "ClassPrivateMethod":
                    case "PrivateName":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlow(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AnyTypeAnnotation":
                    case "ArrayTypeAnnotation":
                    case "BooleanTypeAnnotation":
                    case "BooleanLiteralTypeAnnotation":
                    case "NullLiteralTypeAnnotation":
                    case "ClassImplements":
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "DeclaredPredicate":
                    case "ExistsTypeAnnotation":
                    case "FunctionTypeAnnotation":
                    case "FunctionTypeParam":
                    case "GenericTypeAnnotation":
                    case "InferredPredicate":
                    case "InterfaceExtends":
                    case "InterfaceDeclaration":
                    case "InterfaceTypeAnnotation":
                    case "IntersectionTypeAnnotation":
                    case "MixedTypeAnnotation":
                    case "EmptyTypeAnnotation":
                    case "NullableTypeAnnotation":
                    case "NumberLiteralTypeAnnotation":
                    case "NumberTypeAnnotation":
                    case "ObjectTypeAnnotation":
                    case "ObjectTypeInternalSlot":
                    case "ObjectTypeCallProperty":
                    case "ObjectTypeIndexer":
                    case "ObjectTypeProperty":
                    case "ObjectTypeSpreadProperty":
                    case "OpaqueType":
                    case "QualifiedTypeIdentifier":
                    case "StringLiteralTypeAnnotation":
                    case "StringTypeAnnotation":
                    case "SymbolTypeAnnotation":
                    case "ThisTypeAnnotation":
                    case "TupleTypeAnnotation":
                    case "TypeofTypeAnnotation":
                    case "TypeAlias":
                    case "TypeAnnotation":
                    case "TypeCastExpression":
                    case "TypeParameter":
                    case "TypeParameterDeclaration":
                    case "TypeParameterInstantiation":
                    case "UnionTypeAnnotation":
                    case "Variance":
                    case "VoidTypeAnnotation":
                    case "EnumDeclaration":
                    case "EnumBooleanBody":
                    case "EnumNumberBody":
                    case "EnumStringBody":
                    case "EnumSymbolBody":
                    case "EnumBooleanMember":
                    case "EnumNumberMember":
                    case "EnumStringMember":
                    case "EnumDefaultedMember":
                    case "IndexedAccessType":
                    case "OptionalIndexedAccessType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowType(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AnyTypeAnnotation":
                    case "ArrayTypeAnnotation":
                    case "BooleanTypeAnnotation":
                    case "BooleanLiteralTypeAnnotation":
                    case "NullLiteralTypeAnnotation":
                    case "ExistsTypeAnnotation":
                    case "FunctionTypeAnnotation":
                    case "GenericTypeAnnotation":
                    case "InterfaceTypeAnnotation":
                    case "IntersectionTypeAnnotation":
                    case "MixedTypeAnnotation":
                    case "EmptyTypeAnnotation":
                    case "NullableTypeAnnotation":
                    case "NumberLiteralTypeAnnotation":
                    case "NumberTypeAnnotation":
                    case "ObjectTypeAnnotation":
                    case "StringLiteralTypeAnnotation":
                    case "StringTypeAnnotation":
                    case "SymbolTypeAnnotation":
                    case "ThisTypeAnnotation":
                    case "TupleTypeAnnotation":
                    case "TypeofTypeAnnotation":
                    case "UnionTypeAnnotation":
                    case "VoidTypeAnnotation":
                    case "IndexedAccessType":
                    case "OptionalIndexedAccessType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowBaseAnnotation(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AnyTypeAnnotation":
                    case "BooleanTypeAnnotation":
                    case "NullLiteralTypeAnnotation":
                    case "MixedTypeAnnotation":
                    case "EmptyTypeAnnotation":
                    case "NumberTypeAnnotation":
                    case "StringTypeAnnotation":
                    case "SymbolTypeAnnotation":
                    case "ThisTypeAnnotation":
                    case "VoidTypeAnnotation":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "InterfaceDeclaration":
                    case "OpaqueType":
                    case "TypeAlias":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowPredicate(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DeclaredPredicate":
                    case "InferredPredicate":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumBody(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "EnumBooleanBody":
                    case "EnumNumberBody":
                    case "EnumStringBody":
                    case "EnumSymbolBody":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumMember(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "EnumBooleanMember":
                    case "EnumNumberMember":
                    case "EnumStringMember":
                    case "EnumDefaultedMember":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isJSX(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "JSXAttribute":
                    case "JSXClosingElement":
                    case "JSXElement":
                    case "JSXEmptyExpression":
                    case "JSXExpressionContainer":
                    case "JSXSpreadChild":
                    case "JSXIdentifier":
                    case "JSXMemberExpression":
                    case "JSXNamespacedName":
                    case "JSXOpeningElement":
                    case "JSXSpreadAttribute":
                    case "JSXText":
                    case "JSXFragment":
                    case "JSXOpeningFragment":
                    case "JSXClosingFragment":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isMiscellaneous(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Noop":
                    case "Placeholder":
                    case "V8IntrinsicIdentifier":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeScript(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSParameterProperty":
                    case "TSDeclareFunction":
                    case "TSDeclareMethod":
                    case "TSQualifiedName":
                    case "TSCallSignatureDeclaration":
                    case "TSConstructSignatureDeclaration":
                    case "TSPropertySignature":
                    case "TSMethodSignature":
                    case "TSIndexSignature":
                    case "TSAnyKeyword":
                    case "TSBooleanKeyword":
                    case "TSBigIntKeyword":
                    case "TSIntrinsicKeyword":
                    case "TSNeverKeyword":
                    case "TSNullKeyword":
                    case "TSNumberKeyword":
                    case "TSObjectKeyword":
                    case "TSStringKeyword":
                    case "TSSymbolKeyword":
                    case "TSUndefinedKeyword":
                    case "TSUnknownKeyword":
                    case "TSVoidKeyword":
                    case "TSThisType":
                    case "TSFunctionType":
                    case "TSConstructorType":
                    case "TSTypeReference":
                    case "TSTypePredicate":
                    case "TSTypeQuery":
                    case "TSTypeLiteral":
                    case "TSArrayType":
                    case "TSTupleType":
                    case "TSOptionalType":
                    case "TSRestType":
                    case "TSNamedTupleMember":
                    case "TSUnionType":
                    case "TSIntersectionType":
                    case "TSConditionalType":
                    case "TSInferType":
                    case "TSParenthesizedType":
                    case "TSTypeOperator":
                    case "TSIndexedAccessType":
                    case "TSMappedType":
                    case "TSTemplateLiteralType":
                    case "TSLiteralType":
                    case "TSExpressionWithTypeArguments":
                    case "TSInterfaceDeclaration":
                    case "TSInterfaceBody":
                    case "TSTypeAliasDeclaration":
                    case "TSInstantiationExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSEnumBody":
                    case "TSEnumDeclaration":
                    case "TSEnumMember":
                    case "TSModuleDeclaration":
                    case "TSModuleBlock":
                    case "TSImportType":
                    case "TSImportEqualsDeclaration":
                    case "TSExternalModuleReference":
                    case "TSNonNullExpression":
                    case "TSExportAssignment":
                    case "TSNamespaceExportDeclaration":
                    case "TSTypeAnnotation":
                    case "TSTypeParameterInstantiation":
                    case "TSTypeParameterDeclaration":
                    case "TSTypeParameter":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeElement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSCallSignatureDeclaration":
                    case "TSConstructSignatureDeclaration":
                    case "TSPropertySignature":
                    case "TSMethodSignature":
                    case "TSIndexSignature":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSType(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSAnyKeyword":
                    case "TSBooleanKeyword":
                    case "TSBigIntKeyword":
                    case "TSIntrinsicKeyword":
                    case "TSNeverKeyword":
                    case "TSNullKeyword":
                    case "TSNumberKeyword":
                    case "TSObjectKeyword":
                    case "TSStringKeyword":
                    case "TSSymbolKeyword":
                    case "TSUndefinedKeyword":
                    case "TSUnknownKeyword":
                    case "TSVoidKeyword":
                    case "TSThisType":
                    case "TSFunctionType":
                    case "TSConstructorType":
                    case "TSTypeReference":
                    case "TSTypePredicate":
                    case "TSTypeQuery":
                    case "TSTypeLiteral":
                    case "TSArrayType":
                    case "TSTupleType":
                    case "TSOptionalType":
                    case "TSRestType":
                    case "TSUnionType":
                    case "TSIntersectionType":
                    case "TSConditionalType":
                    case "TSInferType":
                    case "TSParenthesizedType":
                    case "TSTypeOperator":
                    case "TSIndexedAccessType":
                    case "TSMappedType":
                    case "TSTemplateLiteralType":
                    case "TSLiteralType":
                    case "TSExpressionWithTypeArguments":
                    case "TSImportType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSBaseType(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSAnyKeyword":
                    case "TSBooleanKeyword":
                    case "TSBigIntKeyword":
                    case "TSIntrinsicKeyword":
                    case "TSNeverKeyword":
                    case "TSNullKeyword":
                    case "TSNumberKeyword":
                    case "TSObjectKeyword":
                    case "TSStringKeyword":
                    case "TSSymbolKeyword":
                    case "TSUndefinedKeyword":
                    case "TSUnknownKeyword":
                    case "TSVoidKeyword":
                    case "TSThisType":
                    case "TSTemplateLiteralType":
                    case "TSLiteralType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isNumberLiteral(e1, t) {
                (0, s.default)("isNumberLiteral", "isNumericLiteral");
                if (!e1) return false;
                if (e1.type !== "NumberLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRegexLiteral(e1, t) {
                (0, s.default)("isRegexLiteral", "isRegExpLiteral");
                if (!e1) return false;
                if (e1.type !== "RegexLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRestProperty(e1, t) {
                (0, s.default)("isRestProperty", "isRestElement");
                if (!e1) return false;
                if (e1.type !== "RestProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSpreadProperty(e1, t) {
                (0, s.default)("isSpreadProperty", "isSpreadElement");
                if (!e1) return false;
                if (e1.type !== "SpreadProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isModuleDeclaration(e1, t) {
                (0, s.default)("isModuleDeclaration", "isImportOrExportDeclaration");
                return isImportOrExportDeclaration(e1, t);
            }
        },
        7670: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = is;
            var n = r(1119);
            var s = r(8388);
            var i = r(8557);
            var a = r(6767);
            function is(e1, t, r) {
                if (!t) return false;
                const o = (0, s.default)(t.type, e1);
                if (!o) {
                    if (!r && t.type === "Placeholder" && e1 in a.FLIPPED_ALIAS_KEYS) {
                        return (0, i.default)(t.expectedNode, e1);
                    }
                    return false;
                }
                if (r === undefined) {
                    return true;
                } else {
                    return (0, n.default)(t, r);
                }
            }
        },
        5195: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isBinding;
            var n = r(6306);
            function isBinding(e1, t, r) {
                if (r && e1.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression") {
                    return false;
                }
                const s = n.default.keys[t.type];
                if (s) {
                    for(let r = 0; r < s.length; r++){
                        const n = s[r];
                        const i = t[n];
                        if (Array.isArray(i)) {
                            if (i.includes(e1)) return true;
                        } else {
                            if (i === e1) return true;
                        }
                    }
                }
                return false;
            }
        },
        3652: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isBlockScoped;
            var n = r(46);
            var s = r(9626);
            function isBlockScoped(e1) {
                return (0, n.isFunctionDeclaration)(e1) || (0, n.isClassDeclaration)(e1) || (0, s.default)(e1);
            }
        },
        8597: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isImmutable;
            var n = r(8388);
            var s = r(46);
            function isImmutable(e1) {
                if ((0, n.default)(e1.type, "Immutable")) return true;
                if ((0, s.isIdentifier)(e1)) {
                    if (e1.name === "undefined") {
                        return true;
                    } else {
                        return false;
                    }
                }
                return false;
            }
        },
        9626: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isLet;
            var n = r(46);
            {
                var s = Symbol.for("var used to be block scoped");
            }
            function isLet(e1) {
                {
                    return (0, n.isVariableDeclaration)(e1) && (e1.kind !== "var" || e1[s]);
                }
            }
        },
        6087: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isNode;
            var n = r(6767);
            function isNode(e1) {
                return !!(e1 && n.VISITOR_KEYS[e1.type]);
            }
        },
        8486: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isNodesEquivalent;
            var n = r(6767);
            function isNodesEquivalent(e1, t) {
                if (typeof e1 !== "object" || typeof t !== "object" || e1 == null || t == null) {
                    return e1 === t;
                }
                if (e1.type !== t.type) {
                    return false;
                }
                const r = Object.keys(n.NODE_FIELDS[e1.type] || e1.type);
                const s = n.VISITOR_KEYS[e1.type];
                for (const n of r){
                    const r = e1[n];
                    const i = t[n];
                    if (typeof r !== typeof i) {
                        return false;
                    }
                    if (r == null && i == null) {
                        continue;
                    } else if (r == null || i == null) {
                        return false;
                    }
                    if (Array.isArray(r)) {
                        if (!Array.isArray(i)) {
                            return false;
                        }
                        if (r.length !== i.length) {
                            return false;
                        }
                        for(let e1 = 0; e1 < r.length; e1++){
                            if (!isNodesEquivalent(r[e1], i[e1])) {
                                return false;
                            }
                        }
                        continue;
                    }
                    if (typeof r === "object" && !(s != null && s.includes(n))) {
                        for (const e1 of Object.keys(r)){
                            if (r[e1] !== i[e1]) {
                                return false;
                            }
                        }
                        continue;
                    }
                    if (!isNodesEquivalent(r, i)) {
                        return false;
                    }
                }
                return true;
            }
        },
        8557: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isPlaceholderType;
            var n = r(6767);
            function isPlaceholderType(e1, t) {
                if (e1 === t) return true;
                const r = n.PLACEHOLDERS_ALIAS[e1];
                if (r != null && r.includes(t)) return true;
                return false;
            }
        },
        5028: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isReferenced;
            function isReferenced(e1, t, r) {
                switch(t.type){
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        if (t.property === e1) {
                            return !!t.computed;
                        }
                        return t.object === e1;
                    case "JSXMemberExpression":
                        return t.object === e1;
                    case "VariableDeclarator":
                        return t.init === e1;
                    case "ArrowFunctionExpression":
                        return t.body === e1;
                    case "PrivateName":
                        return false;
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "ObjectMethod":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return false;
                    case "ObjectProperty":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return !r || r.type !== "ObjectPattern";
                    case "ClassProperty":
                    case "ClassAccessorProperty":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return true;
                    case "ClassPrivateProperty":
                        return t.key !== e1;
                    case "ClassDeclaration":
                    case "ClassExpression":
                        return t.superClass === e1;
                    case "AssignmentExpression":
                        return t.right === e1;
                    case "AssignmentPattern":
                        return t.right === e1;
                    case "LabeledStatement":
                        return false;
                    case "CatchClause":
                        return false;
                    case "RestElement":
                        return false;
                    case "BreakStatement":
                    case "ContinueStatement":
                        return false;
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                        return false;
                    case "ExportNamespaceSpecifier":
                    case "ExportDefaultSpecifier":
                        return false;
                    case "ExportSpecifier":
                        if (r != null && r.source) {
                            return false;
                        }
                        return t.local === e1;
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                        return false;
                    case "ImportAttribute":
                        return false;
                    case "JSXAttribute":
                        return false;
                    case "ObjectPattern":
                    case "ArrayPattern":
                        return false;
                    case "MetaProperty":
                        return false;
                    case "ObjectTypeProperty":
                        return t.key !== e1;
                    case "TSEnumMember":
                        return t.id !== e1;
                    case "TSPropertySignature":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return true;
                }
                return true;
            }
        },
        1559: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isScope;
            var n = r(46);
            function isScope(e1, t) {
                if ((0, n.isBlockStatement)(e1) && ((0, n.isFunction)(t) || (0, n.isCatchClause)(t))) {
                    return false;
                }
                if ((0, n.isPattern)(e1) && ((0, n.isFunction)(t) || (0, n.isCatchClause)(t))) {
                    return true;
                }
                return (0, n.isScopable)(e1);
            }
        },
        8445: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isSpecifierDefault;
            var n = r(46);
            function isSpecifierDefault(e1) {
                return (0, n.isImportDefaultSpecifier)(e1) || (0, n.isIdentifier)(e1.imported || e1.exported, {
                    name: "default"
                });
            }
        },
        8388: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isType;
            var n = r(6767);
            function isType(e1, t) {
                if (e1 === t) return true;
                if (e1 == null) return false;
                if (n.ALIAS_KEYS[t]) return false;
                const r = n.FLIPPED_ALIAS_KEYS[t];
                if (r != null && r.includes(e1)) return true;
                return false;
            }
        },
        3502: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isValidES3Identifier;
            var n = r(2892);
            const s = new Set([
                "abstract",
                "boolean",
                "byte",
                "char",
                "double",
                "enum",
                "final",
                "float",
                "goto",
                "implements",
                "int",
                "interface",
                "long",
                "native",
                "package",
                "private",
                "protected",
                "public",
                "short",
                "static",
                "synchronized",
                "throws",
                "transient",
                "volatile"
            ]);
            function isValidES3Identifier(e1) {
                return (0, n.default)(e1) && !s.has(e1);
            }
        },
        2892: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isValidIdentifier;
            var n = r(974);
            function isValidIdentifier(e1) {
                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                if (typeof e1 !== "string") return false;
                if (t) {
                    if ((0, n.isKeyword)(e1) || (0, n.isStrictReservedWord)(e1, true)) {
                        return false;
                    }
                }
                return (0, n.isIdentifierName)(e1);
            }
        },
        7581: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isVar;
            var n = r(46);
            {
                var s = Symbol.for("var used to be block scoped");
            }
            function isVar(e1) {
                {
                    return (0, n.isVariableDeclaration)(e1, {
                        kind: "var"
                    }) && !e1[s];
                }
            }
        },
        3447: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = matchesPattern;
            var n = r(46);
            function matchesPattern(e1, t, r) {
                if (!(0, n.isMemberExpression)(e1)) return false;
                const s = Array.isArray(t) ? t : t.split(".");
                const i = [];
                let a;
                for(a = e1; (0, n.isMemberExpression)(a); a = a.object){
                    i.push(a.property);
                }
                i.push(a);
                if (i.length < s.length) return false;
                if (!r && i.length > s.length) return false;
                for(let e1 = 0, t = i.length - 1; e1 < s.length; e1++, t--){
                    const r = i[t];
                    let a;
                    if ((0, n.isIdentifier)(r)) {
                        a = r.name;
                    } else if ((0, n.isStringLiteral)(r)) {
                        a = r.value;
                    } else if ((0, n.isThisExpression)(r)) {
                        a = "this";
                    } else {
                        return false;
                    }
                    if (s[e1] !== a) return false;
                }
                return true;
            }
        },
        339: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isCompatTag;
            function isCompatTag(e1) {
                return !!e1 && /^[a-z]/.test(e1);
            }
        },
        9651: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(7723);
            const s = (0, n.default)("React.Component");
            var i = t["default"] = s;
        },
        8966: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = validate;
            t.validateChild = validateChild;
            t.validateField = validateField;
            t.validateInternal = validateInternal;
            var n = r(6767);
            function validate(e1, t, r) {
                if (!e1) return;
                const s = n.NODE_FIELDS[e1.type];
                if (!s) return;
                const i = s[t];
                validateField(e1, t, r, i);
                validateChild(e1, t, r);
            }
            function validateInternal(e1, t, r, s, i) {
                if (!(e1 != null && e1.validate)) return;
                if (e1.optional && s == null) return;
                e1.validate(t, r, s);
                if (i) {
                    var a;
                    const e1 = s.type;
                    if (e1 == null) return;
                    (a = n.NODE_PARENT_VALIDATIONS[e1]) == null || a.call(n.NODE_PARENT_VALIDATIONS, t, r, s);
                }
            }
            function validateField(e1, t, r, n) {
                if (!(n != null && n.validate)) return;
                if (n.optional && r == null) return;
                n.validate(e1, t, r);
            }
            function validateChild(e1, t, r) {
                var s;
                const i = r == null ? void 0 : r.type;
                if (i == null) return;
                (s = n.NODE_PARENT_VALIDATIONS[i]) == null || s.call(n.NODE_PARENT_VALIDATIONS, e1, t, r);
            }
        },
        1824: (e1, t, r)=>{
            e1.exports = function import_(e1) {
                return r(5565)(e1);
            };
            0 && 0;
        },
        9938: (e1, t, r)=>{
            {
                t.getModuleName = ()=>r(9460).getModuleName;
            }
            0 && 0;
        },
        3702: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"es6.module":{"chrome":"61","and_chr":"61","edge":"16","firefox":"60","and_ff":"60","node":"13.2.0","opera":"48","op_mob":"45","safari":"10.1","ios":"10.3","samsung":"8.2","android":"61","electron":"2.0","ios_saf":"10.3"}}');
        },
        8427: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"transform-duplicate-named-capturing-groups-regex":{"chrome":"126","opera":"112","edge":"126","firefox":"129","safari":"17.4","node":"23","ios":"17.4","electron":"31.0"},"transform-regexp-modifiers":{"chrome":"125","opera":"111","edge":"125","firefox":"132","node":"23","electron":"31.0"},"transform-unicode-sets-regex":{"chrome":"112","opera":"98","edge":"112","firefox":"116","safari":"17","node":"20","deno":"1.32","ios":"17","opera_mobile":"75","electron":"24.0"},"bugfix/transform-v8-static-class-fields-redefine-readonly":{"chrome":"98","opera":"84","edge":"98","firefox":"75","safari":"15","node":"12","deno":"1.18","ios":"15","samsung":"11","opera_mobile":"52","electron":"17.0"},"bugfix/transform-firefox-class-in-computed-class-key":{"chrome":"74","opera":"62","edge":"79","safari":"16","node":"12","deno":"1","ios":"16","samsung":"11","opera_mobile":"53","electron":"6.0"},"bugfix/transform-safari-class-field-initializer-scope":{"chrome":"74","opera":"62","edge":"79","firefox":"69","safari":"16","node":"12","deno":"1","ios":"16","samsung":"11","opera_mobile":"53","electron":"6.0"},"transform-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"proposal-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"transform-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"proposal-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"transform-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"transform-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"transform-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"transform-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","safari":"16.3","node":"6","deno":"1","ios":"16.3","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","deno":"1","ios":"11.3","samsung":"8","rhino":"1.7.15","opera_mobile":"46","electron":"3.0"},"transform-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","deno":"1","ios":"11","samsung":"6","opera_mobile":"42","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","deno":"1","ios":"10.3","samsung":"6","rhino":"1.7.14","opera_mobile":"41","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","deno":"1","ios":"13","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","rhino":"1.7.15","opera_mobile":"32","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"43","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","rhino":"1.7.13","opera_mobile":"34","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","deno":"1","ie":"11","ios":"10","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","rhino":"1.7.14","opera_mobile":"30","electron":"0.27"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","deno":"1","ios":"9","samsung":"3.4","opera_mobile":"29","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","deno":"1","ios":"8","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","rhino":"1.7.15","opera_mobile":"36","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","rhino":"1.7.15","opera_mobile":"32","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","deno":"1","ios":"12","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-block-scoping":{"chrome":"50","opera":"37","edge":"14","firefox":"53","safari":"11","node":"6","deno":"1","ios":"11","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-typeof-symbol":{"chrome":"48","opera":"35","edge":"12","firefox":"36","safari":"9","node":"6","deno":"1","ios":"9","samsung":"5","opera_mobile":"35","electron":"0.37"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.6","deno":"1","ie":"9","android":"4.4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"10.1","electron":"0.20"},"transform-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"},"proposal-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"}}');
        },
        1628: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.27.0","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.26.5","@babel/helper-validator-option":"^7.25.9","@babel/plugin-syntax-jsx":"^7.25.9","@babel/plugin-transform-modules-commonjs":"^7.26.3","@babel/plugin-transform-typescript":"^7.27.0"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.26.10","@babel/helper-plugin-test-runner":"^7.25.9"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
        },
        3676: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var s = t[r] = {
            exports: {}
        };
        var i = true;
        try {
            e1[r].call(s.exports, s, s.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete t[r];
        }
        return s.exports;
    }
    (()=>{
        __nccwpck_require__.o = (e1, t)=>Object.prototype.hasOwnProperty.call(e1, t);
    })();
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/babel") + "/";
    var r = __nccwpck_require__(3050);
    module.exports = r;
})();
}),
]);

//# sourceMappingURL=node_modules_next_dist_compiled_babel_bundle_af90f770.js.map